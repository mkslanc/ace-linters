(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[8765],{

/***/ 68765:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 1696: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_511__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_511__(4406);
                /* provided dependency */ var console = __nested_webpack_require_511__(3716);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_511__(7515), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_511__(4082);
                var _require2 = __nested_webpack_require_511__(3335), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_511__(3335).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_511__(4956).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_511__(4679);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_511__(6796);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 4082: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_31729__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_31729__(4406);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_31729__(3335), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_31729__(7515), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 7515: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65318__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65318__(1696);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65318__(3335);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65318__(1696);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 6796: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76379__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76379__(4679);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76379__(4782);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76379__(3335).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 2680: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_107933__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_107933__(7286);
                var callBind = __nested_webpack_require_107933__(9429);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 9429: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108661__)=>{
                "use strict";
                var bind = __nested_webpack_require_108661__(4090);
                var GetIntrinsic = __nested_webpack_require_108661__(7286);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
                var $max = GetIntrinsic('%Math.max%');
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = null;
                    }
                }
                module1.exports = function callBind(originalFunction) {
                    var func = $reflectApply(bind, $call, arguments);
                    if ($gOPD && $defineProperty) {
                        var desc = $gOPD(func, 'length');
                        if (desc.configurable) {
                            // original length, plus the receiver, minus any additional arguments (after the receiver)
                            $defineProperty(func, 'length', {
                                value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                            });
                        }
                    }
                    return func;
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 3716: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110875__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110875__(3335);
                var assert = __nested_webpack_require_110875__(1696);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110875__.g !== "undefined" && __nested_webpack_require_110875__.g.console) {
                    console = __nested_webpack_require_110875__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 4926: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114558__)=>{
                "use strict";
                var keys = __nested_webpack_require_114558__(3464);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var hasPropertyDescriptors = __nested_webpack_require_114558__(1181)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        origDefineProperty(object, name, {
                            configurable: true,
                            enumerable: false,
                            value: value,
                            writable: true
                        });
                    } else {
                        object[name] = value; // eslint-disable-line no-param-reassign
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4956: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 3243: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_118854__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_118854__(9680);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 7795: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var slice = Array.prototype.slice;
                var toStr = Object.prototype.toString;
                var funcType = '[object Function]';
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slice.call(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, args.concat(slice.call(arguments)));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        } else {
                            return target.apply(that, args.concat(slice.call(arguments)));
                        }
                    };
                    var boundLength = Math.max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs.push('$' + i);
                    }
                    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 4090: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123580__)=>{
                "use strict";
                var implementation = __nested_webpack_require_123580__(7795);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 7286: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123862__)=>{
                "use strict";
                var undefined1;
                var $SyntaxError = SyntaxError;
                var $Function = Function;
                var $TypeError = TypeError;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_123862__(2636)();
                var hasProto = __nested_webpack_require_123862__(8486)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': Error,
                    '%eval%': eval,
                    '%EvalError%': EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': RangeError,
                    '%ReferenceError%': ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_123862__(4090);
                var hasOwn = __nested_webpack_require_123862__(3198);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 326: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_147329__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_147329__(7286);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 1181: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_147920__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_147920__(7286);
                var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    if ($defineProperty) {
                        try {
                            $defineProperty({}, 'a', {
                                value: 1
                            });
                            return true;
                        } catch (e) {
                            // IE 8 has a broken defineProperty
                            return false;
                        }
                    }
                    return false;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!hasPropertyDescriptors()) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 8486: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 2636: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_149995__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_149995__(6679);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 6679: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 7226: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153754__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_153754__(6679);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 3198: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_154106__)=>{
                "use strict";
                var bind = __nested_webpack_require_154106__(4090);
                module1.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
            /***/ },
            /***/ 1285: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 2635: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155784__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_155784__(7226)();
                var callBound = __nested_webpack_require_155784__(2680);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9680: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 3138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_162844__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_162844__(7226)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 7053: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 4782: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_164813__)=>{
                "use strict";
                var callBind = __nested_webpack_require_164813__(9429);
                var define1 = __nested_webpack_require_164813__(4926);
                var implementation = __nested_webpack_require_164813__(7053);
                var getPolyfill = __nested_webpack_require_164813__(755);
                var shim = __nested_webpack_require_164813__(5346);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 755: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_165610__)=>{
                "use strict";
                var implementation = __nested_webpack_require_165610__(7053);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 5346: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_166086__)=>{
                "use strict";
                var define1 = __nested_webpack_require_166086__(4926);
                var getPolyfill = __nested_webpack_require_166086__(755);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 198: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_166852__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_166852__(2094);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 8169: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 4679: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_167840__)=>{
                "use strict";
                var define1 = __nested_webpack_require_167840__(4926);
                var callBind = __nested_webpack_require_167840__(9429);
                var implementation = __nested_webpack_require_167840__(8169);
                var getPolyfill = __nested_webpack_require_167840__(8070);
                var shim = __nested_webpack_require_167840__(191);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 8070: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168567__)=>{
                "use strict";
                var implementation = __nested_webpack_require_168567__(8169);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 191: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168938__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_168938__(8070);
                var define1 = __nested_webpack_require_168938__(4926);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5691: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_169626__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_169626__(801); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 3464: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_175595__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_175595__(801);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_175595__(5691);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 801: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 4406: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 4487: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_185970__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_185970__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_185970__(6297);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_185970__(4881);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.create(document1.uri, document1.languageId, document1.version, document1.text);
                    //TODO:
                    /*if (options)
            this.setSessionOptions(sessionID, options);*/ }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setOptions(sessionID, options, merge = false) {
                        this.options[sessionID] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_1__ /* .mergeObjects */ .PM)(options, this.options[sessionID]) : options;
                    }
                    getOption(sessionID, optionName) {
                        if (this.options[sessionID] && this.options[sessionID][optionName]) {
                            return this.options[sessionID][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ /* .TextDocument */ .n.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    constructor(mode){
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        this.mode = mode;
                    }
                }
            /***/ },
            /***/ 6297: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_193152__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_193152__.d(__nested_webpack_exports__, {
                    /* harmony export */ $p: ()=>/* binding */ checkValueAgainstRegexpArray,
                    /* harmony export */ PM: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, mergeRanges */ function mergeObjects(obj1, obj2) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function notEmpty1(value) {
                    return value !== null && value !== undefined;
                }
                //taken with small changes from ace-code
                function mergeRanges1(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
            /***/ },
            /***/ 82: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 4895: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_196784__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_196784__(2635);
                var isGeneratorFunction = __nested_webpack_require_196784__(3138);
                var whichTypedArray = __nested_webpack_require_196784__(2094);
                var isTypedArray = __nested_webpack_require_196784__(198);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 3335: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_209260__)=>{
                /* provided dependency */ var process = __nested_webpack_require_209260__(4406);
                /* provided dependency */ var console = __nested_webpack_require_209260__(3716);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_209260__(4895);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_209260__(82);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_209260__(1285);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 1200: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_240856__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_240856__(5953);
            /***/ },
            /***/ 5953: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_241415__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_241415__(3632);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_241415__(5247);
                __exportStar(__nested_webpack_require_241415__(5247), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3632: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_245830__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_245830__(3716);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_245830__(5247);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 5247: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_254209__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_254209__(9141);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_254209__(7040);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_254209__(8437);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_254209__(5165);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_254209__(415);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_254209__(178);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_254209__(451);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_254209__(1251);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_254209__(8652);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_254209__(1908);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_254209__(5706);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 415: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_272270__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_272270__(5706);
                const Is = __nested_webpack_require_272270__(8811);
                const events_1 = __nested_webpack_require_272270__(5165);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 1908: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_277204__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_277204__(5706);
                const Is = __nested_webpack_require_277204__(8811);
                const messages_1 = __nested_webpack_require_277204__(9141);
                const linkedMap_1 = __nested_webpack_require_277204__(7040);
                const events_1 = __nested_webpack_require_277204__(5165);
                const cancellation_1 = __nested_webpack_require_277204__(415);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy = exports1.MessageStrategy || (exports1.MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8437: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            /***/ },
            /***/ 5165: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_348295__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_348295__(5706);
                var Event;
                (function(Event) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event.None = function() {
                        return _disposable;
                    };
                })(Event = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 8811: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 7040: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 8652: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 451: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_383987__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_383987__(5706);
                const Is = __nested_webpack_require_383987__(8811);
                const events_1 = __nested_webpack_require_383987__(5165);
                const semaphore_1 = __nested_webpack_require_383987__(2339);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders(true);
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('content-length');
                                if (!contentLength) {
                                    this.fireError(new Error('Header must provide a Content-Length property.'));
                                    return;
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    this.fireError(new Error('Content-Length value must be a number.'));
                                    return;
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            // Make sure that we convert one received message after the
                            // other. Otherwise it could happen that a decoding of a second
                            // smaller message finished before the decoding of a first larger
                            // message and then we would deliver the second message first.
                            this.readSemaphore.lock(async ()=>{
                                const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                this.callback(message);
                            }).catch((error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 1251: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_395249__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_395249__(5706);
                const Is = __nested_webpack_require_395249__(8811);
                const semaphore_1 = __nested_webpack_require_395249__(2339);
                const events_1 = __nested_webpack_require_395249__(5165);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 9141: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_402135__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_402135__(8811);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            /***/ },
            /***/ 5706: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 2339: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_417643__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_417643__(5706);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 178: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_421085__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_421085__(415);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 294: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_424988__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_424988__(1200);
                __exportStar(__nested_webpack_require_424988__(1200), exports1);
                __exportStar(__nested_webpack_require_424988__(9372), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 9372: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_427177__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_427177__(5953), exports1);
                __exportStar(__nested_webpack_require_427177__(4767), exports1);
                __exportStar(__nested_webpack_require_427177__(8599), exports1);
                __exportStar(__nested_webpack_require_427177__(6525), exports1);
                var connection_1 = __nested_webpack_require_427177__(2798);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes = exports1.LSPErrorCodes || (exports1.LSPErrorCodes = {}));
            /***/ },
            /***/ 2798: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_431328__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_431328__(5953);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8599: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_432565__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_432565__(5953);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection = exports1.MessageDirection || (exports1.MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 4434: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_435291__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_435291__(8599);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest = exports1.CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest = exports1.CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 7908: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_438322__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_438322__(8599);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest = exports1.DocumentColorRequest || (exports1.DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest = exports1.ColorPresentationRequest || (exports1.ColorPresentationRequest = {}));
            /***/ },
            /***/ 5442: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_440625__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_440625__(8599);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest = exports1.ConfigurationRequest || (exports1.ConfigurationRequest = {}));
            /***/ },
            /***/ 7210: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_442407__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_442407__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest = exports1.DeclarationRequest || (exports1.DeclarationRequest = {}));
            /***/ },
            /***/ 5692: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_444072__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_444072__(5953);
                const Is = __nested_webpack_require_444072__(2523);
                const messages_1 = __nested_webpack_require_444072__(8599);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData = exports1.DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind = exports1.DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest = exports1.DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest = exports1.WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest = exports1.DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 6190: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_448316__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_448316__(8599);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind = exports1.FileOperationPatternKind || (exports1.FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest = exports1.WillCreateFilesRequest || (exports1.WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification = exports1.DidCreateFilesNotification || (exports1.DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest = exports1.WillRenameFilesRequest || (exports1.WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification = exports1.DidRenameFilesNotification || (exports1.DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification = exports1.DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest = exports1.WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 7029: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_454321__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_454321__(8599);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest = exports1.FoldingRangeRequest || (exports1.FoldingRangeRequest = {}));
            /***/ },
            /***/ 9380: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_455760__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_455760__(8599);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest = exports1.ImplementationRequest || (exports1.ImplementationRequest = {}));
            /***/ },
            /***/ 6315: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_457409__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_457409__(8599);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest = exports1.InlayHintRequest || (exports1.InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest = exports1.InlayHintResolveRequest || (exports1.InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest = exports1.InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 7425: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_460212__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_460212__(8599);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest = exports1.InlineValueRequest || (exports1.InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest = exports1.InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 6525: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_462278__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = void 0;
                const messages_1 = __nested_webpack_require_462278__(8599);
                const vscode_languageserver_types_1 = __nested_webpack_require_462278__(4767);
                const Is = __nested_webpack_require_462278__(2523);
                const protocol_implementation_1 = __nested_webpack_require_462278__(9380);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_462278__(8642);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_462278__(3402);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_462278__(5442);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_462278__(7908);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_462278__(7029);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_462278__(7210);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_462278__(2392);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_462278__(7895);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_462278__(4434);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_462278__(8489);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_462278__(1541);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_462278__(527);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_462278__(6190);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_462278__(1964);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_462278__(5318);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_462278__(7425);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_462278__(6315);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_462278__(5692);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_462278__(4460);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter = exports1.TextDocumentFilter || (exports1.TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter = exports1.NotebookDocumentFilter || (exports1.NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter = exports1.NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector = exports1.DocumentSelector || (exports1.DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest = exports1.RegistrationRequest || (exports1.RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest = exports1.UnregistrationRequest || (exports1.UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind = exports1.ResourceOperationKind || (exports1.ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind = exports1.FailureHandlingKind || (exports1.FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind = exports1.PositionEncodingKind || (exports1.PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions = exports1.StaticRegistrationOptions || (exports1.StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions = exports1.TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions = exports1.WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest = exports1.InitializeRequest || (exports1.InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes = exports1.InitializeErrorCodes || (exports1.InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification = exports1.InitializedNotification || (exports1.InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest = exports1.ShutdownRequest || (exports1.ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification = exports1.ExitNotification || (exports1.ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification = exports1.DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification = exports1.ShowMessageNotification || (exports1.ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest = exports1.ShowMessageRequest || (exports1.ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification = exports1.LogMessageNotification || (exports1.LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification = exports1.TelemetryEventNotification || (exports1.TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind = exports1.TextDocumentSyncKind || (exports1.TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification = exports1.DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent = exports1.TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification = exports1.DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification = exports1.DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification = exports1.DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason = exports1.TextDocumentSaveReason || (exports1.TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification = exports1.WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification = exports1.DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType = exports1.FileChangeType || (exports1.FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern = exports1.RelativePattern || (exports1.RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind = exports1.WatchKind || (exports1.WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification = exports1.PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind = exports1.CompletionTriggerKind || (exports1.CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest = exports1.CompletionRequest || (exports1.CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest = exports1.CompletionResolveRequest || (exports1.CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest = exports1.HoverRequest || (exports1.HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind = exports1.SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest = exports1.SignatureHelpRequest || (exports1.SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest = exports1.DefinitionRequest || (exports1.DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest = exports1.ReferencesRequest || (exports1.ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest = exports1.DocumentHighlightRequest || (exports1.DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest = exports1.DocumentSymbolRequest || (exports1.DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest = exports1.CodeActionRequest || (exports1.CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest = exports1.CodeActionResolveRequest || (exports1.CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest = exports1.WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest = exports1.WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest = exports1.CodeLensRequest || (exports1.CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest = exports1.CodeLensResolveRequest || (exports1.CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest = exports1.CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest = exports1.DocumentLinkRequest || (exports1.DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest = exports1.DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = {}));
                /**
 * A request to to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest = exports1.DocumentFormattingRequest || (exports1.DocumentFormattingRequest = {}));
                /**
 * A request to to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest = exports1.DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest = exports1.DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior = exports1.PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest = exports1.RenameRequest || (exports1.RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest = exports1.PrepareRenameRequest || (exports1.PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest = exports1.ExecuteCommandRequest || (exports1.ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest = exports1.ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 527: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_531392__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_531392__(8599);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest = exports1.LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 1964: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_532765__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_532765__(8599);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel = exports1.UniquenessLevel || (exports1.UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind = exports1.MonikerKind || (exports1.MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest = exports1.MonikerRequest || (exports1.MonikerRequest = {}));
            /***/ },
            /***/ 4460: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_535799__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_535799__(4767);
                const Is = __nested_webpack_require_535799__(2523);
                const messages_1 = __nested_webpack_require_535799__(8599);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind = exports1.NotebookCellKind || (exports1.NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary = exports1.ExecutionSummary || (exports1.ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell = exports1.NotebookCell || (exports1.NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument = exports1.NotebookDocument || (exports1.NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType = exports1.NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification = exports1.DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange = exports1.NotebookCellArrayChange || (exports1.NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification = exports1.DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 7895: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_549376__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_549376__(5953);
                const messages_1 = __nested_webpack_require_549376__(8599);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress = exports1.WorkDoneProgress || (exports1.WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest = exports1.WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 2392: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_552217__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_552217__(8599);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest = exports1.SelectionRangeRequest || (exports1.SelectionRangeRequest = {}));
            /***/ },
            /***/ 8489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_553697__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_553697__(8599);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat = exports1.TokenFormat || (exports1.TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType = exports1.SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest = exports1.SemanticTokensRequest || (exports1.SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest = exports1.SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest = exports1.SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest = exports1.SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 1541: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_558008__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_558008__(8599);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest = exports1.ShowDocumentRequest || (exports1.ShowDocumentRequest = {}));
            /***/ },
            /***/ 8642: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_559486__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_559486__(8599);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest = exports1.TypeDefinitionRequest || (exports1.TypeDefinitionRequest = {}));
            /***/ },
            /***/ 5318: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_561135__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_561135__(8599);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest = exports1.TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest = exports1.TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest = exports1.TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 3402: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_564069__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_564069__(8599);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest = exports1.WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification = exports1.DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 2523: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 4881: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_568964__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_568964__.d(__nested_webpack_exports__, {
                    /* harmony export */ n: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __spreadArray =  false || function(to, from, pack) {
                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
                        if (ar || !(i in from)) {
                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                            ar[i] = from[i];
                        }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };
                var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(changes, version) {
                        for(var _i = 0, changes_1 = changes; _i < changes_1.length; _i++){
                            var change = changes_1[_i];
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                var range = getWellformedRange(change.range);
                                // update content
                                var startOffset = this.offsetAt(range.start);
                                var endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                var startLine = Math.max(range.start.line, 0);
                                var endLine = Math.max(range.end.line, 0);
                                var lineOffsets = this._lineOffsets;
                                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(var i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice.apply(lineOffsets, __spreadArray([
                                            startLine + 1,
                                            endLine - startLine
                                        ], addedLineOffsets, false));
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                var diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return {
                            line: line,
                            character: offset - lineOffsets[line]
                        };
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.isIncremental = function(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    };
                    FullTextDocument.isFull = function(event) {
                        var candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    };
                    return FullTextDocument;
                }();
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = 0;
                        var spans = [];
                        for(var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++){
                            var e = sortedEdits_1[_i];
                            var startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    var p = data.length / 2 | 0;
                    var left = data.slice(0, p);
                    var right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    var leftIdx = 0;
                    var rightIdx = 0;
                    var i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        var ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset) {
                    if (textOffset === void 0) {
                        textOffset = 0;
                    }
                    var result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(var i = 0; i < text.length; i++){
                        var ch = text.charCodeAt(i);
                        if (ch === 13 /* CharCode.CarriageReturn */  || ch === 10 /* CharCode.LineFeed */ ) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function getWellformedRange(range) {
                    var start = range.start;
                    var end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    var range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range: range
                        };
                    }
                    return textEdit;
                }
            /***/ },
            /***/ 4767: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_584788__)=>{
                "use strict";
                __nested_webpack_require_584788__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_584788__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind1,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat1,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString1,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent1,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI;
                (function(URI) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI.is = is;
                })(URI || (URI = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line: line,
                            character: character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri: uri,
                            range: range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri: targetUri,
                            targetRange: targetRange,
                            targetSelectionRange: targetSelectionRange,
                            originSelectionRange: originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red: red,
                            green: green,
                            blue: blue,
                            alpha: alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range: range,
                            color: color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label: label,
                            textEdit: textEdit,
                            additionalTextEdits: additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        var result = {
                            startLine: startLine,
                            endLine: endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location: location,
                            message: message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        var result = {
                            range: range,
                            message: message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command) {
                        var args = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            args[_i - 2] = arguments[_i];
                        }
                        var result = {
                            title: title,
                            command: command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range: range,
                            newText: newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range: range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        var result = {
                            label: label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        var candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range: range,
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range: range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument: textDocument,
                            edits: edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'create',
                            uri: uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        var result = {
                            kind: 'rename',
                            oldUri: oldUri,
                            newUri: newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'delete',
                            uri: uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                var TextEditChangeImpl = /** @class */ function() {
                    function TextEditChangeImpl(edits, changeAnnotations) {
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                    TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.delete = function(range, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.add = function(edit1) {
                        this.edits.push(edit1);
                    };
                    TextEditChangeImpl.prototype.all = function() {
                        return this.edits;
                    };
                    TextEditChangeImpl.prototype.clear = function() {
                        this.edits.splice(0, this.edits.length);
                    };
                    TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {
                        if (value === undefined) {
                            throw new Error("Text edit change is not configured to manage change annotations.");
                        }
                    };
                    return TextEditChangeImpl;
                }();
                /**
 * A helper class
 */ var ChangeAnnotations = /** @class */ function() {
                    function ChangeAnnotations(annotations) {
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                    ChangeAnnotations.prototype.all = function() {
                        return this._annotations;
                    };
                    Object.defineProperty(ChangeAnnotations.prototype, "size", {
                        get: function() {
                            return this._size;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {
                        var id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error("Id ".concat(id, " is already in use."));
                        }
                        if (annotation === undefined) {
                            throw new Error("No annotation provided for id ".concat(id));
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    };
                    ChangeAnnotations.prototype.nextId = function() {
                        this._counter++;
                        return this._counter.toString();
                    };
                    return ChangeAnnotations;
                }();
                /**
 * A workspace change helps constructing changes to a workspace.
 */ var WorkspaceChange = /** @class */ function() {
                    function WorkspaceChange(workspaceEdit) {
                        var _this = this;
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach(function(change) {
                                    if (TextDocumentEdit.is(change)) {
                                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach(function(key) {
                                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    _this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                    Object.defineProperty(WorkspaceChange.prototype, "edit", {
                        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */ get: function() {
                            this.initDocumentChanges();
                            if (this._changeAnnotations !== undefined) {
                                if (this._changeAnnotations.size === 0) {
                                    this._workspaceEdit.changeAnnotations = undefined;
                                } else {
                                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                }
                            }
                            return this._workspaceEdit;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    WorkspaceChange.prototype.getTextEditChange = function(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            var textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            var result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                var edits = [];
                                var textDocumentEdit = {
                                    textDocument: textDocument,
                                    edits: edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            var result = this._textEditChanges[key];
                            if (!result) {
                                var edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    };
                    WorkspaceChange.prototype.initDocumentChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    };
                    WorkspaceChange.prototype.initChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    };
                    WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    return WorkspaceChange;
                }();
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri: uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri: uri,
                            languageId: languageId,
                            version: version,
                            text: text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        var candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent1;
                (function(MarkupContent1) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent1.is = is;
                })(MarkupContent1 || (MarkupContent1 = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind1;
                (function(CompletionItemKind1) {
                    CompletionItemKind1.Text = 1;
                    CompletionItemKind1.Method = 2;
                    CompletionItemKind1.Function = 3;
                    CompletionItemKind1.Constructor = 4;
                    CompletionItemKind1.Field = 5;
                    CompletionItemKind1.Variable = 6;
                    CompletionItemKind1.Class = 7;
                    CompletionItemKind1.Interface = 8;
                    CompletionItemKind1.Module = 9;
                    CompletionItemKind1.Property = 10;
                    CompletionItemKind1.Unit = 11;
                    CompletionItemKind1.Value = 12;
                    CompletionItemKind1.Enum = 13;
                    CompletionItemKind1.Keyword = 14;
                    CompletionItemKind1.Snippet = 15;
                    CompletionItemKind1.Color = 16;
                    CompletionItemKind1.File = 17;
                    CompletionItemKind1.Reference = 18;
                    CompletionItemKind1.Folder = 19;
                    CompletionItemKind1.EnumMember = 20;
                    CompletionItemKind1.Constant = 21;
                    CompletionItemKind1.Struct = 22;
                    CompletionItemKind1.Event = 23;
                    CompletionItemKind1.Operator = 24;
                    CompletionItemKind1.TypeParameter = 25;
                })(CompletionItemKind1 || (CompletionItemKind1 = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat1;
                (function(InsertTextFormat1) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
                })(InsertTextFormat1 || (InsertTextFormat1 = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText: newText,
                            insert: insert,
                            replace: replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label: label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString1;
                (function(MarkedString1) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString1.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        var candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString1.is = is;
                })(MarkedString1 || (MarkedString1 = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        var candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent1.is(candidate.contents) || MarkedString1.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString1.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label: label,
                            documentation: documentation
                        } : {
                            label: label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation) {
                        var parameters = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            parameters[_i - 2] = arguments[_i];
                        }
                        var result = {
                            label: label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        var result = {
                            range: range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        var result = {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        } : {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        var result = {
                            name: name,
                            detail: detail,
                            kind: kind,
                            range: range,
                            selectionRange: selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        var result = {
                            diagnostics: diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        var result = {
                            title: title
                        };
                        var checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        var result = {
                            range: range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize: tabSize,
                            insertSpaces: insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range: range,
                            target: target,
                            data: data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range: range,
                            parent: parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range: range,
                            text: text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range: range,
                            variableName: variableName,
                            caseSensitiveLookup: caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range: range,
                            expression: expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId: frameId,
                            stoppedLocation: stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value: value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        var result = {
                            position: position,
                            label: label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                var EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits, function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = text.length;
                        for(var i = sortedEdits.length - 1; i >= 0; i--){
                            var e = sortedEdits[i];
                            var startOffset = document1.offsetAt(e.range.start);
                            var endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        var p = data.length / 2 | 0;
                        var left = data.slice(0, p);
                        var right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        var leftIdx = 0;
                        var rightIdx = 0;
                        var i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            var ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            var lineOffsets = [];
                            var text = this._content;
                            var isLineStart = true;
                            for(var i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                var ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullTextDocument;
                }();
                var Is;
                (function(Is) {
                    var toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ },
            /***/ 2094: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_695902__)=>{
                "use strict";
                var forEach = __nested_webpack_require_695902__(3243);
                var availableTypedArrays = __nested_webpack_require_695902__(2191);
                var callBind = __nested_webpack_require_695902__(9429);
                var callBound = __nested_webpack_require_695902__(2680);
                var gOPD = __nested_webpack_require_695902__(326);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_695902__(7226)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_695902__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 2191: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_700149__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_700149__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_701415__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_701415__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_701415__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_701415__.o(definition, key) && !__nested_webpack_require_701415__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_701415__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_701415__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_701415__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_701415__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_701415__.d(__nested_webpack_exports__, {
                JsonService: ()=>/* binding */ JsonService
            });
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_701415__(4487);
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/scanner.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */ function createScanner(text, ignoreTrivia = false) {
                const len = text.length;
                let pos = 0, value = '', tokenOffset = 0, token = 16 /* SyntaxKind.Unknown */ , lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* ScanError.None */ ;
                function scanHexDigits(count, exact) {
                    let digits = 0;
                    let value = 0;
                    while(digits < count || !exact){
                        let ch = text.charCodeAt(pos);
                        if (ch >= 48 /* CharacterCodes._0 */  && ch <= 57 /* CharacterCodes._9 */ ) {
                            value = value * 16 + ch - 48 /* CharacterCodes._0 */ ;
                        } else if (ch >= 65 /* CharacterCodes.A */  && ch <= 70 /* CharacterCodes.F */ ) {
                            value = value * 16 + ch - 65 /* CharacterCodes.A */  + 10;
                        } else if (ch >= 97 /* CharacterCodes.a */  && ch <= 102 /* CharacterCodes.f */ ) {
                            value = value * 16 + ch - 97 /* CharacterCodes.a */  + 10;
                        } else {
                            break;
                        }
                        pos++;
                        digits++;
                    }
                    if (digits < count) {
                        value = -1;
                    }
                    return value;
                }
                function setPosition(newPosition) {
                    pos = newPosition;
                    value = '';
                    tokenOffset = 0;
                    token = 16 /* SyntaxKind.Unknown */ ;
                    scanError = 0 /* ScanError.None */ ;
                }
                function scanNumber() {
                    let start = pos;
                    if (text.charCodeAt(pos) === 48 /* CharacterCodes._0 */ ) {
                        pos++;
                    } else {
                        pos++;
                        while(pos < text.length && isDigit(text.charCodeAt(pos))){
                            pos++;
                        }
                    }
                    if (pos < text.length && text.charCodeAt(pos) === 46 /* CharacterCodes.dot */ ) {
                        pos++;
                        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                            pos++;
                            while(pos < text.length && isDigit(text.charCodeAt(pos))){
                                pos++;
                            }
                        } else {
                            scanError = 3 /* ScanError.UnexpectedEndOfNumber */ ;
                            return text.substring(start, pos);
                        }
                    }
                    let end = pos;
                    if (pos < text.length && (text.charCodeAt(pos) === 69 /* CharacterCodes.E */  || text.charCodeAt(pos) === 101 /* CharacterCodes.e */ )) {
                        pos++;
                        if (pos < text.length && text.charCodeAt(pos) === 43 /* CharacterCodes.plus */  || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */ ) {
                            pos++;
                        }
                        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                            pos++;
                            while(pos < text.length && isDigit(text.charCodeAt(pos))){
                                pos++;
                            }
                            end = pos;
                        } else {
                            scanError = 3 /* ScanError.UnexpectedEndOfNumber */ ;
                        }
                    }
                    return text.substring(start, end);
                }
                function scanString() {
                    let result = '', start = pos;
                    while(true){
                        if (pos >= len) {
                            result += text.substring(start, pos);
                            scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                            break;
                        }
                        const ch = text.charCodeAt(pos);
                        if (ch === 34 /* CharacterCodes.doubleQuote */ ) {
                            result += text.substring(start, pos);
                            pos++;
                            break;
                        }
                        if (ch === 92 /* CharacterCodes.backslash */ ) {
                            result += text.substring(start, pos);
                            pos++;
                            if (pos >= len) {
                                scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                                break;
                            }
                            const ch2 = text.charCodeAt(pos++);
                            switch(ch2){
                                case 34 /* CharacterCodes.doubleQuote */ :
                                    result += '\"';
                                    break;
                                case 92 /* CharacterCodes.backslash */ :
                                    result += '\\';
                                    break;
                                case 47 /* CharacterCodes.slash */ :
                                    result += '/';
                                    break;
                                case 98 /* CharacterCodes.b */ :
                                    result += '\b';
                                    break;
                                case 102 /* CharacterCodes.f */ :
                                    result += '\f';
                                    break;
                                case 110 /* CharacterCodes.n */ :
                                    result += '\n';
                                    break;
                                case 114 /* CharacterCodes.r */ :
                                    result += '\r';
                                    break;
                                case 116 /* CharacterCodes.t */ :
                                    result += '\t';
                                    break;
                                case 117 /* CharacterCodes.u */ :
                                    const ch3 = scanHexDigits(4, true);
                                    if (ch3 >= 0) {
                                        result += String.fromCharCode(ch3);
                                    } else {
                                        scanError = 4 /* ScanError.InvalidUnicode */ ;
                                    }
                                    break;
                                default:
                                    scanError = 5 /* ScanError.InvalidEscapeCharacter */ ;
                            }
                            start = pos;
                            continue;
                        }
                        if (ch >= 0 && ch <= 0x1f) {
                            if (isLineBreak(ch)) {
                                result += text.substring(start, pos);
                                scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                                break;
                            } else {
                                scanError = 6 /* ScanError.InvalidCharacter */ ;
                            // mark as error but continue with string
                            }
                        }
                        pos++;
                    }
                    return result;
                }
                function scanNext() {
                    value = '';
                    scanError = 0 /* ScanError.None */ ;
                    tokenOffset = pos;
                    lineStartOffset = lineNumber;
                    prevTokenLineStartOffset = tokenLineStartOffset;
                    if (pos >= len) {
                        // at the end
                        tokenOffset = len;
                        return token = 17 /* SyntaxKind.EOF */ ;
                    }
                    let code = text.charCodeAt(pos);
                    // trivia: whitespace
                    if (isWhiteSpace(code)) {
                        do {
                            pos++;
                            value += String.fromCharCode(code);
                            code = text.charCodeAt(pos);
                        }while (isWhiteSpace(code))
                        return token = 15 /* SyntaxKind.Trivia */ ;
                    }
                    // trivia: newlines
                    if (isLineBreak(code)) {
                        pos++;
                        value += String.fromCharCode(code);
                        if (code === 13 /* CharacterCodes.carriageReturn */  && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */ ) {
                            pos++;
                            value += '\n';
                        }
                        lineNumber++;
                        tokenLineStartOffset = pos;
                        return token = 14 /* SyntaxKind.LineBreakTrivia */ ;
                    }
                    switch(code){
                        // tokens: []{}:,
                        case 123 /* CharacterCodes.openBrace */ :
                            pos++;
                            return token = 1 /* SyntaxKind.OpenBraceToken */ ;
                        case 125 /* CharacterCodes.closeBrace */ :
                            pos++;
                            return token = 2 /* SyntaxKind.CloseBraceToken */ ;
                        case 91 /* CharacterCodes.openBracket */ :
                            pos++;
                            return token = 3 /* SyntaxKind.OpenBracketToken */ ;
                        case 93 /* CharacterCodes.closeBracket */ :
                            pos++;
                            return token = 4 /* SyntaxKind.CloseBracketToken */ ;
                        case 58 /* CharacterCodes.colon */ :
                            pos++;
                            return token = 6 /* SyntaxKind.ColonToken */ ;
                        case 44 /* CharacterCodes.comma */ :
                            pos++;
                            return token = 5 /* SyntaxKind.CommaToken */ ;
                        // strings
                        case 34 /* CharacterCodes.doubleQuote */ :
                            pos++;
                            value = scanString();
                            return token = 10 /* SyntaxKind.StringLiteral */ ;
                        // comments
                        case 47 /* CharacterCodes.slash */ :
                            const start = pos - 1;
                            // Single-line comment
                            if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ ) {
                                pos += 2;
                                while(pos < len){
                                    if (isLineBreak(text.charCodeAt(pos))) {
                                        break;
                                    }
                                    pos++;
                                }
                                value = text.substring(start, pos);
                                return token = 12 /* SyntaxKind.LineCommentTrivia */ ;
                            }
                            // Multi-line comment
                            if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */ ) {
                                pos += 2;
                                const safeLength = len - 1; // For lookahead.
                                let commentClosed = false;
                                while(pos < safeLength){
                                    const ch = text.charCodeAt(pos);
                                    if (ch === 42 /* CharacterCodes.asterisk */  && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ ) {
                                        pos += 2;
                                        commentClosed = true;
                                        break;
                                    }
                                    pos++;
                                    if (isLineBreak(ch)) {
                                        if (ch === 13 /* CharacterCodes.carriageReturn */  && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */ ) {
                                            pos++;
                                        }
                                        lineNumber++;
                                        tokenLineStartOffset = pos;
                                    }
                                }
                                if (!commentClosed) {
                                    pos++;
                                    scanError = 1 /* ScanError.UnexpectedEndOfComment */ ;
                                }
                                value = text.substring(start, pos);
                                return token = 13 /* SyntaxKind.BlockCommentTrivia */ ;
                            }
                            // just a single slash
                            value += String.fromCharCode(code);
                            pos++;
                            return token = 16 /* SyntaxKind.Unknown */ ;
                        // numbers
                        case 45 /* CharacterCodes.minus */ :
                            value += String.fromCharCode(code);
                            pos++;
                            if (pos === len || !isDigit(text.charCodeAt(pos))) {
                                return token = 16 /* SyntaxKind.Unknown */ ;
                            }
                        // found a minus, followed by a number so
                        // we fall through to proceed with scanning
                        // numbers
                        case 48 /* CharacterCodes._0 */ :
                        case 49 /* CharacterCodes._1 */ :
                        case 50 /* CharacterCodes._2 */ :
                        case 51 /* CharacterCodes._3 */ :
                        case 52 /* CharacterCodes._4 */ :
                        case 53 /* CharacterCodes._5 */ :
                        case 54 /* CharacterCodes._6 */ :
                        case 55 /* CharacterCodes._7 */ :
                        case 56 /* CharacterCodes._8 */ :
                        case 57 /* CharacterCodes._9 */ :
                            value += scanNumber();
                            return token = 11 /* SyntaxKind.NumericLiteral */ ;
                        // literals and unknown symbols
                        default:
                            // is a literal? Read the full word.
                            while(pos < len && isUnknownContentCharacter(code)){
                                pos++;
                                code = text.charCodeAt(pos);
                            }
                            if (tokenOffset !== pos) {
                                value = text.substring(tokenOffset, pos);
                                // keywords: true, false, null
                                switch(value){
                                    case 'true':
                                        return token = 8 /* SyntaxKind.TrueKeyword */ ;
                                    case 'false':
                                        return token = 9 /* SyntaxKind.FalseKeyword */ ;
                                    case 'null':
                                        return token = 7 /* SyntaxKind.NullKeyword */ ;
                                }
                                return token = 16 /* SyntaxKind.Unknown */ ;
                            }
                            // some
                            value += String.fromCharCode(code);
                            pos++;
                            return token = 16 /* SyntaxKind.Unknown */ ;
                    }
                }
                function isUnknownContentCharacter(code) {
                    if (isWhiteSpace(code) || isLineBreak(code)) {
                        return false;
                    }
                    switch(code){
                        case 125 /* CharacterCodes.closeBrace */ :
                        case 93 /* CharacterCodes.closeBracket */ :
                        case 123 /* CharacterCodes.openBrace */ :
                        case 91 /* CharacterCodes.openBracket */ :
                        case 34 /* CharacterCodes.doubleQuote */ :
                        case 58 /* CharacterCodes.colon */ :
                        case 44 /* CharacterCodes.comma */ :
                        case 47 /* CharacterCodes.slash */ :
                            return false;
                    }
                    return true;
                }
                function scanNextNonTrivia() {
                    let result;
                    do {
                        result = scanNext();
                    }while (result >= 12 /* SyntaxKind.LineCommentTrivia */  && result <= 15 /* SyntaxKind.Trivia */ )
                    return result;
                }
                return {
                    setPosition: setPosition,
                    getPosition: ()=>pos,
                    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
                    getToken: ()=>token,
                    getTokenValue: ()=>value,
                    getTokenOffset: ()=>tokenOffset,
                    getTokenLength: ()=>pos - tokenOffset,
                    getTokenStartLine: ()=>lineStartOffset,
                    getTokenStartCharacter: ()=>tokenOffset - prevTokenLineStartOffset,
                    getTokenError: ()=>scanError
                };
            }
            function isWhiteSpace(ch) {
                return ch === 32 /* CharacterCodes.space */  || ch === 9 /* CharacterCodes.tab */ ;
            }
            function isLineBreak(ch) {
                return ch === 10 /* CharacterCodes.lineFeed */  || ch === 13 /* CharacterCodes.carriageReturn */ ;
            }
            function isDigit(ch) {
                return ch >= 48 /* CharacterCodes._0 */  && ch <= 57 /* CharacterCodes._9 */ ;
            }
            var CharacterCodes;
            (function(CharacterCodes) {
                CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
                CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
                CharacterCodes[CharacterCodes["space"] = 32] = "space";
                CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
                CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
                CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
                CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
                CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
                CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
                CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
                CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
                CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
                CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
                CharacterCodes[CharacterCodes["a"] = 97] = "a";
                CharacterCodes[CharacterCodes["b"] = 98] = "b";
                CharacterCodes[CharacterCodes["c"] = 99] = "c";
                CharacterCodes[CharacterCodes["d"] = 100] = "d";
                CharacterCodes[CharacterCodes["e"] = 101] = "e";
                CharacterCodes[CharacterCodes["f"] = 102] = "f";
                CharacterCodes[CharacterCodes["g"] = 103] = "g";
                CharacterCodes[CharacterCodes["h"] = 104] = "h";
                CharacterCodes[CharacterCodes["i"] = 105] = "i";
                CharacterCodes[CharacterCodes["j"] = 106] = "j";
                CharacterCodes[CharacterCodes["k"] = 107] = "k";
                CharacterCodes[CharacterCodes["l"] = 108] = "l";
                CharacterCodes[CharacterCodes["m"] = 109] = "m";
                CharacterCodes[CharacterCodes["n"] = 110] = "n";
                CharacterCodes[CharacterCodes["o"] = 111] = "o";
                CharacterCodes[CharacterCodes["p"] = 112] = "p";
                CharacterCodes[CharacterCodes["q"] = 113] = "q";
                CharacterCodes[CharacterCodes["r"] = 114] = "r";
                CharacterCodes[CharacterCodes["s"] = 115] = "s";
                CharacterCodes[CharacterCodes["t"] = 116] = "t";
                CharacterCodes[CharacterCodes["u"] = 117] = "u";
                CharacterCodes[CharacterCodes["v"] = 118] = "v";
                CharacterCodes[CharacterCodes["w"] = 119] = "w";
                CharacterCodes[CharacterCodes["x"] = 120] = "x";
                CharacterCodes[CharacterCodes["y"] = 121] = "y";
                CharacterCodes[CharacterCodes["z"] = 122] = "z";
                CharacterCodes[CharacterCodes["A"] = 65] = "A";
                CharacterCodes[CharacterCodes["B"] = 66] = "B";
                CharacterCodes[CharacterCodes["C"] = 67] = "C";
                CharacterCodes[CharacterCodes["D"] = 68] = "D";
                CharacterCodes[CharacterCodes["E"] = 69] = "E";
                CharacterCodes[CharacterCodes["F"] = 70] = "F";
                CharacterCodes[CharacterCodes["G"] = 71] = "G";
                CharacterCodes[CharacterCodes["H"] = 72] = "H";
                CharacterCodes[CharacterCodes["I"] = 73] = "I";
                CharacterCodes[CharacterCodes["J"] = 74] = "J";
                CharacterCodes[CharacterCodes["K"] = 75] = "K";
                CharacterCodes[CharacterCodes["L"] = 76] = "L";
                CharacterCodes[CharacterCodes["M"] = 77] = "M";
                CharacterCodes[CharacterCodes["N"] = 78] = "N";
                CharacterCodes[CharacterCodes["O"] = 79] = "O";
                CharacterCodes[CharacterCodes["P"] = 80] = "P";
                CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
                CharacterCodes[CharacterCodes["R"] = 82] = "R";
                CharacterCodes[CharacterCodes["S"] = 83] = "S";
                CharacterCodes[CharacterCodes["T"] = 84] = "T";
                CharacterCodes[CharacterCodes["U"] = 85] = "U";
                CharacterCodes[CharacterCodes["V"] = 86] = "V";
                CharacterCodes[CharacterCodes["W"] = 87] = "W";
                CharacterCodes[CharacterCodes["X"] = 88] = "X";
                CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
                CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
                CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
                CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
                CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
                CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
                CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
                CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
                CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
                CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
                CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
                CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
                CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
                CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
                CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
                CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
                CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
            })(CharacterCodes || (CharacterCodes = {}));
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/format.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function format_format(documentText, range, options) {
                let initialIndentLevel;
                let formatText;
                let formatTextStart;
                let rangeStart;
                let rangeEnd;
                if (range) {
                    rangeStart = range.offset;
                    rangeEnd = rangeStart + range.length;
                    formatTextStart = rangeStart;
                    while(formatTextStart > 0 && !format_isEOL(documentText, formatTextStart - 1)){
                        formatTextStart--;
                    }
                    let endOffset = rangeEnd;
                    while(endOffset < documentText.length && !format_isEOL(documentText, endOffset)){
                        endOffset++;
                    }
                    formatText = documentText.substring(formatTextStart, endOffset);
                    initialIndentLevel = computeIndentLevel(formatText, options);
                } else {
                    formatText = documentText;
                    initialIndentLevel = 0;
                    formatTextStart = 0;
                    rangeStart = 0;
                    rangeEnd = documentText.length;
                }
                const eol = getEOL(options, documentText);
                let numberLineBreaks = 0;
                let indentLevel = 0;
                let indentValue;
                if (options.insertSpaces) {
                    indentValue = repeat(' ', options.tabSize || 4);
                } else {
                    indentValue = '\t';
                }
                let scanner = createScanner(formatText, false);
                let hasError = false;
                function newLinesAndIndent() {
                    if (numberLineBreaks > 1) {
                        return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
                    } else {
                        return eol + repeat(indentValue, initialIndentLevel + indentLevel);
                    }
                }
                function scanNext() {
                    let token = scanner.scan();
                    numberLineBreaks = 0;
                    while(token === 15 /* SyntaxKind.Trivia */  || token === 14 /* SyntaxKind.LineBreakTrivia */ ){
                        if (token === 14 /* SyntaxKind.LineBreakTrivia */  && options.keepLines) {
                            numberLineBreaks += 1;
                        } else if (token === 14 /* SyntaxKind.LineBreakTrivia */ ) {
                            numberLineBreaks = 1;
                        }
                        token = scanner.scan();
                    }
                    hasError = token === 16 /* SyntaxKind.Unknown */  || scanner.getTokenError() !== 0 /* ScanError.None */ ;
                    return token;
                }
                const editOperations = [];
                function addEdit(text, startOffset, endOffset) {
                    if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {
                        editOperations.push({
                            offset: startOffset,
                            length: endOffset - startOffset,
                            content: text
                        });
                    }
                }
                let firstToken = scanNext();
                if (options.keepLines && numberLineBreaks > 0) {
                    addEdit(repeat(eol, numberLineBreaks), 0, 0);
                }
                if (firstToken !== 17 /* SyntaxKind.EOF */ ) {
                    let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
                    let initialIndent = repeat(indentValue, initialIndentLevel);
                    addEdit(initialIndent, formatTextStart, firstTokenStart);
                }
                while(firstToken !== 17 /* SyntaxKind.EOF */ ){
                    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
                    let secondToken = scanNext();
                    let replaceContent = '';
                    let needsLineBreak = false;
                    while(numberLineBreaks === 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ )){
                        let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
                        addEdit(' ', firstTokenEnd, commentTokenStart);
                        firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
                        needsLineBreak = secondToken === 12 /* SyntaxKind.LineCommentTrivia */ ;
                        replaceContent = needsLineBreak ? newLinesAndIndent() : '';
                        secondToken = scanNext();
                    }
                    if (secondToken === 2 /* SyntaxKind.CloseBraceToken */ ) {
                        if (firstToken !== 1 /* SyntaxKind.OpenBraceToken */ ) {
                            indentLevel--;
                        }
                        ;
                        if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1 /* SyntaxKind.OpenBraceToken */ ) {
                            replaceContent = newLinesAndIndent();
                        } else if (options.keepLines) {
                            replaceContent = ' ';
                        }
                    } else if (secondToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                        if (firstToken !== 3 /* SyntaxKind.OpenBracketToken */ ) {
                            indentLevel--;
                        }
                        ;
                        if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3 /* SyntaxKind.OpenBracketToken */ ) {
                            replaceContent = newLinesAndIndent();
                        } else if (options.keepLines) {
                            replaceContent = ' ';
                        }
                    } else {
                        switch(firstToken){
                            case 3 /* SyntaxKind.OpenBracketToken */ :
                            case 1 /* SyntaxKind.OpenBraceToken */ :
                                indentLevel++;
                                if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    replaceContent = ' ';
                                }
                                break;
                            case 5 /* SyntaxKind.CommaToken */ :
                                if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    replaceContent = ' ';
                                }
                                break;
                            case 12 /* SyntaxKind.LineCommentTrivia */ :
                                replaceContent = newLinesAndIndent();
                                break;
                            case 13 /* SyntaxKind.BlockCommentTrivia */ :
                                if (numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (!needsLineBreak) {
                                    replaceContent = ' ';
                                }
                                break;
                            case 6 /* SyntaxKind.ColonToken */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (!needsLineBreak) {
                                    replaceContent = ' ';
                                }
                                break;
                            case 10 /* SyntaxKind.StringLiteral */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (secondToken === 6 /* SyntaxKind.ColonToken */  && !needsLineBreak) {
                                    replaceContent = '';
                                }
                                break;
                            case 7 /* SyntaxKind.NullKeyword */ :
                            case 8 /* SyntaxKind.TrueKeyword */ :
                            case 9 /* SyntaxKind.FalseKeyword */ :
                            case 11 /* SyntaxKind.NumericLiteral */ :
                            case 2 /* SyntaxKind.CloseBraceToken */ :
                            case 4 /* SyntaxKind.CloseBracketToken */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    if ((secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ ) && !needsLineBreak) {
                                        replaceContent = ' ';
                                    } else if (secondToken !== 5 /* SyntaxKind.CommaToken */  && secondToken !== 17 /* SyntaxKind.EOF */ ) {
                                        hasError = true;
                                    }
                                }
                                break;
                            case 16 /* SyntaxKind.Unknown */ :
                                hasError = true;
                                break;
                        }
                        if (numberLineBreaks > 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ )) {
                            replaceContent = newLinesAndIndent();
                        }
                    }
                    if (secondToken === 17 /* SyntaxKind.EOF */ ) {
                        if (options.keepLines && numberLineBreaks > 0) {
                            replaceContent = newLinesAndIndent();
                        } else {
                            replaceContent = options.insertFinalNewline ? eol : '';
                        }
                    }
                    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
                    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
                    firstToken = secondToken;
                }
                return editOperations;
            }
            function repeat(s, count) {
                let result = '';
                for(let i = 0; i < count; i++){
                    result += s;
                }
                return result;
            }
            function computeIndentLevel(content, options) {
                let i = 0;
                let nChars = 0;
                const tabSize = options.tabSize || 4;
                while(i < content.length){
                    let ch = content.charAt(i);
                    if (ch === ' ') {
                        nChars++;
                    } else if (ch === '\t') {
                        nChars += tabSize;
                    } else {
                        break;
                    }
                    i++;
                }
                return Math.floor(nChars / tabSize);
            }
            function getEOL(options, text) {
                for(let i = 0; i < text.length; i++){
                    const ch = text.charAt(i);
                    if (ch === '\r') {
                        if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                            return '\r\n';
                        }
                        return '\r';
                    } else if (ch === '\n') {
                        return '\n';
                    }
                }
                return options && options.eol || '\n';
            }
            function format_isEOL(text, offset) {
                return '\r\n'.indexOf(text.charAt(offset)) !== -1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/parser.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var ParseOptions;
            (function(ParseOptions) {
                ParseOptions.DEFAULT = {
                    allowTrailingComma: false
                };
            })(ParseOptions || (ParseOptions = {}));
            /**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */ function getLocation(text, position) {
                const segments = []; // strings or numbers
                const earlyReturnException = new Object();
                let previousNode = undefined;
                const previousNodeInst = {
                    value: {},
                    offset: 0,
                    length: 0,
                    type: 'object',
                    parent: undefined
                };
                let isAtPropertyKey = false;
                function setPreviousNode(value, offset, length, type) {
                    previousNodeInst.value = value;
                    previousNodeInst.offset = offset;
                    previousNodeInst.length = length;
                    previousNodeInst.type = type;
                    previousNodeInst.colonOffset = undefined;
                    previousNode = previousNodeInst;
                }
                try {
                    visit(text, {
                        onObjectBegin: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            isAtPropertyKey = position > offset;
                            segments.push(''); // push a placeholder (will be replaced)
                        },
                        onObjectProperty: (name, offset, length)=>{
                            if (position < offset) {
                                throw earlyReturnException;
                            }
                            setPreviousNode(name, offset, length, 'property');
                            segments[segments.length - 1] = name;
                            if (position <= offset + length) {
                                throw earlyReturnException;
                            }
                        },
                        onObjectEnd: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.pop();
                        },
                        onArrayBegin: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.push(0);
                        },
                        onArrayEnd: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.pop();
                        },
                        onLiteralValue: (value, offset, length)=>{
                            if (position < offset) {
                                throw earlyReturnException;
                            }
                            setPreviousNode(value, offset, length, getNodeType(value));
                            if (position <= offset + length) {
                                throw earlyReturnException;
                            }
                        },
                        onSeparator: (sep, offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            if (sep === ':' && previousNode && previousNode.type === 'property') {
                                previousNode.colonOffset = offset;
                                isAtPropertyKey = false;
                                previousNode = undefined;
                            } else if (sep === ',') {
                                const last = segments[segments.length - 1];
                                if (typeof last === 'number') {
                                    segments[segments.length - 1] = last + 1;
                                } else {
                                    isAtPropertyKey = true;
                                    segments[segments.length - 1] = '';
                                }
                                previousNode = undefined;
                            }
                        }
                    });
                } catch (e) {
                    if (e !== earlyReturnException) {
                        throw e;
                    }
                }
                return {
                    path: segments,
                    previousNode,
                    isAtPropertyKey,
                    matches: (pattern)=>{
                        let k = 0;
                        for(let i = 0; k < pattern.length && i < segments.length; i++){
                            if (pattern[k] === segments[i] || pattern[k] === '*') {
                                k++;
                            } else if (pattern[k] !== '**') {
                                return false;
                            }
                        }
                        return k === pattern.length;
                    }
                };
            }
            /**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */ function parse(text, errors = [], options = ParseOptions.DEFAULT) {
                let currentProperty = null;
                let currentParent = [];
                const previousParents = [];
                function onValue(value) {
                    if (Array.isArray(currentParent)) {
                        currentParent.push(value);
                    } else if (currentProperty !== null) {
                        currentParent[currentProperty] = value;
                    }
                }
                const visitor = {
                    onObjectBegin: ()=>{
                        const object = {};
                        onValue(object);
                        previousParents.push(currentParent);
                        currentParent = object;
                        currentProperty = null;
                    },
                    onObjectProperty: (name)=>{
                        currentProperty = name;
                    },
                    onObjectEnd: ()=>{
                        currentParent = previousParents.pop();
                    },
                    onArrayBegin: ()=>{
                        const array = [];
                        onValue(array);
                        previousParents.push(currentParent);
                        currentParent = array;
                        currentProperty = null;
                    },
                    onArrayEnd: ()=>{
                        currentParent = previousParents.pop();
                    },
                    onLiteralValue: onValue,
                    onError: (error, offset, length)=>{
                        errors.push({
                            error,
                            offset,
                            length
                        });
                    }
                };
                visit(text, visitor, options);
                return currentParent[0];
            }
            /**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */ function parser_parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
                let currentParent = {
                    type: 'array',
                    offset: -1,
                    length: -1,
                    children: [],
                    parent: undefined
                }; // artificial root
                function ensurePropertyComplete(endOffset) {
                    if (currentParent.type === 'property') {
                        currentParent.length = endOffset - currentParent.offset;
                        currentParent = currentParent.parent;
                    }
                }
                function onValue(valueNode) {
                    currentParent.children.push(valueNode);
                    return valueNode;
                }
                const visitor = {
                    onObjectBegin: (offset)=>{
                        currentParent = onValue({
                            type: 'object',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                    },
                    onObjectProperty: (name, offset, length)=>{
                        currentParent = onValue({
                            type: 'property',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                        currentParent.children.push({
                            type: 'string',
                            value: name,
                            offset,
                            length,
                            parent: currentParent
                        });
                    },
                    onObjectEnd: (offset, length)=>{
                        ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete
                        currentParent.length = offset + length - currentParent.offset;
                        currentParent = currentParent.parent;
                        ensurePropertyComplete(offset + length);
                    },
                    onArrayBegin: (offset, length)=>{
                        currentParent = onValue({
                            type: 'array',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                    },
                    onArrayEnd: (offset, length)=>{
                        currentParent.length = offset + length - currentParent.offset;
                        currentParent = currentParent.parent;
                        ensurePropertyComplete(offset + length);
                    },
                    onLiteralValue: (value, offset, length)=>{
                        onValue({
                            type: getNodeType(value),
                            offset,
                            length,
                            parent: currentParent,
                            value
                        });
                        ensurePropertyComplete(offset + length);
                    },
                    onSeparator: (sep, offset, length)=>{
                        if (currentParent.type === 'property') {
                            if (sep === ':') {
                                currentParent.colonOffset = offset;
                            } else if (sep === ',') {
                                ensurePropertyComplete(offset);
                            }
                        }
                    },
                    onError: (error, offset, length)=>{
                        errors.push({
                            error,
                            offset,
                            length
                        });
                    }
                };
                visit(text, visitor, options);
                const result = currentParent.children[0];
                if (result) {
                    delete result.parent;
                }
                return result;
            }
            /**
 * Finds the node at the given path in a JSON DOM.
 */ function parser_findNodeAtLocation(root, path) {
                if (!root) {
                    return undefined;
                }
                let node = root;
                for (let segment of path){
                    if (typeof segment === 'string') {
                        if (node.type !== 'object' || !Array.isArray(node.children)) {
                            return undefined;
                        }
                        let found = false;
                        for (const propertyNode of node.children){
                            if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
                                node = propertyNode.children[1];
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            return undefined;
                        }
                    } else {
                        const index = segment;
                        if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                            return undefined;
                        }
                        node = node.children[index];
                    }
                }
                return node;
            }
            /**
 * Gets the JSON path of the given JSON DOM node
 */ function getNodePath(node) {
                if (!node.parent || !node.parent.children) {
                    return [];
                }
                const path = getNodePath(node.parent);
                if (node.parent.type === 'property') {
                    const key = node.parent.children[0].value;
                    path.push(key);
                } else if (node.parent.type === 'array') {
                    const index = node.parent.children.indexOf(node);
                    if (index !== -1) {
                        path.push(index);
                    }
                }
                return path;
            }
            /**
 * Evaluates the JavaScript object of the given JSON DOM node
 */ function getNodeValue(node) {
                switch(node.type){
                    case 'array':
                        return node.children.map(getNodeValue);
                    case 'object':
                        const obj = Object.create(null);
                        for (let prop of node.children){
                            const valueNode = prop.children[1];
                            if (valueNode) {
                                obj[prop.children[0].value] = getNodeValue(valueNode);
                            }
                        }
                        return obj;
                    case 'null':
                    case 'string':
                    case 'number':
                    case 'boolean':
                        return node.value;
                    default:
                        return undefined;
                }
            }
            function contains(node, offset, includeRightBound = false) {
                return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
            }
            /**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */ function findNodeAtOffset(node, offset, includeRightBound = false) {
                if (contains(node, offset, includeRightBound)) {
                    const children = node.children;
                    if (Array.isArray(children)) {
                        for(let i = 0; i < children.length && children[i].offset <= offset; i++){
                            const item = findNodeAtOffset(children[i], offset, includeRightBound);
                            if (item) {
                                return item;
                            }
                        }
                    }
                    return node;
                }
                return undefined;
            }
            /**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */ function visit(text, visitor, options = ParseOptions.DEFAULT) {
                const _scanner = createScanner(text, false);
                // Important: Only pass copies of this to visitor functions to prevent accidental modification, and
                // to not affect visitor functions which stored a reference to a previous JSONPath
                const _jsonPath = [];
                function toNoArgVisit(visitFunction) {
                    return visitFunction ? ()=>visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : ()=>true;
                }
                function toNoArgVisitWithPath(visitFunction) {
                    return visitFunction ? ()=>visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), ()=>_jsonPath.slice()) : ()=>true;
                }
                function toOneArgVisit(visitFunction) {
                    return visitFunction ? (arg)=>visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : ()=>true;
                }
                function toOneArgVisitWithPath(visitFunction) {
                    return visitFunction ? (arg)=>visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), ()=>_jsonPath.slice()) : ()=>true;
                }
                const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
                const disallowComments = options && options.disallowComments;
                const allowTrailingComma = options && options.allowTrailingComma;
                function scanNext() {
                    while(true){
                        const token = _scanner.scan();
                        switch(_scanner.getTokenError()){
                            case 4 /* ScanError.InvalidUnicode */ :
                                handleError(14 /* ParseErrorCode.InvalidUnicode */ );
                                break;
                            case 5 /* ScanError.InvalidEscapeCharacter */ :
                                handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */ );
                                break;
                            case 3 /* ScanError.UnexpectedEndOfNumber */ :
                                handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */ );
                                break;
                            case 1 /* ScanError.UnexpectedEndOfComment */ :
                                if (!disallowComments) {
                                    handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */ );
                                }
                                break;
                            case 2 /* ScanError.UnexpectedEndOfString */ :
                                handleError(12 /* ParseErrorCode.UnexpectedEndOfString */ );
                                break;
                            case 6 /* ScanError.InvalidCharacter */ :
                                handleError(16 /* ParseErrorCode.InvalidCharacter */ );
                                break;
                        }
                        switch(token){
                            case 12 /* SyntaxKind.LineCommentTrivia */ :
                            case 13 /* SyntaxKind.BlockCommentTrivia */ :
                                if (disallowComments) {
                                    handleError(10 /* ParseErrorCode.InvalidCommentToken */ );
                                } else {
                                    onComment();
                                }
                                break;
                            case 16 /* SyntaxKind.Unknown */ :
                                handleError(1 /* ParseErrorCode.InvalidSymbol */ );
                                break;
                            case 15 /* SyntaxKind.Trivia */ :
                            case 14 /* SyntaxKind.LineBreakTrivia */ :
                                break;
                            default:
                                return token;
                        }
                    }
                }
                function handleError(error, skipUntilAfter = [], skipUntil = []) {
                    onError(error);
                    if (skipUntilAfter.length + skipUntil.length > 0) {
                        let token = _scanner.getToken();
                        while(token !== 17 /* SyntaxKind.EOF */ ){
                            if (skipUntilAfter.indexOf(token) !== -1) {
                                scanNext();
                                break;
                            } else if (skipUntil.indexOf(token) !== -1) {
                                break;
                            }
                            token = scanNext();
                        }
                    }
                }
                function parseString(isValue) {
                    const value = _scanner.getTokenValue();
                    if (isValue) {
                        onLiteralValue(value);
                    } else {
                        onObjectProperty(value);
                        // add property name afterwards
                        _jsonPath.push(value);
                    }
                    scanNext();
                    return true;
                }
                function parseLiteral() {
                    switch(_scanner.getToken()){
                        case 11 /* SyntaxKind.NumericLiteral */ :
                            const tokenValue = _scanner.getTokenValue();
                            let value = Number(tokenValue);
                            if (isNaN(value)) {
                                handleError(2 /* ParseErrorCode.InvalidNumberFormat */ );
                                value = 0;
                            }
                            onLiteralValue(value);
                            break;
                        case 7 /* SyntaxKind.NullKeyword */ :
                            onLiteralValue(null);
                            break;
                        case 8 /* SyntaxKind.TrueKeyword */ :
                            onLiteralValue(true);
                            break;
                        case 9 /* SyntaxKind.FalseKeyword */ :
                            onLiteralValue(false);
                            break;
                        default:
                            return false;
                    }
                    scanNext();
                    return true;
                }
                function parseProperty() {
                    if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */ ) {
                        handleError(3 /* ParseErrorCode.PropertyNameExpected */ , [], [
                            2 /* SyntaxKind.CloseBraceToken */ ,
                            5 /* SyntaxKind.CommaToken */ 
                        ]);
                        return false;
                    }
                    parseString(false);
                    if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */ ) {
                        onSeparator(':');
                        scanNext(); // consume colon
                        if (!parseValue()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                2 /* SyntaxKind.CloseBraceToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                    } else {
                        handleError(5 /* ParseErrorCode.ColonExpected */ , [], [
                            2 /* SyntaxKind.CloseBraceToken */ ,
                            5 /* SyntaxKind.CommaToken */ 
                        ]);
                    }
                    _jsonPath.pop(); // remove processed property name
                    return true;
                }
                function parseObject() {
                    onObjectBegin();
                    scanNext(); // consume open brace
                    let needsComma = false;
                    while(_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */  && _scanner.getToken() !== 17 /* SyntaxKind.EOF */ ){
                        if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                            }
                            onSeparator(',');
                            scanNext(); // consume comma
                            if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */  && allowTrailingComma) {
                                break;
                            }
                        } else if (needsComma) {
                            handleError(6 /* ParseErrorCode.CommaExpected */ , [], []);
                        }
                        if (!parseProperty()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                2 /* SyntaxKind.CloseBraceToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                        needsComma = true;
                    }
                    onObjectEnd();
                    if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ ) {
                        handleError(7 /* ParseErrorCode.CloseBraceExpected */ , [
                            2 /* SyntaxKind.CloseBraceToken */ 
                        ], []);
                    } else {
                        scanNext(); // consume close brace
                    }
                    return true;
                }
                function parseArray() {
                    onArrayBegin();
                    scanNext(); // consume open bracket
                    let isFirstElement = true;
                    let needsComma = false;
                    while(_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */  && _scanner.getToken() !== 17 /* SyntaxKind.EOF */ ){
                        if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                            }
                            onSeparator(',');
                            scanNext(); // consume comma
                            if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */  && allowTrailingComma) {
                                break;
                            }
                        } else if (needsComma) {
                            handleError(6 /* ParseErrorCode.CommaExpected */ , [], []);
                        }
                        if (isFirstElement) {
                            _jsonPath.push(0);
                            isFirstElement = false;
                        } else {
                            _jsonPath[_jsonPath.length - 1]++;
                        }
                        if (!parseValue()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                4 /* SyntaxKind.CloseBracketToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                        needsComma = true;
                    }
                    onArrayEnd();
                    if (!isFirstElement) {
                        _jsonPath.pop(); // remove array index
                    }
                    if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ ) {
                        handleError(8 /* ParseErrorCode.CloseBracketExpected */ , [
                            4 /* SyntaxKind.CloseBracketToken */ 
                        ], []);
                    } else {
                        scanNext(); // consume close bracket
                    }
                    return true;
                }
                function parseValue() {
                    switch(_scanner.getToken()){
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            return parseArray();
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                            return parseObject();
                        case 10 /* SyntaxKind.StringLiteral */ :
                            return parseString(true);
                        default:
                            return parseLiteral();
                    }
                }
                scanNext();
                if (_scanner.getToken() === 17 /* SyntaxKind.EOF */ ) {
                    if (options.allowEmptyContent) {
                        return true;
                    }
                    handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                    return false;
                }
                if (!parseValue()) {
                    handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                    return false;
                }
                if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */ ) {
                    handleError(9 /* ParseErrorCode.EndOfFileExpected */ , [], []);
                }
                return true;
            }
            /**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */ function stripComments(text, replaceCh) {
                let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
                do {
                    pos = _scanner.getPosition();
                    kind = _scanner.scan();
                    switch(kind){
                        case 12 /* SyntaxKind.LineCommentTrivia */ :
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                        case 17 /* SyntaxKind.EOF */ :
                            if (offset !== pos) {
                                parts.push(text.substring(offset, pos));
                            }
                            if (replaceCh !== undefined) {
                                parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                            }
                            offset = _scanner.getPosition();
                            break;
                    }
                }while (kind !== 17 /* SyntaxKind.EOF */ )
                return parts.join('');
            }
            function getNodeType(value) {
                switch(typeof value){
                    case 'boolean':
                        return 'boolean';
                    case 'number':
                        return 'number';
                    case 'string':
                        return 'string';
                    case 'object':
                        {
                            if (!value) {
                                return 'null';
                            } else if (Array.isArray(value)) {
                                return 'array';
                            }
                            return 'object';
                        }
                    default:
                        return 'null';
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/edit.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function removeProperty(text, path, options) {
                return setProperty(text, path, void 0, options);
            }
            function setProperty(text, originalPath, value, options) {
                const path = originalPath.slice();
                const errors = [];
                const root = parseTree(text, errors);
                let parent = void 0;
                let lastSegment = void 0;
                while(path.length > 0){
                    lastSegment = path.pop();
                    parent = findNodeAtLocation(root, path);
                    if (parent === void 0 && value !== void 0) {
                        if (typeof lastSegment === 'string') {
                            value = {
                                [lastSegment]: value
                            };
                        } else {
                            value = [
                                value
                            ];
                        }
                    } else {
                        break;
                    }
                }
                if (!parent) {
                    // empty document
                    if (value === void 0) {
                        throw new Error('Can not delete in empty document');
                    }
                    return withFormatting(text, {
                        offset: root ? root.offset : 0,
                        length: root ? root.length : 0,
                        content: JSON.stringify(value)
                    }, options);
                } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {
                    const existing = findNodeAtLocation(parent, [
                        lastSegment
                    ]);
                    if (existing !== void 0) {
                        if (value === void 0) {
                            if (!existing.parent) {
                                throw new Error('Malformed AST');
                            }
                            const propertyIndex = parent.children.indexOf(existing.parent);
                            let removeBegin;
                            let removeEnd = existing.parent.offset + existing.parent.length;
                            if (propertyIndex > 0) {
                                // remove the comma of the previous node
                                let previous = parent.children[propertyIndex - 1];
                                removeBegin = previous.offset + previous.length;
                            } else {
                                removeBegin = parent.offset + 1;
                                if (parent.children.length > 1) {
                                    // remove the comma of the next node
                                    let next = parent.children[1];
                                    removeEnd = next.offset;
                                }
                            }
                            return withFormatting(text, {
                                offset: removeBegin,
                                length: removeEnd - removeBegin,
                                content: ''
                            }, options);
                        } else {
                            // set value of existing property
                            return withFormatting(text, {
                                offset: existing.offset,
                                length: existing.length,
                                content: JSON.stringify(value)
                            }, options);
                        }
                    } else {
                        if (value === void 0) {
                            return []; // property does not exist, nothing to do
                        }
                        const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
                        const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map((p)=>p.children[0].value)) : parent.children.length;
                        let edit1;
                        if (index > 0) {
                            let previous = parent.children[index - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        } else if (parent.children.length === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty
                            };
                        } else {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty + ','
                            };
                        }
                        return withFormatting(text, edit1, options);
                    }
                } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {
                    const insertIndex = lastSegment;
                    if (insertIndex === -1) {
                        // Insert
                        const newProperty = `${JSON.stringify(value)}`;
                        let edit1;
                        if (parent.children.length === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty
                            };
                        } else {
                            const previous = parent.children[parent.children.length - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else if (value === void 0 && parent.children.length >= 0) {
                        // Removal
                        const removalIndex = lastSegment;
                        const toRemove = parent.children[removalIndex];
                        let edit1;
                        if (parent.children.length === 1) {
                            // only item
                            edit1 = {
                                offset: parent.offset + 1,
                                length: parent.length - 2,
                                content: ''
                            };
                        } else if (parent.children.length - 1 === removalIndex) {
                            // last item
                            let previous = parent.children[removalIndex - 1];
                            let offset = previous.offset + previous.length;
                            let parentEndOffset = parent.offset + parent.length;
                            edit1 = {
                                offset,
                                length: parentEndOffset - 2 - offset,
                                content: ''
                            };
                        } else {
                            edit1 = {
                                offset: toRemove.offset,
                                length: parent.children[removalIndex + 1].offset - toRemove.offset,
                                content: ''
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else if (value !== void 0) {
                        let edit1;
                        const newProperty = `${JSON.stringify(value)}`;
                        if (!options.isArrayInsertion && parent.children.length > lastSegment) {
                            const toModify = parent.children[lastSegment];
                            edit1 = {
                                offset: toModify.offset,
                                length: toModify.length,
                                content: newProperty
                            };
                        } else if (parent.children.length === 0 || lastSegment === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: parent.children.length === 0 ? newProperty : newProperty + ','
                            };
                        } else {
                            const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
                            const previous = parent.children[index - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else {
                        throw new Error(`Can not ${value === void 0 ? 'remove' : options.isArrayInsertion ? 'insert' : 'modify'} Array index ${insertIndex} as length is not sufficient`);
                    }
                } else {
                    throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);
                }
            }
            function withFormatting(text, edit1, options) {
                if (!options.formattingOptions) {
                    return [
                        edit1
                    ];
                }
                // apply the edit
                let newText = applyEdit(text, edit1);
                // format the new text
                let begin = edit1.offset;
                let end = edit1.offset + edit1.content.length;
                if (edit1.length === 0 || edit1.content.length === 0) {
                    while(begin > 0 && !isEOL(newText, begin - 1)){
                        begin--;
                    }
                    while(end < newText.length && !isEOL(newText, end)){
                        end++;
                    }
                }
                const edits = format(newText, {
                    offset: begin,
                    length: end - begin
                }, {
                    ...options.formattingOptions,
                    keepLines: false
                });
                // apply the formatting edits and track the begin and end offsets of the changes
                for(let i = edits.length - 1; i >= 0; i--){
                    const edit1 = edits[i];
                    newText = applyEdit(newText, edit1);
                    begin = Math.min(begin, edit1.offset);
                    end = Math.max(end, edit1.offset + edit1.length);
                    end += edit1.content.length - edit1.length;
                }
                // create a single edit with all changes
                const editLength = text.length - (newText.length - end) - begin;
                return [
                    {
                        offset: begin,
                        length: editLength,
                        content: newText.substring(begin, end)
                    }
                ];
            }
            function applyEdit(text, edit1) {
                return text.substring(0, edit1.offset) + edit1.content + text.substring(edit1.offset + edit1.length);
            }
            function isWS(text, offset) {
                return '\r\n \t'.indexOf(text.charAt(offset)) !== -1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/main.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */ const main_createScanner = createScanner;
            var ScanError;
            (function(ScanError) {
                ScanError[ScanError["None"] = 0] = "None";
                ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
                ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
                ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
                ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
                ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
                ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
            })(ScanError || (ScanError = {}));
            var SyntaxKind;
            (function(SyntaxKind) {
                SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
                SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
                SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
                SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
                SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
                SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
                SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
                SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
                SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
                SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
                SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
                SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
                SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
                SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
                SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
                SyntaxKind[SyntaxKind["Unknown"] = 16] = "Unknown";
                SyntaxKind[SyntaxKind["EOF"] = 17] = "EOF";
            })(SyntaxKind || (SyntaxKind = {}));
            /**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */ const main_getLocation = getLocation;
            /**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore, always check the errors list to find out if the input was valid.
 */ const main_parse = parse;
            /**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */ const main_parseTree = parser_parseTree;
            /**
 * Finds the node at the given path in a JSON DOM.
 */ const main_findNodeAtLocation = parser_findNodeAtLocation;
            /**
 * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */ const main_findNodeAtOffset = findNodeAtOffset;
            /**
 * Gets the JSON path of the given JSON DOM node
 */ const main_getNodePath = getNodePath;
            /**
 * Evaluates the JavaScript object of the given JSON DOM node
 */ const main_getNodeValue = getNodeValue;
            /**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */ const main_visit = visit;
            /**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */ const main_stripComments = stripComments;
            var ParseErrorCode;
            (function(ParseErrorCode) {
                ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 1] = "InvalidSymbol";
                ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
                ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 3] = "PropertyNameExpected";
                ParseErrorCode[ParseErrorCode["ValueExpected"] = 4] = "ValueExpected";
                ParseErrorCode[ParseErrorCode["ColonExpected"] = 5] = "ColonExpected";
                ParseErrorCode[ParseErrorCode["CommaExpected"] = 6] = "CommaExpected";
                ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 7] = "CloseBraceExpected";
                ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 8] = "CloseBracketExpected";
                ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 9] = "EndOfFileExpected";
                ParseErrorCode[ParseErrorCode["InvalidCommentToken"] = 10] = "InvalidCommentToken";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
                ParseErrorCode[ParseErrorCode["InvalidUnicode"] = 14] = "InvalidUnicode";
                ParseErrorCode[ParseErrorCode["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
                ParseErrorCode[ParseErrorCode["InvalidCharacter"] = 16] = "InvalidCharacter";
            })(ParseErrorCode || (ParseErrorCode = {}));
            function printParseErrorCode(code) {
                switch(code){
                    case 1 /* ParseErrorCode.InvalidSymbol */ :
                        return 'InvalidSymbol';
                    case 2 /* ParseErrorCode.InvalidNumberFormat */ :
                        return 'InvalidNumberFormat';
                    case 3 /* ParseErrorCode.PropertyNameExpected */ :
                        return 'PropertyNameExpected';
                    case 4 /* ParseErrorCode.ValueExpected */ :
                        return 'ValueExpected';
                    case 5 /* ParseErrorCode.ColonExpected */ :
                        return 'ColonExpected';
                    case 6 /* ParseErrorCode.CommaExpected */ :
                        return 'CommaExpected';
                    case 7 /* ParseErrorCode.CloseBraceExpected */ :
                        return 'CloseBraceExpected';
                    case 8 /* ParseErrorCode.CloseBracketExpected */ :
                        return 'CloseBracketExpected';
                    case 9 /* ParseErrorCode.EndOfFileExpected */ :
                        return 'EndOfFileExpected';
                    case 10 /* ParseErrorCode.InvalidCommentToken */ :
                        return 'InvalidCommentToken';
                    case 11 /* ParseErrorCode.UnexpectedEndOfComment */ :
                        return 'UnexpectedEndOfComment';
                    case 12 /* ParseErrorCode.UnexpectedEndOfString */ :
                        return 'UnexpectedEndOfString';
                    case 13 /* ParseErrorCode.UnexpectedEndOfNumber */ :
                        return 'UnexpectedEndOfNumber';
                    case 14 /* ParseErrorCode.InvalidUnicode */ :
                        return 'InvalidUnicode';
                    case 15 /* ParseErrorCode.InvalidEscapeCharacter */ :
                        return 'InvalidEscapeCharacter';
                    case 16 /* ParseErrorCode.InvalidCharacter */ :
                        return 'InvalidCharacter';
                }
                return '<unknown ParseErrorCode>';
            }
            /**
 * Computes the edit operations needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */ function main_format(documentText, range, options) {
                return format_format(documentText, range, options);
            }
            /**
 * Computes the edit operations needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */ function modify(text, path, value, options) {
                return edit.setProperty(text, path, value, options);
            }
            /**
 * Applies edits to an input string.
 * @param text The input text
 * @param edits Edit operations following the format described in {@linkcode EditResult}.
 * @returns The text with the applied edits.
 * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.
 */ function applyEdits(text, edits) {
                let sortedEdits = edits.slice(0).sort((a, b)=>{
                    const diff = a.offset - b.offset;
                    if (diff === 0) {
                        return a.length - b.length;
                    }
                    return diff;
                });
                let lastModifiedOffset = text.length;
                for(let i = sortedEdits.length - 1; i >= 0; i--){
                    let e = sortedEdits[i];
                    if (e.offset + e.length <= lastModifiedOffset) {
                        text = edit.applyEdit(text, e);
                    } else {
                        throw new Error('Overlapping edit');
                    }
                    lastModifiedOffset = e.offset;
                }
                return text;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/objects.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function equals(one, other) {
                if (one === other) {
                    return true;
                }
                if (one === null || one === undefined || other === null || other === undefined) {
                    return false;
                }
                if (typeof one !== typeof other) {
                    return false;
                }
                if (typeof one !== 'object') {
                    return false;
                }
                if (Array.isArray(one) !== Array.isArray(other)) {
                    return false;
                }
                let i, key;
                if (Array.isArray(one)) {
                    if (one.length !== other.length) {
                        return false;
                    }
                    for(i = 0; i < one.length; i++){
                        if (!equals(one[i], other[i])) {
                            return false;
                        }
                    }
                } else {
                    const oneKeys = [];
                    for(key in one){
                        oneKeys.push(key);
                    }
                    oneKeys.sort();
                    const otherKeys = [];
                    for(key in other){
                        otherKeys.push(key);
                    }
                    otherKeys.sort();
                    if (!equals(oneKeys, otherKeys)) {
                        return false;
                    }
                    for(i = 0; i < oneKeys.length; i++){
                        if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            function isNumber(val) {
                return typeof val === 'number';
            }
            function isDefined(val) {
                return typeof val !== 'undefined';
            }
            function isBoolean(val) {
                return typeof val === 'boolean';
            }
            function isString(val) {
                return typeof val === 'string';
            }
            function isObject(val) {
                return typeof val === 'object' && val !== null && !Array.isArray(val);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/strings.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function startsWith(haystack, needle) {
                if (haystack.length < needle.length) {
                    return false;
                }
                for(let i = 0; i < needle.length; i++){
                    if (haystack[i] !== needle[i]) {
                        return false;
                    }
                }
                return true;
            }
            /**
 * Determines if haystack ends with needle.
 */ function endsWith(haystack, needle) {
                const diff = haystack.length - needle.length;
                if (diff > 0) {
                    return haystack.lastIndexOf(needle) === diff;
                } else if (diff === 0) {
                    return haystack === needle;
                } else {
                    return false;
                }
            }
            function convertSimple2RegExpPattern(pattern) {
                return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
            }
            function strings_repeat(value, count) {
                let s = '';
                while(count > 0){
                    if ((count & 1) === 1) {
                        s += value;
                    }
                    value += value;
                    count = count >>> 1;
                }
                return s;
            }
            function extendedRegExp(pattern) {
                let flags = '';
                if (startsWith(pattern, '(?i)')) {
                    pattern = pattern.substring(4);
                    flags = 'i';
                }
                try {
                    return new RegExp(pattern, flags + 'u');
                } catch (e) {
                    // could be an exception due to the 'u ' flag
                    try {
                        return new RegExp(pattern, flags);
                    } catch (e) {
                        // invalid pattern
                        return undefined;
                    }
                }
            }
            // from https://tanishiking.github.io/posts/count-unicode-codepoint/#work-hard-with-for-statements
            function stringLength(str) {
                let count = 0;
                for(let i = 0; i < str.length; i++){
                    count++;
                    // obtain the i-th 16-bit
                    const code = str.charCodeAt(i);
                    if (0xD800 <= code && code <= 0xDBFF) {
                        // if the i-th 16bit is an upper surrogate
                        // skip the next 16 bits (lower surrogate)
                        i++;
                    }
                }
                return count;
            }
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-types/lib/esm/main.js
            var main = __nested_webpack_require_701415__(4767);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js
            var esm_main = __nested_webpack_require_701415__(4881);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageTypes.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Error codes used by diagnostics
 */ var ErrorCode;
            (function(ErrorCode) {
                ErrorCode[ErrorCode["Undefined"] = 0] = "Undefined";
                ErrorCode[ErrorCode["EnumValueMismatch"] = 1] = "EnumValueMismatch";
                ErrorCode[ErrorCode["Deprecated"] = 2] = "Deprecated";
                ErrorCode[ErrorCode["UnexpectedEndOfComment"] = 257] = "UnexpectedEndOfComment";
                ErrorCode[ErrorCode["UnexpectedEndOfString"] = 258] = "UnexpectedEndOfString";
                ErrorCode[ErrorCode["UnexpectedEndOfNumber"] = 259] = "UnexpectedEndOfNumber";
                ErrorCode[ErrorCode["InvalidUnicode"] = 260] = "InvalidUnicode";
                ErrorCode[ErrorCode["InvalidEscapeCharacter"] = 261] = "InvalidEscapeCharacter";
                ErrorCode[ErrorCode["InvalidCharacter"] = 262] = "InvalidCharacter";
                ErrorCode[ErrorCode["PropertyExpected"] = 513] = "PropertyExpected";
                ErrorCode[ErrorCode["CommaExpected"] = 514] = "CommaExpected";
                ErrorCode[ErrorCode["ColonExpected"] = 515] = "ColonExpected";
                ErrorCode[ErrorCode["ValueExpected"] = 516] = "ValueExpected";
                ErrorCode[ErrorCode["CommaOrCloseBacketExpected"] = 517] = "CommaOrCloseBacketExpected";
                ErrorCode[ErrorCode["CommaOrCloseBraceExpected"] = 518] = "CommaOrCloseBraceExpected";
                ErrorCode[ErrorCode["TrailingComma"] = 519] = "TrailingComma";
                ErrorCode[ErrorCode["DuplicateKey"] = 520] = "DuplicateKey";
                ErrorCode[ErrorCode["CommentNotPermitted"] = 521] = "CommentNotPermitted";
                ErrorCode[ErrorCode["SchemaResolveError"] = 768] = "SchemaResolveError";
                ErrorCode[ErrorCode["SchemaUnsupportedFeature"] = 769] = "SchemaUnsupportedFeature";
            })(ErrorCode || (ErrorCode = {}));
            var SchemaDraft;
            (function(SchemaDraft) {
                SchemaDraft[SchemaDraft["v3"] = 3] = "v3";
                SchemaDraft[SchemaDraft["v4"] = 4] = "v4";
                SchemaDraft[SchemaDraft["v6"] = 6] = "v6";
                SchemaDraft[SchemaDraft["v7"] = 7] = "v7";
                SchemaDraft[SchemaDraft["v2019_09"] = 19] = "v2019_09";
                SchemaDraft[SchemaDraft["v2020_12"] = 20] = "v2020_12";
            })(SchemaDraft || (SchemaDraft = {}));
            var ClientCapabilities;
            (function(ClientCapabilities) {
                ClientCapabilities.LATEST = {
                    textDocument: {
                        completion: {
                            completionItem: {
                                documentationFormat: [
                                    main.MarkupKind.Markdown,
                                    main.MarkupKind.PlainText
                                ],
                                commitCharactersSupport: true,
                                labelDetailsSupport: true
                            }
                        }
                    }
                };
            })(ClientCapabilities || (ClientCapabilities = {}));
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/node_modules/@vscode/l10n/dist/browser.js
            // src/browser/reader.ts
            async function readFileFromUri(uri) {
                if (uri.protocol === "http:" || uri.protocol === "https:") {
                    const res = await fetch(uri);
                    return await res.text();
                }
                throw new Error("Unsupported protocol");
            }
            function readFileFromFsPath(_) {
                throw new Error("Unsupported in browser");
            }
            // src/main.ts
            var bundle;
            function config(config2) {
                if ("contents" in config2) {
                    if (typeof config2.contents === "string") {
                        bundle = JSON.parse(config2.contents);
                    } else {
                        bundle = config2.contents;
                    }
                    return;
                }
                if ("fsPath" in config2) {
                    const fileContent = readFileFromFsPath(config2.fsPath);
                    const content = JSON.parse(fileContent);
                    bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
                    return;
                }
                if (config2.uri) {
                    let uri = config2.uri;
                    if (typeof config2.uri === "string") {
                        uri = new URL(config2.uri);
                    }
                    return new Promise((resolve, reject)=>{
                        const p = readFileFromUri(uri).then((uriContent)=>{
                            try {
                                const content = JSON.parse(uriContent);
                                bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
                            } catch (err) {
                                reject(err);
                            }
                        }).catch((err)=>{
                            reject(err);
                        });
                        resolve(p);
                    });
                }
            }
            function t(...args) {
                const firstArg = args[0];
                let key;
                let message;
                let formatArgs;
                if (typeof firstArg === "string") {
                    key = firstArg;
                    message = firstArg;
                    args.splice(0, 1);
                    formatArgs = !args || typeof args[0] !== "object" ? args : args[0];
                } else {
                    message = firstArg.message;
                    key = message;
                    if (firstArg.comment && firstArg.comment.length > 0) {
                        key += `/${Array.isArray(firstArg.comment) ? firstArg.comment.join("") : firstArg.comment}`;
                    }
                    var _firstArg_args;
                    formatArgs = (_firstArg_args = firstArg.args) !== null && _firstArg_args !== void 0 ? _firstArg_args : {};
                }
                if (!bundle) {
                    return browser_format(message, formatArgs);
                }
                const messageFromBundle = bundle[key];
                if (!messageFromBundle) {
                    return browser_format(message, formatArgs);
                }
                if (typeof messageFromBundle === "string") {
                    return browser_format(messageFromBundle, formatArgs);
                }
                if (messageFromBundle.comment) {
                    return browser_format(messageFromBundle.message, formatArgs);
                }
                return browser_format(message, formatArgs);
            }
            var _format2Regexp = /{([^}]+)}/g;
            function browser_format(template, values) {
                var _values_group;
                return template.replace(_format2Regexp, (match, group)=>(_values_group = values[group]) !== null && _values_group !== void 0 ? _values_group : match);
            }
            function isBuiltinExtension(json) {
                var _json_contents, _json, _json1;
                return !!(typeof ((_json = json) === null || _json === void 0 ? void 0 : (_json_contents = _json.contents) === null || _json_contents === void 0 ? void 0 : _json_contents.bundle) === "object" && typeof ((_json1 = json) === null || _json1 === void 0 ? void 0 : _json1.version) === "string");
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/parser/jsonParser.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const formats = {
                'color-hex': {
                    errorMessage: t('Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'),
                    pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/
                },
                'date-time': {
                    errorMessage: t('String is not a RFC3339 date-time.'),
                    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
                },
                'date': {
                    errorMessage: t('String is not a RFC3339 date.'),
                    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i
                },
                'time': {
                    errorMessage: t('String is not a RFC3339 time.'),
                    pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
                },
                'email': {
                    errorMessage: t('String is not an e-mail address.'),
                    pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}))$/
                },
                'hostname': {
                    errorMessage: t('String is not a hostname.'),
                    pattern: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i
                },
                'ipv4': {
                    errorMessage: t('String is not an IPv4 address.'),
                    pattern: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/
                },
                'ipv6': {
                    errorMessage: t('String is not an IPv6 address.'),
                    pattern: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i
                }
            };
            class ASTNodeImpl {
                get children() {
                    return [];
                }
                toString() {
                    return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');
                }
                constructor(parent, offset, length = 0){
                    this.offset = offset;
                    this.length = length;
                    this.parent = parent;
                }
            }
            class NullASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'null';
                    this.value = null;
                }
            }
            class BooleanASTNodeImpl extends ASTNodeImpl {
                constructor(parent, boolValue, offset){
                    super(parent, offset);
                    this.type = 'boolean';
                    this.value = boolValue;
                }
            }
            class ArrayASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.items;
                }
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'array';
                    this.items = [];
                }
            }
            class NumberASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'number';
                    this.isInteger = true;
                    this.value = Number.NaN;
                }
            }
            class StringASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset, length){
                    super(parent, offset, length);
                    this.type = 'string';
                    this.value = '';
                }
            }
            class PropertyASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.valueNode ? [
                        this.keyNode,
                        this.valueNode
                    ] : [
                        this.keyNode
                    ];
                }
                constructor(parent, offset, keyNode){
                    super(parent, offset);
                    this.type = 'property';
                    this.colonOffset = -1;
                    this.keyNode = keyNode;
                }
            }
            class ObjectASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.properties;
                }
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'object';
                    this.properties = [];
                }
            }
            function asSchema(schema) {
                if (isBoolean(schema)) {
                    return schema ? {} : {
                        "not": {}
                    };
                }
                return schema;
            }
            var EnumMatch;
            (function(EnumMatch) {
                EnumMatch[EnumMatch["Key"] = 0] = "Key";
                EnumMatch[EnumMatch["Enum"] = 1] = "Enum";
            })(EnumMatch || (EnumMatch = {}));
            const schemaDraftFromId = {
                'http://json-schema.org/draft-03/schema#': SchemaDraft.v3,
                'http://json-schema.org/draft-04/schema#': SchemaDraft.v4,
                'http://json-schema.org/draft-06/schema#': SchemaDraft.v6,
                'http://json-schema.org/draft-07/schema#': SchemaDraft.v7,
                'https://json-schema.org/draft/2019-09/schema': SchemaDraft.v2019_09,
                'https://json-schema.org/draft/2020-12/schema': SchemaDraft.v2020_12
            };
            class EvaluationContext {
                constructor(schemaDraft){
                    this.schemaDraft = schemaDraft;
                }
            }
            class SchemaCollector {
                add(schema) {
                    this.schemas.push(schema);
                }
                merge(other) {
                    Array.prototype.push.apply(this.schemas, other.schemas);
                }
                include(node) {
                    return (this.focusOffset === -1 || jsonParser_contains(node, this.focusOffset)) && node !== this.exclude;
                }
                newSub() {
                    return new SchemaCollector(-1, this.exclude);
                }
                constructor(focusOffset = -1, exclude){
                    this.focusOffset = focusOffset;
                    this.exclude = exclude;
                    this.schemas = [];
                }
            }
            class NoOpSchemaCollector {
                get schemas() {
                    return [];
                }
                add(_schema) {}
                merge(_other) {}
                include(_node) {
                    return true;
                }
                newSub() {
                    return this;
                }
                constructor(){}
            }
            NoOpSchemaCollector.instance = new NoOpSchemaCollector();
            class ValidationResult {
                hasProblems() {
                    return !!this.problems.length;
                }
                merge(validationResult) {
                    this.problems = this.problems.concat(validationResult.problems);
                    this.propertiesMatches += validationResult.propertiesMatches;
                    this.propertiesValueMatches += validationResult.propertiesValueMatches;
                    this.mergeProcessedProperties(validationResult);
                }
                mergeEnumValues(validationResult) {
                    if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
                        this.enumValues = this.enumValues.concat(validationResult.enumValues);
                        for (const error of this.problems){
                            if (error.code === ErrorCode.EnumValueMismatch) {
                                error.message = t('Value is not accepted. Valid values: {0}.', this.enumValues.map((v)=>JSON.stringify(v)).join(', '));
                            }
                        }
                    }
                }
                mergePropertyMatch(propertyValidationResult) {
                    this.problems = this.problems.concat(propertyValidationResult.problems);
                    this.propertiesMatches++;
                    if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
                        this.propertiesValueMatches++;
                    }
                    if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {
                        this.primaryValueMatches++;
                    }
                }
                mergeProcessedProperties(validationResult) {
                    validationResult.processedProperties.forEach((p)=>this.processedProperties.add(p));
                }
                compare(other) {
                    const hasProblems = this.hasProblems();
                    if (hasProblems !== other.hasProblems()) {
                        return hasProblems ? -1 : 1;
                    }
                    if (this.enumValueMatch !== other.enumValueMatch) {
                        return other.enumValueMatch ? -1 : 1;
                    }
                    if (this.primaryValueMatches !== other.primaryValueMatches) {
                        return this.primaryValueMatches - other.primaryValueMatches;
                    }
                    if (this.propertiesValueMatches !== other.propertiesValueMatches) {
                        return this.propertiesValueMatches - other.propertiesValueMatches;
                    }
                    return this.propertiesMatches - other.propertiesMatches;
                }
                constructor(){
                    this.problems = [];
                    this.propertiesMatches = 0;
                    this.processedProperties = new Set();
                    this.propertiesValueMatches = 0;
                    this.primaryValueMatches = 0;
                    this.enumValueMatch = false;
                    this.enumValues = undefined;
                }
            }
            function newJSONDocument(root, diagnostics = []) {
                return new JSONDocument(root, diagnostics, []);
            }
            function jsonParser_getNodeValue(node) {
                return main_getNodeValue(node);
            }
            function jsonParser_getNodePath(node) {
                return main_getNodePath(node);
            }
            function jsonParser_contains(node, offset, includeRightBound = false) {
                return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
            }
            class JSONDocument {
                getNodeFromOffset(offset, includeRightBound = false) {
                    if (this.root) {
                        return main_findNodeAtOffset(this.root, offset, includeRightBound);
                    }
                    return undefined;
                }
                visit(visitor) {
                    if (this.root) {
                        const doVisit = (node)=>{
                            let ctn = visitor(node);
                            const children = node.children;
                            if (Array.isArray(children)) {
                                for(let i = 0; i < children.length && ctn; i++){
                                    ctn = doVisit(children[i]);
                                }
                            }
                            return ctn;
                        };
                        doVisit(this.root);
                    }
                }
                validate(textDocument, schema, severity = main.DiagnosticSeverity.Warning, schemaDraft) {
                    if (this.root && schema) {
                        const validationResult = new ValidationResult();
                        validate(this.root, schema, validationResult, NoOpSchemaCollector.instance, new EvaluationContext(schemaDraft !== null && schemaDraft !== void 0 ? schemaDraft : getSchemaDraft(schema)));
                        return validationResult.problems.map((p)=>{
                            const range = main.Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
                            var _p_severity;
                            return main.Diagnostic.create(range, p.message, (_p_severity = p.severity) !== null && _p_severity !== void 0 ? _p_severity : severity, p.code);
                        });
                    }
                    return undefined;
                }
                getMatchingSchemas(schema, focusOffset = -1, exclude) {
                    if (this.root && schema) {
                        const matchingSchemas = new SchemaCollector(focusOffset, exclude);
                        const schemaDraft = getSchemaDraft(schema);
                        const context = new EvaluationContext(schemaDraft);
                        validate(this.root, schema, new ValidationResult(), matchingSchemas, context);
                        return matchingSchemas.schemas;
                    }
                    return [];
                }
                constructor(root, syntaxErrors = [], comments = []){
                    this.root = root;
                    this.syntaxErrors = syntaxErrors;
                    this.comments = comments;
                }
            }
            function getSchemaDraft(schema, fallBack = SchemaDraft.v2020_12) {
                let schemaId = schema.$schema;
                if (schemaId) {
                    var _schemaDraftFromId_schemaId;
                    return (_schemaDraftFromId_schemaId = schemaDraftFromId[schemaId]) !== null && _schemaDraftFromId_schemaId !== void 0 ? _schemaDraftFromId_schemaId : fallBack;
                }
                return fallBack;
            }
            function validate(n, schema, validationResult, matchingSchemas, context) {
                if (!n || !matchingSchemas.include(n)) {
                    return;
                }
                if (n.type === 'property') {
                    return validate(n.valueNode, schema, validationResult, matchingSchemas, context);
                }
                const node = n;
                _validateNode();
                switch(node.type){
                    case 'object':
                        _validateObjectNode(node);
                        break;
                    case 'array':
                        _validateArrayNode(node);
                        break;
                    case 'string':
                        _validateStringNode(node);
                        break;
                    case 'number':
                        _validateNumberNode(node);
                        break;
                }
                matchingSchemas.add({
                    node: node,
                    schema: schema
                });
                function _validateNode() {
                    function matchesType(type) {
                        return node.type === type || type === 'integer' && node.type === 'number' && node.isInteger;
                    }
                    if (Array.isArray(schema.type)) {
                        if (!schema.type.some(matchesType)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Incorrect type. Expected one of {0}.', schema.type.join(', '))
                            });
                        }
                    } else if (schema.type) {
                        if (!matchesType(schema.type)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Incorrect type. Expected "{0}".', schema.type)
                            });
                        }
                    }
                    if (Array.isArray(schema.allOf)) {
                        for (const subSchemaRef of schema.allOf){
                            const subValidationResult = new ValidationResult();
                            const subMatchingSchemas = matchingSchemas.newSub();
                            validate(node, asSchema(subSchemaRef), subValidationResult, subMatchingSchemas, context);
                            validationResult.merge(subValidationResult);
                            matchingSchemas.merge(subMatchingSchemas);
                        }
                    }
                    const notSchema = asSchema(schema.not);
                    if (notSchema) {
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, notSchema, subValidationResult, subMatchingSchemas, context);
                        if (!subValidationResult.hasProblems()) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t("Matches a schema that is not allowed.")
                            });
                        }
                        for (const ms of subMatchingSchemas.schemas){
                            ms.inverted = !ms.inverted;
                            matchingSchemas.add(ms);
                        }
                    }
                    const testAlternatives = (alternatives, maxOneMatch)=>{
                        const matches = [];
                        // remember the best match that is used for error messages
                        let bestMatch = undefined;
                        for (const subSchemaRef of alternatives){
                            const subSchema = asSchema(subSchemaRef);
                            const subValidationResult = new ValidationResult();
                            const subMatchingSchemas = matchingSchemas.newSub();
                            validate(node, subSchema, subValidationResult, subMatchingSchemas, context);
                            if (!subValidationResult.hasProblems()) {
                                matches.push(subSchema);
                            }
                            if (!bestMatch) {
                                bestMatch = {
                                    schema: subSchema,
                                    validationResult: subValidationResult,
                                    matchingSchemas: subMatchingSchemas
                                };
                            } else {
                                if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {
                                    // no errors, both are equally good matches
                                    bestMatch.matchingSchemas.merge(subMatchingSchemas);
                                    bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;
                                    bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
                                    bestMatch.validationResult.mergeProcessedProperties(subValidationResult);
                                } else {
                                    const compareResult = subValidationResult.compare(bestMatch.validationResult);
                                    if (compareResult > 0) {
                                        // our node is the best matching so far
                                        bestMatch = {
                                            schema: subSchema,
                                            validationResult: subValidationResult,
                                            matchingSchemas: subMatchingSchemas
                                        };
                                    } else if (compareResult === 0) {
                                        // there's already a best matching but we are as good
                                        bestMatch.matchingSchemas.merge(subMatchingSchemas);
                                        bestMatch.validationResult.mergeEnumValues(subValidationResult);
                                    }
                                }
                            }
                        }
                        if (matches.length > 1 && maxOneMatch) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: 1
                                },
                                message: t("Matches multiple schemas when only one must validate.")
                            });
                        }
                        if (bestMatch) {
                            validationResult.merge(bestMatch.validationResult);
                            matchingSchemas.merge(bestMatch.matchingSchemas);
                        }
                        return matches.length;
                    };
                    if (Array.isArray(schema.anyOf)) {
                        testAlternatives(schema.anyOf, false);
                    }
                    if (Array.isArray(schema.oneOf)) {
                        testAlternatives(schema.oneOf, true);
                    }
                    const testBranch = (schema)=>{
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, asSchema(schema), subValidationResult, subMatchingSchemas, context);
                        validationResult.merge(subValidationResult);
                        matchingSchemas.merge(subMatchingSchemas);
                    };
                    const testCondition = (ifSchema, thenSchema, elseSchema)=>{
                        const subSchema = asSchema(ifSchema);
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, subSchema, subValidationResult, subMatchingSchemas, context);
                        matchingSchemas.merge(subMatchingSchemas);
                        validationResult.mergeProcessedProperties(subValidationResult);
                        if (!subValidationResult.hasProblems()) {
                            if (thenSchema) {
                                testBranch(thenSchema);
                            }
                        } else if (elseSchema) {
                            testBranch(elseSchema);
                        }
                    };
                    const ifSchema = asSchema(schema.if);
                    if (ifSchema) {
                        testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));
                    }
                    if (Array.isArray(schema.enum)) {
                        const val = jsonParser_getNodeValue(node);
                        let enumValueMatch = false;
                        for (const e of schema.enum){
                            if (equals(val, e)) {
                                enumValueMatch = true;
                                break;
                            }
                        }
                        validationResult.enumValues = schema.enum;
                        validationResult.enumValueMatch = enumValueMatch;
                        if (!enumValueMatch) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                code: ErrorCode.EnumValueMismatch,
                                message: schema.errorMessage || t('Value is not accepted. Valid values: {0}.', schema.enum.map((v)=>JSON.stringify(v)).join(', '))
                            });
                        }
                    }
                    if (isDefined(schema.const)) {
                        const val = jsonParser_getNodeValue(node);
                        if (!equals(val, schema.const)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                code: ErrorCode.EnumValueMismatch,
                                message: schema.errorMessage || t('Value must be {0}.', JSON.stringify(schema.const))
                            });
                            validationResult.enumValueMatch = false;
                        } else {
                            validationResult.enumValueMatch = true;
                        }
                        validationResult.enumValues = [
                            schema.const
                        ];
                    }
                    let deprecationMessage = schema.deprecationMessage;
                    if ((deprecationMessage || schema.deprecated) && node.parent) {
                        deprecationMessage = deprecationMessage || t('Value is deprecated');
                        validationResult.problems.push({
                            location: {
                                offset: node.parent.offset,
                                length: node.parent.length
                            },
                            severity: main.DiagnosticSeverity.Warning,
                            message: deprecationMessage,
                            code: ErrorCode.Deprecated
                        });
                    }
                }
                function _validateNumberNode(node) {
                    const val = node.value;
                    function normalizeFloats(float) {
                        var _parts_;
                        const parts = /^(-?\d+)(?:\.(\d+))?(?:e([-+]\d+))?$/.exec(float.toString());
                        return parts && {
                            value: Number(parts[1] + (parts[2] || '')),
                            multiplier: (((_parts_ = parts[2]) === null || _parts_ === void 0 ? void 0 : _parts_.length) || 0) - (parseInt(parts[3]) || 0)
                        };
                    }
                    ;
                    if (isNumber(schema.multipleOf)) {
                        let remainder = -1;
                        if (Number.isInteger(schema.multipleOf)) {
                            remainder = val % schema.multipleOf;
                        } else {
                            let normMultipleOf = normalizeFloats(schema.multipleOf);
                            let normValue = normalizeFloats(val);
                            if (normMultipleOf && normValue) {
                                const multiplier = 10 ** Math.abs(normValue.multiplier - normMultipleOf.multiplier);
                                if (normValue.multiplier < normMultipleOf.multiplier) {
                                    normValue.value *= multiplier;
                                } else {
                                    normMultipleOf.value *= multiplier;
                                }
                                remainder = normValue.value % normMultipleOf.value;
                            }
                        }
                        if (remainder !== 0) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Value is not divisible by {0}.', schema.multipleOf)
                            });
                        }
                    }
                    function getExclusiveLimit(limit, exclusive) {
                        if (isNumber(exclusive)) {
                            return exclusive;
                        }
                        if (isBoolean(exclusive) && exclusive) {
                            return limit;
                        }
                        return undefined;
                    }
                    function getLimit(limit, exclusive) {
                        if (!isBoolean(exclusive) || !exclusive) {
                            return limit;
                        }
                        return undefined;
                    }
                    const exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);
                    if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is below the exclusive minimum of {0}.', exclusiveMinimum)
                        });
                    }
                    const exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);
                    if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is above the exclusive maximum of {0}.', exclusiveMaximum)
                        });
                    }
                    const minimum = getLimit(schema.minimum, schema.exclusiveMinimum);
                    if (isNumber(minimum) && val < minimum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is below the minimum of {0}.', minimum)
                        });
                    }
                    const maximum = getLimit(schema.maximum, schema.exclusiveMaximum);
                    if (isNumber(maximum) && val > maximum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is above the maximum of {0}.', maximum)
                        });
                    }
                }
                function _validateStringNode(node) {
                    if (isNumber(schema.minLength) && stringLength(node.value) < schema.minLength) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('String is shorter than the minimum length of {0}.', schema.minLength)
                        });
                    }
                    if (isNumber(schema.maxLength) && stringLength(node.value) > schema.maxLength) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('String is longer than the maximum length of {0}.', schema.maxLength)
                        });
                    }
                    if (isString(schema.pattern)) {
                        var _regex;
                        const regex = extendedRegExp(schema.pattern);
                        if (!((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(node.value))) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.patternErrorMessage || schema.errorMessage || t('String does not match the pattern of "{0}".', schema.pattern)
                            });
                        }
                    }
                    if (schema.format) {
                        switch(schema.format){
                            case 'uri':
                            case 'uri-reference':
                                {
                                    let errorMessage;
                                    if (!node.value) {
                                        errorMessage = t('URI expected.');
                                    } else {
                                        const match = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(node.value);
                                        if (!match) {
                                            errorMessage = t('URI is expected.');
                                        } else if (!match[2] && schema.format === 'uri') {
                                            errorMessage = t('URI with a scheme is expected.');
                                        }
                                    }
                                    if (errorMessage) {
                                        validationResult.problems.push({
                                            location: {
                                                offset: node.offset,
                                                length: node.length
                                            },
                                            message: schema.patternErrorMessage || schema.errorMessage || t('String is not a URI: {0}', errorMessage)
                                        });
                                    }
                                }
                                break;
                            case 'color-hex':
                            case 'date-time':
                            case 'date':
                            case 'time':
                            case 'email':
                            case 'hostname':
                            case 'ipv4':
                            case 'ipv6':
                                const format1 = formats[schema.format];
                                if (!node.value || !format1.pattern.exec(node.value)) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: schema.patternErrorMessage || schema.errorMessage || format1.errorMessage
                                    });
                                }
                            default:
                        }
                    }
                }
                function _validateArrayNode(node) {
                    let prefixItemsSchemas;
                    let additionalItemSchema;
                    if (context.schemaDraft >= SchemaDraft.v2020_12) {
                        prefixItemsSchemas = schema.prefixItems;
                        additionalItemSchema = !Array.isArray(schema.items) ? schema.items : undefined;
                    } else {
                        prefixItemsSchemas = Array.isArray(schema.items) ? schema.items : undefined;
                        additionalItemSchema = !Array.isArray(schema.items) ? schema.items : schema.additionalItems;
                    }
                    let index = 0;
                    if (prefixItemsSchemas !== undefined) {
                        const max = Math.min(prefixItemsSchemas.length, node.items.length);
                        for(; index < max; index++){
                            const subSchemaRef = prefixItemsSchemas[index];
                            const subSchema = asSchema(subSchemaRef);
                            const itemValidationResult = new ValidationResult();
                            const item = node.items[index];
                            if (item) {
                                validate(item, subSchema, itemValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(itemValidationResult);
                            }
                            validationResult.processedProperties.add(String(index));
                        }
                    }
                    if (additionalItemSchema !== undefined && index < node.items.length) {
                        if (typeof additionalItemSchema === 'boolean') {
                            if (additionalItemSchema === false) {
                                validationResult.problems.push({
                                    location: {
                                        offset: node.offset,
                                        length: node.length
                                    },
                                    message: t('Array has too many items according to schema. Expected {0} or fewer.', index)
                                });
                            }
                            for(; index < node.items.length; index++){
                                validationResult.processedProperties.add(String(index));
                                validationResult.propertiesValueMatches++;
                            }
                        } else {
                            for(; index < node.items.length; index++){
                                const itemValidationResult = new ValidationResult();
                                validate(node.items[index], additionalItemSchema, itemValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(itemValidationResult);
                                validationResult.processedProperties.add(String(index));
                            }
                        }
                    }
                    const containsSchema = asSchema(schema.contains);
                    if (containsSchema) {
                        let containsCount = 0;
                        for(let index = 0; index < node.items.length; index++){
                            const item = node.items[index];
                            const itemValidationResult = new ValidationResult();
                            validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance, context);
                            if (!itemValidationResult.hasProblems()) {
                                containsCount++;
                                if (context.schemaDraft >= SchemaDraft.v2020_12) {
                                    validationResult.processedProperties.add(String(index));
                                }
                            }
                        }
                        if (containsCount === 0 && !isNumber(schema.minContains)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Array does not contain required item.')
                            });
                        }
                        if (isNumber(schema.minContains) && containsCount < schema.minContains) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Array has too few items that match the contains contraint. Expected {0} or more.', schema.minContains)
                            });
                        }
                        if (isNumber(schema.maxContains) && containsCount > schema.maxContains) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Array has too many items that match the contains contraint. Expected {0} or less.', schema.maxContains)
                            });
                        }
                    }
                    const unevaluatedItems = schema.unevaluatedItems;
                    if (unevaluatedItems !== undefined) {
                        for(let i = 0; i < node.items.length; i++){
                            if (!validationResult.processedProperties.has(String(i))) {
                                if (unevaluatedItems === false) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: t('Item does not match any validation rule from the array.')
                                    });
                                } else {
                                    const itemValidationResult = new ValidationResult();
                                    validate(node.items[i], schema.unevaluatedItems, itemValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(itemValidationResult);
                                }
                            }
                            validationResult.processedProperties.add(String(i));
                            validationResult.propertiesValueMatches++;
                        }
                    }
                    if (isNumber(schema.minItems) && node.items.length < schema.minItems) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Array has too few items. Expected {0} or more.', schema.minItems)
                        });
                    }
                    if (isNumber(schema.maxItems) && node.items.length > schema.maxItems) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Array has too many items. Expected {0} or fewer.', schema.maxItems)
                        });
                    }
                    if (schema.uniqueItems === true) {
                        const values = jsonParser_getNodeValue(node);
                        const duplicates = values.some((value, index)=>{
                            return index !== values.lastIndexOf(value);
                        });
                        if (duplicates) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Array has duplicate items.')
                            });
                        }
                    }
                }
                function _validateObjectNode(node) {
                    const seenKeys = Object.create(null);
                    const unprocessedProperties = new Set();
                    for (const propertyNode of node.properties){
                        const key = propertyNode.keyNode.value;
                        seenKeys[key] = propertyNode.valueNode;
                        unprocessedProperties.add(key);
                    }
                    if (Array.isArray(schema.required)) {
                        for (const propertyName of schema.required){
                            if (!seenKeys[propertyName]) {
                                const keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;
                                const location = keyNode ? {
                                    offset: keyNode.offset,
                                    length: keyNode.length
                                } : {
                                    offset: node.offset,
                                    length: 1
                                };
                                validationResult.problems.push({
                                    location: location,
                                    message: t('Missing property "{0}".', propertyName)
                                });
                            }
                        }
                    }
                    const propertyProcessed = (prop)=>{
                        unprocessedProperties.delete(prop);
                        validationResult.processedProperties.add(prop);
                    };
                    if (schema.properties) {
                        for (const propertyName of Object.keys(schema.properties)){
                            propertyProcessed(propertyName);
                            const propertySchema = schema.properties[propertyName];
                            const child = seenKeys[propertyName];
                            if (child) {
                                if (isBoolean(propertySchema)) {
                                    if (!propertySchema) {
                                        const propertyNode = child.parent;
                                        validationResult.problems.push({
                                            location: {
                                                offset: propertyNode.keyNode.offset,
                                                length: propertyNode.keyNode.length
                                            },
                                            message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                        });
                                    } else {
                                        validationResult.propertiesMatches++;
                                        validationResult.propertiesValueMatches++;
                                    }
                                } else {
                                    const propertyValidationResult = new ValidationResult();
                                    validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(propertyValidationResult);
                                }
                            }
                        }
                    }
                    if (schema.patternProperties) {
                        for (const propertyPattern of Object.keys(schema.patternProperties)){
                            const regex = extendedRegExp(propertyPattern);
                            if (regex) {
                                const processed = [];
                                for (const propertyName of unprocessedProperties){
                                    if (regex.test(propertyName)) {
                                        processed.push(propertyName);
                                        const child = seenKeys[propertyName];
                                        if (child) {
                                            const propertySchema = schema.patternProperties[propertyPattern];
                                            if (isBoolean(propertySchema)) {
                                                if (!propertySchema) {
                                                    const propertyNode = child.parent;
                                                    validationResult.problems.push({
                                                        location: {
                                                            offset: propertyNode.keyNode.offset,
                                                            length: propertyNode.keyNode.length
                                                        },
                                                        message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                                    });
                                                } else {
                                                    validationResult.propertiesMatches++;
                                                    validationResult.propertiesValueMatches++;
                                                }
                                            } else {
                                                const propertyValidationResult = new ValidationResult();
                                                validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);
                                                validationResult.mergePropertyMatch(propertyValidationResult);
                                            }
                                        }
                                    }
                                }
                                processed.forEach(propertyProcessed);
                            }
                        }
                    }
                    const additionalProperties = schema.additionalProperties;
                    if (additionalProperties !== undefined) {
                        for (const propertyName of unprocessedProperties){
                            propertyProcessed(propertyName);
                            const child = seenKeys[propertyName];
                            if (child) {
                                if (additionalProperties === false) {
                                    const propertyNode = child.parent;
                                    validationResult.problems.push({
                                        location: {
                                            offset: propertyNode.keyNode.offset,
                                            length: propertyNode.keyNode.length
                                        },
                                        message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                    });
                                } else if (additionalProperties !== true) {
                                    const propertyValidationResult = new ValidationResult();
                                    validate(child, additionalProperties, propertyValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(propertyValidationResult);
                                }
                            }
                        }
                    }
                    const unevaluatedProperties = schema.unevaluatedProperties;
                    if (unevaluatedProperties !== undefined) {
                        const processed = [];
                        for (const propertyName of unprocessedProperties){
                            if (!validationResult.processedProperties.has(propertyName)) {
                                processed.push(propertyName);
                                const child = seenKeys[propertyName];
                                if (child) {
                                    if (unevaluatedProperties === false) {
                                        const propertyNode = child.parent;
                                        validationResult.problems.push({
                                            location: {
                                                offset: propertyNode.keyNode.offset,
                                                length: propertyNode.keyNode.length
                                            },
                                            message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                        });
                                    } else if (unevaluatedProperties !== true) {
                                        const propertyValidationResult = new ValidationResult();
                                        validate(child, unevaluatedProperties, propertyValidationResult, matchingSchemas, context);
                                        validationResult.mergePropertyMatch(propertyValidationResult);
                                    }
                                }
                            }
                        }
                        processed.forEach(propertyProcessed);
                    }
                    if (isNumber(schema.maxProperties)) {
                        if (node.properties.length > schema.maxProperties) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Object has more properties than limit of {0}.', schema.maxProperties)
                            });
                        }
                    }
                    if (isNumber(schema.minProperties)) {
                        if (node.properties.length < schema.minProperties) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Object has fewer properties than the required number of {0}', schema.minProperties)
                            });
                        }
                    }
                    if (schema.dependentRequired) {
                        for(const key in schema.dependentRequired){
                            const prop = seenKeys[key];
                            const propertyDeps = schema.dependentRequired[key];
                            if (prop && Array.isArray(propertyDeps)) {
                                _validatePropertyDependencies(key, propertyDeps);
                            }
                        }
                    }
                    if (schema.dependentSchemas) {
                        for(const key in schema.dependentSchemas){
                            const prop = seenKeys[key];
                            const propertyDeps = schema.dependentSchemas[key];
                            if (prop && isObject(propertyDeps)) {
                                _validatePropertyDependencies(key, propertyDeps);
                            }
                        }
                    }
                    if (schema.dependencies) {
                        for(const key in schema.dependencies){
                            const prop = seenKeys[key];
                            if (prop) {
                                _validatePropertyDependencies(key, schema.dependencies[key]);
                            }
                        }
                    }
                    const propertyNames = asSchema(schema.propertyNames);
                    if (propertyNames) {
                        for (const f of node.properties){
                            const key = f.keyNode;
                            if (key) {
                                validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance, context);
                            }
                        }
                    }
                    function _validatePropertyDependencies(key, propertyDep) {
                        if (Array.isArray(propertyDep)) {
                            for (const requiredProp of propertyDep){
                                if (!seenKeys[requiredProp]) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: t('Object is missing property {0} required by property {1}.', requiredProp, key)
                                    });
                                } else {
                                    validationResult.propertiesValueMatches++;
                                }
                            }
                        } else {
                            const propertySchema = asSchema(propertyDep);
                            if (propertySchema) {
                                const propertyValidationResult = new ValidationResult();
                                validate(node, propertySchema, propertyValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(propertyValidationResult);
                            }
                        }
                    }
                }
            }
            function jsonParser_parse(textDocument, config) {
                const problems = [];
                let lastProblemOffset = -1;
                const text = textDocument.getText();
                const scanner = main_createScanner(text, false);
                const commentRanges = config && config.collectComments ? [] : undefined;
                function _scanNext() {
                    while(true){
                        const token = scanner.scan();
                        _checkScanError();
                        switch(token){
                            case 12 /* Json.SyntaxKind.LineCommentTrivia */ :
                            case 13 /* Json.SyntaxKind.BlockCommentTrivia */ :
                                if (Array.isArray(commentRanges)) {
                                    commentRanges.push(main.Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));
                                }
                                break;
                            case 15 /* Json.SyntaxKind.Trivia */ :
                            case 14 /* Json.SyntaxKind.LineBreakTrivia */ :
                                break;
                            default:
                                return token;
                        }
                    }
                }
                function _accept(token) {
                    if (scanner.getToken() === token) {
                        _scanNext();
                        return true;
                    }
                    return false;
                }
                function _errorAtRange(message, code, startOffset, endOffset, severity = main.DiagnosticSeverity.Error) {
                    if (problems.length === 0 || startOffset !== lastProblemOffset) {
                        const range = main.Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));
                        problems.push(main.Diagnostic.create(range, message, severity, code, textDocument.languageId));
                        lastProblemOffset = startOffset;
                    }
                }
                function _error(message, code, node = undefined, skipUntilAfter = [], skipUntil = []) {
                    let start = scanner.getTokenOffset();
                    let end = scanner.getTokenOffset() + scanner.getTokenLength();
                    if (start === end && start > 0) {
                        start--;
                        while(start > 0 && /\s/.test(text.charAt(start))){
                            start--;
                        }
                        end = start + 1;
                    }
                    _errorAtRange(message, code, start, end);
                    if (node) {
                        _finalize(node, false);
                    }
                    if (skipUntilAfter.length + skipUntil.length > 0) {
                        let token = scanner.getToken();
                        while(token !== 17 /* Json.SyntaxKind.EOF */ ){
                            if (skipUntilAfter.indexOf(token) !== -1) {
                                _scanNext();
                                break;
                            } else if (skipUntil.indexOf(token) !== -1) {
                                break;
                            }
                            token = _scanNext();
                        }
                    }
                    return node;
                }
                function _checkScanError() {
                    switch(scanner.getTokenError()){
                        case 4 /* Json.ScanError.InvalidUnicode */ :
                            _error(t('Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);
                            return true;
                        case 5 /* Json.ScanError.InvalidEscapeCharacter */ :
                            _error(t('Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);
                            return true;
                        case 3 /* Json.ScanError.UnexpectedEndOfNumber */ :
                            _error(t('Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);
                            return true;
                        case 1 /* Json.ScanError.UnexpectedEndOfComment */ :
                            _error(t('Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);
                            return true;
                        case 2 /* Json.ScanError.UnexpectedEndOfString */ :
                            _error(t('Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);
                            return true;
                        case 6 /* Json.ScanError.InvalidCharacter */ :
                            _error(t('Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);
                            return true;
                    }
                    return false;
                }
                function _finalize(node, scanNext) {
                    node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;
                    if (scanNext) {
                        _scanNext();
                    }
                    return node;
                }
                function _parseArray(parent) {
                    if (scanner.getToken() !== 3 /* Json.SyntaxKind.OpenBracketToken */ ) {
                        return undefined;
                    }
                    const node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());
                    _scanNext(); // consume OpenBracketToken
                    const count = 0;
                    let needsComma = false;
                    while(scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */  && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ){
                        if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                _error(t('Value expected'), ErrorCode.ValueExpected);
                            }
                            const commaOffset = scanner.getTokenOffset();
                            _scanNext(); // consume comma
                            if (scanner.getToken() === 4 /* Json.SyntaxKind.CloseBracketToken */ ) {
                                if (needsComma) {
                                    _errorAtRange(t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                                }
                                continue;
                            }
                        } else if (needsComma) {
                            _error(t('Expected comma'), ErrorCode.CommaExpected);
                        }
                        const item = _parseValue(node);
                        if (!item) {
                            _error(t('Value expected'), ErrorCode.ValueExpected, undefined, [], [
                                4 /* Json.SyntaxKind.CloseBracketToken */ ,
                                5 /* Json.SyntaxKind.CommaToken */ 
                            ]);
                        } else {
                            node.items.push(item);
                        }
                        needsComma = true;
                    }
                    if (scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */ ) {
                        return _error(t('Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);
                    }
                    return _finalize(node, true);
                }
                const keyPlaceholder = new StringASTNodeImpl(undefined, 0, 0);
                function _parseProperty(parent, keysSeen) {
                    const node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);
                    let key = _parseString(node);
                    if (!key) {
                        if (scanner.getToken() === 16 /* Json.SyntaxKind.Unknown */ ) {
                            // give a more helpful error message
                            _error(t('Property keys must be doublequoted'), ErrorCode.Undefined);
                            const keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());
                            keyNode.value = scanner.getTokenValue();
                            key = keyNode;
                            _scanNext(); // consume Unknown
                        } else {
                            return undefined;
                        }
                    }
                    node.keyNode = key;
                    // For JSON files that forbid code comments, there is a convention to use the key name "//" to add comments.
                    // Multiple instances of "//" are okay.
                    if (key.value !== "//") {
                        const seen = keysSeen[key.value];
                        if (seen) {
                            _errorAtRange(t("Duplicate object key"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, main.DiagnosticSeverity.Warning);
                            if (isObject(seen)) {
                                _errorAtRange(t("Duplicate object key"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, main.DiagnosticSeverity.Warning);
                            }
                            keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting
                        } else {
                            keysSeen[key.value] = node;
                        }
                    }
                    if (scanner.getToken() === 6 /* Json.SyntaxKind.ColonToken */ ) {
                        node.colonOffset = scanner.getTokenOffset();
                        _scanNext(); // consume ColonToken
                    } else {
                        _error(t('Colon expected'), ErrorCode.ColonExpected);
                        if (scanner.getToken() === 10 /* Json.SyntaxKind.StringLiteral */  && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {
                            node.length = key.length;
                            return node;
                        }
                    }
                    const value = _parseValue(node);
                    if (!value) {
                        return _error(t('Value expected'), ErrorCode.ValueExpected, node, [], [
                            2 /* Json.SyntaxKind.CloseBraceToken */ ,
                            5 /* Json.SyntaxKind.CommaToken */ 
                        ]);
                    }
                    node.valueNode = value;
                    node.length = value.offset + value.length - node.offset;
                    return node;
                }
                function _parseObject(parent) {
                    if (scanner.getToken() !== 1 /* Json.SyntaxKind.OpenBraceToken */ ) {
                        return undefined;
                    }
                    const node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());
                    const keysSeen = Object.create(null);
                    _scanNext(); // consume OpenBraceToken
                    let needsComma = false;
                    while(scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */  && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ){
                        if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                _error(t('Property expected'), ErrorCode.PropertyExpected);
                            }
                            const commaOffset = scanner.getTokenOffset();
                            _scanNext(); // consume comma
                            if (scanner.getToken() === 2 /* Json.SyntaxKind.CloseBraceToken */ ) {
                                if (needsComma) {
                                    _errorAtRange(t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                                }
                                continue;
                            }
                        } else if (needsComma) {
                            _error(t('Expected comma'), ErrorCode.CommaExpected);
                        }
                        const property = _parseProperty(node, keysSeen);
                        if (!property) {
                            _error(t('Property expected'), ErrorCode.PropertyExpected, undefined, [], [
                                2 /* Json.SyntaxKind.CloseBraceToken */ ,
                                5 /* Json.SyntaxKind.CommaToken */ 
                            ]);
                        } else {
                            node.properties.push(property);
                        }
                        needsComma = true;
                    }
                    if (scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */ ) {
                        return _error(t('Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);
                    }
                    return _finalize(node, true);
                }
                function _parseString(parent) {
                    if (scanner.getToken() !== 10 /* Json.SyntaxKind.StringLiteral */ ) {
                        return undefined;
                    }
                    const node = new StringASTNodeImpl(parent, scanner.getTokenOffset());
                    node.value = scanner.getTokenValue();
                    return _finalize(node, true);
                }
                function _parseNumber(parent) {
                    if (scanner.getToken() !== 11 /* Json.SyntaxKind.NumericLiteral */ ) {
                        return undefined;
                    }
                    const node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());
                    if (scanner.getTokenError() === 0 /* Json.ScanError.None */ ) {
                        const tokenValue = scanner.getTokenValue();
                        try {
                            const numberValue = JSON.parse(tokenValue);
                            if (!isNumber(numberValue)) {
                                return _error(t('Invalid number format.'), ErrorCode.Undefined, node);
                            }
                            node.value = numberValue;
                        } catch (e) {
                            return _error(t('Invalid number format.'), ErrorCode.Undefined, node);
                        }
                        node.isInteger = tokenValue.indexOf('.') === -1;
                    }
                    return _finalize(node, true);
                }
                function _parseLiteral(parent) {
                    let node;
                    switch(scanner.getToken()){
                        case 7 /* Json.SyntaxKind.NullKeyword */ :
                            return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);
                        case 8 /* Json.SyntaxKind.TrueKeyword */ :
                            return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);
                        case 9 /* Json.SyntaxKind.FalseKeyword */ :
                            return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);
                        default:
                            return undefined;
                    }
                }
                function _parseValue(parent) {
                    return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);
                }
                let _root = undefined;
                const token = _scanNext();
                if (token !== 17 /* Json.SyntaxKind.EOF */ ) {
                    _root = _parseValue(_root);
                    if (!_root) {
                        _error(t('Expected a JSON object, array or literal.'), ErrorCode.Undefined);
                    } else if (scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ) {
                        _error(t('End of file expected.'), ErrorCode.Undefined);
                    }
                }
                return new JSONDocument(_root, problems, commentRanges);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/json.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function stringifyObject(obj, indent, stringifyLiteral) {
                if (obj !== null && typeof obj === 'object') {
                    const newIndent = indent + '\t';
                    if (Array.isArray(obj)) {
                        if (obj.length === 0) {
                            return '[]';
                        }
                        let result = '[\n';
                        for(let i = 0; i < obj.length; i++){
                            result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);
                            if (i < obj.length - 1) {
                                result += ',';
                            }
                            result += '\n';
                        }
                        result += indent + ']';
                        return result;
                    } else {
                        const keys = Object.keys(obj);
                        if (keys.length === 0) {
                            return '{}';
                        }
                        let result = '{\n';
                        for(let i = 0; i < keys.length; i++){
                            const key = keys[i];
                            result += newIndent + JSON.stringify(key) + ': ' + stringifyObject(obj[key], newIndent, stringifyLiteral);
                            if (i < keys.length - 1) {
                                result += ',';
                            }
                            result += '\n';
                        }
                        result += indent + '}';
                        return result;
                    }
                }
                return stringifyLiteral(obj);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonCompletion.js
            /* provided dependency */ var console = __nested_webpack_require_701415__(3716);
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const valueCommitCharacters = [
                ',',
                '}',
                ']'
            ];
            const propertyCommitCharacters = [
                ':'
            ];
            class JSONCompletion {
                doResolve(item) {
                    for(let i = this.contributions.length - 1; i >= 0; i--){
                        const resolveCompletion = this.contributions[i].resolveCompletion;
                        if (resolveCompletion) {
                            const resolver = resolveCompletion(item);
                            if (resolver) {
                                return resolver;
                            }
                        }
                    }
                    return this.promiseConstructor.resolve(item);
                }
                doComplete(document1, position, doc) {
                    const result = {
                        items: [],
                        isIncomplete: false
                    };
                    const text = document1.getText();
                    const offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset, true);
                    if (this.isInComment(document1, node ? node.offset : 0, offset)) {
                        return Promise.resolve(result);
                    }
                    if (node && offset === node.offset + node.length && offset > 0) {
                        const ch = text[offset - 1];
                        if (node.type === 'object' && ch === '}' || node.type === 'array' && ch === ']') {
                            // after ] or }
                            node = node.parent;
                        }
                    }
                    const currentWord = this.getCurrentWord(document1, offset);
                    let overwriteRange;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        overwriteRange = main.Range.create(document1.positionAt(node.offset), document1.positionAt(node.offset + node.length));
                    } else {
                        let overwriteStart = offset - currentWord.length;
                        if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
                            overwriteStart--;
                        }
                        overwriteRange = main.Range.create(document1.positionAt(overwriteStart), position);
                    }
                    const supportsCommitCharacters = false; //this.doesSupportsCommitCharacters(); disabled for now, waiting for new API: https://github.com/microsoft/vscode/issues/42544
                    const proposed = new Map();
                    const collector = {
                        add: (suggestion)=>{
                            let label = suggestion.label;
                            const existing = proposed.get(label);
                            if (!existing) {
                                label = label.replace(/[\n]/g, '');
                                if (label.length > 60) {
                                    const shortendedLabel = label.substr(0, 57).trim() + '...';
                                    if (!proposed.has(shortendedLabel)) {
                                        label = shortendedLabel;
                                    }
                                }
                                suggestion.textEdit = main.TextEdit.replace(overwriteRange, suggestion.insertText);
                                if (supportsCommitCharacters) {
                                    suggestion.commitCharacters = suggestion.kind === main.CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;
                                }
                                suggestion.label = label;
                                proposed.set(label, suggestion);
                                result.items.push(suggestion);
                            } else {
                                if (!existing.documentation) {
                                    existing.documentation = suggestion.documentation;
                                }
                                if (!existing.detail) {
                                    existing.detail = suggestion.detail;
                                }
                                if (!existing.labelDetails) {
                                    existing.labelDetails = suggestion.labelDetails;
                                }
                            }
                        },
                        setAsIncomplete: ()=>{
                            result.isIncomplete = true;
                        },
                        error: (message)=>{
                            console.error(message);
                        },
                        getNumberOfProposals: ()=>{
                            return result.items.length;
                        }
                    };
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        const collectionPromises = [];
                        let addValue = true;
                        let currentKey = '';
                        let currentProperty = undefined;
                        if (node) {
                            if (node.type === 'string') {
                                const parent = node.parent;
                                if (parent && parent.type === 'property' && parent.keyNode === node) {
                                    addValue = !parent.valueNode;
                                    currentProperty = parent;
                                    currentKey = text.substr(node.offset + 1, node.length - 2);
                                    if (parent) {
                                        node = parent.parent;
                                    }
                                }
                            }
                        }
                        // proposals for properties
                        if (node && node.type === 'object') {
                            // don't suggest keys when the cursor is just before the opening curly brace
                            if (node.offset === offset) {
                                return result;
                            }
                            // don't suggest properties that are already present
                            const properties = node.properties;
                            properties.forEach((p)=>{
                                if (!currentProperty || currentProperty !== p) {
                                    proposed.set(p.keyNode.value, main.CompletionItem.create('__'));
                                }
                            });
                            let separatorAfter = '';
                            if (addValue) {
                                separatorAfter = this.evaluateSeparatorAfter(document1, document1.offsetAt(overwriteRange.end));
                            }
                            if (schema) {
                                // property proposals with schema
                                this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector);
                            } else {
                                // property proposals without schema
                                this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);
                            }
                            const location = jsonParser_getNodePath(node);
                            this.contributions.forEach((contribution)=>{
                                const collectPromise = contribution.collectPropertyCompletions(document1.uri, location, currentWord, addValue, separatorAfter === '', collector);
                                if (collectPromise) {
                                    collectionPromises.push(collectPromise);
                                }
                            });
                            if (!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"') {
                                collector.add({
                                    kind: main.CompletionItemKind.Property,
                                    label: this.getLabelForValue(currentWord),
                                    insertText: this.getInsertTextForProperty(currentWord, undefined, false, separatorAfter),
                                    insertTextFormat: main.InsertTextFormat.Snippet,
                                    documentation: ''
                                });
                                collector.setAsIncomplete();
                            }
                        }
                        // proposals for values
                        const types = {};
                        if (schema) {
                            // value proposals with schema
                            this.getValueCompletions(schema, doc, node, offset, document1, collector, types);
                        } else {
                            // value proposals without schema
                            this.getSchemaLessValueCompletions(doc, node, offset, document1, collector);
                        }
                        if (this.contributions.length > 0) {
                            this.getContributedValueCompletions(doc, node, offset, document1, collector, collectionPromises);
                        }
                        return this.promiseConstructor.all(collectionPromises).then(()=>{
                            if (collector.getNumberOfProposals() === 0) {
                                let offsetForSeparator = offset;
                                if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                                    offsetForSeparator = node.offset + node.length;
                                }
                                const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                                this.addFillerValueCompletions(types, separatorAfter, collector);
                            }
                            return result;
                        });
                    });
                }
                getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector) {
                    const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
                    matchingSchemas.forEach((s)=>{
                        if (s.node === node && !s.inverted) {
                            const schemaProperties = s.schema.properties;
                            if (schemaProperties) {
                                Object.keys(schemaProperties).forEach((key)=>{
                                    const propertySchema = schemaProperties[key];
                                    if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {
                                        const proposal = {
                                            kind: main.CompletionItemKind.Property,
                                            label: key,
                                            insertText: this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),
                                            insertTextFormat: main.InsertTextFormat.Snippet,
                                            filterText: this.getFilterTextForValue(key),
                                            documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || ''
                                        };
                                        if (propertySchema.suggestSortText !== undefined) {
                                            proposal.sortText = propertySchema.suggestSortText;
                                        }
                                        if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {
                                            proposal.command = {
                                                title: 'Suggest',
                                                command: 'editor.action.triggerSuggest'
                                            };
                                        }
                                        collector.add(proposal);
                                    }
                                });
                            }
                            const schemaPropertyNames = s.schema.propertyNames;
                            if (typeof schemaPropertyNames === 'object' && !schemaPropertyNames.deprecationMessage && !schemaPropertyNames.doNotSuggest) {
                                const propertyNameCompletionItem = (name, enumDescription = undefined)=>{
                                    const proposal = {
                                        kind: main.CompletionItemKind.Property,
                                        label: name,
                                        insertText: this.getInsertTextForProperty(name, undefined, addValue, separatorAfter),
                                        insertTextFormat: main.InsertTextFormat.Snippet,
                                        filterText: this.getFilterTextForValue(name),
                                        documentation: enumDescription || this.fromMarkup(schemaPropertyNames.markdownDescription) || schemaPropertyNames.description || ''
                                    };
                                    if (schemaPropertyNames.suggestSortText !== undefined) {
                                        proposal.sortText = schemaPropertyNames.suggestSortText;
                                    }
                                    if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {
                                        proposal.command = {
                                            title: 'Suggest',
                                            command: 'editor.action.triggerSuggest'
                                        };
                                    }
                                    collector.add(proposal);
                                };
                                if (schemaPropertyNames.enum) {
                                    for(let i = 0; i < schemaPropertyNames.enum.length; i++){
                                        let enumDescription = undefined;
                                        if (schemaPropertyNames.markdownEnumDescriptions && i < schemaPropertyNames.markdownEnumDescriptions.length) {
                                            enumDescription = this.fromMarkup(schemaPropertyNames.markdownEnumDescriptions[i]);
                                        } else if (schemaPropertyNames.enumDescriptions && i < schemaPropertyNames.enumDescriptions.length) {
                                            enumDescription = schemaPropertyNames.enumDescriptions[i];
                                        }
                                        propertyNameCompletionItem(schemaPropertyNames.enum[i], enumDescription);
                                    }
                                }
                                if (schemaPropertyNames.const) {
                                    propertyNameCompletionItem(schemaPropertyNames.const);
                                }
                            }
                        }
                    });
                }
                getSchemaLessPropertyCompletions(doc, node, currentKey, collector) {
                    const collectCompletionsForSimilarObject = (obj)=>{
                        obj.properties.forEach((p)=>{
                            const key = p.keyNode.value;
                            collector.add({
                                kind: main.CompletionItemKind.Property,
                                label: key,
                                insertText: this.getInsertTextForValue(key, ''),
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                filterText: this.getFilterTextForValue(key),
                                documentation: ''
                            });
                        });
                    };
                    if (node.parent) {
                        if (node.parent.type === 'property') {
                            // if the object is a property value, check the tree for other objects that hang under a property of the same name
                            const parentKey = node.parent.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'object') {
                                    collectCompletionsForSimilarObject(n.valueNode);
                                }
                                return true;
                            });
                        } else if (node.parent.type === 'array') {
                            // if the object is in an array, use all other array elements as similar objects
                            node.parent.items.forEach((n)=>{
                                if (n.type === 'object' && n !== node) {
                                    collectCompletionsForSimilarObject(n);
                                }
                            });
                        }
                    } else if (node.type === 'object') {
                        collector.add({
                            kind: main.CompletionItemKind.Property,
                            label: '$schema',
                            insertText: this.getInsertTextForProperty('$schema', undefined, true, ''),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: '',
                            filterText: this.getFilterTextForValue("$schema")
                        });
                    }
                }
                getSchemaLessValueCompletions(doc, node, offset, document1, collector) {
                    let offsetForSeparator = offset;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        offsetForSeparator = node.offset + node.length;
                        node = node.parent;
                    }
                    if (!node) {
                        collector.add({
                            kind: this.getSuggestionKind('object'),
                            label: 'Empty object',
                            insertText: this.getInsertTextForValue({}, ''),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: ''
                        });
                        collector.add({
                            kind: this.getSuggestionKind('array'),
                            label: 'Empty array',
                            insertText: this.getInsertTextForValue([], ''),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: ''
                        });
                        return;
                    }
                    const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                    const collectSuggestionsForValues = (value)=>{
                        if (value.parent && !jsonParser_contains(value.parent, offset, true)) {
                            collector.add({
                                kind: this.getSuggestionKind(value.type),
                                label: this.getLabelTextForMatchingNode(value, document1),
                                insertText: this.getInsertTextForMatchingNode(value, document1, separatorAfter),
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                documentation: ''
                            });
                        }
                        if (value.type === 'boolean') {
                            this.addBooleanValueCompletion(!value.value, separatorAfter, collector);
                        }
                    };
                    if (node.type === 'property') {
                        if (offset > (node.colonOffset || 0)) {
                            const valueNode = node.valueNode;
                            if (valueNode && (offset > valueNode.offset + valueNode.length || valueNode.type === 'object' || valueNode.type === 'array')) {
                                return;
                            }
                            // suggest values at the same key
                            const parentKey = node.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode) {
                                    collectSuggestionsForValues(n.valueNode);
                                }
                                return true;
                            });
                            if (parentKey === '$schema' && node.parent && !node.parent.parent) {
                                this.addDollarSchemaCompletions(separatorAfter, collector);
                            }
                        }
                    }
                    if (node.type === 'array') {
                        if (node.parent && node.parent.type === 'property') {
                            // suggest items of an array at the same key
                            const parentKey = node.parent.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'array') {
                                    n.valueNode.items.forEach(collectSuggestionsForValues);
                                }
                                return true;
                            });
                        } else {
                            // suggest items in the same array
                            node.items.forEach(collectSuggestionsForValues);
                        }
                    }
                }
                getValueCompletions(schema, doc, node, offset, document1, collector, types) {
                    let offsetForSeparator = offset;
                    let parentKey = undefined;
                    let valueNode = undefined;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        offsetForSeparator = node.offset + node.length;
                        valueNode = node;
                        node = node.parent;
                    }
                    if (!node) {
                        this.addSchemaValueCompletions(schema.schema, '', collector, types);
                        return;
                    }
                    if (node.type === 'property' && offset > (node.colonOffset || 0)) {
                        const valueNode = node.valueNode;
                        if (valueNode && offset > valueNode.offset + valueNode.length) {
                            return; // we are past the value node
                        }
                        parentKey = node.keyNode.value;
                        node = node.parent;
                    }
                    if (node && (parentKey !== undefined || node.type === 'array')) {
                        const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                        const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);
                        for (const s of matchingSchemas){
                            if (s.node === node && !s.inverted && s.schema) {
                                if (node.type === 'array' && s.schema.items) {
                                    let c = collector;
                                    if (s.schema.uniqueItems) {
                                        const existingValues = new Set();
                                        node.children.forEach((n)=>{
                                            if (n.type !== 'array' && n.type !== 'object') {
                                                existingValues.add(this.getLabelForValue(jsonParser_getNodeValue(n)));
                                            }
                                        });
                                        c = {
                                            ...collector,
                                            add (suggestion) {
                                                if (!existingValues.has(suggestion.label)) {
                                                    collector.add(suggestion);
                                                }
                                            }
                                        };
                                    }
                                    if (Array.isArray(s.schema.items)) {
                                        const index = this.findItemAtOffset(node, document1, offset);
                                        if (index < s.schema.items.length) {
                                            this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, c, types);
                                        }
                                    } else {
                                        this.addSchemaValueCompletions(s.schema.items, separatorAfter, c, types);
                                    }
                                }
                                if (parentKey !== undefined) {
                                    let propertyMatched = false;
                                    if (s.schema.properties) {
                                        const propertySchema = s.schema.properties[parentKey];
                                        if (propertySchema) {
                                            propertyMatched = true;
                                            this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                        }
                                    }
                                    if (s.schema.patternProperties && !propertyMatched) {
                                        for (const pattern of Object.keys(s.schema.patternProperties)){
                                            var _regex;
                                            const regex = extendedRegExp(pattern);
                                            if ((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(parentKey)) {
                                                propertyMatched = true;
                                                const propertySchema = s.schema.patternProperties[pattern];
                                                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                            }
                                        }
                                    }
                                    if (s.schema.additionalProperties && !propertyMatched) {
                                        const propertySchema = s.schema.additionalProperties;
                                        this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                    }
                                }
                            }
                        }
                        if (parentKey === '$schema' && !node.parent) {
                            this.addDollarSchemaCompletions(separatorAfter, collector);
                        }
                        if (types['boolean']) {
                            this.addBooleanValueCompletion(true, separatorAfter, collector);
                            this.addBooleanValueCompletion(false, separatorAfter, collector);
                        }
                        if (types['null']) {
                            this.addNullValueCompletion(separatorAfter, collector);
                        }
                    }
                }
                getContributedValueCompletions(doc, node, offset, document1, collector, collectionPromises) {
                    if (!node) {
                        this.contributions.forEach((contribution)=>{
                            const collectPromise = contribution.collectDefaultCompletions(document1.uri, collector);
                            if (collectPromise) {
                                collectionPromises.push(collectPromise);
                            }
                        });
                    } else {
                        if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {
                            node = node.parent;
                        }
                        if (node && node.type === 'property' && offset > (node.colonOffset || 0)) {
                            const parentKey = node.keyNode.value;
                            const valueNode = node.valueNode;
                            if ((!valueNode || offset <= valueNode.offset + valueNode.length) && node.parent) {
                                const location = jsonParser_getNodePath(node.parent);
                                this.contributions.forEach((contribution)=>{
                                    const collectPromise = contribution.collectValueCompletions(document1.uri, location, parentKey, collector);
                                    if (collectPromise) {
                                        collectionPromises.push(collectPromise);
                                    }
                                });
                            }
                        }
                    }
                }
                addSchemaValueCompletions(schema, separatorAfter, collector, types) {
                    if (typeof schema === 'object') {
                        this.addEnumValueCompletions(schema, separatorAfter, collector);
                        this.addDefaultValueCompletions(schema, separatorAfter, collector);
                        this.collectTypes(schema, types);
                        if (Array.isArray(schema.allOf)) {
                            schema.allOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                        if (Array.isArray(schema.anyOf)) {
                            schema.anyOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                        if (Array.isArray(schema.oneOf)) {
                            schema.oneOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                    }
                }
                addDefaultValueCompletions(schema, separatorAfter, collector, arrayDepth = 0) {
                    let hasProposals = false;
                    if (isDefined(schema.default)) {
                        let type = schema.type;
                        let value = schema.default;
                        for(let i = arrayDepth; i > 0; i--){
                            value = [
                                value
                            ];
                            type = 'array';
                        }
                        const completionItem = {
                            kind: this.getSuggestionKind(type),
                            label: this.getLabelForValue(value),
                            insertText: this.getInsertTextForValue(value, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet
                        };
                        if (this.doesSupportsLabelDetails()) {
                            completionItem.labelDetails = {
                                description: t('Default value')
                            };
                        } else {
                            completionItem.detail = t('Default value');
                        }
                        collector.add(completionItem);
                        hasProposals = true;
                    }
                    if (Array.isArray(schema.examples)) {
                        schema.examples.forEach((example)=>{
                            let type = schema.type;
                            let value = example;
                            for(let i = arrayDepth; i > 0; i--){
                                value = [
                                    value
                                ];
                                type = 'array';
                            }
                            collector.add({
                                kind: this.getSuggestionKind(type),
                                label: this.getLabelForValue(value),
                                insertText: this.getInsertTextForValue(value, separatorAfter),
                                insertTextFormat: main.InsertTextFormat.Snippet
                            });
                            hasProposals = true;
                        });
                    }
                    if (Array.isArray(schema.defaultSnippets)) {
                        schema.defaultSnippets.forEach((s)=>{
                            let type = schema.type;
                            let value = s.body;
                            let label = s.label;
                            let insertText;
                            let filterText;
                            if (isDefined(value)) {
                                let type = schema.type;
                                for(let i = arrayDepth; i > 0; i--){
                                    value = [
                                        value
                                    ];
                                    type = 'array';
                                }
                                insertText = this.getInsertTextForSnippetValue(value, separatorAfter);
                                filterText = this.getFilterTextForSnippetValue(value);
                                label = label || this.getLabelForSnippetValue(value);
                            } else if (typeof s.bodyText === 'string') {
                                let prefix = '', suffix = '', indent = '';
                                for(let i = arrayDepth; i > 0; i--){
                                    prefix = prefix + indent + '[\n';
                                    suffix = suffix + '\n' + indent + ']';
                                    indent += '\t';
                                    type = 'array';
                                }
                                insertText = prefix + indent + s.bodyText.split('\n').join('\n' + indent) + suffix + separatorAfter;
                                label = label || insertText, filterText = insertText.replace(/[\n]/g, ''); // remove new lines
                            } else {
                                return;
                            }
                            collector.add({
                                kind: this.getSuggestionKind(type),
                                label,
                                documentation: this.fromMarkup(s.markdownDescription) || s.description,
                                insertText,
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                filterText
                            });
                            hasProposals = true;
                        });
                    }
                    if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items) && arrayDepth < 5 /* beware of recursion */ ) {
                        this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);
                    }
                }
                addEnumValueCompletions(schema, separatorAfter, collector) {
                    if (isDefined(schema.const)) {
                        collector.add({
                            kind: this.getSuggestionKind(schema.type),
                            label: this.getLabelForValue(schema.const),
                            insertText: this.getInsertTextForValue(schema.const, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: this.fromMarkup(schema.markdownDescription) || schema.description
                        });
                    }
                    if (Array.isArray(schema.enum)) {
                        for(let i = 0, length = schema.enum.length; i < length; i++){
                            const enm = schema.enum[i];
                            let documentation = this.fromMarkup(schema.markdownDescription) || schema.description;
                            if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {
                                documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);
                            } else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {
                                documentation = schema.enumDescriptions[i];
                            }
                            collector.add({
                                kind: this.getSuggestionKind(schema.type),
                                label: this.getLabelForValue(enm),
                                insertText: this.getInsertTextForValue(enm, separatorAfter),
                                insertTextFormat: main.InsertTextFormat.Snippet,
                                documentation
                            });
                        }
                    }
                }
                collectTypes(schema, types) {
                    if (Array.isArray(schema.enum) || isDefined(schema.const)) {
                        return;
                    }
                    const type = schema.type;
                    if (Array.isArray(type)) {
                        type.forEach((t)=>types[t] = true);
                    } else if (type) {
                        types[type] = true;
                    }
                }
                addFillerValueCompletions(types, separatorAfter, collector) {
                    if (types['object']) {
                        collector.add({
                            kind: this.getSuggestionKind('object'),
                            label: '{}',
                            insertText: this.getInsertTextForGuessedValue({}, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            detail: t('New object'),
                            documentation: ''
                        });
                    }
                    if (types['array']) {
                        collector.add({
                            kind: this.getSuggestionKind('array'),
                            label: '[]',
                            insertText: this.getInsertTextForGuessedValue([], separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            detail: t('New array'),
                            documentation: ''
                        });
                    }
                }
                addBooleanValueCompletion(value, separatorAfter, collector) {
                    collector.add({
                        kind: this.getSuggestionKind('boolean'),
                        label: value ? 'true' : 'false',
                        insertText: this.getInsertTextForValue(value, separatorAfter),
                        insertTextFormat: main.InsertTextFormat.Snippet,
                        documentation: ''
                    });
                }
                addNullValueCompletion(separatorAfter, collector) {
                    collector.add({
                        kind: this.getSuggestionKind('null'),
                        label: 'null',
                        insertText: 'null' + separatorAfter,
                        insertTextFormat: main.InsertTextFormat.Snippet,
                        documentation: ''
                    });
                }
                addDollarSchemaCompletions(separatorAfter, collector) {
                    const schemaIds = this.schemaService.getRegisteredSchemaIds((schema)=>schema === 'http' || schema === 'https');
                    schemaIds.forEach((schemaId)=>collector.add({
                            kind: main.CompletionItemKind.Module,
                            label: this.getLabelForValue(schemaId),
                            filterText: this.getFilterTextForValue(schemaId),
                            insertText: this.getInsertTextForValue(schemaId, separatorAfter),
                            insertTextFormat: main.InsertTextFormat.Snippet,
                            documentation: ''
                        }));
                }
                getLabelForValue(value) {
                    return JSON.stringify(value);
                }
                getValueFromLabel(value) {
                    return JSON.parse(value);
                }
                getFilterTextForValue(value) {
                    return JSON.stringify(value);
                }
                getFilterTextForSnippetValue(value) {
                    return JSON.stringify(value).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
                }
                getLabelForSnippetValue(value) {
                    const label = JSON.stringify(value);
                    return label.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
                }
                getInsertTextForPlainText(text) {
                    return text.replace(/[\\\$\}]/g, '\\$&'); // escape $, \ and }
                }
                getInsertTextForValue(value, separatorAfter) {
                    const text = JSON.stringify(value, null, '\t');
                    if (text === '{}') {
                        return '{$1}' + separatorAfter;
                    } else if (text === '[]') {
                        return '[$1]' + separatorAfter;
                    }
                    return this.getInsertTextForPlainText(text + separatorAfter);
                }
                getInsertTextForSnippetValue(value, separatorAfter) {
                    const replacer = (value)=>{
                        if (typeof value === 'string') {
                            if (value[0] === '^') {
                                return value.substr(1);
                            }
                        }
                        return JSON.stringify(value);
                    };
                    return stringifyObject(value, '', replacer) + separatorAfter;
                }
                getInsertTextForGuessedValue(value, separatorAfter) {
                    switch(typeof value){
                        case 'object':
                            if (value === null) {
                                return '${1:null}' + separatorAfter;
                            }
                            return this.getInsertTextForValue(value, separatorAfter);
                        case 'string':
                            let snippetValue = JSON.stringify(value);
                            snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes
                            snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \ and }
                            return '"${1:' + snippetValue + '}"' + separatorAfter;
                        case 'number':
                        case 'boolean':
                            return '${1:' + JSON.stringify(value) + '}' + separatorAfter;
                    }
                    return this.getInsertTextForValue(value, separatorAfter);
                }
                getSuggestionKind(type) {
                    if (Array.isArray(type)) {
                        const array = type;
                        type = array.length > 0 ? array[0] : undefined;
                    }
                    if (!type) {
                        return main.CompletionItemKind.Value;
                    }
                    switch(type){
                        case 'string':
                            return main.CompletionItemKind.Value;
                        case 'object':
                            return main.CompletionItemKind.Module;
                        case 'property':
                            return main.CompletionItemKind.Property;
                        default:
                            return main.CompletionItemKind.Value;
                    }
                }
                getLabelTextForMatchingNode(node, document1) {
                    switch(node.type){
                        case 'array':
                            return '[]';
                        case 'object':
                            return '{}';
                        default:
                            const content = document1.getText().substr(node.offset, node.length);
                            return content;
                    }
                }
                getInsertTextForMatchingNode(node, document1, separatorAfter) {
                    switch(node.type){
                        case 'array':
                            return this.getInsertTextForValue([], separatorAfter);
                        case 'object':
                            return this.getInsertTextForValue({}, separatorAfter);
                        default:
                            const content = document1.getText().substr(node.offset, node.length) + separatorAfter;
                            return this.getInsertTextForPlainText(content);
                    }
                }
                getInsertTextForProperty(key, propertySchema, addValue, separatorAfter) {
                    const propertyText = this.getInsertTextForValue(key, '');
                    if (!addValue) {
                        return propertyText;
                    }
                    const resultText = propertyText + ': ';
                    let value;
                    let nValueProposals = 0;
                    if (propertySchema) {
                        if (Array.isArray(propertySchema.defaultSnippets)) {
                            if (propertySchema.defaultSnippets.length === 1) {
                                const body = propertySchema.defaultSnippets[0].body;
                                if (isDefined(body)) {
                                    value = this.getInsertTextForSnippetValue(body, '');
                                }
                            }
                            nValueProposals += propertySchema.defaultSnippets.length;
                        }
                        if (propertySchema.enum) {
                            if (!value && propertySchema.enum.length === 1) {
                                value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');
                            }
                            nValueProposals += propertySchema.enum.length;
                        }
                        if (isDefined(propertySchema.const)) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.const, '');
                            }
                            nValueProposals++;
                        }
                        if (isDefined(propertySchema.default)) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.default, '');
                            }
                            nValueProposals++;
                        }
                        if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.examples[0], '');
                            }
                            nValueProposals += propertySchema.examples.length;
                        }
                        if (nValueProposals === 0) {
                            let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
                            if (!type) {
                                if (propertySchema.properties) {
                                    type = 'object';
                                } else if (propertySchema.items) {
                                    type = 'array';
                                }
                            }
                            switch(type){
                                case 'boolean':
                                    value = '$1';
                                    break;
                                case 'string':
                                    value = '"$1"';
                                    break;
                                case 'object':
                                    value = '{$1}';
                                    break;
                                case 'array':
                                    value = '[$1]';
                                    break;
                                case 'number':
                                case 'integer':
                                    value = '${1:0}';
                                    break;
                                case 'null':
                                    value = '${1:null}';
                                    break;
                                default:
                                    return propertyText;
                            }
                        }
                    }
                    if (!value || nValueProposals > 1) {
                        value = '$1';
                    }
                    return resultText + value + separatorAfter;
                }
                getCurrentWord(document1, offset) {
                    let i = offset - 1;
                    const text = document1.getText();
                    while(i >= 0 && ' \t\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1){
                        i--;
                    }
                    return text.substring(i + 1, offset);
                }
                evaluateSeparatorAfter(document1, offset) {
                    const scanner = main_createScanner(document1.getText(), true);
                    scanner.setPosition(offset);
                    const token = scanner.scan();
                    switch(token){
                        case 5 /* Json.SyntaxKind.CommaToken */ :
                        case 2 /* Json.SyntaxKind.CloseBraceToken */ :
                        case 4 /* Json.SyntaxKind.CloseBracketToken */ :
                        case 17 /* Json.SyntaxKind.EOF */ :
                            return '';
                        default:
                            return ',';
                    }
                }
                findItemAtOffset(node, document1, offset) {
                    const scanner = main_createScanner(document1.getText(), true);
                    const children = node.items;
                    for(let i = children.length - 1; i >= 0; i--){
                        const child = children[i];
                        if (offset > child.offset + child.length) {
                            scanner.setPosition(child.offset + child.length);
                            const token = scanner.scan();
                            if (token === 5 /* Json.SyntaxKind.CommaToken */  && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {
                                return i + 1;
                            }
                            return i;
                        } else if (offset >= child.offset) {
                            return i;
                        }
                    }
                    return 0;
                }
                isInComment(document1, start, offset) {
                    const scanner = main_createScanner(document1.getText(), false);
                    scanner.setPosition(start);
                    let token = scanner.scan();
                    while(token !== 17 /* Json.SyntaxKind.EOF */  && scanner.getTokenOffset() + scanner.getTokenLength() < offset){
                        token = scanner.scan();
                    }
                    return (token === 12 /* Json.SyntaxKind.LineCommentTrivia */  || token === 13 /* Json.SyntaxKind.BlockCommentTrivia */ ) && scanner.getTokenOffset() <= offset;
                }
                fromMarkup(markupString) {
                    if (markupString && this.doesSupportMarkdown()) {
                        return {
                            kind: main.MarkupKind.Markdown,
                            value: markupString
                        };
                    }
                    return undefined;
                }
                doesSupportMarkdown() {
                    if (!isDefined(this.supportsMarkdown)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        const documentationFormat = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.documentationFormat;
                        this.supportsMarkdown = Array.isArray(documentationFormat) && documentationFormat.indexOf(main.MarkupKind.Markdown) !== -1;
                    }
                    return this.supportsMarkdown;
                }
                doesSupportsCommitCharacters() {
                    if (!isDefined(this.supportsCommitCharacters)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        this.labelDetailsSupport = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.commitCharactersSupport;
                    }
                    return this.supportsCommitCharacters;
                }
                doesSupportsLabelDetails() {
                    if (!isDefined(this.labelDetailsSupport)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        this.labelDetailsSupport = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.labelDetailsSupport;
                    }
                    return this.labelDetailsSupport;
                }
                constructor(schemaService, contributions = [], promiseConstructor = Promise, clientCapabilities = {}){
                    this.schemaService = schemaService;
                    this.contributions = contributions;
                    this.promiseConstructor = promiseConstructor;
                    this.clientCapabilities = clientCapabilities;
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonHover.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONHover {
                doHover(document1, position, doc) {
                    const offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset);
                    if (!node || (node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1) {
                        return this.promise.resolve(null);
                    }
                    const hoverRangeNode = node;
                    // use the property description when hovering over an object key
                    if (node.type === 'string') {
                        const parent = node.parent;
                        if (parent && parent.type === 'property' && parent.keyNode === node) {
                            node = parent.valueNode;
                            if (!node) {
                                return this.promise.resolve(null);
                            }
                        }
                    }
                    const hoverRange = main.Range.create(document1.positionAt(hoverRangeNode.offset), document1.positionAt(hoverRangeNode.offset + hoverRangeNode.length));
                    const createHover = (contents)=>{
                        const result = {
                            contents: contents,
                            range: hoverRange
                        };
                        return result;
                    };
                    const location = jsonParser_getNodePath(node);
                    for(let i = this.contributions.length - 1; i >= 0; i--){
                        const contribution = this.contributions[i];
                        const promise = contribution.getInfoContribution(document1.uri, location);
                        if (promise) {
                            return promise.then((htmlContent)=>createHover(htmlContent));
                        }
                    }
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        if (schema && node) {
                            const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
                            let title = undefined;
                            let markdownDescription = undefined;
                            let markdownEnumValueDescription = undefined, enumValue = undefined;
                            matchingSchemas.every((s)=>{
                                if (s.node === node && !s.inverted && s.schema) {
                                    title = title || s.schema.title;
                                    markdownDescription = markdownDescription || s.schema.markdownDescription || toMarkdown(s.schema.description);
                                    if (s.schema.enum) {
                                        const idx = s.schema.enum.indexOf(jsonParser_getNodeValue(node));
                                        if (s.schema.markdownEnumDescriptions) {
                                            markdownEnumValueDescription = s.schema.markdownEnumDescriptions[idx];
                                        } else if (s.schema.enumDescriptions) {
                                            markdownEnumValueDescription = toMarkdown(s.schema.enumDescriptions[idx]);
                                        }
                                        if (markdownEnumValueDescription) {
                                            enumValue = s.schema.enum[idx];
                                            if (typeof enumValue !== 'string') {
                                                enumValue = JSON.stringify(enumValue);
                                            }
                                        }
                                    }
                                }
                                return true;
                            });
                            let result = '';
                            if (title) {
                                result = toMarkdown(title);
                            }
                            if (markdownDescription) {
                                if (result.length > 0) {
                                    result += "\n\n";
                                }
                                result += markdownDescription;
                            }
                            if (markdownEnumValueDescription) {
                                if (result.length > 0) {
                                    result += "\n\n";
                                }
                                result += `\`${toMarkdownCodeBlock(enumValue)}\`: ${markdownEnumValueDescription}`;
                            }
                            return createHover([
                                result
                            ]);
                        }
                        return null;
                    });
                }
                constructor(schemaService, contributions = [], promiseConstructor){
                    this.schemaService = schemaService;
                    this.contributions = contributions;
                    this.promise = promiseConstructor || Promise;
                }
            }
            function toMarkdown(plain) {
                if (plain) {
                    const res = plain.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, '$1\n\n$3'); // single new lines to \n\n (Markdown paragraph)
                    return res.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                }
                return undefined;
            }
            function toMarkdownCodeBlock(content) {
                // see https://daringfireball.net/projects/markdown/syntax#precode
                if (content.indexOf('`') !== -1) {
                    return '`` ' + content + ' ``';
                }
                return content;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonValidation.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONValidation {
                configure(raw) {
                    if (raw) {
                        this.validationEnabled = raw.validate !== false;
                        this.commentSeverity = raw.allowComments ? undefined : main.DiagnosticSeverity.Error;
                    }
                }
                doValidation(textDocument, jsonDocument, documentSettings, schema) {
                    if (!this.validationEnabled) {
                        return this.promise.resolve([]);
                    }
                    const diagnostics = [];
                    const added = {};
                    const addProblem = (problem)=>{
                        // remove duplicated messages
                        const signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;
                        if (!added[signature]) {
                            added[signature] = true;
                            diagnostics.push(problem);
                        }
                    };
                    const getDiagnostics = (schema)=>{
                        var _documentSettings, _documentSettings1, _documentSettings2, _documentSettings3;
                        let trailingCommaSeverity = ((_documentSettings = documentSettings) === null || _documentSettings === void 0 ? void 0 : _documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : main.DiagnosticSeverity.Error;
                        let commentSeverity = ((_documentSettings1 = documentSettings) === null || _documentSettings1 === void 0 ? void 0 : _documentSettings1.comments) ? toDiagnosticSeverity(documentSettings.comments) : this.commentSeverity;
                        let schemaValidation = ((_documentSettings2 = documentSettings) === null || _documentSettings2 === void 0 ? void 0 : _documentSettings2.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : main.DiagnosticSeverity.Warning;
                        let schemaRequest = ((_documentSettings3 = documentSettings) === null || _documentSettings3 === void 0 ? void 0 : _documentSettings3.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : main.DiagnosticSeverity.Warning;
                        if (schema) {
                            const addSchemaProblem = (errorMessage, errorCode)=>{
                                if (jsonDocument.root && schemaRequest) {
                                    const astRoot = jsonDocument.root;
                                    const property = astRoot.type === 'object' ? astRoot.properties[0] : undefined;
                                    if (property && property.keyNode.value === '$schema') {
                                        const node = property.valueNode || property;
                                        const range = main.Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));
                                        addProblem(main.Diagnostic.create(range, errorMessage, schemaRequest, errorCode));
                                    } else {
                                        const range = main.Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));
                                        addProblem(main.Diagnostic.create(range, errorMessage, schemaRequest, errorCode));
                                    }
                                }
                            };
                            if (schema.errors.length) {
                                addSchemaProblem(schema.errors[0], ErrorCode.SchemaResolveError);
                            } else if (schemaValidation) {
                                var _documentSettings4;
                                for (const warning of schema.warnings){
                                    addSchemaProblem(warning, ErrorCode.SchemaUnsupportedFeature);
                                }
                                const semanticErrors = jsonDocument.validate(textDocument, schema.schema, schemaValidation, (_documentSettings4 = documentSettings) === null || _documentSettings4 === void 0 ? void 0 : _documentSettings4.schemaDraft);
                                if (semanticErrors) {
                                    semanticErrors.forEach(addProblem);
                                }
                            }
                            if (schemaAllowsComments(schema.schema)) {
                                commentSeverity = undefined;
                            }
                            if (schemaAllowsTrailingCommas(schema.schema)) {
                                trailingCommaSeverity = undefined;
                            }
                        }
                        for (const p of jsonDocument.syntaxErrors){
                            if (p.code === ErrorCode.TrailingComma) {
                                if (typeof trailingCommaSeverity !== 'number') {
                                    continue;
                                }
                                p.severity = trailingCommaSeverity;
                            }
                            addProblem(p);
                        }
                        if (typeof commentSeverity === 'number') {
                            const message = t('Comments are not permitted in JSON.');
                            jsonDocument.comments.forEach((c)=>{
                                addProblem(main.Diagnostic.create(c, message, commentSeverity, ErrorCode.CommentNotPermitted));
                            });
                        }
                        return diagnostics;
                    };
                    if (schema) {
                        const uri = schema.id || 'schemaservice://untitled/' + idCounter++;
                        const handle = this.jsonSchemaService.registerExternalSchema({
                            uri,
                            schema
                        });
                        return handle.getResolvedSchema().then((resolvedSchema)=>{
                            return getDiagnostics(resolvedSchema);
                        });
                    }
                    return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then((schema)=>{
                        return getDiagnostics(schema);
                    });
                }
                getLanguageStatus(textDocument, jsonDocument) {
                    return {
                        schemas: this.jsonSchemaService.getSchemaURIsForResource(textDocument.uri, jsonDocument)
                    };
                }
                constructor(jsonSchemaService, promiseConstructor){
                    this.jsonSchemaService = jsonSchemaService;
                    this.promise = promiseConstructor;
                    this.validationEnabled = true;
                }
            }
            let idCounter = 0;
            function schemaAllowsComments(schemaRef) {
                if (schemaRef && typeof schemaRef === 'object') {
                    if (isBoolean(schemaRef.allowComments)) {
                        return schemaRef.allowComments;
                    }
                    if (schemaRef.allOf) {
                        for (const schema of schemaRef.allOf){
                            const allow = schemaAllowsComments(schema);
                            if (isBoolean(allow)) {
                                return allow;
                            }
                        }
                    }
                }
                return undefined;
            }
            function schemaAllowsTrailingCommas(schemaRef) {
                if (schemaRef && typeof schemaRef === 'object') {
                    if (isBoolean(schemaRef.allowTrailingCommas)) {
                        return schemaRef.allowTrailingCommas;
                    }
                    const deprSchemaRef = schemaRef;
                    if (isBoolean(deprSchemaRef['allowsTrailingCommas'])) {
                        return deprSchemaRef['allowsTrailingCommas'];
                    }
                    if (schemaRef.allOf) {
                        for (const schema of schemaRef.allOf){
                            const allow = schemaAllowsTrailingCommas(schema);
                            if (isBoolean(allow)) {
                                return allow;
                            }
                        }
                    }
                }
                return undefined;
            }
            function toDiagnosticSeverity(severityLevel) {
                switch(severityLevel){
                    case 'error':
                        return main.DiagnosticSeverity.Error;
                    case 'warning':
                        return main.DiagnosticSeverity.Warning;
                    case 'ignore':
                        return undefined;
                }
                return undefined;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/colors.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const Digit0 = 48;
            const Digit9 = 57;
            const A = 65;
            const a = 97;
            const f = 102;
            function hexDigit(charCode) {
                if (charCode < Digit0) {
                    return 0;
                }
                if (charCode <= Digit9) {
                    return charCode - Digit0;
                }
                if (charCode < a) {
                    charCode += a - A;
                }
                if (charCode >= a && charCode <= f) {
                    return charCode - a + 10;
                }
                return 0;
            }
            function colorFromHex(text) {
                if (text[0] !== '#') {
                    return undefined;
                }
                switch(text.length){
                    case 4:
                        return {
                            red: hexDigit(text.charCodeAt(1)) * 0x11 / 255.0,
                            green: hexDigit(text.charCodeAt(2)) * 0x11 / 255.0,
                            blue: hexDigit(text.charCodeAt(3)) * 0x11 / 255.0,
                            alpha: 1
                        };
                    case 5:
                        return {
                            red: hexDigit(text.charCodeAt(1)) * 0x11 / 255.0,
                            green: hexDigit(text.charCodeAt(2)) * 0x11 / 255.0,
                            blue: hexDigit(text.charCodeAt(3)) * 0x11 / 255.0,
                            alpha: hexDigit(text.charCodeAt(4)) * 0x11 / 255.0
                        };
                    case 7:
                        return {
                            red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                            green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                            blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                            alpha: 1
                        };
                    case 9:
                        return {
                            red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                            green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                            blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                            alpha: (hexDigit(text.charCodeAt(7)) * 0x10 + hexDigit(text.charCodeAt(8))) / 255.0
                        };
                }
                return undefined;
            }
            function colorFrom256RGB(red, green, blue, alpha = 1.0) {
                return {
                    red: red / 255.0,
                    green: green / 255.0,
                    blue: blue / 255.0,
                    alpha
                };
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonDocumentSymbols.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONDocumentSymbols {
                findDocumentSymbols(document1, doc, context = {
                    resultLimit: Number.MAX_VALUE
                }) {
                    const root = doc.root;
                    if (!root) {
                        return [];
                    }
                    let limit = context.resultLimit || Number.MAX_VALUE;
                    // special handling for key bindings
                    const resourceString = document1.uri;
                    if (resourceString === 'vscode://defaultsettings/keybindings.json' || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
                        if (root.type === 'array') {
                            const result = [];
                            for (const item of root.items){
                                if (item.type === 'object') {
                                    for (const property of item.properties){
                                        if (property.keyNode.value === 'key' && property.valueNode) {
                                            const location = main.Location.create(document1.uri, getRange(document1, item));
                                            result.push({
                                                name: getName(property.valueNode),
                                                kind: main.SymbolKind.Function,
                                                location: location
                                            });
                                            limit--;
                                            if (limit <= 0) {
                                                if (context && context.onResultLimitExceeded) {
                                                    context.onResultLimitExceeded(resourceString);
                                                }
                                                return result;
                                            }
                                        }
                                    }
                                }
                            }
                            return result;
                        }
                    }
                    const toVisit = [
                        {
                            node: root,
                            containerName: ''
                        }
                    ];
                    let nextToVisit = 0;
                    let limitExceeded = false;
                    const result = [];
                    const collectOutlineEntries = (node, containerName)=>{
                        if (node.type === 'array') {
                            node.items.forEach((node)=>{
                                if (node) {
                                    toVisit.push({
                                        node,
                                        containerName
                                    });
                                }
                            });
                        } else if (node.type === 'object') {
                            node.properties.forEach((property)=>{
                                const valueNode = property.valueNode;
                                if (valueNode) {
                                    if (limit > 0) {
                                        limit--;
                                        const location = main.Location.create(document1.uri, getRange(document1, property));
                                        const childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;
                                        result.push({
                                            name: this.getKeyLabel(property),
                                            kind: this.getSymbolKind(valueNode.type),
                                            location: location,
                                            containerName: containerName
                                        });
                                        toVisit.push({
                                            node: valueNode,
                                            containerName: childContainerName
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        }
                    };
                    // breath first traversal
                    while(nextToVisit < toVisit.length){
                        const next = toVisit[nextToVisit++];
                        collectOutlineEntries(next.node, next.containerName);
                    }
                    if (limitExceeded && context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                    }
                    return result;
                }
                findDocumentSymbols2(document1, doc, context = {
                    resultLimit: Number.MAX_VALUE
                }) {
                    const root = doc.root;
                    if (!root) {
                        return [];
                    }
                    let limit = context.resultLimit || Number.MAX_VALUE;
                    // special handling for key bindings
                    const resourceString = document1.uri;
                    if (resourceString === 'vscode://defaultsettings/keybindings.json' || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
                        if (root.type === 'array') {
                            const result = [];
                            for (const item of root.items){
                                if (item.type === 'object') {
                                    for (const property of item.properties){
                                        if (property.keyNode.value === 'key' && property.valueNode) {
                                            const range = getRange(document1, item);
                                            const selectionRange = getRange(document1, property.keyNode);
                                            result.push({
                                                name: getName(property.valueNode),
                                                kind: main.SymbolKind.Function,
                                                range,
                                                selectionRange
                                            });
                                            limit--;
                                            if (limit <= 0) {
                                                if (context && context.onResultLimitExceeded) {
                                                    context.onResultLimitExceeded(resourceString);
                                                }
                                                return result;
                                            }
                                        }
                                    }
                                }
                            }
                            return result;
                        }
                    }
                    const result = [];
                    const toVisit = [
                        {
                            node: root,
                            result
                        }
                    ];
                    let nextToVisit = 0;
                    let limitExceeded = false;
                    const collectOutlineEntries = (node, result)=>{
                        if (node.type === 'array') {
                            node.items.forEach((node, index)=>{
                                if (node) {
                                    if (limit > 0) {
                                        limit--;
                                        const range = getRange(document1, node);
                                        const selectionRange = range;
                                        const name = String(index);
                                        const symbol = {
                                            name,
                                            kind: this.getSymbolKind(node.type),
                                            range,
                                            selectionRange,
                                            children: []
                                        };
                                        result.push(symbol);
                                        toVisit.push({
                                            result: symbol.children,
                                            node
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        } else if (node.type === 'object') {
                            node.properties.forEach((property)=>{
                                const valueNode = property.valueNode;
                                if (valueNode) {
                                    if (limit > 0) {
                                        limit--;
                                        const range = getRange(document1, property);
                                        const selectionRange = getRange(document1, property.keyNode);
                                        const children = [];
                                        const symbol = {
                                            name: this.getKeyLabel(property),
                                            kind: this.getSymbolKind(valueNode.type),
                                            range,
                                            selectionRange,
                                            children,
                                            detail: this.getDetail(valueNode)
                                        };
                                        result.push(symbol);
                                        toVisit.push({
                                            result: children,
                                            node: valueNode
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        }
                    };
                    // breath first traversal
                    while(nextToVisit < toVisit.length){
                        const next = toVisit[nextToVisit++];
                        collectOutlineEntries(next.node, next.result);
                    }
                    if (limitExceeded && context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                    }
                    return result;
                }
                getSymbolKind(nodeType) {
                    switch(nodeType){
                        case 'object':
                            return main.SymbolKind.Module;
                        case 'string':
                            return main.SymbolKind.String;
                        case 'number':
                            return main.SymbolKind.Number;
                        case 'array':
                            return main.SymbolKind.Array;
                        case 'boolean':
                            return main.SymbolKind.Boolean;
                        default:
                            return main.SymbolKind.Variable;
                    }
                }
                getKeyLabel(property) {
                    let name = property.keyNode.value;
                    if (name) {
                        name = name.replace(/[\n]/g, '');
                    }
                    if (name && name.trim()) {
                        return name;
                    }
                    return `"${name}"`;
                }
                getDetail(node) {
                    if (!node) {
                        return undefined;
                    }
                    if (node.type === 'boolean' || node.type === 'number' || node.type === 'null' || node.type === 'string') {
                        return String(node.value);
                    } else {
                        if (node.type === 'array') {
                            return node.children.length ? undefined : '[]';
                        } else if (node.type === 'object') {
                            return node.children.length ? undefined : '{}';
                        }
                    }
                    return undefined;
                }
                findDocumentColors(document1, doc, context) {
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        const result = [];
                        if (schema) {
                            let limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;
                            const matchingSchemas = doc.getMatchingSchemas(schema.schema);
                            const visitedNode = {};
                            for (const s of matchingSchemas){
                                if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {
                                    const nodeId = String(s.node.offset);
                                    if (!visitedNode[nodeId]) {
                                        const color = colorFromHex(jsonParser_getNodeValue(s.node));
                                        if (color) {
                                            const range = getRange(document1, s.node);
                                            result.push({
                                                color,
                                                range
                                            });
                                        }
                                        visitedNode[nodeId] = true;
                                        limit--;
                                        if (limit <= 0) {
                                            if (context && context.onResultLimitExceeded) {
                                                context.onResultLimitExceeded(document1.uri);
                                            }
                                            return result;
                                        }
                                    }
                                }
                            }
                        }
                        return result;
                    });
                }
                getColorPresentations(document1, doc, color, range) {
                    const result = [];
                    const red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
                    function toTwoDigitHex(n) {
                        const r = n.toString(16);
                        return r.length !== 2 ? '0' + r : r;
                    }
                    let label;
                    if (color.alpha === 1) {
                        label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}`;
                    } else {
                        label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}${toTwoDigitHex(Math.round(color.alpha * 255))}`;
                    }
                    result.push({
                        label: label,
                        textEdit: main.TextEdit.replace(range, JSON.stringify(label))
                    });
                    return result;
                }
                constructor(schemaService){
                    this.schemaService = schemaService;
                }
            }
            function getRange(document1, node) {
                return main.Range.create(document1.positionAt(node.offset), document1.positionAt(node.offset + node.length));
            }
            function getName(node) {
                return jsonParser_getNodeValue(node) || t('<empty>');
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/configuration.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const schemaContributions = {
                schemaAssociations: [],
                schemas: {
                    // refer to the latest schema
                    'http://json-schema.org/schema#': {
                        $ref: 'http://json-schema.org/draft-07/schema#'
                    },
                    // bundle the schema-schema to include (localized) descriptions
                    'http://json-schema.org/draft-04/schema#': {
                        '$schema': 'http://json-schema.org/draft-04/schema#',
                        'definitions': {
                            'schemaArray': {
                                'type': 'array',
                                'minItems': 1,
                                'items': {
                                    '$ref': '#'
                                }
                            },
                            'positiveInteger': {
                                'type': 'integer',
                                'minimum': 0
                            },
                            'positiveIntegerDefault0': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    },
                                    {
                                        'default': 0
                                    }
                                ]
                            },
                            'simpleTypes': {
                                'type': 'string',
                                'enum': [
                                    'array',
                                    'boolean',
                                    'integer',
                                    'null',
                                    'number',
                                    'object',
                                    'string'
                                ]
                            },
                            'stringArray': {
                                'type': 'array',
                                'items': {
                                    'type': 'string'
                                },
                                'minItems': 1,
                                'uniqueItems': true
                            }
                        },
                        'type': 'object',
                        'properties': {
                            'id': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            '$schema': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            'title': {
                                'type': 'string'
                            },
                            'description': {
                                'type': 'string'
                            },
                            'default': {},
                            'multipleOf': {
                                'type': 'number',
                                'minimum': 0,
                                'exclusiveMinimum': true
                            },
                            'maximum': {
                                'type': 'number'
                            },
                            'exclusiveMaximum': {
                                'type': 'boolean',
                                'default': false
                            },
                            'minimum': {
                                'type': 'number'
                            },
                            'exclusiveMinimum': {
                                'type': 'boolean',
                                'default': false
                            },
                            'maxLength': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minLength': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'pattern': {
                                'type': 'string',
                                'format': 'regex'
                            },
                            'additionalItems': {
                                'anyOf': [
                                    {
                                        'type': 'boolean'
                                    },
                                    {
                                        '$ref': '#'
                                    }
                                ],
                                'default': {}
                            },
                            'items': {
                                'anyOf': [
                                    {
                                        '$ref': '#'
                                    },
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ],
                                'default': {}
                            },
                            'maxItems': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minItems': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'uniqueItems': {
                                'type': 'boolean',
                                'default': false
                            },
                            'maxProperties': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minProperties': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'required': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/stringArray'
                                    }
                                ]
                            },
                            'additionalProperties': {
                                'anyOf': [
                                    {
                                        'type': 'boolean'
                                    },
                                    {
                                        '$ref': '#'
                                    }
                                ],
                                'default': {}
                            },
                            'definitions': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'properties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'patternProperties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'dependencies': {
                                'type': 'object',
                                'additionalProperties': {
                                    'anyOf': [
                                        {
                                            '$ref': '#'
                                        },
                                        {
                                            '$ref': '#/definitions/stringArray'
                                        }
                                    ]
                                }
                            },
                            'enum': {
                                'type': 'array',
                                'minItems': 1,
                                'uniqueItems': true
                            },
                            'type': {
                                'anyOf': [
                                    {
                                        '$ref': '#/definitions/simpleTypes'
                                    },
                                    {
                                        'type': 'array',
                                        'items': {
                                            '$ref': '#/definitions/simpleTypes'
                                        },
                                        'minItems': 1,
                                        'uniqueItems': true
                                    }
                                ]
                            },
                            'format': {
                                'anyOf': [
                                    {
                                        'type': 'string',
                                        'enum': [
                                            'date-time',
                                            'uri',
                                            'email',
                                            'hostname',
                                            'ipv4',
                                            'ipv6',
                                            'regex'
                                        ]
                                    },
                                    {
                                        'type': 'string'
                                    }
                                ]
                            },
                            'allOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'anyOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'oneOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'not': {
                                'allOf': [
                                    {
                                        '$ref': '#'
                                    }
                                ]
                            }
                        },
                        'dependencies': {
                            'exclusiveMaximum': [
                                'maximum'
                            ],
                            'exclusiveMinimum': [
                                'minimum'
                            ]
                        },
                        'default': {}
                    },
                    'http://json-schema.org/draft-07/schema#': {
                        'definitions': {
                            'schemaArray': {
                                'type': 'array',
                                'minItems': 1,
                                'items': {
                                    '$ref': '#'
                                }
                            },
                            'nonNegativeInteger': {
                                'type': 'integer',
                                'minimum': 0
                            },
                            'nonNegativeIntegerDefault0': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/nonNegativeInteger'
                                    },
                                    {
                                        'default': 0
                                    }
                                ]
                            },
                            'simpleTypes': {
                                'enum': [
                                    'array',
                                    'boolean',
                                    'integer',
                                    'null',
                                    'number',
                                    'object',
                                    'string'
                                ]
                            },
                            'stringArray': {
                                'type': 'array',
                                'items': {
                                    'type': 'string'
                                },
                                'uniqueItems': true,
                                'default': []
                            }
                        },
                        'type': [
                            'object',
                            'boolean'
                        ],
                        'properties': {
                            '$id': {
                                'type': 'string',
                                'format': 'uri-reference'
                            },
                            '$schema': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            '$ref': {
                                'type': 'string',
                                'format': 'uri-reference'
                            },
                            '$comment': {
                                'type': 'string'
                            },
                            'title': {
                                'type': 'string'
                            },
                            'description': {
                                'type': 'string'
                            },
                            'default': true,
                            'readOnly': {
                                'type': 'boolean',
                                'default': false
                            },
                            'examples': {
                                'type': 'array',
                                'items': true
                            },
                            'multipleOf': {
                                'type': 'number',
                                'exclusiveMinimum': 0
                            },
                            'maximum': {
                                'type': 'number'
                            },
                            'exclusiveMaximum': {
                                'type': 'number'
                            },
                            'minimum': {
                                'type': 'number'
                            },
                            'exclusiveMinimum': {
                                'type': 'number'
                            },
                            'maxLength': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minLength': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'pattern': {
                                'type': 'string',
                                'format': 'regex'
                            },
                            'additionalItems': {
                                '$ref': '#'
                            },
                            'items': {
                                'anyOf': [
                                    {
                                        '$ref': '#'
                                    },
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ],
                                'default': true
                            },
                            'maxItems': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minItems': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'uniqueItems': {
                                'type': 'boolean',
                                'default': false
                            },
                            'contains': {
                                '$ref': '#'
                            },
                            'maxProperties': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minProperties': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'required': {
                                '$ref': '#/definitions/stringArray'
                            },
                            'additionalProperties': {
                                '$ref': '#'
                            },
                            'definitions': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'properties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'patternProperties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'propertyNames': {
                                    'format': 'regex'
                                },
                                'default': {}
                            },
                            'dependencies': {
                                'type': 'object',
                                'additionalProperties': {
                                    'anyOf': [
                                        {
                                            '$ref': '#'
                                        },
                                        {
                                            '$ref': '#/definitions/stringArray'
                                        }
                                    ]
                                }
                            },
                            'propertyNames': {
                                '$ref': '#'
                            },
                            'const': true,
                            'enum': {
                                'type': 'array',
                                'items': true,
                                'minItems': 1,
                                'uniqueItems': true
                            },
                            'type': {
                                'anyOf': [
                                    {
                                        '$ref': '#/definitions/simpleTypes'
                                    },
                                    {
                                        'type': 'array',
                                        'items': {
                                            '$ref': '#/definitions/simpleTypes'
                                        },
                                        'minItems': 1,
                                        'uniqueItems': true
                                    }
                                ]
                            },
                            'format': {
                                'type': 'string'
                            },
                            'contentMediaType': {
                                'type': 'string'
                            },
                            'contentEncoding': {
                                'type': 'string'
                            },
                            'if': {
                                '$ref': '#'
                            },
                            'then': {
                                '$ref': '#'
                            },
                            'else': {
                                '$ref': '#'
                            },
                            'allOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'anyOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'oneOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'not': {
                                '$ref': '#'
                            }
                        },
                        'default': true
                    }
                }
            };
            const descriptions = {
                id: t("A unique identifier for the schema."),
                $schema: t("The schema to verify this document against."),
                title: t("A descriptive title of the element."),
                description: t("A long description of the element. Used in hover menus and suggestions."),
                default: t("A default value. Used by suggestions."),
                multipleOf: t("A number that should cleanly divide the current value (i.e. have no remainder)."),
                maximum: t("The maximum numerical value, inclusive by default."),
                exclusiveMaximum: t("Makes the maximum property exclusive."),
                minimum: t("The minimum numerical value, inclusive by default."),
                exclusiveMinimum: t("Makes the minimum property exclusive."),
                maxLength: t("The maximum length of a string."),
                minLength: t("The minimum length of a string."),
                pattern: t("A regular expression to match the string against. It is not implicitly anchored."),
                additionalItems: t("For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail."),
                items: t("For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on."),
                maxItems: t("The maximum number of items that can be inside an array. Inclusive."),
                minItems: t("The minimum number of items that can be inside an array. Inclusive."),
                uniqueItems: t("If all of the items in the array must be unique. Defaults to false."),
                maxProperties: t("The maximum number of properties an object can have. Inclusive."),
                minProperties: t("The minimum number of properties an object can have. Inclusive."),
                required: t("An array of strings that lists the names of all properties required on this object."),
                additionalProperties: t("Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail."),
                definitions: t("Not used for validation. Place subschemas here that you wish to reference inline with $ref."),
                properties: t("A map of property names to schemas for each property."),
                patternProperties: t("A map of regular expressions on property names to schemas for matching properties."),
                dependencies: t("A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object."),
                enum: t("The set of literal values that are valid."),
                type: t("Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types."),
                format: t("Describes the format expected for the value."),
                allOf: t("An array of schemas, all of which must match."),
                anyOf: t("An array of schemas, where at least one must match."),
                oneOf: t("An array of schemas, exactly one of which must match."),
                not: t("A schema which must not match."),
                $id: t("A unique identifier for the schema."),
                $ref: t("Reference a definition hosted on any location."),
                $comment: t("Comments from schema authors to readers or maintainers of the schema."),
                readOnly: t("Indicates that the value of the instance is managed exclusively by the owning authority."),
                examples: t("Sample JSON values associated with a particular schema, for the purpose of illustrating usage."),
                contains: t("An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema."),
                propertyNames: t("If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema."),
                const: t("An instance validates successfully against this keyword if its value is equal to the value of the keyword."),
                contentMediaType: t("Describes the media type of a string property."),
                contentEncoding: t("Describes the content encoding of a string property."),
                if: t("The validation outcome of the \"if\" subschema controls which of the \"then\" or \"else\" keywords are evaluated."),
                then: t("The \"if\" subschema is used for validation when the \"if\" subschema succeeds."),
                else: t("The \"else\" subschema is used for validation when the \"if\" subschema fails.")
            };
            for(const schemaName in schemaContributions.schemas){
                const schema = schemaContributions.schemas[schemaName];
                for(const property in schema.properties){
                    let propertyObject = schema.properties[property];
                    if (typeof propertyObject === 'boolean') {
                        propertyObject = schema.properties[property] = {};
                    }
                    const description = descriptions[property];
                    if (description) {
                        propertyObject['description'] = description;
                    }
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-uri/lib/esm/index.js
            /* provided dependency */ var process = __nested_webpack_require_701415__(4406);
            var LIB;
            (()=>{
                "use strict";
                var t = {
                    470: (t)=>{
                        function e(t) {
                            if ("string" != typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
                        }
                        function r(t, e) {
                            for(var r, n = "", o = 0, i = -1, a = 0, h = 0; h <= t.length; ++h){
                                if (h < t.length) r = t.charCodeAt(h);
                                else {
                                    if (47 === r) break;
                                    r = 47;
                                }
                                if (47 === r) {
                                    if (i === h - 1 || 1 === a) ;
                                    else if (i !== h - 1 && 2 === a) {
                                        if (n.length < 2 || 2 !== o || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2)) {
                                            if (n.length > 2) {
                                                var s = n.lastIndexOf("/");
                                                if (s !== n.length - 1) {
                                                    -1 === s ? (n = "", o = 0) : o = (n = n.slice(0, s)).length - 1 - n.lastIndexOf("/"), i = h, a = 0;
                                                    continue;
                                                }
                                            } else if (2 === n.length || 1 === n.length) {
                                                n = "", o = 0, i = h, a = 0;
                                                continue;
                                            }
                                        }
                                        e && (n.length > 0 ? n += "/.." : n = "..", o = 2);
                                    } else n.length > 0 ? n += "/" + t.slice(i + 1, h) : n = t.slice(i + 1, h), o = h - i - 1;
                                    i = h, a = 0;
                                } else 46 === r && -1 !== a ? ++a : a = -1;
                            }
                            return n;
                        }
                        var n = {
                            resolve: function() {
                                for(var t, n = "", o = !1, i = arguments.length - 1; i >= -1 && !o; i--){
                                    var a;
                                    i >= 0 ? a = arguments[i] : (void 0 === t && (t = process.cwd()), a = t), e(a), 0 !== a.length && (n = a + "/" + n, o = 47 === a.charCodeAt(0));
                                }
                                return n = r(n, !o), o ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
                            },
                            normalize: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                var n = 47 === t.charCodeAt(0), o = 47 === t.charCodeAt(t.length - 1);
                                return 0 !== (t = r(t, !n)).length || n || (t = "."), t.length > 0 && o && (t += "/"), n ? "/" + t : t;
                            },
                            isAbsolute: function(t) {
                                return e(t), t.length > 0 && 47 === t.charCodeAt(0);
                            },
                            join: function() {
                                if (0 === arguments.length) return ".";
                                for(var t, r = 0; r < arguments.length; ++r){
                                    var o = arguments[r];
                                    e(o), o.length > 0 && (void 0 === t ? t = o : t += "/" + o);
                                }
                                return void 0 === t ? "." : n.normalize(t);
                            },
                            relative: function(t, r) {
                                if (e(t), e(r), t === r) return "";
                                if ((t = n.resolve(t)) === (r = n.resolve(r))) return "";
                                for(var o = 1; o < t.length && 47 === t.charCodeAt(o); ++o);
                                for(var i = t.length, a = i - o, h = 1; h < r.length && 47 === r.charCodeAt(h); ++h);
                                for(var s = r.length - h, c = a < s ? a : s, f = -1, u = 0; u <= c; ++u){
                                    if (u === c) {
                                        if (s > c) {
                                            if (47 === r.charCodeAt(h + u)) return r.slice(h + u + 1);
                                            if (0 === u) return r.slice(h + u);
                                        } else a > c && (47 === t.charCodeAt(o + u) ? f = u : 0 === u && (f = 0));
                                        break;
                                    }
                                    var l = t.charCodeAt(o + u);
                                    if (l !== r.charCodeAt(h + u)) break;
                                    47 === l && (f = u);
                                }
                                var p = "";
                                for(u = o + f + 1; u <= i; ++u)u !== i && 47 !== t.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
                                return p.length > 0 ? p + r.slice(h + f) : (h += f, 47 === r.charCodeAt(h) && ++h, r.slice(h));
                            },
                            _makeLong: function(t) {
                                return t;
                            },
                            dirname: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                for(var r = t.charCodeAt(0), n = 47 === r, o = -1, i = !0, a = t.length - 1; a >= 1; --a)if (47 === (r = t.charCodeAt(a))) {
                                    if (!i) {
                                        o = a;
                                        break;
                                    }
                                } else i = !1;
                                return -1 === o ? n ? "/" : "." : n && 1 === o ? "//" : t.slice(0, o);
                            },
                            basename: function(t, r) {
                                if (void 0 !== r && "string" != typeof r) throw new TypeError('"ext" argument must be a string');
                                e(t);
                                var n, o = 0, i = -1, a = !0;
                                if (void 0 !== r && r.length > 0 && r.length <= t.length) {
                                    if (r.length === t.length && r === t) return "";
                                    var h = r.length - 1, s = -1;
                                    for(n = t.length - 1; n >= 0; --n){
                                        var c = t.charCodeAt(n);
                                        if (47 === c) {
                                            if (!a) {
                                                o = n + 1;
                                                break;
                                            }
                                        } else -1 === s && (a = !1, s = n + 1), h >= 0 && (c === r.charCodeAt(h) ? -1 == --h && (i = n) : (h = -1, i = s));
                                    }
                                    return o === i ? i = s : -1 === i && (i = t.length), t.slice(o, i);
                                }
                                for(n = t.length - 1; n >= 0; --n)if (47 === t.charCodeAt(n)) {
                                    if (!a) {
                                        o = n + 1;
                                        break;
                                    }
                                } else -1 === i && (a = !1, i = n + 1);
                                return -1 === i ? "" : t.slice(o, i);
                            },
                            extname: function(t) {
                                e(t);
                                for(var r = -1, n = 0, o = -1, i = !0, a = 0, h = t.length - 1; h >= 0; --h){
                                    var s = t.charCodeAt(h);
                                    if (47 !== s) -1 === o && (i = !1, o = h + 1), 46 === s ? -1 === r ? r = h : 1 !== a && (a = 1) : -1 !== r && (a = -1);
                                    else if (!i) {
                                        n = h + 1;
                                        break;
                                    }
                                }
                                return -1 === r || -1 === o || 0 === a || 1 === a && r === o - 1 && r === n + 1 ? "" : t.slice(r, o);
                            },
                            format: function(t) {
                                if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
                                return function(t, e) {
                                    var r = e.dir || e.root, n = e.base || (e.name || "") + (e.ext || "");
                                    return r ? r === e.root ? r + n : r + "/" + n : n;
                                }(0, t);
                            },
                            parse: function(t) {
                                e(t);
                                var r = {
                                    root: "",
                                    dir: "",
                                    base: "",
                                    ext: "",
                                    name: ""
                                };
                                if (0 === t.length) return r;
                                var n, o = t.charCodeAt(0), i = 47 === o;
                                i ? (r.root = "/", n = 1) : n = 0;
                                for(var a = -1, h = 0, s = -1, c = !0, f = t.length - 1, u = 0; f >= n; --f)if (47 !== (o = t.charCodeAt(f))) -1 === s && (c = !1, s = f + 1), 46 === o ? -1 === a ? a = f : 1 !== u && (u = 1) : -1 !== a && (u = -1);
                                else if (!c) {
                                    h = f + 1;
                                    break;
                                }
                                return -1 === a || -1 === s || 0 === u || 1 === u && a === s - 1 && a === h + 1 ? -1 !== s && (r.base = r.name = 0 === h && i ? t.slice(1, s) : t.slice(h, s)) : (0 === h && i ? (r.name = t.slice(1, a), r.base = t.slice(1, s)) : (r.name = t.slice(h, a), r.base = t.slice(h, s)), r.ext = t.slice(a, s)), h > 0 ? r.dir = t.slice(0, h - 1) : i && (r.dir = "/"), r;
                            },
                            sep: "/",
                            delimiter: ":",
                            win32: null,
                            posix: null
                        };
                        n.posix = n, t.exports = n;
                    }
                }, e = {};
                function r(n) {
                    var o = e[n];
                    if (void 0 !== o) return o.exports;
                    var i = e[n] = {
                        exports: {}
                    };
                    return t[n](i, i.exports, r), i.exports;
                }
                r.d = (t, e)=>{
                    for(var n in e)r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                        enumerable: !0,
                        get: e[n]
                    });
                }, r.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), r.r = (t)=>{
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                };
                var n = {};
                (()=>{
                    var t;
                    if (r.r(n), r.d(n, {
                        URI: ()=>g,
                        Utils: ()=>O
                    }), "object" == typeof process) t = "win32" === process.platform;
                    else if ("object" == typeof navigator) {
                        var e = navigator.userAgent;
                        t = e.indexOf("Windows") >= 0;
                    }
                    var o, i, a = (o = function(t, e) {
                        return o = Object.setPrototypeOf || ({
                            __proto__: []
                        }) instanceof Array && function(t, e) {
                            t.__proto__ = e;
                        } || function(t, e) {
                            for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                        }, o(t, e);
                    }, function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
                        function r() {
                            this.constructor = t;
                        }
                        o(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r);
                    }), h = /^\w[\w\d+.-]*$/, s = /^\//, c = /^\/\//;
                    function f(t, e) {
                        if (!t.scheme && e) throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t.authority, '", path: "').concat(t.path, '", query: "').concat(t.query, '", fragment: "').concat(t.fragment, '"}'));
                        if (t.scheme && !h.test(t.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                        if (t.path) {
                            if (t.authority) {
                                if (!s.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                            } else if (c.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                        }
                    }
                    var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, g = function() {
                        function e(t, e, r, n, o, i) {
                            void 0 === i && (i = !1), "object" == typeof t ? (this.scheme = t.scheme || u, this.authority = t.authority || u, this.path = t.path || u, this.query = t.query || u, this.fragment = t.fragment || u) : (this.scheme = function(t, e) {
                                return t || e ? t : "file";
                            }(t, i), this.authority = e || u, this.path = function(t, e) {
                                switch(t){
                                    case "https":
                                    case "http":
                                    case "file":
                                        e ? e[0] !== l && (e = l + e) : e = l;
                                }
                                return e;
                            }(this.scheme, r || u), this.query = n || u, this.fragment = o || u, f(this, i));
                        }
                        return e.isUri = function(t) {
                            return t instanceof e || !!t && "string" == typeof t.authority && "string" == typeof t.fragment && "string" == typeof t.path && "string" == typeof t.query && "string" == typeof t.scheme && "string" == typeof t.fsPath && "function" == typeof t.with && "function" == typeof t.toString;
                        }, Object.defineProperty(e.prototype, "fsPath", {
                            get: function() {
                                return C(this, !1);
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.with = function(t) {
                            if (!t) return this;
                            var e = t.scheme, r = t.authority, n = t.path, o = t.query, i = t.fragment;
                            return void 0 === e ? e = this.scheme : null === e && (e = u), void 0 === r ? r = this.authority : null === r && (r = u), void 0 === n ? n = this.path : null === n && (n = u), void 0 === o ? o = this.query : null === o && (o = u), void 0 === i ? i = this.fragment : null === i && (i = u), e === this.scheme && r === this.authority && n === this.path && o === this.query && i === this.fragment ? this : new v(e, r, n, o, i);
                        }, e.parse = function(t, e) {
                            void 0 === e && (e = !1);
                            var r = p.exec(t);
                            return r ? new v(r[2] || u, _(r[4] || u), _(r[5] || u), _(r[7] || u), _(r[9] || u), e) : new v(u, u, u, u, u);
                        }, e.file = function(e) {
                            var r = u;
                            if (t && (e = e.replace(/\\/g, l)), e[0] === l && e[1] === l) {
                                var n = e.indexOf(l, 2);
                                -1 === n ? (r = e.substring(2), e = l) : (r = e.substring(2, n), e = e.substring(n) || l);
                            }
                            return new v("file", r, e, u, u);
                        }, e.from = function(t) {
                            var e = new v(t.scheme, t.authority, t.path, t.query, t.fragment);
                            return f(e, !0), e;
                        }, e.prototype.toString = function(t) {
                            return void 0 === t && (t = !1), A(this, t);
                        }, e.prototype.toJSON = function() {
                            return this;
                        }, e.revive = function(t) {
                            if (t) {
                                if (t instanceof e) return t;
                                var r = new v(t);
                                return r._formatted = t.external, r._fsPath = t._sep === d ? t.fsPath : null, r;
                            }
                            return t;
                        }, e;
                    }(), d = t ? 1 : void 0, v = function(t) {
                        function e() {
                            var e = null !== t && t.apply(this, arguments) || this;
                            return e._formatted = null, e._fsPath = null, e;
                        }
                        return a(e, t), Object.defineProperty(e.prototype, "fsPath", {
                            get: function() {
                                return this._fsPath || (this._fsPath = C(this, !1)), this._fsPath;
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.toString = function(t) {
                            return void 0 === t && (t = !1), t ? A(this, !0) : (this._formatted || (this._formatted = A(this, !1)), this._formatted);
                        }, e.prototype.toJSON = function() {
                            var t = {
                                $mid: 1
                            };
                            return this._fsPath && (t.fsPath = this._fsPath, t._sep = d), this._formatted && (t.external = this._formatted), this.path && (t.path = this.path), this.scheme && (t.scheme = this.scheme), this.authority && (t.authority = this.authority), this.query && (t.query = this.query), this.fragment && (t.fragment = this.fragment), t;
                        }, e;
                    }(g), y = ((i = {})[58] = "%3A", i[47] = "%2F", i[63] = "%3F", i[35] = "%23", i[91] = "%5B", i[93] = "%5D", i[64] = "%40", i[33] = "%21", i[36] = "%24", i[38] = "%26", i[39] = "%27", i[40] = "%28", i[41] = "%29", i[42] = "%2A", i[43] = "%2B", i[44] = "%2C", i[59] = "%3B", i[61] = "%3D", i[32] = "%20", i);
                    function m(t, e, r) {
                        for(var n = void 0, o = -1, i = 0; i < t.length; i++){
                            var a = t.charCodeAt(i);
                            if (a >= 97 && a <= 122 || a >= 65 && a <= 90 || a >= 48 && a <= 57 || 45 === a || 46 === a || 95 === a || 126 === a || e && 47 === a || r && 91 === a || r && 93 === a || r && 58 === a) -1 !== o && (n += encodeURIComponent(t.substring(o, i)), o = -1), void 0 !== n && (n += t.charAt(i));
                            else {
                                void 0 === n && (n = t.substr(0, i));
                                var h = y[a];
                                void 0 !== h ? (-1 !== o && (n += encodeURIComponent(t.substring(o, i)), o = -1), n += h) : -1 === o && (o = i);
                            }
                        }
                        return -1 !== o && (n += encodeURIComponent(t.substring(o))), void 0 !== n ? n : t;
                    }
                    function b(t) {
                        for(var e = void 0, r = 0; r < t.length; r++){
                            var n = t.charCodeAt(r);
                            35 === n || 63 === n ? (void 0 === e && (e = t.substr(0, r)), e += y[n]) : void 0 !== e && (e += t[r]);
                        }
                        return void 0 !== e ? e : t;
                    }
                    function C(e, r) {
                        var n;
                        return n = e.authority && e.path.length > 1 && "file" === e.scheme ? "//".concat(e.authority).concat(e.path) : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? r ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, t && (n = n.replace(/\//g, "\\")), n;
                    }
                    function A(t, e) {
                        var r = e ? b : m, n = "", o = t.scheme, i = t.authority, a = t.path, h = t.query, s = t.fragment;
                        if (o && (n += o, n += ":"), (i || "file" === o) && (n += l, n += l), i) {
                            var c = i.indexOf("@");
                            if (-1 !== c) {
                                var f = i.substr(0, c);
                                i = i.substr(c + 1), -1 === (c = f.lastIndexOf(":")) ? n += r(f, !1, !1) : (n += r(f.substr(0, c), !1, !1), n += ":", n += r(f.substr(c + 1), !1, !0)), n += "@";
                            }
                            -1 === (c = (i = i.toLowerCase()).lastIndexOf(":")) ? n += r(i, !1, !0) : (n += r(i.substr(0, c), !1, !0), n += i.substr(c));
                        }
                        if (a) {
                            if (a.length >= 3 && 47 === a.charCodeAt(0) && 58 === a.charCodeAt(2)) (u = a.charCodeAt(1)) >= 65 && u <= 90 && (a = "/".concat(String.fromCharCode(u + 32), ":").concat(a.substr(3)));
                            else if (a.length >= 2 && 58 === a.charCodeAt(1)) {
                                var u;
                                (u = a.charCodeAt(0)) >= 65 && u <= 90 && (a = "".concat(String.fromCharCode(u + 32), ":").concat(a.substr(2)));
                            }
                            n += r(a, !0, !1);
                        }
                        return h && (n += "?", n += r(h, !1, !1)), s && (n += "#", n += e ? s : m(s, !1, !1)), n;
                    }
                    function w(t) {
                        try {
                            return decodeURIComponent(t);
                        } catch (e) {
                            return t.length > 3 ? t.substr(0, 3) + w(t.substr(3)) : t;
                        }
                    }
                    var x = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
                    function _(t) {
                        return t.match(x) ? t.replace(x, function(t) {
                            return w(t);
                        }) : t;
                    }
                    var O, P = r(470), j = function(t, e, r) {
                        if (r || 2 === arguments.length) for(var n, o = 0, i = e.length; o < i; o++)!n && o in e || (n || (n = Array.prototype.slice.call(e, 0, o)), n[o] = e[o]);
                        return t.concat(n || Array.prototype.slice.call(e));
                    }, I = P.posix || P, U = "/";
                    !function(t) {
                        t.joinPath = function(t) {
                            for(var e = [], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];
                            return t.with({
                                path: I.join.apply(I, j([
                                    t.path
                                ], e, !1))
                            });
                        }, t.resolvePath = function(t) {
                            for(var e = [], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];
                            var n = t.path, o = !1;
                            n[0] !== U && (n = U + n, o = !0);
                            var i = I.resolve.apply(I, j([
                                n
                            ], e, !1));
                            return o && i[0] === U && !t.authority && (i = i.substring(1)), t.with({
                                path: i
                            });
                        }, t.dirname = function(t) {
                            if (0 === t.path.length || t.path === U) return t;
                            var e = I.dirname(t.path);
                            return 1 === e.length && 46 === e.charCodeAt(0) && (e = ""), t.with({
                                path: e
                            });
                        }, t.basename = function(t) {
                            return I.basename(t.path);
                        }, t.extname = function(t) {
                            return I.extname(t.path);
                        };
                    }(O || (O = {}));
                })(), LIB = n;
            })();
            const { URI, Utils } = LIB;
            //# sourceMappingURL=index.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/glob.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Copyright (c) 2013, Nick Fitzgerald
 *  Licensed under the MIT License. See LICENCE.md in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function createRegex(glob, opts) {
                if (typeof glob !== 'string') {
                    throw new TypeError('Expected a string');
                }
                const str = String(glob);
                // The regexp we are building, as a string.
                let reStr = "";
                // Whether we are matching so called "extended" globs (like bash) and should
                // support single character matching, matching ranges of characters, group
                // matching, etc.
                const extended = opts ? !!opts.extended : false;
                // When globstar is _false_ (default), '/foo/*' is translated a regexp like
                // '^\/foo\/.*$' which will match any string beginning with '/foo/'
                // When globstar is _true_, '/foo/*' is translated to regexp like
                // '^\/foo\/[^/]*$' which will match any string beginning with '/foo/' BUT
                // which does not have a '/' to the right of it.
                // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but
                // these will not '/foo/bar/baz', '/foo/bar/baz.txt'
                // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when
                // globstar is _false_
                const globstar = opts ? !!opts.globstar : false;
                // If we are doing extended matching, this boolean is true when we are inside
                // a group (eg {*.html,*.js}), and false otherwise.
                let inGroup = false;
                // RegExp flags (eg "i" ) to pass in to RegExp constructor.
                const flags = opts && typeof opts.flags === "string" ? opts.flags : "";
                let c;
                for(let i = 0, len = str.length; i < len; i++){
                    c = str[i];
                    switch(c){
                        case "/":
                        case "$":
                        case "^":
                        case "+":
                        case ".":
                        case "(":
                        case ")":
                        case "=":
                        case "!":
                        case "|":
                            reStr += "\\" + c;
                            break;
                        case "?":
                            if (extended) {
                                reStr += ".";
                                break;
                            }
                        case "[":
                        case "]":
                            if (extended) {
                                reStr += c;
                                break;
                            }
                        case "{":
                            if (extended) {
                                inGroup = true;
                                reStr += "(";
                                break;
                            }
                        case "}":
                            if (extended) {
                                inGroup = false;
                                reStr += ")";
                                break;
                            }
                        case ",":
                            if (inGroup) {
                                reStr += "|";
                                break;
                            }
                            reStr += "\\" + c;
                            break;
                        case "*":
                            // Move over all consecutive "*"'s.
                            // Also store the previous and next characters
                            const prevChar = str[i - 1];
                            let starCount = 1;
                            while(str[i + 1] === "*"){
                                starCount++;
                                i++;
                            }
                            const nextChar = str[i + 1];
                            if (!globstar) {
                                // globstar is disabled, so treat any number of "*" as one
                                reStr += ".*";
                            } else {
                                // globstar is enabled, so determine if this is a globstar segment
                                const isGlobstar = starCount > 1 // multiple "*"'s
                                 && (prevChar === "/" || prevChar === undefined || prevChar === '{' || prevChar === ',' // from the start of the segment
                                ) && (nextChar === "/" || nextChar === undefined || nextChar === ',' || nextChar === '}'); // to the end of the segment
                                if (isGlobstar) {
                                    if (nextChar === "/") {
                                        i++; // move over the "/"
                                    } else if (prevChar === '/' && reStr.endsWith('\\/')) {
                                        reStr = reStr.substr(0, reStr.length - 2);
                                    }
                                    // it's a globstar, so match zero or more path segments
                                    reStr += "((?:[^/]*(?:\/|$))*)";
                                } else {
                                    // it's not a globstar, so only match one path segment
                                    reStr += "([^/]*)";
                                }
                            }
                            break;
                        default:
                            reStr += c;
                    }
                }
                // When regexp 'g' flag is specified don't
                // constrain the regular expression with ^ & $
                if (!flags || !~flags.indexOf('g')) {
                    reStr = "^" + reStr + "$";
                }
                return new RegExp(reStr, flags);
            }
            ;
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSchemaService.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const BANG = '!';
            const PATH_SEP = '/';
            class FilePatternAssociation {
                matchesPattern(fileName) {
                    if (this.folderUri && !fileName.startsWith(this.folderUri)) {
                        return false;
                    }
                    let match = false;
                    for (const { regexp, include } of this.globWrappers){
                        if (regexp.test(fileName)) {
                            match = include;
                        }
                    }
                    return match;
                }
                getURIs() {
                    return this.uris;
                }
                constructor(pattern, folderUri, uris){
                    this.folderUri = folderUri;
                    this.uris = uris;
                    this.globWrappers = [];
                    try {
                        for (let patternString of pattern){
                            const include = patternString[0] !== BANG;
                            if (!include) {
                                patternString = patternString.substring(1);
                            }
                            if (patternString.length > 0) {
                                if (patternString[0] === PATH_SEP) {
                                    patternString = patternString.substring(1);
                                }
                                this.globWrappers.push({
                                    regexp: createRegex('**/' + patternString, {
                                        extended: true,
                                        globstar: true
                                    }),
                                    include: include
                                });
                            }
                        }
                        ;
                        if (folderUri) {
                            folderUri = normalizeResourceForMatching(folderUri);
                            if (!folderUri.endsWith('/')) {
                                folderUri = folderUri + '/';
                            }
                            this.folderUri = folderUri;
                        }
                    } catch (e) {
                        this.globWrappers.length = 0;
                        this.uris = [];
                    }
                }
            }
            class SchemaHandle {
                getUnresolvedSchema() {
                    if (!this.unresolvedSchema) {
                        this.unresolvedSchema = this.service.loadSchema(this.uri);
                    }
                    return this.unresolvedSchema;
                }
                getResolvedSchema() {
                    if (!this.resolvedSchema) {
                        this.resolvedSchema = this.getUnresolvedSchema().then((unresolved)=>{
                            return this.service.resolveSchemaContent(unresolved, this);
                        });
                    }
                    return this.resolvedSchema;
                }
                clearSchema() {
                    const hasChanges = !!this.unresolvedSchema;
                    this.resolvedSchema = undefined;
                    this.unresolvedSchema = undefined;
                    this.dependencies.clear();
                    this.anchors = undefined;
                    return hasChanges;
                }
                constructor(service, uri, unresolvedSchemaContent){
                    this.service = service;
                    this.uri = uri;
                    this.dependencies = new Set();
                    this.anchors = undefined;
                    if (unresolvedSchemaContent) {
                        this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));
                    }
                }
            }
            class UnresolvedSchema {
                constructor(schema, errors = []){
                    this.schema = schema;
                    this.errors = errors;
                }
            }
            class ResolvedSchema {
                getSection(path) {
                    const schemaRef = this.getSectionRecursive(path, this.schema);
                    if (schemaRef) {
                        return asSchema(schemaRef);
                    }
                    return undefined;
                }
                getSectionRecursive(path, schema) {
                    if (!schema || typeof schema === 'boolean' || path.length === 0) {
                        return schema;
                    }
                    const next = path.shift();
                    if (schema.properties && typeof schema.properties[next]) {
                        return this.getSectionRecursive(path, schema.properties[next]);
                    } else if (schema.patternProperties) {
                        for (const pattern of Object.keys(schema.patternProperties)){
                            var _regex;
                            const regex = extendedRegExp(pattern);
                            if ((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(next)) {
                                return this.getSectionRecursive(path, schema.patternProperties[pattern]);
                            }
                        }
                    } else if (typeof schema.additionalProperties === 'object') {
                        return this.getSectionRecursive(path, schema.additionalProperties);
                    } else if (next.match('[0-9]+')) {
                        if (Array.isArray(schema.items)) {
                            const index = parseInt(next, 10);
                            if (!isNaN(index) && schema.items[index]) {
                                return this.getSectionRecursive(path, schema.items[index]);
                            }
                        } else if (schema.items) {
                            return this.getSectionRecursive(path, schema.items);
                        }
                    }
                    return undefined;
                }
                constructor(schema, errors = [], warnings = [], schemaDraft){
                    this.schema = schema;
                    this.errors = errors;
                    this.warnings = warnings;
                    this.schemaDraft = schemaDraft;
                }
            }
            class JSONSchemaService {
                getRegisteredSchemaIds(filter) {
                    return Object.keys(this.registeredSchemasIds).filter((id)=>{
                        const scheme = URI.parse(id).scheme;
                        return scheme !== 'schemaservice' && (!filter || filter(scheme));
                    });
                }
                get promise() {
                    return this.promiseConstructor;
                }
                dispose() {
                    while(this.callOnDispose.length > 0){
                        this.callOnDispose.pop()();
                    }
                }
                onResourceChange(uri) {
                    // always clear this local cache when a resource changes
                    this.cachedSchemaForResource = undefined;
                    let hasChanges = false;
                    uri = normalizeId(uri);
                    const toWalk = [
                        uri
                    ];
                    const all = Object.keys(this.schemasById).map((key)=>this.schemasById[key]);
                    while(toWalk.length){
                        const curr = toWalk.pop();
                        for(let i = 0; i < all.length; i++){
                            const handle = all[i];
                            if (handle && (handle.uri === curr || handle.dependencies.has(curr))) {
                                if (handle.uri !== curr) {
                                    toWalk.push(handle.uri);
                                }
                                if (handle.clearSchema()) {
                                    hasChanges = true;
                                }
                                all[i] = undefined;
                            }
                        }
                    }
                    return hasChanges;
                }
                setSchemaContributions(schemaContributions) {
                    if (schemaContributions.schemas) {
                        const schemas = schemaContributions.schemas;
                        for(const id in schemas){
                            const normalizedId = normalizeId(id);
                            this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);
                        }
                    }
                    if (Array.isArray(schemaContributions.schemaAssociations)) {
                        const schemaAssociations = schemaContributions.schemaAssociations;
                        for (let schemaAssociation of schemaAssociations){
                            const uris = schemaAssociation.uris.map(normalizeId);
                            const association = this.addFilePatternAssociation(schemaAssociation.pattern, schemaAssociation.folderUri, uris);
                            this.contributionAssociations.push(association);
                        }
                    }
                }
                addSchemaHandle(id, unresolvedSchemaContent) {
                    const schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);
                    this.schemasById[id] = schemaHandle;
                    return schemaHandle;
                }
                getOrAddSchemaHandle(id, unresolvedSchemaContent) {
                    return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);
                }
                addFilePatternAssociation(pattern, folderUri, uris) {
                    const fpa = new FilePatternAssociation(pattern, folderUri, uris);
                    this.filePatternAssociations.push(fpa);
                    return fpa;
                }
                registerExternalSchema(config) {
                    const id = normalizeId(config.uri);
                    this.registeredSchemasIds[id] = true;
                    this.cachedSchemaForResource = undefined;
                    if (config.fileMatch && config.fileMatch.length) {
                        this.addFilePatternAssociation(config.fileMatch, config.folderUri, [
                            id
                        ]);
                    }
                    return config.schema ? this.addSchemaHandle(id, config.schema) : this.getOrAddSchemaHandle(id);
                }
                clearExternalSchemas() {
                    this.schemasById = {};
                    this.filePatternAssociations = [];
                    this.registeredSchemasIds = {};
                    this.cachedSchemaForResource = undefined;
                    for(const id in this.contributionSchemas){
                        this.schemasById[id] = this.contributionSchemas[id];
                        this.registeredSchemasIds[id] = true;
                    }
                    for (const contributionAssociation of this.contributionAssociations){
                        this.filePatternAssociations.push(contributionAssociation);
                    }
                }
                getResolvedSchema(schemaId) {
                    const id = normalizeId(schemaId);
                    const schemaHandle = this.schemasById[id];
                    if (schemaHandle) {
                        return schemaHandle.getResolvedSchema();
                    }
                    return this.promise.resolve(undefined);
                }
                loadSchema(url) {
                    if (!this.requestService) {
                        const errorMessage = t('Unable to load schema from \'{0}\'. No schema request service available', toDisplayString(url));
                        return this.promise.resolve(new UnresolvedSchema({}, [
                            errorMessage
                        ]));
                    }
                    return this.requestService(url).then((content)=>{
                        if (!content) {
                            const errorMessage = t('Unable to load schema from \'{0}\': No content.', toDisplayString(url));
                            return new UnresolvedSchema({}, [
                                errorMessage
                            ]);
                        }
                        const errors = [];
                        if (content.charCodeAt(0) === 65279) {
                            errors.push(t('Problem reading content from \'{0}\': UTF-8 with BOM detected, only UTF 8 is allowed.', toDisplayString(url)));
                            content = content.trimStart();
                        }
                        let schemaContent = {};
                        const jsonErrors = [];
                        schemaContent = main_parse(content, jsonErrors);
                        if (jsonErrors.length) {
                            errors.push(t('Unable to parse content from \'{0}\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset));
                        }
                        return new UnresolvedSchema(schemaContent, errors);
                    }, (error)=>{
                        let errorMessage = error.toString();
                        const errorSplit = error.toString().split('Error: ');
                        if (errorSplit.length > 1) {
                            // more concise error message, URL and context are attached by caller anyways
                            errorMessage = errorSplit[1];
                        }
                        if (endsWith(errorMessage, '.')) {
                            errorMessage = errorMessage.substr(0, errorMessage.length - 1);
                        }
                        return new UnresolvedSchema({}, [
                            t('Unable to load schema from \'{0}\': {1}.', toDisplayString(url), errorMessage)
                        ]);
                    });
                }
                resolveSchemaContent(schemaToResolve, handle) {
                    const resolveErrors = schemaToResolve.errors.slice(0);
                    const schema = schemaToResolve.schema;
                    let schemaDraft = schema.$schema ? normalizeId(schema.$schema) : undefined;
                    if (schemaDraft === 'http://json-schema.org/draft-03/schema') {
                        return this.promise.resolve(new ResolvedSchema({}, [
                            t("Draft-03 schemas are not supported.")
                        ], [], schemaDraft));
                    }
                    let usesUnsupportedFeatures = new Set();
                    const contextService = this.contextService;
                    const findSectionByJSONPointer = (schema, path)=>{
                        path = decodeURIComponent(path);
                        let current = schema;
                        if (path[0] === '/') {
                            path = path.substring(1);
                        }
                        path.split('/').some((part)=>{
                            part = part.replace(/~1/g, '/').replace(/~0/g, '~');
                            current = current[part];
                            return !current;
                        });
                        return current;
                    };
                    const findSchemaById = (schema, handle, id)=>{
                        if (!handle.anchors) {
                            handle.anchors = collectAnchors(schema);
                        }
                        return handle.anchors.get(id);
                    };
                    const merge = (target, section)=>{
                        for(const key in section){
                            if (section.hasOwnProperty(key) && key !== 'id' && key !== '$id') {
                                target[key] = section[key];
                            }
                        }
                    };
                    const mergeRef = (target, sourceRoot, sourceHandle, refSegment)=>{
                        let section;
                        if (refSegment === undefined || refSegment.length === 0) {
                            section = sourceRoot;
                        } else if (refSegment.charAt(0) === '/') {
                            // A $ref to a JSON Pointer (i.e #/definitions/foo)
                            section = findSectionByJSONPointer(sourceRoot, refSegment);
                        } else {
                            // A $ref to a sub-schema with an $id (i.e #hello)
                            section = findSchemaById(sourceRoot, sourceHandle, refSegment);
                        }
                        if (section) {
                            merge(target, section);
                        } else {
                            resolveErrors.push(t('$ref \'{0}\' in \'{1}\' can not be resolved.', refSegment || '', sourceHandle.uri));
                        }
                    };
                    const resolveExternalLink = (node, uri, refSegment, parentHandle)=>{
                        if (contextService && !/^[A-Za-z][A-Za-z0-9+\-.+]*:\/\/.*/.test(uri)) {
                            uri = contextService.resolveRelativePath(uri, parentHandle.uri);
                        }
                        uri = normalizeId(uri);
                        const referencedHandle = this.getOrAddSchemaHandle(uri);
                        return referencedHandle.getUnresolvedSchema().then((unresolvedSchema)=>{
                            parentHandle.dependencies.add(uri);
                            if (unresolvedSchema.errors.length) {
                                const loc = refSegment ? uri + '#' + refSegment : uri;
                                resolveErrors.push(t('Problems loading reference \'{0}\': {1}', loc, unresolvedSchema.errors[0]));
                            }
                            mergeRef(node, unresolvedSchema.schema, referencedHandle, refSegment);
                            return resolveRefs(node, unresolvedSchema.schema, referencedHandle);
                        });
                    };
                    const resolveRefs = (node, parentSchema, parentHandle)=>{
                        const openPromises = [];
                        this.traverseNodes(node, (next)=>{
                            const seenRefs = new Set();
                            while(next.$ref){
                                const ref = next.$ref;
                                const segments = ref.split('#', 2);
                                delete next.$ref;
                                if (segments[0].length > 0) {
                                    // This is a reference to an external schema
                                    openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentHandle));
                                    return;
                                } else {
                                    // This is a reference inside the current schema
                                    if (!seenRefs.has(ref)) {
                                        const id = segments[1];
                                        mergeRef(next, parentSchema, parentHandle, id);
                                        seenRefs.add(ref);
                                    }
                                }
                            }
                            if (next.$recursiveRef) {
                                usesUnsupportedFeatures.add('$recursiveRef');
                            }
                            if (next.$dynamicRef) {
                                usesUnsupportedFeatures.add('$dynamicRef');
                            }
                        });
                        return this.promise.all(openPromises);
                    };
                    const collectAnchors = (root)=>{
                        const result = new Map();
                        this.traverseNodes(root, (next)=>{
                            const id = next.$id || next.id;
                            const anchor = isString(id) && id.charAt(0) === '#' ? id.substring(1) : next.$anchor;
                            if (anchor) {
                                if (result.has(anchor)) {
                                    resolveErrors.push(t('Duplicate anchor declaration: \'{0}\'', anchor));
                                } else {
                                    result.set(anchor, next);
                                }
                            }
                            if (next.$recursiveAnchor) {
                                usesUnsupportedFeatures.add('$recursiveAnchor');
                            }
                            if (next.$dynamicAnchor) {
                                usesUnsupportedFeatures.add('$dynamicAnchor');
                            }
                        });
                        return result;
                    };
                    return resolveRefs(schema, schema, handle).then((_)=>{
                        let resolveWarnings = [];
                        if (usesUnsupportedFeatures.size) {
                            resolveWarnings.push(t('The schema uses meta-schema features ({0}) that are not yet supported by the validator.', Array.from(usesUnsupportedFeatures.keys()).join(', ')));
                        }
                        return new ResolvedSchema(schema, resolveErrors, resolveWarnings, schemaDraft);
                    });
                }
                traverseNodes(root, handle) {
                    if (!root || typeof root !== 'object') {
                        return Promise.resolve(null);
                    }
                    const seen = new Set();
                    const collectEntries = (...entries)=>{
                        for (const entry of entries){
                            if (isObject(entry)) {
                                toWalk.push(entry);
                            }
                        }
                    };
                    const collectMapEntries = (...maps)=>{
                        for (const map of maps){
                            if (isObject(map)) {
                                for(const k in map){
                                    const key = k;
                                    const entry = map[key];
                                    if (isObject(entry)) {
                                        toWalk.push(entry);
                                    }
                                }
                            }
                        }
                    };
                    const collectArrayEntries = (...arrays)=>{
                        for (const array of arrays){
                            if (Array.isArray(array)) {
                                for (const entry of array){
                                    if (isObject(entry)) {
                                        toWalk.push(entry);
                                    }
                                }
                            }
                        }
                    };
                    const collectEntryOrArrayEntries = (items)=>{
                        if (Array.isArray(items)) {
                            for (const entry of items){
                                if (isObject(entry)) {
                                    toWalk.push(entry);
                                }
                            }
                        } else if (isObject(items)) {
                            toWalk.push(items);
                        }
                    };
                    const toWalk = [
                        root
                    ];
                    let next = toWalk.pop();
                    while(next){
                        if (!seen.has(next)) {
                            seen.add(next);
                            handle(next);
                            collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);
                            collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);
                            collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);
                            collectEntryOrArrayEntries(next.items);
                        }
                        next = toWalk.pop();
                    }
                }
                getSchemaFromProperty(resource, document1) {
                    var _document_root;
                    if (((_document_root = document1.root) === null || _document_root === void 0 ? void 0 : _document_root.type) === 'object') {
                        for (const p of document1.root.properties){
                            var _p_valueNode;
                            if (p.keyNode.value === '$schema' && ((_p_valueNode = p.valueNode) === null || _p_valueNode === void 0 ? void 0 : _p_valueNode.type) === 'string') {
                                let schemaId = p.valueNode.value;
                                if (this.contextService && !/^\w[\w\d+.-]*:/.test(schemaId)) {
                                    schemaId = this.contextService.resolveRelativePath(schemaId, resource);
                                }
                                return schemaId;
                            }
                        }
                    }
                    return undefined;
                }
                getAssociatedSchemas(resource) {
                    const seen = Object.create(null);
                    const schemas = [];
                    const normalizedResource = normalizeResourceForMatching(resource);
                    for (const entry of this.filePatternAssociations){
                        if (entry.matchesPattern(normalizedResource)) {
                            for (const schemaId of entry.getURIs()){
                                if (!seen[schemaId]) {
                                    schemas.push(schemaId);
                                    seen[schemaId] = true;
                                }
                            }
                        }
                    }
                    return schemas;
                }
                getSchemaURIsForResource(resource, document1) {
                    let schemeId = document1 && this.getSchemaFromProperty(resource, document1);
                    if (schemeId) {
                        return [
                            schemeId
                        ];
                    }
                    return this.getAssociatedSchemas(resource);
                }
                getSchemaForResource(resource, document1) {
                    if (document1) {
                        // first use $schema if present
                        let schemeId = this.getSchemaFromProperty(resource, document1);
                        if (schemeId) {
                            const id = normalizeId(schemeId);
                            return this.getOrAddSchemaHandle(id).getResolvedSchema();
                        }
                    }
                    if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {
                        return this.cachedSchemaForResource.resolvedSchema;
                    }
                    const schemas = this.getAssociatedSchemas(resource);
                    const resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(undefined);
                    this.cachedSchemaForResource = {
                        resource,
                        resolvedSchema
                    };
                    return resolvedSchema;
                }
                createCombinedSchema(resource, schemaIds) {
                    if (schemaIds.length === 1) {
                        return this.getOrAddSchemaHandle(schemaIds[0]);
                    } else {
                        const combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);
                        const combinedSchema = {
                            allOf: schemaIds.map((schemaId)=>({
                                    $ref: schemaId
                                }))
                        };
                        return this.addSchemaHandle(combinedSchemaId, combinedSchema);
                    }
                }
                getMatchingSchemas(document1, jsonDocument, schema) {
                    if (schema) {
                        const id = schema.id || 'schemaservice://untitled/matchingSchemas/' + jsonSchemaService_idCounter++;
                        const handle = this.addSchemaHandle(id, schema);
                        return handle.getResolvedSchema().then((resolvedSchema)=>{
                            return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter((s)=>!s.inverted);
                        });
                    }
                    return this.getSchemaForResource(document1.uri, jsonDocument).then((schema)=>{
                        if (schema) {
                            return jsonDocument.getMatchingSchemas(schema.schema).filter((s)=>!s.inverted);
                        }
                        return [];
                    });
                }
                constructor(requestService, contextService, promiseConstructor){
                    this.contextService = contextService;
                    this.requestService = requestService;
                    this.promiseConstructor = promiseConstructor || Promise;
                    this.callOnDispose = [];
                    this.contributionSchemas = {};
                    this.contributionAssociations = [];
                    this.schemasById = {};
                    this.filePatternAssociations = [];
                    this.registeredSchemasIds = {};
                }
            }
            let jsonSchemaService_idCounter = 0;
            function normalizeId(id) {
                // remove trailing '#', normalize drive capitalization
                try {
                    return URI.parse(id).toString(true);
                } catch (e) {
                    return id;
                }
            }
            function normalizeResourceForMatching(resource) {
                // remove queries and fragments, normalize drive capitalization
                try {
                    return URI.parse(resource).with({
                        fragment: null,
                        query: null
                    }).toString(true);
                } catch (e) {
                    return resource;
                }
            }
            function toDisplayString(url) {
                try {
                    const uri = URI.parse(url);
                    if (uri.scheme === 'file') {
                        return uri.fsPath;
                    }
                } catch (e) {
                // ignore
                }
                return url;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonFolding.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getFoldingRanges(document1, context) {
                const ranges = [];
                const nestingLevels = [];
                const stack = [];
                let prevStart = -1;
                const scanner = main_createScanner(document1.getText(), false);
                let token = scanner.scan();
                function addRange(range) {
                    ranges.push(range);
                    nestingLevels.push(stack.length);
                }
                while(token !== 17 /* SyntaxKind.EOF */ ){
                    switch(token){
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            {
                                const startLine = document1.positionAt(scanner.getTokenOffset()).line;
                                const range = {
                                    startLine,
                                    endLine: startLine,
                                    kind: token === 1 /* SyntaxKind.OpenBraceToken */  ? 'object' : 'array'
                                };
                                stack.push(range);
                                break;
                            }
                        case 2 /* SyntaxKind.CloseBraceToken */ :
                        case 4 /* SyntaxKind.CloseBracketToken */ :
                            {
                                const kind = token === 2 /* SyntaxKind.CloseBraceToken */  ? 'object' : 'array';
                                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {
                                    const range = stack.pop();
                                    const line = document1.positionAt(scanner.getTokenOffset()).line;
                                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {
                                        range.endLine = line - 1;
                                        addRange(range);
                                        prevStart = range.startLine;
                                    }
                                }
                                break;
                            }
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                            {
                                const startLine = document1.positionAt(scanner.getTokenOffset()).line;
                                const endLine = document1.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;
                                if (scanner.getTokenError() === 1 /* ScanError.UnexpectedEndOfComment */  && startLine + 1 < document1.lineCount) {
                                    scanner.setPosition(document1.offsetAt(main.Position.create(startLine + 1, 0)));
                                } else {
                                    if (startLine < endLine) {
                                        addRange({
                                            startLine,
                                            endLine,
                                            kind: main.FoldingRangeKind.Comment
                                        });
                                        prevStart = startLine;
                                    }
                                }
                                break;
                            }
                        case 12 /* SyntaxKind.LineCommentTrivia */ :
                            {
                                const text = document1.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());
                                const m = text.match(/^\/\/\s*#(region\b)|(endregion\b)/);
                                if (m) {
                                    const line = document1.positionAt(scanner.getTokenOffset()).line;
                                    if (m[1]) {
                                        const range = {
                                            startLine: line,
                                            endLine: line,
                                            kind: main.FoldingRangeKind.Region
                                        };
                                        stack.push(range);
                                    } else {
                                        let i = stack.length - 1;
                                        while(i >= 0 && stack[i].kind !== main.FoldingRangeKind.Region){
                                            i--;
                                        }
                                        if (i >= 0) {
                                            const range = stack[i];
                                            stack.length = i;
                                            if (line > range.startLine && prevStart !== range.startLine) {
                                                range.endLine = line;
                                                addRange(range);
                                                prevStart = range.startLine;
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                    }
                    token = scanner.scan();
                }
                const rangeLimit = context && context.rangeLimit;
                if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {
                    return ranges;
                }
                if (context && context.onRangeLimitExceeded) {
                    context.onRangeLimitExceeded(document1.uri);
                }
                const counts = [];
                for (let level of nestingLevels){
                    if (level < 30) {
                        counts[level] = (counts[level] || 0) + 1;
                    }
                }
                let entries = 0;
                let maxLevel = 0;
                for(let i = 0; i < counts.length; i++){
                    const n = counts[i];
                    if (n) {
                        if (n + entries > rangeLimit) {
                            maxLevel = i;
                            break;
                        }
                        entries += n;
                    }
                }
                const result = [];
                for(let i = 0; i < ranges.length; i++){
                    const level = nestingLevels[i];
                    if (typeof level === 'number') {
                        if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {
                            result.push(ranges[i]);
                        }
                    }
                }
                return result;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSelectionRanges.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getSelectionRanges(document1, positions, doc) {
                function getSelectionRange(position) {
                    let offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset, true);
                    const result = [];
                    while(node){
                        switch(node.type){
                            case 'string':
                            case 'object':
                            case 'array':
                                // range without ", [ or {
                                const cStart = node.offset + 1, cEnd = node.offset + node.length - 1;
                                if (cStart < cEnd && offset >= cStart && offset <= cEnd) {
                                    result.push(newRange(cStart, cEnd));
                                }
                                result.push(newRange(node.offset, node.offset + node.length));
                                break;
                            case 'number':
                            case 'boolean':
                            case 'null':
                            case 'property':
                                result.push(newRange(node.offset, node.offset + node.length));
                                break;
                        }
                        if (node.type === 'property' || node.parent && node.parent.type === 'array') {
                            const afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5 /* SyntaxKind.CommaToken */ );
                            if (afterCommaOffset !== -1) {
                                result.push(newRange(node.offset, afterCommaOffset));
                            }
                        }
                        node = node.parent;
                    }
                    let current = undefined;
                    for(let index = result.length - 1; index >= 0; index--){
                        current = main.SelectionRange.create(result[index], current);
                    }
                    if (!current) {
                        current = main.SelectionRange.create(main.Range.create(position, position));
                    }
                    return current;
                }
                function newRange(start, end) {
                    return main.Range.create(document1.positionAt(start), document1.positionAt(end));
                }
                const scanner = main_createScanner(document1.getText(), true);
                function getOffsetAfterNextToken(offset, expectedToken) {
                    scanner.setPosition(offset);
                    let token = scanner.scan();
                    if (token === expectedToken) {
                        return scanner.getTokenOffset() + scanner.getTokenLength();
                    }
                    return -1;
                }
                return positions.map(getSelectionRange);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/format.js
            function utils_format_format(documentToFormat, formattingOptions, formattingRange) {
                var _formattingOptions, _formattingOptions1, _formattingOptions2;
                let range = undefined;
                if (formattingRange) {
                    const offset = documentToFormat.offsetAt(formattingRange.start);
                    const length = documentToFormat.offsetAt(formattingRange.end) - offset;
                    range = {
                        offset,
                        length
                    };
                }
                const options = {
                    tabSize: formattingOptions ? formattingOptions.tabSize : 4,
                    insertSpaces: ((_formattingOptions = formattingOptions) === null || _formattingOptions === void 0 ? void 0 : _formattingOptions.insertSpaces) === true,
                    insertFinalNewline: ((_formattingOptions1 = formattingOptions) === null || _formattingOptions1 === void 0 ? void 0 : _formattingOptions1.insertFinalNewline) === true,
                    eol: '\n',
                    keepLines: ((_formattingOptions2 = formattingOptions) === null || _formattingOptions2 === void 0 ? void 0 : _formattingOptions2.keepLines) === true
                };
                return main_format(documentToFormat.getText(), range, options).map((edit1)=>{
                    return main.TextEdit.replace(main.Range.create(documentToFormat.positionAt(edit1.offset), documentToFormat.positionAt(edit1.offset + edit1.length)), edit1.content);
                });
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/propertyTree.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ var Container;
            (function(Container) {
                Container[Container["Object"] = 0] = "Object";
                Container[Container["Array"] = 1] = "Array";
            })(Container || (Container = {}));
            class PropertyTree {
                addChildProperty(childProperty) {
                    childProperty.parent = this;
                    if (this.childrenProperties.length > 0) {
                        let insertionIndex = 0;
                        if (childProperty.noKeyName) {
                            insertionIndex = this.childrenProperties.length;
                        } else {
                            insertionIndex = binarySearchOnPropertyArray(this.childrenProperties, childProperty, compareProperties);
                        }
                        if (insertionIndex < 0) {
                            insertionIndex = insertionIndex * -1 - 1;
                        }
                        this.childrenProperties.splice(insertionIndex, 0, childProperty);
                    } else {
                        this.childrenProperties.push(childProperty);
                    }
                    return childProperty;
                }
                constructor(propertyName, beginningLineNumber){
                    this.propertyName = propertyName !== null && propertyName !== void 0 ? propertyName : '';
                    this.beginningLineNumber = beginningLineNumber;
                    this.childrenProperties = [];
                    this.lastProperty = false;
                    this.noKeyName = false;
                }
            }
            function compareProperties(propertyTree1, propertyTree2) {
                const propertyName1 = propertyTree1.propertyName.toLowerCase();
                const propertyName2 = propertyTree2.propertyName.toLowerCase();
                if (propertyName1 < propertyName2) {
                    return -1;
                } else if (propertyName1 > propertyName2) {
                    return 1;
                }
                return 0;
            }
            function binarySearchOnPropertyArray(propertyTreeArray, propertyTree, compare_fn) {
                const propertyName = propertyTree.propertyName.toLowerCase();
                const firstPropertyInArrayName = propertyTreeArray[0].propertyName.toLowerCase();
                const lastPropertyInArrayName = propertyTreeArray[propertyTreeArray.length - 1].propertyName.toLowerCase();
                if (propertyName < firstPropertyInArrayName) {
                    return 0;
                }
                if (propertyName > lastPropertyInArrayName) {
                    return propertyTreeArray.length;
                }
                let m = 0;
                let n = propertyTreeArray.length - 1;
                while(m <= n){
                    let k = n + m >> 1;
                    let cmp = compare_fn(propertyTree, propertyTreeArray[k]);
                    if (cmp > 0) {
                        m = k + 1;
                    } else if (cmp < 0) {
                        n = k - 1;
                    } else {
                        return k;
                    }
                }
                return -m - 1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/sort.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ // import { TextEdit} from 'vscode-languageserver-textdocument';
            function sort(documentToSort, formattingOptions) {
                const options = {
                    ...formattingOptions,
                    keepLines: false
                };
                const formattedJsonString = esm_main /* TextDocument */ .n.applyEdits(documentToSort, utils_format_format(documentToSort, options, undefined));
                const formattedJsonDocument = esm_main /* TextDocument */ .n.create('test://test.json', 'json', 0, formattedJsonString);
                const jsonPropertyTree = findJsoncPropertyTree(formattedJsonDocument);
                const sortedJsonDocument = sortJsoncDocument(formattedJsonDocument, jsonPropertyTree);
                const edits = utils_format_format(sortedJsonDocument, options, undefined);
                const sortedAndFormattedJsonDocument = esm_main /* TextDocument */ .n.applyEdits(sortedJsonDocument, edits);
                return [
                    main.TextEdit.replace(main.Range.create(main.Position.create(0, 0), documentToSort.positionAt(documentToSort.getText().length)), sortedAndFormattedJsonDocument)
                ];
            }
            function findJsoncPropertyTree(formattedDocument) {
                const formattedString = formattedDocument.getText();
                const scanner = main_createScanner(formattedString, false);
                // The tree that will be returned
                let rootTree = new PropertyTree();
                // The tree where the current properties can be added as children
                let currentTree = rootTree;
                // The tree representing the current property analyzed
                let currentProperty = rootTree;
                // The tree representing the previous property analyzed
                let lastProperty = rootTree;
                // The current scanned token
                let token = undefined;
                // Line number of the last token found
                let lastTokenLine = 0;
                // Total number of characters on the lines prior to current line 
                let numberOfCharactersOnPreviousLines = 0;
                // The last token scanned that is not trivial, nor a comment
                let lastNonTriviaNonCommentToken = undefined;
                // The second to last token scanned that is not trivial, nor a comment
                let secondToLastNonTriviaNonCommentToken = undefined;
                // Line number of last token that is not trivial, nor a comment
                let lineOfLastNonTriviaNonCommentToken = -1;
                // End index on its line of last token that is not trivial, nor a comment
                let endIndexOfLastNonTriviaNonCommentToken = -1;
                // Line number of the start of the range of current/next property
                let beginningLineNumber = 0;
                // Line number of the end of the range of current/next property
                let endLineNumber = 0;
                // Stack indicating whether we are inside of an object or an array
                let currentContainerStack = [];
                // Boolean indicating that the current property end line number needs to be updated. Used only when block comments are encountered.
                let updateLastPropertyEndLineNumber = false;
                // Boolean indicating that the beginning line number should be updated. Used only when block comments are encountered. 
                let updateBeginningLineNumber = false;
                while((token = scanner.scan()) !== 17 /* SyntaxKind.EOF */ ){
                    // In the case when a block comment has been encountered that starts on the same line as the comma ending a property, update the end line of that
                    // property so that it covers the block comment. For example, if we have: 
                    // 1. "key" : {}, /* some block
                    // 2. comment */
                    // Then, the end line of the property "key" should be line 2 not line 1
                    if (updateLastPropertyEndLineNumber === true && token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 15 /* SyntaxKind.Trivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */  && currentProperty.endLineNumber === undefined) {
                        let endLineNumber = scanner.getTokenStartLine();
                        // Update the end line number in the case when the last property visited is a container (object or array)
                        if (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                            lastProperty.endLineNumber = endLineNumber - 1;
                        } else {
                            currentProperty.endLineNumber = endLineNumber - 1;
                        }
                        beginningLineNumber = endLineNumber;
                        updateLastPropertyEndLineNumber = false;
                    }
                    // When a block comment follows an open brace or an open bracket, that block comment should be associated to that brace or bracket, not the property below it. For example, for:
                    // 1. { /*
                    // 2. ... */
                    // 3. "key" : {}
                    // 4. }
                    // Instead of associating the block comment to the property on line 3, it is associate to the property on line 1
                    if (updateBeginningLineNumber === true && token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 15 /* SyntaxKind.Trivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */ ) {
                        beginningLineNumber = scanner.getTokenStartLine();
                        updateBeginningLineNumber = false;
                    }
                    // Update the number of characters on all the previous lines each time the new token is on a different line to the previous token
                    if (scanner.getTokenStartLine() !== lastTokenLine) {
                        for(let i = lastTokenLine; i < scanner.getTokenStartLine(); i++){
                            const lengthOfLine = formattedDocument.getText(main.Range.create(main.Position.create(i, 0), main.Position.create(i + 1, 0))).length;
                            numberOfCharactersOnPreviousLines = numberOfCharactersOnPreviousLines + lengthOfLine;
                        }
                        lastTokenLine = scanner.getTokenStartLine();
                    }
                    switch(token){
                        // When a string is found, if it follows an open brace or a comma token and it is within an object, then it corresponds to a key name, not a simple string
                        case 10 /* SyntaxKind.StringLiteral */ :
                            {
                                if (lastNonTriviaNonCommentToken === undefined || lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */  || lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */  && currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                    // In that case create the child property which starts at beginningLineNumber, add it to the current tree
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                }
                                break;
                            }
                        // When the token is an open bracket, then we enter into an array
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            {
                                // If the root tree beginning line number is not defined, then this open bracket is the first open bracket in the document
                                if (rootTree.beginningLineNumber === undefined) {
                                    rootTree.beginningLineNumber = scanner.getTokenStartLine();
                                }
                                // Suppose we are inside of an object, then the current array is associated to a key, and has already been created
                                // We have the following configuration: {"a": "val", "array": [...], "b": "val"}
                                // In that case navigate down to the child property
                                if (currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                    currentTree = currentProperty;
                                } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    childProperty.noKeyName = true;
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                    currentTree = currentProperty;
                                }
                                currentContainerStack.push(Container.Array);
                                currentProperty.type = Container.Array;
                                beginningLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber++;
                                break;
                            }
                        // When the token is an open brace, then we enter into an object
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                            {
                                // If the root tree beginning line number is not defined, then this open brace is the first open brace in the document
                                if (rootTree.beginningLineNumber === undefined) {
                                    rootTree.beginningLineNumber = scanner.getTokenStartLine();
                                } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    childProperty.noKeyName = true;
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                }
                                currentProperty.type = Container.Object;
                                currentContainerStack.push(Container.Object);
                                currentTree = currentProperty;
                                beginningLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber++;
                                break;
                            }
                        case 4 /* SyntaxKind.CloseBracketToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                currentContainerStack.pop();
                                // If the last non-trivial non-comment token is a closing brace or bracket, then the currentProperty end line number has not been set yet so set it
                                // The configuration considered is: [..., {}] or [..., []]
                                if (currentProperty.endLineNumber === undefined && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ )) {
                                    currentProperty.endLineNumber = endLineNumber - 1;
                                    currentProperty.lastProperty = true;
                                    currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;
                                    currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                rootTree.endLineNumber = endLineNumber;
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 2 /* SyntaxKind.CloseBraceToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                currentContainerStack.pop();
                                // If we are not inside of an empty object and current property end line number has not yet been defined, define it
                                if (lastNonTriviaNonCommentToken !== 1 /* SyntaxKind.OpenBraceToken */  && currentProperty.endLineNumber === undefined) {
                                    currentProperty.endLineNumber = endLineNumber - 1;
                                    // The current property is also the last property
                                    currentProperty.lastProperty = true;
                                    // The last property of an object is associated with the line and index of where to add the comma, in case after sorting, it is no longer the last property
                                    currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;
                                    currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                rootTree.endLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 5 /* SyntaxKind.CommaToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                // If the current container is an object or the current container is an array and the last non-trivia non-comment token is a closing brace or a closing bracket
                                // Then update the end line number of the current property
                                if (currentProperty.endLineNumber === undefined && (currentContainerStack[currentContainerStack.length - 1] === Container.Object || currentContainerStack[currentContainerStack.length - 1] === Container.Array && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ))) {
                                    currentProperty.endLineNumber = endLineNumber;
                                    // Store the line and the index of the comma in case it needs to be removed during the sorting
                                    currentProperty.commaIndex = scanner.getTokenOffset() - numberOfCharactersOnPreviousLines;
                                    currentProperty.commaLine = endLineNumber;
                                }
                                if (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                            {
                                // If the last non trivia non-comment token is a comma and the block comment starts on the same line as the comma, then update the end line number of the current property. For example if:
                                // 1. {}, /* ...
                                // 2. ..*/
                                // The the property on line 1 shoud end on line 2, not line 1
                                // In the case we are in an array we update the end line number only if the second to last non-trivia non-comment token is a closing brace or bracket
                                if (lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */  && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine() && (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) || currentContainerStack[currentContainerStack.length - 1] === Container.Object)) {
                                    if (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) || currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                        currentProperty.endLineNumber = undefined;
                                        updateLastPropertyEndLineNumber = true;
                                    }
                                }
                                // When the block comment follows an open brace or an open token, we have the following scenario:
                                // { /**
                                // ../
                                // }
                                // The block comment should be assigned to the open brace not the first property below it
                                if ((lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */  || lastNonTriviaNonCommentToken === 3 /* SyntaxKind.OpenBracketToken */ ) && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine()) {
                                    updateBeginningLineNumber = true;
                                }
                                break;
                            }
                    }
                    // Update the last and second to last non-trivia non-comment tokens
                    if (token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 15 /* SyntaxKind.Trivia */ ) {
                        secondToLastNonTriviaNonCommentToken = lastNonTriviaNonCommentToken;
                        lastNonTriviaNonCommentToken = token;
                        lineOfLastNonTriviaNonCommentToken = scanner.getTokenStartLine();
                        endIndexOfLastNonTriviaNonCommentToken = scanner.getTokenOffset() + scanner.getTokenLength() - numberOfCharactersOnPreviousLines;
                    }
                }
                return rootTree;
            }
            function sortJsoncDocument(jsonDocument, propertyTree) {
                if (propertyTree.childrenProperties.length === 0) {
                    return jsonDocument;
                }
                const sortedJsonDocument = esm_main /* TextDocument */ .n.create('test://test.json', 'json', 0, jsonDocument.getText());
                const queueToSort = [];
                updateSortingQueue(queueToSort, propertyTree, propertyTree.beginningLineNumber);
                while(queueToSort.length > 0){
                    const dataToSort = queueToSort.shift();
                    const propertyTreeArray = dataToSort.propertyTreeArray;
                    let beginningLineNumber = dataToSort.beginningLineNumber;
                    for(let i = 0; i < propertyTreeArray.length; i++){
                        const propertyTree = propertyTreeArray[i];
                        const range = main.Range.create(main.Position.create(propertyTree.beginningLineNumber, 0), main.Position.create(propertyTree.endLineNumber + 1, 0));
                        const jsonContentToReplace = jsonDocument.getText(range);
                        const jsonDocumentToReplace = esm_main /* TextDocument */ .n.create('test://test.json', 'json', 0, jsonContentToReplace);
                        if (propertyTree.lastProperty === true && i !== propertyTreeArray.length - 1) {
                            const lineWhereToAddComma = propertyTree.lineWhereToAddComma - propertyTree.beginningLineNumber;
                            const indexWhereToAddComma = propertyTree.indexWhereToAddComa;
                            const edit1 = {
                                range: main.Range.create(main.Position.create(lineWhereToAddComma, indexWhereToAddComma), main.Position.create(lineWhereToAddComma, indexWhereToAddComma)),
                                text: ','
                            };
                            esm_main /* TextDocument */ .n.update(jsonDocumentToReplace, [
                                edit1
                            ], 1);
                        } else if (propertyTree.lastProperty === false && i === propertyTreeArray.length - 1) {
                            const commaIndex = propertyTree.commaIndex;
                            const commaLine = propertyTree.commaLine;
                            const lineWhereToRemoveComma = commaLine - propertyTree.beginningLineNumber;
                            const edit1 = {
                                range: main.Range.create(main.Position.create(lineWhereToRemoveComma, commaIndex), main.Position.create(lineWhereToRemoveComma, commaIndex + 1)),
                                text: ''
                            };
                            esm_main /* TextDocument */ .n.update(jsonDocumentToReplace, [
                                edit1
                            ], 1);
                        }
                        const length = propertyTree.endLineNumber - propertyTree.beginningLineNumber + 1;
                        const edit1 = {
                            range: main.Range.create(main.Position.create(beginningLineNumber, 0), main.Position.create(beginningLineNumber + length, 0)),
                            text: jsonDocumentToReplace.getText()
                        };
                        esm_main /* TextDocument */ .n.update(sortedJsonDocument, [
                            edit1
                        ], 1);
                        updateSortingQueue(queueToSort, propertyTree, beginningLineNumber);
                        beginningLineNumber = beginningLineNumber + length;
                    }
                }
                return sortedJsonDocument;
            }
            function updateSortingQueue(queue, propertyTree, beginningLineNumber) {
                if (propertyTree.childrenProperties.length === 0) {
                    return;
                }
                if (propertyTree.type === Container.Object) {
                    let minimumBeginningLineNumber = Infinity;
                    for (const childProperty of propertyTree.childrenProperties){
                        if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {
                            minimumBeginningLineNumber = childProperty.beginningLineNumber;
                        }
                    }
                    const diff = minimumBeginningLineNumber - propertyTree.beginningLineNumber;
                    beginningLineNumber = beginningLineNumber + diff;
                    queue.push(new SortingRange(beginningLineNumber, propertyTree.childrenProperties));
                } else if (propertyTree.type === Container.Array) {
                    updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber);
                }
            }
            function updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber) {
                for (const subObject of propertyTree.childrenProperties){
                    // If the child property of the array is an object, then you can sort the properties within this object
                    if (subObject.type === Container.Object) {
                        let minimumBeginningLineNumber = Infinity;
                        for (const childProperty of subObject.childrenProperties){
                            if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {
                                minimumBeginningLineNumber = childProperty.beginningLineNumber;
                            }
                        }
                        const diff = minimumBeginningLineNumber - subObject.beginningLineNumber;
                        queue.push(new SortingRange(beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber + diff, subObject.childrenProperties));
                    }
                    // If the child property of the array is an array, then you need to recurse on the children properties, until you find an object to sort
                    if (subObject.type === Container.Array) {
                        updateSortingQueueForArrayProperties(queue, subObject, beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber);
                    }
                }
            }
            class SortingRange {
                constructor(beginningLineNumber, propertyTreeArray){
                    this.beginningLineNumber = beginningLineNumber;
                    this.propertyTreeArray = propertyTreeArray;
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonLinks.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function findLinks(document1, doc) {
                const links = [];
                doc.visit((node)=>{
                    var _node_valueNode;
                    if (node.type === "property" && node.keyNode.value === "$ref" && ((_node_valueNode = node.valueNode) === null || _node_valueNode === void 0 ? void 0 : _node_valueNode.type) === 'string') {
                        const path = node.valueNode.value;
                        const targetNode = findTargetNode(doc, path);
                        if (targetNode) {
                            const targetPos = document1.positionAt(targetNode.offset);
                            links.push({
                                target: `${document1.uri}#${targetPos.line + 1},${targetPos.character + 1}`,
                                range: createRange(document1, node.valueNode)
                            });
                        }
                    }
                    return true;
                });
                return Promise.resolve(links);
            }
            function createRange(document1, node) {
                return main.Range.create(document1.positionAt(node.offset + 1), document1.positionAt(node.offset + node.length - 1));
            }
            function findTargetNode(doc, path) {
                const tokens = parseJSONPointer(path);
                if (!tokens) {
                    return null;
                }
                return findNode(tokens, doc.root);
            }
            function findNode(pointer, node) {
                if (!node) {
                    return null;
                }
                if (pointer.length === 0) {
                    return node;
                }
                const token = pointer.shift();
                if (node && node.type === 'object') {
                    const propertyNode = node.properties.find((propertyNode)=>propertyNode.keyNode.value === token);
                    if (!propertyNode) {
                        return null;
                    }
                    return findNode(pointer, propertyNode.valueNode);
                } else if (node && node.type === 'array') {
                    if (token.match(/^(0|[1-9][0-9]*)$/)) {
                        const index = Number.parseInt(token);
                        const arrayItem = node.items[index];
                        if (!arrayItem) {
                            return null;
                        }
                        return findNode(pointer, arrayItem);
                    }
                }
                return null;
            }
            function parseJSONPointer(path) {
                if (path === "#") {
                    return [];
                }
                if (path[0] !== '#' || path[1] !== '/') {
                    return null;
                }
                return path.substring(2).split(/\//).map(jsonLinks_unescape);
            }
            function jsonLinks_unescape(str) {
                return str.replace(/~1/g, '/').replace(/~0/g, '~');
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageService.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getLanguageService(params) {
                const promise = params.promiseConstructor || Promise;
                const jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);
                jsonSchemaService.setSchemaContributions(schemaContributions);
                const jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);
                const jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);
                const jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);
                const jsonValidation = new JSONValidation(jsonSchemaService, promise);
                return {
                    configure: (settings)=>{
                        var _settings_schemas;
                        jsonSchemaService.clearExternalSchemas();
                        (_settings_schemas = settings.schemas) === null || _settings_schemas === void 0 ? void 0 : _settings_schemas.forEach(jsonSchemaService.registerExternalSchema.bind(jsonSchemaService));
                        jsonValidation.configure(settings);
                    },
                    resetSchema: (uri)=>jsonSchemaService.onResourceChange(uri),
                    doValidation: jsonValidation.doValidation.bind(jsonValidation),
                    getLanguageStatus: jsonValidation.getLanguageStatus.bind(jsonValidation),
                    parseJSONDocument: (document1)=>jsonParser_parse(document1, {
                            collectComments: true
                        }),
                    newJSONDocument: (root, diagnostics)=>newJSONDocument(root, diagnostics),
                    getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),
                    doResolve: jsonCompletion.doResolve.bind(jsonCompletion),
                    doComplete: jsonCompletion.doComplete.bind(jsonCompletion),
                    findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),
                    findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),
                    findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),
                    getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),
                    doHover: jsonHover.doHover.bind(jsonHover),
                    getFoldingRanges: getFoldingRanges,
                    getSelectionRanges: getSelectionRanges,
                    findDefinition: ()=>Promise.resolve([]),
                    findLinks: findLinks,
                    format: (document1, range, options)=>utils_format_format(document1, options, range),
                    sort: (document1, options)=>sort(document1, options)
                };
            }
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var browser_main = __nested_webpack_require_701415__(294);
            // EXTERNAL MODULE: ./src/utils.ts
            var utils = __nested_webpack_require_701415__(6297);
            ; // CONCATENATED MODULE: ./src/ace/range-singleton.ts
            function _define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class AceRange {
                static getConstructor(editor) {
                    if (!AceRange._instance && editor) {
                        AceRange._instance = editor.getSelectionRange().constructor;
                    }
                    return AceRange._instance;
                }
            }
            _define_property(AceRange, "_instance", void 0);
            ; // CONCATENATED MODULE: ./src/type-converters/common-converters.ts
            var common_converters_CommonConverter;
            (function(CommonConverter1) {
                function normalizeRanges(completions) {
                    return completions && completions.map((el)=>{
                        if (el["range"]) {
                            el["range"] = toRange(el["range"]);
                        }
                        return el;
                    });
                }
                CommonConverter1.normalizeRanges = normalizeRanges;
                function cleanHtml(html) {
                    return html.replace(/<a\s/, "<a target='_blank' ");
                }
                CommonConverter1.cleanHtml = cleanHtml;
                function toRange(range) {
                    if (!range || !range.start || !range.end) {
                        return;
                    }
                    let Range = AceRange.getConstructor();
                    // @ts-ignore
                    return Range.fromPoints(range.start, range.end);
                }
                CommonConverter1.toRange = toRange;
                function convertKind(kind) {
                    switch(kind){
                        case "primitiveType":
                        case "keyword":
                            return browser_main.CompletionItemKind.Keyword;
                        case "variable":
                        case "localVariable":
                            return browser_main.CompletionItemKind.Variable;
                        case "memberVariable":
                        case "memberGetAccessor":
                        case "memberSetAccessor":
                            return browser_main.CompletionItemKind.Field;
                        case "function":
                        case "memberFunction":
                        case "constructSignature":
                        case "callSignature":
                        case "indexSignature":
                            return browser_main.CompletionItemKind.Function;
                        case "enum":
                            return browser_main.CompletionItemKind.Enum;
                        case "module":
                            return browser_main.CompletionItemKind.Module;
                        case "class":
                            return browser_main.CompletionItemKind.Class;
                        case "interface":
                            return browser_main.CompletionItemKind.Interface;
                        case "warning":
                            return browser_main.CompletionItemKind.File;
                    }
                    return browser_main.CompletionItemKind.Property;
                }
                CommonConverter1.convertKind = convertKind;
                function excludeByErrorMessage(diagnostics, errorMessagesToIgnore, fieldName = "message") {
                    if (!errorMessagesToIgnore) return diagnostics;
                    return diagnostics.filter((el)=>!(0, utils /* checkValueAgainstRegexpArray */ .$p)(el[fieldName], errorMessagesToIgnore));
                }
                CommonConverter1.excludeByErrorMessage = excludeByErrorMessage;
            })(common_converters_CommonConverter || (common_converters_CommonConverter = {}));
            ; // CONCATENATED MODULE: ./src/type-converters/lsp-converters.ts
            function fromRange(range) {
                return {
                    start: {
                        line: range.start.row,
                        character: range.start.column
                    },
                    end: {
                        line: range.end.row,
                        character: range.end.column
                    }
                };
            }
            function rangeFromPositions(start, end) {
                return {
                    start: start,
                    end: end
                };
            }
            function toRange(range) {
                return {
                    start: {
                        row: range.start.line,
                        column: range.start.character
                    },
                    end: {
                        row: range.end.line,
                        column: range.end.character
                    }
                };
            }
            function fromPoint(point) {
                return {
                    line: point.row,
                    character: point.column
                };
            }
            function toPoint(position) {
                return {
                    row: position.line,
                    column: position.character
                };
            }
            function toAnnotations(diagnostics) {
                return diagnostics.map((el)=>{
                    return {
                        row: el.range.start.line,
                        column: el.range.start.character,
                        text: el.message,
                        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info"
                    };
                });
            }
            function toCompletion(item) {
                var _item_textEdit, _item_command;
                let itemKind = item.kind;
                let kind = itemKind ? Object.keys(CompletionItemKind)[Object.values(CompletionItemKind).indexOf(itemKind)] : undefined;
                var _item_textEdit_newText, _ref;
                let text = (_ref = (_item_textEdit_newText = (_item_textEdit = item.textEdit) === null || _item_textEdit === void 0 ? void 0 : _item_textEdit.newText) !== null && _item_textEdit_newText !== void 0 ? _item_textEdit_newText : item.insertText) !== null && _ref !== void 0 ? _ref : item.label;
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.textEdit ? getTextEditRange(item.textEdit) : undefined;
                let completion = {
                    meta: kind,
                    caption: item.label,
                    score: undefined
                };
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (item.insertTextFormat == InsertTextFormat.Snippet) {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["documentation"] = item.documentation; //TODO: this is workaround for services with instant completion
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = completions.map((el)=>{
                        if (!el.completions) {
                            return [];
                        }
                        let allCompletions;
                        if (Array.isArray(el.completions)) {
                            allCompletions = el.completions;
                        } else {
                            allCompletions = el.completions.items;
                        }
                        return allCompletions.map((item)=>{
                            item["service"] = el.service;
                            return item;
                        });
                    }).flat();
                    return combinedCompletions.map((item)=>toCompletion(item));
                }
                return [];
            }
            function toResolvedCompletion(completion, item) {
                completion["docMarkdown"] = fromMarkupContent(item.documentation);
                return completion;
            }
            function toCompletionItem(completion) {
                let command;
                if (completion["command"]) {
                    command = {
                        title: "triggerSuggest",
                        command: completion["command"]
                    };
                }
                var _completion_caption;
                let completionItem = {
                    label: (_completion_caption = completion.caption) !== null && _completion_caption !== void 0 ? _completion_caption : "",
                    kind: CommonConverter.convertKind(completion.meta),
                    command: command,
                    insertTextFormat: completion["snippet"] ? InsertTextFormat.Snippet : InsertTextFormat.PlainText,
                    documentation: completion["documentation"]
                };
                if (completion["range"]) {
                    var _completion_snippet;
                    completionItem.textEdit = {
                        range: fromRange(completion["range"]),
                        newText: (_completion_snippet = completion["snippet"]) !== null && _completion_snippet !== void 0 ? _completion_snippet : completion["value"]
                    };
                } else {
                    var _completion_snippet1;
                    completionItem.insertText = (_completion_snippet1 = completion["snippet"]) !== null && _completion_snippet1 !== void 0 ? _completion_snippet1 : completion["value"];
                }
                completionItem["fileName"] = completion["fileName"];
                completionItem["position"] = completion["position"];
                completionItem["item"] = completion["item"];
                completionItem["service"] = completion["service"]; //TODO:
                return completionItem;
            }
            function getTextEditRange(textEdit) {
                if (textEdit.hasOwnProperty("insert") && textEdit.hasOwnProperty("replace")) {
                    textEdit = textEdit;
                    let mergedRanges = mergeRanges([
                        toRange(textEdit.insert),
                        toRange(textEdit.replace)
                    ]);
                    return mergedRanges[0];
                } else {
                    textEdit = textEdit;
                    return toRange(textEdit.range);
                }
            }
            function toTooltip(hover) {
                var _hover_find;
                if (!hover) return;
                let content = hover.map((el)=>{
                    if (!el || !el.contents) return;
                    if (MarkupContent.is(el.contents)) {
                        return fromMarkupContent(el.contents);
                    } else if (MarkedString.is(el.contents)) {
                        if (typeof el.contents === "string") {
                            return el.contents;
                        }
                        return "```" + el.contents.value + "```";
                    } else {
                        let contents = el.contents.map((el)=>{
                            if (typeof el !== "string") {
                                return `\`\`\`${el.value}\`\`\``;
                            } else {
                                return el;
                            }
                        });
                        return contents.join("\n\n");
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                //TODO: it could be merged within all ranges in future
                let lspRange = (_hover_find = hover.find((el)=>{
                    var _el;
                    return (_el = el) === null || _el === void 0 ? void 0 : _el.range;
                })) === null || _hover_find === void 0 ? void 0 : _hover_find.range;
                let range;
                if (lspRange) range = toRange(lspRange);
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    },
                    range: range
                };
            }
            function fromSignatureHelp(signatureHelp) {
                if (!signatureHelp) return;
                let content = signatureHelp.map((el)=>{
                    var _el, _el1;
                    if (!el) return;
                    let signatureIndex = ((_el = el) === null || _el === void 0 ? void 0 : _el.activeSignature) || 0;
                    let activeSignature = el.signatures[signatureIndex];
                    if (!activeSignature) return;
                    let activeParam = (_el1 = el) === null || _el1 === void 0 ? void 0 : _el1.activeParameter;
                    let contents = activeSignature.label;
                    if (activeParam != undefined && activeSignature.parameters && activeSignature.parameters[activeParam]) {
                        let param = activeSignature.parameters[activeParam].label;
                        if (typeof param == "string") {
                            contents = contents.replace(param, `**${param}**`);
                        }
                    }
                    if (activeSignature.documentation) {
                        if (MarkupContent.is(activeSignature.documentation)) {
                            return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
                        } else {
                            contents += "\n\n" + activeSignature.documentation;
                            return contents;
                        }
                    } else {
                        return contents;
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            }
            function fromMarkupContent(content) {
                if (!content) return;
                if (typeof content === "string") {
                    return content;
                } else {
                    return content.value;
                }
            }
            function fromAceDelta(delta, eol) {
                const text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
                return {
                    range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
                    text: delta.action === "insert" ? text : ""
                };
            }
            function filterDiagnostics(diagnostics, filterErrors) {
                return common_converters_CommonConverter.excludeByErrorMessage(diagnostics, filterErrors.errorMessagesToIgnore).map((el)=>{
                    if ((0, utils /* checkValueAgainstRegexpArray */ .$p)(el.message, filterErrors.errorMessagesToTreatAsWarning)) {
                        el.severity = browser_main.DiagnosticSeverity.Warning;
                    } else if ((0, utils /* checkValueAgainstRegexpArray */ .$p)(el.message, filterErrors.errorMessagesToTreatAsInfo)) {
                        el.severity = browser_main.DiagnosticSeverity.Information;
                    }
                    return el;
                });
            }
            function fromDocumentHighlights(documentHighlights) {
                return documentHighlights.map(function(el) {
                    let className = el.kind == 2 ? "language_highlight_read" : el.kind == 3 ? "language_highlight_write" : "language_highlight_text";
                    return toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), className);
                });
            }
            function toMarkerGroupItem(range, className, tooltipText) {
                let markerGroupItem = {
                    range: range,
                    className: className
                };
                if (tooltipText) {
                    markerGroupItem["tooltipText"] = tooltipText;
                }
                return markerGroupItem;
            }
            ; // CONCATENATED MODULE: ./src/services/json/json-service.ts
            function json_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class JsonService extends base_service.BaseService {
                $getJsonSchemaUri(sessionID) {
                    return this.getOption(sessionID, "schemaUri");
                }
                addDocument(document1) {
                    super.addDocument(document1);
                    this.$configureService(document1.uri);
                }
                $configureService(sessionID) {
                    var _schemas;
                    let schemas = this.getOption(sessionID !== null && sessionID !== void 0 ? sessionID : "", "schemas");
                    let sessionIDs = sessionID ? [] : Object.keys(this.documents);
                    (_schemas = schemas) === null || _schemas === void 0 ? void 0 : _schemas.forEach((el)=>{
                        if (sessionID) {
                            if (this.$getJsonSchemaUri(sessionID) == el.uri) {
                                var _el;
                                var _fileMatch;
                                (_fileMatch = (_el = el).fileMatch) !== null && _fileMatch !== void 0 ? _fileMatch : _el.fileMatch = [];
                                el.fileMatch.push(sessionID);
                            }
                        } else {
                            el.fileMatch = sessionIDs.filter((sessionID)=>this.$getJsonSchemaUri(sessionID) == el.uri);
                        }
                        var _el_schema;
                        let schema = (_el_schema = el.schema) !== null && _el_schema !== void 0 ? _el_schema : this.schemas[el.uri];
                        if (schema) this.schemas[el.uri] = schema;
                        this.$service.resetSchema(el.uri);
                        el.schema = undefined;
                    });
                    this.$service.configure({
                        schemas: schemas,
                        allowComments: this.mode === "json5"
                    });
                }
                removeDocument(document1) {
                    var _schemas;
                    super.removeDocument(document1);
                    let schemas = this.getOption(document1.uri, "schemas");
                    (_schemas = schemas) === null || _schemas === void 0 ? void 0 : _schemas.forEach((el)=>{
                        if (el.uri === this.$getJsonSchemaUri(document1.uri)) {
                            var _el_fileMatch;
                            el.fileMatch = (_el_fileMatch = el.fileMatch) === null || _el_fileMatch === void 0 ? void 0 : _el_fileMatch.filter((pattern)=>pattern != document1.uri);
                        }
                    });
                    this.$service.configure({
                        schemas: schemas,
                        allowComments: this.mode === "json5"
                    });
                }
                setOptions(sessionID, options, merge = false) {
                    super.setOptions(sessionID, options, merge);
                    this.$configureService(sessionID);
                }
                setGlobalOptions(options) {
                    super.setGlobalOptions(options);
                    this.$configureService();
                }
                format(document1, range, options) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return Promise.resolve([]);
                    return Promise.resolve(this.$service.format(fullDocument, range, options));
                }
                async doHover(document1, position) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return null;
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    return this.$service.doHover(fullDocument, position, jsonDocument);
                }
                async doValidation(document1) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return [];
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    let diagnostics = await this.$service.doValidation(fullDocument, jsonDocument, {
                        trailingCommas: this.mode === "json5" ? "ignore" : "error"
                    });
                    return filterDiagnostics(diagnostics, this.optionsToFilterDiagnostics);
                }
                async doComplete(document1, position) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return null;
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    return this.$service.doComplete(fullDocument, position, jsonDocument);
                }
                async doResolve(item) {
                    return this.$service.doResolve(item);
                }
                constructor(mode){
                    super(mode);
                    json_service_define_property(this, "$service", void 0);
                    json_service_define_property(this, "schemas", {});
                    json_service_define_property(this, "serviceCapabilities", {
                        completionProvider: {
                            triggerCharacters: [
                                '"',
                                ':'
                            ]
                        },
                        diagnosticProvider: {
                            interFileDependencies: true,
                            workspaceDiagnostics: true
                        }
                    });
                    this.$service = getLanguageService({
                        schemaRequestService: (uri)=>{
                            uri = uri.replace("file:///", "");
                            let jsonSchema = this.schemas[uri];
                            if (jsonSchema) return Promise.resolve(jsonSchema);
                            return Promise.reject(`Unable to load schema at ${uri}`);
                        }
                    });
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztnQkFDL0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMs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N2EsT0FBTyxDQUFDLFlBQVk7NEJBQzlCLElBQUk2K0UsYUFBYSxJQUFJLENBQUNyc0IsT0FBTyxDQUFDMzNDLElBQUk7NEJBQ2xDLElBQUlna0UsWUFBWSxPQUFPL3BGLFFBQVFDLE9BQU8sQ0FBQzhwRjs0QkFDdkMsT0FBTy9wRixRQUFRb3hCLE1BQU0sQ0FBQyxDQUFDLHlCQUF5QixFQUFFckwsSUFBSSxDQUFDO3dCQUMzRDtvQkFDSjtnQkFDSjtZQUNKO1FBRUE7UUFFQSxNQUFNLEdBQUksT0FBT1IsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL2FjZS1saW50ZXJzLXJvb3QvLi9wYWNrYWdlcy9hY2UtbGludGVycy9idWlsZC9qc29uLXNlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gMTY5Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDA2KTtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MTYpO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9hc3NlcnQuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMmE1MWFlNDI0YTUxM2VjOWE2YWEzNDY2YmFhMGNjMWQ1NWRkNGYzYlxuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzUxNSksXG4gICAgX3JlcXVpcmUkY29kZXMgPSBfcmVxdWlyZS5jb2RlcyxcbiAgICBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX0FNQklHVU9VU19BUkdVTUVOVCxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9JTlZBTElEX0FSR19WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19WQUxVRSxcbiAgICBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1M7XG5cbnZhciBBc3NlcnRpb25FcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDA4Mik7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMzUpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gKF9fd2VicGFja19yZXF1aXJlX18oMzMzNSkudHlwZXMpLFxuICAgIGlzUHJvbWlzZSA9IF9yZXF1aXJlJHR5cGVzLmlzUHJvbWlzZSxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwO1xuXG52YXIgb2JqZWN0QXNzaWduID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24gOiAoX193ZWJwYWNrX3JlcXVpcmVfXyg0OTU2KS5hc3NpZ24pO1xudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogX193ZWJwYWNrX3JlcXVpcmVfXyg0Njc5KTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3OTYpO1xuXG4gIGlzRGVlcEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBFcXVhbDtcbiAgaXNEZWVwU3RyaWN0RXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcFN0cmljdEVxdWFsO1xufSAvLyBFc2NhcGUgY29udHJvbCBjaGFyYWN0ZXJzIGJ1dCBub3QgXFxuIGFuZCBcXHQgdG8ga2VlcCB0aGUgbGluZSBicmVha3MgYW5kXG4vLyBpbmRlbnRhdGlvbiBpbnRhY3QuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG5cbnZhciBlc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xceDAwLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXS9nO1xudmFyIG1ldGEgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbXCJcXFxcdTAwMDBcIiwgXCJcXFxcdTAwMDFcIiwgXCJcXFxcdTAwMDJcIiwgXCJcXFxcdTAwMDNcIiwgXCJcXFxcdTAwMDRcIiwgXCJcXFxcdTAwMDVcIiwgXCJcXFxcdTAwMDZcIiwgXCJcXFxcdTAwMDdcIiwgJ1xcXFxiJywgJycsICcnLCBcIlxcXFx1MDAwYlwiLCAnXFxcXGYnLCAnJywgXCJcXFxcdTAwMGVcIiwgXCJcXFxcdTAwMGZcIiwgXCJcXFxcdTAwMTBcIiwgXCJcXFxcdTAwMTFcIiwgXCJcXFxcdTAwMTJcIiwgXCJcXFxcdTAwMTNcIiwgXCJcXFxcdTAwMTRcIiwgXCJcXFxcdTAwMTVcIiwgXCJcXFxcdTAwMTZcIiwgXCJcXFxcdTAwMTdcIiwgXCJcXFxcdTAwMThcIiwgXCJcXFxcdTAwMTlcIiwgXCJcXFxcdTAwMWFcIiwgXCJcXFxcdTAwMWJcIiwgXCJcXFxcdTAwMWNcIiwgXCJcXFxcdTAwMWRcIiwgXCJcXFxcdTAwMWVcIiwgXCJcXFxcdTAwMWZcIl0pKTtcblxudmFyIGVzY2FwZUZuID0gZnVuY3Rpb24gZXNjYXBlRm4oc3RyKSB7XG4gIHJldHVybiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTtcbn07XG5cbnZhciB3YXJuZWQgPSBmYWxzZTsgLy8gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xudmFyIE5PX0VYQ0VQVElPTl9TRU5USU5FTCA9IHt9OyAvLyBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGlubmVyRmFpbChvYmopIHtcbiAgaWYgKG9iai5tZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG9iai5tZXNzYWdlO1xuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZuKSB7XG4gIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGludGVybmFsTWVzc2FnZTtcblxuICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgIGludGVybmFsTWVzc2FnZSA9ICdGYWlsZWQnO1xuICB9IGVsc2UgaWYgKGFyZ3NMZW4gPT09IDEpIHtcbiAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAod2FybmVkID09PSBmYWxzZSkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHZhciB3YXJuID0gcHJvY2Vzcy5lbWl0V2FybmluZyA/IHByb2Nlc3MuZW1pdFdhcm5pbmcgOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgIHdhcm4oJ2Fzc2VydC5mYWlsKCkgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSBhc3NlcnQuc3RyaWN0RXF1YWwoKSBpbnN0ZWFkIG9yIG9ubHkgcGFzcyBhIG1lc3NhZ2UuJywgJ0RlcHJlY2F0aW9uV2FybmluZycsICdERVAwMDk0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3NMZW4gPT09IDIpIG9wZXJhdG9yID0gJyE9JztcbiAgfVxuXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG1lc3NhZ2U7XG4gIHZhciBlcnJBcmdzID0ge1xuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdmYWlsJyA6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuIHx8IGZhaWxcbiAgfTtcblxuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyQXJncy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyQXJncyk7XG5cbiAgaWYgKGludGVybmFsTWVzc2FnZSkge1xuICAgIGVyci5tZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuXG4gIHRocm93IGVycjtcbn1cblxuYXNzZXJ0LmZhaWwgPSBmYWlsOyAvLyBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBpbnRlcm5hbC9lcnJvci5cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbmZ1bmN0aW9uIGlubmVyT2soZm4sIGFyZ0xlbiwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHZhciBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG5cbiAgICBpZiAoYXJnTGVuID09PSAwKSB7XG4gICAgICBnZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgIG1lc3NhZ2UgPSAnTm8gdmFsdWUgYXJndW1lbnQgcGFzc2VkIHRvIGBhc3NlcnQub2soKWAnO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cblxuICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiB2YWx1ZSxcbiAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn0gLy8gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISF2YWx1ZS5cblxuXG5mdW5jdGlvbiBvaygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbb2ssIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQub2sgPSBvazsgLy8gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoID09LlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdFxuLy8gZXF1YWwgd2l0aCAhPS5cblxuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnIT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cblxuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG5cblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcblxuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKCFvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ3N0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAob2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBDb21wYXJpc29uID0gZnVuY3Rpb24gQ29tcGFyaXNvbihvYmosIGtleXMsIGFjdHVhbCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wYXJpc29uKTtcblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoYWN0dWFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChvYmpba2V5XSkgJiYgb2JqW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IGFjdHVhbFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbWVzc2FnZSwga2V5cywgZm4pIHtcbiAgaWYgKCEoa2V5IGluIGFjdHVhbCkgfHwgIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbFtrZXldLCBleHBlY3RlZFtrZXldKSkge1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIG9iamVjdHMgdG8gY3JlYXRlIGEgbmljZSBvdXRwdXQuXG4gICAgICB2YXIgYSA9IG5ldyBDb21wYXJpc29uKGFjdHVhbCwga2V5cyk7XG4gICAgICB2YXIgYiA9IG5ldyBDb21wYXJpc29uKGV4cGVjdGVkLCBrZXlzLCBhY3R1YWwpO1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIuYWN0dWFsID0gYWN0dWFsO1xuICAgICAgZXJyLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogZm4ubmFtZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBtc2csIGZuKSB7XG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoaXNSZWdFeHAoZXhwZWN0ZWQpKSByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBhc3NlcnQuZG9lc05vdFRocm93IGRvZXMgbm90IGFjY2VwdCBvYmplY3RzLlxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXhwZWN0ZWQnLCBbJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBleHBlY3RlZCk7XG4gICAgfSAvLyBIYW5kbGUgcHJpbWl0aXZlcyBwcm9wZXJseS5cblxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gU3BlY2lhbCBoYW5kbGUgZXJyb3JzIHRvIG1ha2Ugc3VyZSB0aGUgbmFtZSBhbmQgdGhlIG1lc3NhZ2UgYXJlIGNvbXBhcmVkXG4gICAgLy8gYXMgd2VsbC5cblxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBrZXlzLnB1c2goJ25hbWUnLCAnbWVzc2FnZScpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoJ2Vycm9yJywgZXhwZWN0ZWQsICdtYXkgbm90IGJlIGFuIGVtcHR5IG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAoZXhwZWN0ZWRba2V5XSkgJiYgZXhwZWN0ZWRba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtc2csIGtleXMsIGZuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBHdWFyZCBpbnN0YW5jZW9mIGFnYWluc3QgYXJyb3cgZnVuY3Rpb25zIGFzIHRoZXkgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZS5cblxuXG4gIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEFjdHVhbChmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsICdGdW5jdGlvbicsIGZuKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbn1cblxuZnVuY3Rpb24gY2hlY2tJc1Byb21pc2Uob2JqKSB7XG4gIC8vIEFjY2VwdCBuYXRpdmUgRVM2IHByb21pc2VzIGFuZCBwcm9taXNlcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBpbiBhIHNpbWlsYXJcbiAgLy8gd2F5LiBEbyBub3QgYWNjZXB0IHRoZW5hYmxlcyB0aGF0IHVzZSBhIGZ1bmN0aW9uIGFzIGBvYmpgIGFuZCB0aGF0IGhhdmUgbm9cbiAgLy8gYGNhdGNoYCBoYW5kbGVyLlxuICAvLyBUT0RPOiB0aGVuYWJsZXMgYXJlIGNoZWNrZWQgdXAgdW50aWwgdGhleSBoYXZlIHRoZSBjb3JyZWN0IG1ldGhvZHMsXG4gIC8vIGJ1dCBhY2NvcmRpbmcgdG8gZG9jdW1lbnRhdGlvbiwgdGhlIGB0aGVuYCBtZXRob2Qgc2hvdWxkIHJlY2VpdmVcbiAgLy8gdGhlIGBmdWxmaWxsYCBhbmQgYHJlamVjdGAgYXJndW1lbnRzIGFzIHdlbGwgb3IgaXQgbWF5IGJlIG5ldmVyIHJlc29sdmVkLlxuICByZXR1cm4gaXNQcm9taXNlKG9iaikgfHwgb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY2F0Y2ggPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0UHJvbWlzZTtcblxuICAgIGlmICh0eXBlb2YgcHJvbWlzZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBSZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGlmIGBwcm9taXNlRm5gIHRocm93cyBzeW5jaHJvbm91c2x5LlxuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbigpOyAvLyBGYWlsIGluIGNhc2Ugbm8gcHJvbWlzZSBpcyByZXR1cm5lZC5cblxuICAgICAgaWYgKCFjaGVja0lzUHJvbWlzZShyZXN1bHRQcm9taXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdpbnN0YW5jZSBvZiBQcm9taXNlJywgJ3Byb21pc2VGbicsIHJlc3VsdFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hlY2tJc1Byb21pc2UocHJvbWlzZUZuKSkge1xuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdwcm9taXNlRm4nLCBbJ0Z1bmN0aW9uJywgJ1Byb21pc2UnXSwgcHJvbWlzZUZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXhwZWN0c0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChhY3R1YWwubWVzc2FnZSA9PT0gZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBtZXNzYWdlIFxcXCJcIi5jb25jYXQoYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFjdHVhbCA9PT0gZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgXFxcIlwiLmNvbmNhdChhY3R1YWwsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZXJyb3IgIT0gbnVsbCAmJiBfdHlwZW9mKGVycm9yKSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gIH1cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHtcbiAgICB2YXIgZGV0YWlscyA9ICcnO1xuXG4gICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUpIHtcbiAgICAgIGRldGFpbHMgKz0gXCIgKFwiLmNvbmNhdChlcnJvci5uYW1lLCBcIilcIik7XG4gICAgfVxuXG4gICAgZGV0YWlscyArPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdyZWplY3RzJyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIGV4cGVjdGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZXJyb3IgJiYgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UsIHN0YWNrU3RhcnRGbikpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0c05vRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFlcnJvciB8fCBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yKSkge1xuICAgIHZhciBkZXRhaWxzID0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAnZG9lc05vdFJlamVjdCcgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiR290IHVud2FudGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzLCBcIlxcblwiKSArIFwiQWN0dWFsIG1lc3NhZ2U6IFxcXCJcIi5jb25jYXQoYWN0dWFsICYmIGFjdHVhbC5tZXNzYWdlLCBcIlxcXCJcIiksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgYWN0dWFsO1xufVxuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gdGhyb3dzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbdGhyb3dzLCBnZXRBY3R1YWwocHJvbWlzZUZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5yZWplY3RzID0gZnVuY3Rpb24gcmVqZWN0cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3JlamVjdHMsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgfVxuXG4gIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RUaHJvdywgZ2V0QWN0dWFsKGZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5kb2VzTm90UmVqZWN0ID0gZnVuY3Rpb24gZG9lc05vdFJlamVjdChmbikge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChmbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RSZWplY3QsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uIGlmRXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdpZkVycm9yIGdvdCB1bndhbnRlZCBleGNlcHRpb246ICc7XG5cbiAgICBpZiAoX3R5cGVvZihlcnIpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UubGVuZ3RoID09PSAwICYmIGVyci5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSBpbnNwZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIG5ld0VyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IGVycixcbiAgICAgIGV4cGVjdGVkOiBudWxsLFxuICAgICAgb3BlcmF0b3I6ICdpZkVycm9yJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBzdGFja1N0YXJ0Rm46IGlmRXJyb3JcbiAgICB9KTsgLy8gTWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzdGFjayB0cmFjZSFcblxuICAgIHZhciBvcmlnU3RhY2sgPSBlcnIuc3RhY2s7XG5cbiAgICBpZiAodHlwZW9mIG9yaWdTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZW1vdmUgYW55IGR1cGxpY2F0ZWQgZnJhbWVzIGZyb20gdGhlIGVycm9yIGZyYW1lcyB0YWtlblxuICAgICAgLy8gZnJvbSB3aXRoaW4gYGlmRXJyb3JgIGFuZCBhZGQgdGhlIG9yaWdpbmFsIGVycm9yIGZyYW1lcyB0byB0aGUgbmV3bHlcbiAgICAgIC8vIGNyZWF0ZWQgb25lcy5cbiAgICAgIHZhciB0bXAyID0gb3JpZ1N0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHRtcDIuc2hpZnQoKTsgLy8gRmlsdGVyIGFsbCBmcmFtZXMgZXhpc3RpbmcgaW4gZXJyLnN0YWNrLlxuXG4gICAgICB2YXIgdG1wMSA9IG5ld0Vyci5zdGFjay5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBmcmFtZS5cbiAgICAgICAgdmFyIHBvcyA9IHRtcDEuaW5kZXhPZih0bXAyW2ldKTtcblxuICAgICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAgIC8vIE9ubHkga2VlcCBuZXcgZnJhbWVzLlxuICAgICAgICAgIHRtcDEgPSB0bXAxLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3RXJyLnN0YWNrID0gXCJcIi5jb25jYXQodG1wMS5qb2luKCdcXG4nKSwgXCJcXG5cIikuY29uY2F0KHRtcDIuam9pbignXFxuJykpO1xuICAgIH1cblxuICAgIHRocm93IG5ld0VycjtcbiAgfVxufTsgLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcblxuXG5mdW5jdGlvbiBzdHJpY3QoKSB7XG4gIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbc3RyaWN0LCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDgyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDYpO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzA4MTc4NDBmNzc1MDMyMTY5ZGRkNzBjODVhYzA1OWYxOGZmY2M4MWNcblxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzM1KSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUxNSksXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZTIuY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEU7IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCB8fCBjb3VudCA9PSAwKSByZXR1cm4gJyc7XG4gIHZhciBtYXhDb3VudCA9IHN0ci5sZW5ndGggKiBjb3VudDtcbiAgY291bnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKGNvdW50KSAvIE1hdGgubG9nKDIpKTtcblxuICB3aGlsZSAoY291bnQpIHtcbiAgICBzdHIgKz0gc3RyO1xuICAgIGNvdW50LS07XG4gIH1cblxuICBzdHIgKz0gc3RyLnN1YnN0cmluZygwLCBtYXhDb3VudCAtIHN0ci5sZW5ndGgpO1xuICByZXR1cm4gc3RyO1xufVxuXG52YXIgYmx1ZSA9ICcnO1xudmFyIGdyZWVuID0gJyc7XG52YXIgcmVkID0gJyc7XG52YXIgd2hpdGUgPSAnJztcbnZhciBrUmVhZGFibGVPcGVyYXRvciA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIG5vdERlZXBFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgbG9vc2VseSB1bmVxdWFsIHRvOicsXG4gIG5vdElkZW50aWNhbDogJ1ZhbHVlcyBpZGVudGljYWwgYnV0IG5vdCByZWZlcmVuY2UtZXF1YWw6J1xufTsgLy8gQ29tcGFyaW5nIHNob3J0IHByaW1pdGl2ZXMgc2hvdWxkIGp1c3Qgc2hvdyA9PT0gLyAhPT0gaW5zdGVhZCBvZiB1c2luZyB0aGVcbi8vIGRpZmYuXG5cbnZhciBrTWF4U2hvcnRMZW5ndGggPSAxMDtcblxuZnVuY3Rpb24gY29weUVycm9yKHNvdXJjZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ21lc3NhZ2UnLCB7XG4gICAgdmFsdWU6IHNvdXJjZS5tZXNzYWdlXG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0VmFsdWUodmFsKSB7XG4gIC8vIFRoZSB1dGlsLmluc3BlY3QgZGVmYXVsdCB2YWx1ZXMgY291bGQgYmUgY2hhbmdlZC4gVGhpcyBtYWtlcyBzdXJlIHRoZVxuICAvLyBlcnJvciBtZXNzYWdlcyBjb250YWluIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gbmV2ZXJ0aGVsZXNzLlxuICByZXR1cm4gaW5zcGVjdCh2YWwsIHtcbiAgICBjb21wYWN0OiBmYWxzZSxcbiAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICBkZXB0aDogMTAwMCxcbiAgICBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGNvbXBhcmVzIG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzICh3aXRoIGEgZmV3IGV4Y2VwdGlvbnMpLlxuICAgIHNob3dIaWRkZW46IGZhbHNlLFxuICAgIC8vIEhhdmluZyBhIGxvbmcgbGluZSBhcyBlcnJvciBpcyBiZXR0ZXIgdGhhbiB3cmFwcGluZyB0aGUgbGluZSBmb3JcbiAgICAvLyBjb21wYXJpc29uIGZvciBub3cuXG4gICAgLy8gVE9ETyhCcmlkZ2VBUik6IGBicmVha0xlbmd0aGAgc2hvdWxkIGJlIGxpbWl0ZWQgYXMgc29vbiBhcyBzb29uIGFzIHdlXG4gICAgLy8gaGF2ZSBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnNwZWN0ZWQgcHJvcGVydGllcyAoaS5lLiwga25vdyB3aGVyZVxuICAgIC8vIGluIHdoYXQgbGluZSB0aGUgcHJvcGVydHkgc3RhcnRzIGFuZCBlbmRzKS5cbiAgICBicmVha0xlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGRvZXMgbm90IGRldGVjdCBwcm94aWVzIGN1cnJlbnRseS5cbiAgICBzaG93UHJveHk6IGZhbHNlLFxuICAgIHNvcnRlZDogdHJ1ZSxcbiAgICAvLyBJbnNwZWN0IGdldHRlcnMgYXMgd2UgYWxzbyBjaGVjayB0aGVtIHdoZW4gY29tcGFyaW5nIGVudHJpZXMuXG4gICAgZ2V0dGVyczogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikge1xuICB2YXIgb3RoZXIgPSAnJztcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbGFzdFBvcyA9IDA7XG4gIHZhciBlbmQgPSAnJztcbiAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgdmFyIGFjdHVhbEluc3BlY3RlZCA9IGluc3BlY3RWYWx1ZShhY3R1YWwpO1xuICB2YXIgYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpO1xuICB2YXIgZXhwZWN0ZWRMaW5lcyA9IGluc3BlY3RWYWx1ZShleHBlY3RlZCkuc3BsaXQoJ1xcbicpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBpbmRpY2F0b3IgPSAnJzsgLy8gSW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgb2JqZWN0cyBleHBsaWNpdGx5IG1hcmsgdGhlbSBhcyBub3QgcmVmZXJlbmNlIGVxdWFsXG4gIC8vIGZvciB0aGUgYHN0cmljdEVxdWFsYCBvcGVyYXRvci5cblxuICBpZiAob3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcgJiYgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsICYmIGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgb3BlcmF0b3IgPSAnc3RyaWN0RXF1YWxPYmplY3QnO1xuICB9IC8vIElmIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiBmaXQgb24gYSBzaW5nbGUgbGluZSBhbmQgdGhleSBhcmUgbm90IHN0cmljdGx5XG4gIC8vIGVxdWFsLCBjaGVjayBmdXJ0aGVyIHNwZWNpYWwgaGFuZGxpbmcuXG5cblxuICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAxICYmIGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAxICYmIGFjdHVhbExpbmVzWzBdICE9PSBleHBlY3RlZExpbmVzWzBdKSB7XG4gICAgdmFyIGlucHV0TGVuZ3RoID0gYWN0dWFsTGluZXNbMF0ubGVuZ3RoICsgZXhwZWN0ZWRMaW5lc1swXS5sZW5ndGg7IC8vIElmIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiB0b2dldGhlciBpcyBsZXNzIHRoYW5cbiAgICAvLyBrTWF4U2hvcnRMZW5ndGggYW5kIGlmIG5laXRoZXIgaXMgYW4gb2JqZWN0IGFuZCBhdCBsZWFzdCBvbmUgb2YgdGhlbSBpc1xuICAgIC8vIG5vdCBgemVyb2AsIHVzZSB0aGUgc3RyaWN0IGVxdWFsIGNvbXBhcmlzb24gdG8gdmlzdWFsaXplIHRoZSBvdXRwdXQuXG5cbiAgICBpZiAoaW5wdXRMZW5ndGggPD0ga01heFNob3J0TGVuZ3RoKSB7XG4gICAgICBpZiAoKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSAmJiAoX3R5cGVvZihleHBlY3RlZCkgIT09ICdvYmplY3QnIHx8IGV4cGVjdGVkID09PSBudWxsKSAmJiAoYWN0dWFsICE9PSAwIHx8IGV4cGVjdGVkICE9PSAwKSkge1xuICAgICAgICAvLyAtMCA9PT0gKzBcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikgKyBcIlwiLmNvbmNhdChhY3R1YWxMaW5lc1swXSwgXCIgIT09IFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1swXSwgXCJcXG5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJ3N0cmljdEVxdWFsT2JqZWN0Jykge1xuICAgICAgLy8gSWYgdGhlIHN0ZGVyciBpcyBhIHR0eSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50XG4gICAgICAvLyBjb2x1bW5zIHBlciBsaW5lLCBhZGQgYSBtaXNtYXRjaCBpbmRpY2F0b3IgYmVsb3cgdGhlIG91dHB1dC4gSWYgaXQgaXNcbiAgICAgIC8vIG5vdCBhIHR0eSwgdXNlIGEgZGVmYXVsdCB2YWx1ZSBvZiA4MCBjaGFyYWN0ZXJzLlxuICAgICAgdmFyIG1heExlbmd0aCA9IHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZID8gcHJvY2Vzcy5zdGRlcnIuY29sdW1ucyA6IDgwO1xuXG4gICAgICBpZiAoaW5wdXRMZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKGFjdHVhbExpbmVzWzBdW2ldID09PSBleHBlY3RlZExpbmVzWzBdW2ldKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IC8vIElnbm9yZSB0aGUgZmlyc3QgY2hhcmFjdGVycy5cblxuXG4gICAgICAgIGlmIChpID4gMikge1xuICAgICAgICAgIC8vIEFkZCBwb3NpdGlvbiBpbmRpY2F0b3IgZm9yIHRoZSBmaXJzdCBtaXNtYXRjaCBpbiBjYXNlIGl0IGlzIGFcbiAgICAgICAgICAvLyBzaW5nbGUgbGluZSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIGNvbHVtbiBsZW5ndGguXG4gICAgICAgICAgaW5kaWNhdG9yID0gXCJcXG4gIFwiLmNvbmNhdChyZXBlYXQoJyAnLCBpKSwgXCJeXCIpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlbW92ZSBhbGwgZW5kaW5nIGxpbmVzIHRoYXQgbWF0Y2ggKHRoaXMgb3B0aW1pemVzIHRoZSBvdXRwdXQgZm9yXG4gIC8vIHJlYWRhYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBudW1iZXIgb2YgdG90YWwgY2hhbmdlZCBsaW5lcykuXG5cblxuICB2YXIgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICB2YXIgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcblxuICB3aGlsZSAoYSA9PT0gYikge1xuICAgIGlmIChpKysgPCAyKSB7XG4gICAgICBlbmQgPSBcIlxcbiAgXCIuY29uY2F0KGEpLmNvbmNhdChlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlciA9IGE7XG4gICAgfVxuXG4gICAgYWN0dWFsTGluZXMucG9wKCk7XG4gICAgZXhwZWN0ZWRMaW5lcy5wb3AoKTtcbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAwIHx8IGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gICAgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHZhciBtYXhMaW5lcyA9IE1hdGgubWF4KGFjdHVhbExpbmVzLmxlbmd0aCwgZXhwZWN0ZWRMaW5lcy5sZW5ndGgpOyAvLyBTdHJpY3QgZXF1YWwgd2l0aCBpZGVudGljYWwgb2JqZWN0cyB0aGF0IGFyZSBub3QgaWRlbnRpY2FsIGJ5IHJlZmVyZW5jZS5cbiAgLy8gRS5nLiwgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh7IGE6IFN5bWJvbCgpIH0sIHsgYTogU3ltYm9sKCkgfSlcblxuICBpZiAobWF4TGluZXMgPT09IDApIHtcbiAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcmVzdWx0IGFnYWluLiBUaGUgbGluZXMgd2VyZSBhbGwgcmVtb3ZlZCBiZWZvcmUuXG4gICAgdmFyIF9hY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cblxuXG4gICAgaWYgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAzMCkge1xuICAgICAgX2FjdHVhbExpbmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgIHdoaWxlIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgX2FjdHVhbExpbmVzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvci5ub3RJZGVudGljYWwsIFwiXFxuXFxuXCIpLmNvbmNhdChfYWN0dWFsTGluZXMuam9pbignXFxuJyksIFwiXFxuXCIpO1xuICB9XG5cbiAgaWYgKGkgPiAzKSB7XG4gICAgZW5kID0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKS5jb25jYXQoZW5kKTtcbiAgICBza2lwcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvdGhlciAhPT0gJycpIHtcbiAgICBlbmQgPSBcIlxcbiAgXCIuY29uY2F0KG90aGVyKS5jb25jYXQoZW5kKTtcbiAgICBvdGhlciA9ICcnO1xuICB9XG5cbiAgdmFyIHByaW50ZWRMaW5lcyA9IDA7XG4gIHZhciBtc2cgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0gKyBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrIGFjdHVhbFwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQocmVkLCBcIi0gZXhwZWN0ZWRcIikuY29uY2F0KHdoaXRlKTtcbiAgdmFyIHNraXBwZWRNc2cgPSBcIiBcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlLCBcIiBMaW5lcyBza2lwcGVkXCIpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXhMaW5lczsgaSsrKSB7XG4gICAgLy8gT25seSBleHRyYSBleHBlY3RlZCBsaW5lcyBleGlzdFxuICAgIHZhciBjdXIgPSBpIC0gbGFzdFBvcztcblxuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBleHBlY3RlZCBsaW5lIHRvIHRoZSBjYWNoZS5cblxuICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7IC8vIE9ubHkgZXh0cmEgYWN0dWFsIGxpbmVzIGV4aXN0XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdC5cblxuICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBMaW5lcyBkaXZlcmdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBleHBlY3RlZExpbmUgPSBleHBlY3RlZExpbmVzW2ldO1xuICAgICAgdmFyIGFjdHVhbExpbmUgPSBhY3R1YWxMaW5lc1tpXTsgLy8gSWYgdGhlIGxpbmVzIGRpdmVyZ2UsIHNwZWNpZmljYWxseSBjaGVjayBmb3IgbGluZXMgdGhhdCBvbmx5IGRpdmVyZ2UgYnlcbiAgICAgIC8vIGEgdHJhaWxpbmcgY29tbWEuIEluIHRoYXQgY2FzZSBpdCBpcyBhY3R1YWxseSBpZGVudGljYWwgYW5kIHdlIHNob3VsZFxuICAgICAgLy8gbWFyayBpdCBhcyBzdWNoLlxuXG4gICAgICB2YXIgZGl2ZXJnaW5nTGluZXMgPSBhY3R1YWxMaW5lICE9PSBleHBlY3RlZExpbmUgJiYgKCFlbmRzV2l0aChhY3R1YWxMaW5lLCAnLCcpIHx8IGFjdHVhbExpbmUuc2xpY2UoMCwgLTEpICE9PSBleHBlY3RlZExpbmUpOyAvLyBJZiB0aGUgZXhwZWN0ZWQgbGluZSBoYXMgYSB0cmFpbGluZyBjb21tYSBidXQgaXMgb3RoZXJ3aXNlIGlkZW50aWNhbCxcbiAgICAgIC8vIGFkZCBhIGNvbW1hIGF0IHRoZSBlbmQgb2YgdGhlIGFjdHVhbCBsaW5lLiBPdGhlcndpc2UgdGhlIG91dHB1dCBjb3VsZFxuICAgICAgLy8gbG9vayB3ZWlyZCBhcyBpbjpcbiAgICAgIC8vXG4gICAgICAvLyAgIFtcbiAgICAgIC8vICAgICAxICAgICAgICAgLy8gTm8gY29tbWEgYXQgdGhlIGVuZCFcbiAgICAgIC8vICsgICAyXG4gICAgICAvLyAgIF1cbiAgICAgIC8vXG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcyAmJiBlbmRzV2l0aChleHBlY3RlZExpbmUsICcsJykgJiYgZXhwZWN0ZWRMaW5lLnNsaWNlKDAsIC0xKSA9PT0gYWN0dWFsTGluZSkge1xuICAgICAgICBkaXZlcmdpbmdMaW5lcyA9IGZhbHNlO1xuICAgICAgICBhY3R1YWxMaW5lICs9ICcsJztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzKSB7XG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdCBhbmQgY2FjaGUgdGhlIGV4cGVjdGVkIGRpdmVyZ2luZ1xuICAgICAgICAvLyBsaW5lIHNvIGNvbnNlY3V0aXZlIGRpdmVyZ2luZyBsaW5lcyBzaG93IHVwIGFzICsrKy0tLSBhbmQgbm90ICstKy0rLS5cblxuICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZSk7XG4gICAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmUpO1xuICAgICAgICBwcmludGVkTGluZXMgKz0gMjsgLy8gTGluZXMgYXJlIGlkZW50aWNhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIGFsbCBjYWNoZWQgaW5mb3JtYXRpb24gdG8gdGhlIHJlc3VsdCBiZWZvcmUgYWRkaW5nIG90aGVyIHRoaW5nc1xuICAgICAgICAvLyBhbmQgcmVzZXQgdGhlIGNhY2hlLlxuICAgICAgICByZXMgKz0gb3RoZXI7XG4gICAgICAgIG90aGVyID0gJyc7IC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIGV4YWN0bHkgb25lIGxpbmUgYWJvdmUgb3IgaWYgaXQgaXMgdGhlXG4gICAgICAgIC8vIHZlcnkgZmlyc3QgbGluZSwgYWRkIHRoZSBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgICAgaWYgKGN1ciA9PT0gMSB8fCBpID09PSAwKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEluc3BlY3RlZCBvYmplY3QgdG8gYmlnIChTaG93IH4yMCByb3dzIG1heClcblxuXG4gICAgaWYgKHByaW50ZWRMaW5lcyA+IDIwICYmIGkgPCBtYXhMaW5lcyAtIDIpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkTXNnLCBcIlxcblwiKS5jb25jYXQocmVzLCBcIlxcblwiKS5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKS5jb25jYXQob3RoZXIsIFwiXFxuXCIpICsgXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZCA/IHNraXBwZWRNc2cgOiAnJywgXCJcXG5cIikuY29uY2F0KHJlcykuY29uY2F0KG90aGVyKS5jb25jYXQoZW5kKS5jb25jYXQoaW5kaWNhdG9yKTtcbn1cblxudmFyIEFzc2VydGlvbkVycm9yID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEFzc2VydGlvbkVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNzZXJ0aW9uRXJyb3IpO1xuXG4gICAgaWYgKF90eXBlb2Yob3B0aW9ucykgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgb3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yLFxuICAgICAgICBzdGFja1N0YXJ0Rm4gPSBvcHRpb25zLnN0YWNrU3RhcnRGbjtcbiAgICB2YXIgYWN0dWFsID0gb3B0aW9ucy5hY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcblxuICAgIGlmIChtZXNzYWdlICE9IG51bGwpIHtcbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFN0cmluZyhtZXNzYWdlKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICAgICAgLy8gUmVzZXQgb24gZWFjaCBjYWxsIHRvIG1ha2Ugc3VyZSB3ZSBoYW5kbGUgZHluYW1pY2FsbHkgc2V0IGVudmlyb25tZW50XG4gICAgICAgIC8vIHZhcmlhYmxlcyBjb3JyZWN0LlxuICAgICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoKCkgIT09IDEpIHtcbiAgICAgICAgICBibHVlID0gXCJcXHgxQlszNG1cIjtcbiAgICAgICAgICBncmVlbiA9IFwiXFx4MUJbMzJtXCI7XG4gICAgICAgICAgd2hpdGUgPSBcIlxceDFCWzM5bVwiO1xuICAgICAgICAgIHJlZCA9IFwiXFx4MUJbMzFtXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmx1ZSA9ICcnO1xuICAgICAgICAgIGdyZWVuID0gJyc7XG4gICAgICAgICAgd2hpdGUgPSAnJztcbiAgICAgICAgICByZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQcmV2ZW50IHRoZSBlcnJvciBzdGFjayBmcm9tIGJlaW5nIHZpc2libGUgYnkgZHVwbGljYXRpbmcgdGhlIGVycm9yXG4gICAgICAvLyBpbiBhIHZlcnkgY2xvc2Ugd2F5IHRvIHRoZSBvcmlnaW5hbCBpbiBjYXNlIGJvdGggc2lkZXMgYXJlIGFjdHVhbGx5XG4gICAgICAvLyBpbnN0YW5jZXMgb2YgRXJyb3IuXG5cblxuICAgICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZCAhPT0gbnVsbCAmJiAnc3RhY2snIGluIGFjdHVhbCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBFcnJvciAmJiAnc3RhY2snIGluIGV4cGVjdGVkICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgYWN0dWFsID0gY29weUVycm9yKGFjdHVhbCk7XG4gICAgICAgIGV4cGVjdGVkID0gY29weUVycm9yKGV4cGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJykge1xuICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSkpO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ25vdERlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdub3RTdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgYnV0IHRoZSBvcGVyYXRvciByZXF1aXJlcyB1bmVxdWFsLCBzaG93XG4gICAgICAgIC8vIHRoZSBmaXJzdCBvYmplY3QgYW5kIHNheSBBIGVxdWFscyBCXG4gICAgICAgIHZhciBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdO1xuICAgICAgICB2YXIgcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCkuc3BsaXQoJ1xcbicpOyAvLyBJbiBjYXNlIFwiYWN0dWFsXCIgaXMgYW4gb2JqZWN0LCBpdCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZSBlcXVhbC5cblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3RTdHJpY3RFcXVhbCcgJiYgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgICAgICBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Iubm90U3RyaWN0RXF1YWxPYmplY3Q7XG4gICAgICAgIH0gLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAgICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cblxuXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICByZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcblxuICAgICAgICAgIHdoaWxlIChyZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gT25seSBwcmludCBhIHNpbmdsZSBpbnB1dC5cblxuXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCIgXCIpLmNvbmNhdChyZXNbMF0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCJcXG5cXG5cIikuY29uY2F0KHJlcy5qb2luKCdcXG4nKSwgXCJcXG5cIikpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9yZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcblxuICAgICAgICB2YXIgb3RoZXIgPSAnJztcbiAgICAgICAgdmFyIGtub3duT3BlcmF0b3JzID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdO1xuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdERlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdub3RFcXVhbCcpIHtcbiAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKS5jb25jYXQoX3Jlcyk7XG5cbiAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCAxMDIxKSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQoaW5zcGVjdFZhbHVlKGV4cGVjdGVkKSk7XG5cbiAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChfcmVzLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlci5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQob3RoZXIuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ2VxdWFsJykge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtub3duT3BlcmF0b3JzLCBcIlxcblxcblwiKS5jb25jYXQoX3JlcywgXCJcXG5cXG5zaG91bGQgZXF1YWxcXG5cXG5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyID0gXCIgXCIuY29uY2F0KG9wZXJhdG9yLCBcIiBcIikuY29uY2F0KG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChfcmVzKS5jb25jYXQob3RoZXIpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gICAgX3RoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXScsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICBfdGhpcy5hY3R1YWwgPSBhY3R1YWw7XG4gICAgX3RoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBzdGFja1N0YXJ0Rm4pO1xuICAgIH0gLy8gQ3JlYXRlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlIGluIHRoZSBuYW1lLlxuXG5cbiAgICBfdGhpcy5zdGFjazsgLy8gUmVzZXQgdGhlIG5hbWUuXG5cbiAgICBfdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFzc2VydGlvbkVycm9yLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiIFtcIikuY29uY2F0KHRoaXMuY29kZSwgXCJdOiBcIikuY29uY2F0KHRoaXMubWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBpbnNwZWN0LmN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVjdXJzZVRpbWVzLCBjdHgpIHtcbiAgICAgIC8vIFRoaXMgbGltaXRzIHRoZSBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYCBwcm9wZXJ0eSBkZWZhdWx0IGluc3BlY3Rpb24gdG9cbiAgICAgIC8vIHRoZSBtaW5pbXVtIGRlcHRoLiBPdGhlcndpc2UgdGhvc2UgdmFsdWVzIHdvdWxkIGJlIHRvbyB2ZXJib3NlIGNvbXBhcmVkXG4gICAgICAvLyB0byB0aGUgYWN0dWFsIGVycm9yIG1lc3NhZ2Ugd2hpY2ggY29udGFpbnMgYSBjb21iaW5lZCB2aWV3IG9mIHRoZXNlIHR3b1xuICAgICAgLy8gaW5wdXQgdmFsdWVzLlxuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgY3R4LCB7XG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgICAgICBkZXB0aDogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBc3NlcnRpb25FcnJvcjtcbn0oX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzUxNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4gLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4vLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcbi8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3Jcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgY29kZXMgPSB7fTsgLy8gTGF6eSBsb2FkZWRcblxudmFyIGFzc2VydDtcbnZhciB1dGlsO1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVFcnJvcik7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE5vZGVFcnJvcikuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSk7XG4gICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfQU1CSUdVT1VTX0FSR1VNRU5UJywgJ1RoZSBcIiVzXCIgYXJndW1lbnQgaXMgYW1iaWd1b3VzLiAlcycsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OTYpO1xuICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBcIiduYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIpOyAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXG5cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KF90eXBlb2YoYWN0dWFsKSk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2lzIGludmFsaWQnO1xuICBpZiAodXRpbCA9PT0gdW5kZWZpbmVkKSB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzM1KTtcbiAgdmFyIGluc3BlY3RlZCA9IHV0aWwuaW5zcGVjdCh2YWx1ZSk7XG5cbiAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAxMjgpIHtcbiAgICBpbnNwZWN0ZWQgPSBcIlwiLmNvbmNhdChpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSwgXCIuLi5cIik7XG4gIH1cblxuICByZXR1cm4gXCJUaGUgYXJndW1lbnQgJ1wiLmNvbmNhdChuYW1lLCBcIicgXCIpLmNvbmNhdChyZWFzb24sIFwiLiBSZWNlaXZlZCBcIikuY29uY2F0KGluc3BlY3RlZCk7XG59LCBUeXBlRXJyb3IsIFJhbmdlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnLCBmdW5jdGlvbiAoaW5wdXQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0eXBlO1xuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgdHlwZSA9IFwiaW5zdGFuY2Ugb2YgXCIuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBcInR5cGUgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiLmNvbmNhdChpbnB1dCwgXCIgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXFxcIlwiKS5jb25jYXQobmFtZSwgXCJcXFwiXCIpICsgXCIgZnVuY3Rpb24gYnV0IGdvdCBcIi5jb25jYXQodHlwZSwgXCIuXCIpO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01JU1NJTkdfQVJHUycsIGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjk2KTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYW5kIFwiKS5jb25jYXQoYXJnc1sxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Nzk2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xuXG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IF9fd2VicGFja19yZXF1aXJlX18oNDY3OSk7XG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXTtcbn07XG52YXIgbnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gPyBOdW1iZXIuaXNOYU4gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3ODIpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBvYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgX3JlcXVpcmUkdHlwZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzMzM1KS50eXBlcyksXG4gICAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1NykgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cblxuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoaXNOb25JbmRleCkuY29uY2F0KG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkuZmlsdGVyKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSkpKTtcbn0gLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIE9OTFlfRU5VTUVSQUJMRSA9IHVuZGVmaW5lZDtcbnZhciBrU3RyaWN0ID0gdHJ1ZTtcbnZhciBrTG9vc2UgPSBmYWxzZTtcbnZhciBrTm9JdGVyYXRvciA9IDA7XG52YXIga0lzQXJyYXkgPSAxO1xudmFyIGtJc1NldCA9IDI7XG52YXIga0lzTWFwID0gMzsgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcbi8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbi8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG4vLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4vLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXG4vL1xuLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXG4vLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4vLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxuLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbi8vXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcbi8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cblxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcblxuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXG4gICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XG4gIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgLy8gd2FuJ3QgdG8gZWFybHkgcmV0dXJuIG91dCBvZiB0aGUgcmVzdCBvZiB0aGUgY2hlY2tzLiBIb3dldmVyIHdlIGNhbiBjaGVja1xuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEYXRlKHZhbDEpKSB7XG4gICAgaWYgKCFpc0RhdGUodmFsMikgfHwgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDEpICE9PSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgIC8vIGlzIG90aGVyd2lzZSBpZGVudGljYWwuXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XG4gICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cblxuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoX2tleXMubGVuZ3RoICE9PSBfa2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcCk7XG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgIGlmICghYXJlRXF1YWxBcnJheUJ1ZmZlcnModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWwxKSAmJiAhaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcbiAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcblxuICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBVc2UgbWVtb3MgdG8gaGFuZGxlIGN5Y2xlcy5cblxuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG5cbiAgICBpZiAodmFsMk1lbW9BICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcblxuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG5cbiAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pO1xuICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbik7XG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcbiAgbWVtb3MudmFsMS5kZWxldGUodmFsMSk7XG4gIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpO1xuICByZXR1cm4gYXJlRXE7XG59XG5cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG5cbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XG4gIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwcmltID0gK3ByaW07XG4gICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG5cbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYWx0VmFsdWU7XG4gIH1cblxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcblxuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXG4gICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuXG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAhYS5oYXMoX3ZhbCkgJiYgIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRvIGJlIGFibGUgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAga2V5ID0gX2FFbnRyaWVzJGlbMF0sXG4gICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG5cbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlIHdlIHByZXZlbnQgYW5vdGhlciBiLmhhcyhrZXkpIGNoZWNrIGluXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KTtcblxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KGtleSksIGl0ZW0sIGZhbHNlLCBtZW1vKSkgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG5cbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzQVtpXTtcblxuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gIGlzRGVlcFN0cmljdEVxdWFsOiBpc0RlZXBTdHJpY3RFcXVhbFxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDI2ODA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyODYpO1xuXG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0MjkpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk0Mjk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDkwKTtcbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyODYpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzM1KVxudmFyIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5NilcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09IFwidW5kZWZpbmVkXCIgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTI2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2NCk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExODEpKCk7XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gb3JpZ0RlZmluZVByb3BlcnR5ICYmIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKHByZWRpY2F0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0aWYgKG9iamVjdFtuYW1lXSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDk1Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGFzc2lnblxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnbixcbiAgcG9seWZpbGw6IHBvbHlmaWxsXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMjQzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTY4MCk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm9yRWFjaEFycmF5ID0gZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaFN0cmluZyA9IGZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlcmF0b3Ioc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaE9iamVjdCA9IGZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgb2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjZWl2ZXI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICByZWNlaXZlciA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgaWYgKHRvU3RyLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc3OTU6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDkwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3OTUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Mjg2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYzNikoKTtcbnZhciBoYXNQcm90byA9IF9fd2VicGFja19yZXF1aXJlX18oODQ4NikoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IChcblx0aGFzUHJvdG9cblx0XHQ/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cdFx0OiBudWxsXG4pO1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG5pZiAoZ2V0UHJvdG8pIHtcblx0dHJ5IHtcblx0XHRudWxsLmVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc2hhZG93cmVhbG0vcHVsbC8zODQjaXNzdWVjb21tZW50LTEzNjQyNjQyMjlcblx0XHR2YXIgZXJyb3JQcm90byA9IGdldFByb3RvKGdldFByb3RvKGUpKTtcblx0XHRJTlRSSU5TSUNTWyclRXJyb3IucHJvdG90eXBlJSddID0gZXJyb3JQcm90bztcblx0fVxufVxuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuICYmIGdldFByb3RvKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwOTApO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oMzE5OCk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMjY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyODYpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuXG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMTgxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mjg2KTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCFoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODQ4Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2NzkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Njc5OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MjI2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oNjY3OSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxOTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDkwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEyODU6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MzU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIyNikoKTtcbnZhciBjYWxsQm91bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2ODApO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NjgwOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcmVmbGVjdEFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QgIT09IG51bGwgJiYgUmVmbGVjdC5hcHBseTtcbnZhciBiYWRBcnJheUxpa2U7XG52YXIgaXNDYWxsYWJsZU1hcmtlcjtcbmlmICh0eXBlb2YgcmVmbGVjdEFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcblx0dHJ5IHtcblx0XHRiYWRBcnJheUxpa2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdsZW5ndGgnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgaXNDYWxsYWJsZU1hcmtlcjtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpc0NhbGxhYmxlTWFya2VyID0ge307XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblx0XHRyZWZsZWN0QXBwbHkoZnVuY3Rpb24gKCkgeyB0aHJvdyA0MjsgfSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0fSBjYXRjaCAoXykge1xuXHRcdGlmIChfICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkgPSBudWxsO1xuXHRcdH1cblx0fVxufSBlbHNlIHtcblx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcbn1cblxudmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzc1xcYi87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KGZuU3RyKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm90IGEgZnVuY3Rpb25cblx0fVxufTtcblxudmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25Ub1N0cih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGRkYUNsYXNzID0gJ1tvYmplY3QgSFRNTEFsbENvbGxlY3Rpb25dJzsgLy8gSUUgMTFcbnZhciBkZGFDbGFzczIgPSAnW29iamVjdCBIVE1MIGRvY3VtZW50LmFsbCBjbGFzc10nO1xudmFyIGRkYUNsYXNzMyA9ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc7IC8vIElFIDktMTBcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7IC8vIGJldHRlcjogdXNlIGBoYXMtdG9zdHJpbmd0YWdgXG5cbnZhciBpc0lFNjggPSAhKDAgaW4gWyxdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zcGFyc2UtYXJyYXlzLCBjb21tYS1zcGFjaW5nXG5cbnZhciBpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwoKSB7IHJldHVybiBmYWxzZTsgfTtcbmlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSB7XG5cdC8vIEZpcmVmb3ggMyBjYW5vbmljYWxpemVzIEREQSB0byB1bmRlZmluZWQgd2hlbiBpdCdzIG5vdCBhY2Nlc3NlZCBkaXJlY3RseVxuXHR2YXIgYWxsID0gZG9jdW1lbnQuYWxsO1xuXHRpZiAodG9TdHIuY2FsbChhbGwpID09PSB0b1N0ci5jYWxsKGRvY3VtZW50LmFsbCkpIHtcblx0XHRpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwodmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbHMgZG9jdW1lbnQ6IGZhbHNlICovXG5cdFx0XHQvLyBpbiBJRSA2LTgsIHR5cGVvZiBkb2N1bWVudC5hbGwgaXMgXCJvYmplY3RcIiBhbmQgaXQncyB0cnV0aHlcblx0XHRcdGlmICgoaXNJRTY4IHx8ICF2YWx1ZSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdHN0ciA9PT0gZGRhQ2xhc3Ncblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MyXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMyAvLyBvcGVyYSAxMi4xNlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBvYmplY3RDbGFzcyAvLyBJRSA2LThcblx0XHRcdFx0XHQpICYmIHZhbHVlKCcnKSA9PSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWZsZWN0QXBwbHlcblx0PyBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkodmFsdWUsIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKGUgIT09IGlzQ2FsbGFibGVNYXJrZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiAhaXNFUzZDbGFzc0ZuKHZhbHVlKSAmJiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH1cblx0OiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHN0ckNsYXNzICE9PSBmbkNsYXNzICYmIHN0ckNsYXNzICE9PSBnZW5DbGFzcyAmJiAhKC9eXFxbb2JqZWN0IEhUTUwvKS50ZXN0KHN0ckNsYXNzKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRyZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMTM4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMjYpKCk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24qKCkge30nKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn07XG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNTM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3ODI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyOSk7XG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTI2KTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDUzKTtcbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU1KTtcbnZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzQ2KTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzA1Myk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdGlmIChOdW1iZXIuaXNOYU4gJiYgTnVtYmVyLmlzTmFOKE5hTikgJiYgIU51bWJlci5pc05hTignYScpKSB7XG5cdFx0cmV0dXJuIE51bWJlci5pc05hTjtcblx0fVxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MzQ2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTI2KTtcbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU1KTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1OdW1iZXJJc05hTigpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE51bWJlciwgeyBpc05hTjogcG9seWZpbGwgfSwge1xuXHRcdGlzTmFOOiBmdW5jdGlvbiB0ZXN0SXNOYU4oKSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOTQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRyZXR1cm4gISF3aGljaFR5cGVkQXJyYXkodmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODE2OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Njc5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTI2KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyOSk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODE2OSk7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNzApO1xudmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MSk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE9iamVjdCk7XG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNzA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODE2OSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oODA3MCk7XG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTI2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY5MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oODAxKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0NjQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMSk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogX193ZWJwYWNrX3JlcXVpcmVfXyg1NjkxKTtcblxudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHR2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODAxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDA2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDQ4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBCYXNlU2VydmljZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQmFzZVNlcnZpY2UpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjI5Nyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODgxKTtcbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5jbGFzcyBCYXNlU2VydmljZSB7XG4gICAgYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXSA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLm4uY3JlYXRlKGRvY3VtZW50LnVyaSwgZG9jdW1lbnQubGFuZ3VhZ2VJZCwgZG9jdW1lbnQudmVyc2lvbiwgZG9jdW1lbnQudGV4dCk7XG4gICAgLy9UT0RPOlxuICAgIC8qaWYgKG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLnNldFNlc3Npb25PcHRpb25zKHNlc3Npb25JRCwgb3B0aW9ucyk7Ki8gfVxuICAgIGdldERvY3VtZW50KHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudHNbdXJpXTtcbiAgICB9XG4gICAgcmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRzW2RvY3VtZW50LnVyaV07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbZG9jdW1lbnQudXJpXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERvY3VtZW50VmFsdWUodXJpKSB7XG4gICAgICAgIHZhciBfdGhpc19nZXREb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIChfdGhpc19nZXREb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQodXJpKSkgPT09IG51bGwgfHwgX3RoaXNfZ2V0RG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX2dldERvY3VtZW50LmdldFRleHQoKTtcbiAgICB9XG4gICAgc2V0VmFsdWUoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGRvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChpZGVudGlmaWVyLnVyaSk7XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQgPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18vKiAuVGV4dERvY3VtZW50ICovIC5uLmNyZWF0ZShkb2N1bWVudC51cmksIGRvY3VtZW50Lmxhbmd1YWdlSWQsIGRvY3VtZW50LnZlcnNpb24sIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRzW2RvY3VtZW50LnVyaV0gPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxPcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgfVxuICAgIHNldE9wdGlvbnMoc2Vzc2lvbklELCBvcHRpb25zLCBtZXJnZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1tzZXNzaW9uSURdID0gbWVyZ2UgPyAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5tZXJnZU9iamVjdHMgKi8gLlBNKShvcHRpb25zLCB0aGlzLm9wdGlvbnNbc2Vzc2lvbklEXSkgOiBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRPcHRpb24oc2Vzc2lvbklELCBvcHRpb25OYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbc2Vzc2lvbklEXSAmJiB0aGlzLm9wdGlvbnNbc2Vzc2lvbklEXVtvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tzZXNzaW9uSURdW29wdGlvbk5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseURlbHRhcyhpZGVudGlmaWVyLCBkZWx0YXMpIHtcbiAgICAgICAgbGV0IGRvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChpZGVudGlmaWVyLnVyaSk7XG4gICAgICAgIGlmIChkb2N1bWVudCkgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLyogLlRleHREb2N1bWVudCAqLyAubi51cGRhdGUoZG9jdW1lbnQsIGRlbHRhcywgaWRlbnRpZmllci52ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvSG92ZXIoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb1Jlc29sdmUoaXRlbSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9WYWxpZGF0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZm9ybWF0KGRvY3VtZW50LCByYW5nZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgYXN5bmMgcHJvdmlkZVNpZ25hdHVyZUhlbHAoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBmaW5kRG9jdW1lbnRIaWdobGlnaHRzKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldCBvcHRpb25zVG9GaWx0ZXJEaWFnbm9zdGljcygpIHtcbiAgICAgICAgdmFyIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlLCBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nLCBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvLCBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSwgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yQ29kZXNUb0lnbm9yZTogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb0lnbm9yZSkgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlIDogW10sXG4gICAgICAgICAgICBlcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmcgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmcpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmcgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmcgOiBbXSxcbiAgICAgICAgICAgIGVycm9yQ29kZXNUb1RyZWF0QXNJbmZvOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9UcmVhdEFzSW5mbykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyA6IFtdLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlc1RvSWdub3JlOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvSWdub3JlKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyA6IFtdLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm86IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvIDogW11cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobW9kZSl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJkb2N1bWVudHNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJnbG9iYWxPcHRpb25zXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VEYXRhXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHt9KTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYyOTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgJHA6ICgpID0+ICgvKiBiaW5kaW5nICovIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQTTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWVyZ2VPYmplY3RzKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnRzIG5vdEVtcHR5LCBtZXJnZVJhbmdlcyAqL1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIpIHtcbiAgICBpZiAoIW9iajEpIHJldHVybiBvYmoyO1xuICAgIGlmICghb2JqMikgcmV0dXJuIG9iajE7XG4gICAgY29uc3QgbWVyZ2VkT2JqZWN0cyA9IHtcbiAgICAgICAgLi4ub2JqMixcbiAgICAgICAgLi4ub2JqMVxuICAgIH07IC8vIEdpdmUgcHJpb3JpdHkgdG8gb2JqMSB2YWx1ZXMgYnkgc3ByZWFkaW5nIG9iajIgZmlyc3QsIHRoZW4gb2JqMVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1lcmdlZE9iamVjdHMpKXtcbiAgICAgICAgaWYgKG9iajFba2V5XSAmJiBvYmoyW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iajFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBvYmoxW2tleV0uY29uY2F0KG9iajJba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqMltrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG9iajJba2V5XS5jb25jYXQob2JqMVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iajFba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajJba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBtZXJnZU9iamVjdHMob2JqMVtrZXldLCBvYmoyW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRPYmplY3RzO1xufVxuZnVuY3Rpb24gbm90RW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vdGFrZW4gd2l0aCBzbWFsbCBjaGFuZ2VzIGZyb20gYWNlLWNvZGVcbmZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHJhbmdlcykge1xuICAgIHZhciBsaXN0ID0gcmFuZ2VzO1xuICAgIGxpc3QgPSBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgICB9KTtcbiAgICB2YXIgbmV4dCA9IGxpc3RbMF0sIHJhbmdlO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICBuZXh0ID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LnN0YXJ0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY21wID09IDAgJiYgIXJhbmdlLmlzRW1wdHkoKSAmJiAhbmV4dC5pc0VtcHR5KCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuZW5kKSA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBuZXh0LmVuZC5yb3c7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gbmV4dC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBuZXh0ID0gcmFuZ2U7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBjb21wYXJlUG9pbnRzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgLSBwMi5yb3cgfHwgcDEuY29sdW1uIC0gcDIuY29sdW1uO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSh2YWx1ZSwgcmVnZXhwQXJyYXkpIHtcbiAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHJlZ2V4cEFycmF5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHJlZ2V4cEFycmF5W2ldLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDg5NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjM1KTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTM4KTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOTQpO1xudmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTk4KTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMzMzU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0MDYpO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxNik7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4OTUpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mik7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4NSk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTUzKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU5NTM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYzMik7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjQ3KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDUyNDcpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNjMyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MTYpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjQ3KTtcbmNsYXNzIE1lc3NhZ2VCdWZmZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuYXNjaWlEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICAgIH1cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXI7XG4gICAgfVxuICAgIGZyb21TdHJpbmcodmFsdWUsIF9lbmNvZGluZykge1xuICAgICAgICByZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc2NpaURlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc05hdGl2ZShidWZmZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NOYXRpdmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH1cbn1cbk1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBhcGlfMS5SQUwpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgYXBpXzEuUkFMLmluc3RhbGwoX3JpbCk7XG4gICAgfVxuICAgIFJJTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJJTCB8fCAoUklMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUklMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjQ3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvdGhlbmFibGUuZC50c1wiIC8+XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5Ub3VjaCA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuUkFMID0gdm9pZCAwO1xuZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTQxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk1lc3NhZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNlRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2Rlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuRXJyb3JDb2RlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzOyB9IH0pKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDQwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZE1hcFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxpbmtlZE1hcDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMUlVDYWNoZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxSVUNhY2hlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvdWNoXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuVG91Y2g7IH0gfSkpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDM3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3Bvc2FibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZTsgfSB9KSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkV2ZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtaXR0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FbWl0dGVyOyB9IH0pKTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pKTtcbmNvbnN0IHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VSZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjUxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuQWJzdHJhY3RNZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlQnVmZmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2NTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlQnVmZmVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZUJ1ZmZlcl8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlcjsgfSB9KSk7XG5jb25zdCBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MDgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uT3B0aW9uc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uT3B0aW9uczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsTG9nZ2VyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk51bGxMb2dnZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUb2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1Rva2VuOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1R5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VWYWx1ZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VWYWx1ZXM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VGb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VGb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2V0VHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuU2V0VHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nVHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTG9nVHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3JzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5NZXNzYWdlU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xuZXhwb3J0cy5SQUwgPSByYWxfMS5kZWZhdWx0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MTU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgxMSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmVcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXG4gICAgICAgICAgICB8fCAoSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpICYmICEhY2FuZGlkYXRlLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTA4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzA2KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxNDEpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNDApO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxNjUpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNSk7XG52YXIgQ2FuY2VsTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvY2FuY2VsUmVxdWVzdCcpO1xufSkoQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChDYW5jZWxOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIFByb2dyZXNzVG9rZW47XG4oZnVuY3Rpb24gKFByb2dyZXNzVG9rZW4pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBQcm9ncmVzc1Rva2VuLmlzID0gaXM7XG59KShQcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuIHx8IChleHBvcnRzLlByb2dyZXNzVG9rZW4gPSB7fSkpO1xudmFyIFByb2dyZXNzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChQcm9ncmVzc05vdGlmaWNhdGlvbikge1xuICAgIFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL3Byb2dyZXNzJyk7XG59KShQcm9ncmVzc05vdGlmaWNhdGlvbiB8fCAoUHJvZ3Jlc3NOb3RpZmljYXRpb24gPSB7fSkpO1xuY2xhc3MgUHJvZ3Jlc3NUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzVHlwZSA9IFByb2dyZXNzVHlwZTtcbnZhciBTdGFyUmVxdWVzdEhhbmRsZXI7XG4oZnVuY3Rpb24gKFN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJcy5mdW5jKHZhbHVlKTtcbiAgICB9XG4gICAgU3RhclJlcXVlc3RIYW5kbGVyLmlzID0gaXM7XG59KShTdGFyUmVxdWVzdEhhbmRsZXIgfHwgKFN0YXJSZXF1ZXN0SGFuZGxlciA9IHt9KSk7XG5leHBvcnRzLk51bGxMb2dnZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogKCkgPT4geyB9LFxuICAgIHdhcm46ICgpID0+IHsgfSxcbiAgICBpbmZvOiAoKSA9PiB7IH0sXG4gICAgbG9nOiAoKSA9PiB7IH1cbn0pO1xudmFyIFRyYWNlO1xuKGZ1bmN0aW9uIChUcmFjZSkge1xuICAgIFRyYWNlW1RyYWNlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xuICAgIFRyYWNlW1RyYWNlW1wiTWVzc2FnZXNcIl0gPSAxXSA9IFwiTWVzc2FnZXNcIjtcbiAgICBUcmFjZVtUcmFjZVtcIkNvbXBhY3RcIl0gPSAyXSA9IFwiQ29tcGFjdFwiO1xuICAgIFRyYWNlW1RyYWNlW1wiVmVyYm9zZVwiXSA9IDNdID0gXCJWZXJib3NlXCI7XG59KShUcmFjZSA9IGV4cG9ydHMuVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlVmFsdWVzO1xuKGZ1bmN0aW9uIChUcmFjZVZhbHVlcykge1xuICAgIC8qKlxuICAgICAqIFR1cm4gdHJhY2luZyBvZmYuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuT2ZmID0gJ29mZic7XG4gICAgLyoqXG4gICAgICogVHJhY2UgbWVzc2FnZXMgb25seS5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5NZXNzYWdlcyA9ICdtZXNzYWdlcyc7XG4gICAgLyoqXG4gICAgICogQ29tcGFjdCBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuQ29tcGFjdCA9ICdjb21wYWN0JztcbiAgICAvKipcbiAgICAgKiBWZXJib3NlIG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5WZXJib3NlID0gJ3ZlcmJvc2UnO1xufSkoVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlVmFsdWVzIHx8IChleHBvcnRzLlRyYWNlVmFsdWVzID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuTWVzc2FnZXM7XG4gICAgICAgICAgICBjYXNlICdjb21wYWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuQ29tcGFjdDtcbiAgICAgICAgICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5WZXJib3NlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuT2ZmOlxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmJztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuTWVzc2FnZXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZXNzYWdlcyc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjb21wYWN0JztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcmJvc2UnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2UudG9TdHJpbmcgPSB0b1N0cmluZztcbn0pKFRyYWNlID0gZXhwb3J0cy5UcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IHt9KSk7XG52YXIgVHJhY2VGb3JtYXQ7XG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XG4gICAgVHJhY2VGb3JtYXRbXCJUZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgVHJhY2VGb3JtYXRbXCJKU09OXCJdID0gXCJqc29uXCI7XG59KShUcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuSlNPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlRm9ybWF0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0ge30pKTtcbnZhciBTZXRUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoU2V0VHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBTZXRUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9zZXRUcmFjZScpO1xufSkoU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBMb2dUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoTG9nVHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9sb2dUcmFjZScpO1xufSkoTG9nVHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBDb25uZWN0aW9uRXJyb3JzO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkNsb3NlZFwiXSA9IDFdID0gXCJDbG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiRGlzcG9zZWRcIl0gPSAyXSA9IFwiRGlzcG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGluIGxpc3RlbmluZyBtb2RlLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkFscmVhZHlMaXN0ZW5pbmdcIl0gPSAzXSA9IFwiQWxyZWFkeUxpc3RlbmluZ1wiO1xufSkoQ29ubmVjdGlvbkVycm9ycyA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0ge30pKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XG52YXIgQ29ubmVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jYW5jZWxVbmRpc3BhdGNoZWQpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUua2luZCA9PT0gJ2lkJykgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLklkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVxdWVzdCcgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKHZhbHVlKSB8fCBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZW5kQ2FuY2VsbGF0aW9uKGNvbm4sIGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubi5zZW5kTm90aWZpY2F0aW9uKENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLCB7IGlkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwKF8pIHsgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLnNlbmRDYW5jZWxsYXRpb24pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNsZWFudXApO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHJlY2VpdmVyOiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UsXG4gICAgICAgIHNlbmRlcjogQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnJlY2VpdmVyKSAmJiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUuc2VuZGVyKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgTWVzc2FnZVN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5oYW5kbGVNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVN0cmF0ZWd5LmlzID0gaXM7XG59KShNZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSB8fCAoZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChDYW5jZWxsYXRpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHx8IENvbm5lY3Rpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY29ubmVjdGlvblN0cmF0ZWd5KSB8fCBNZXNzYWdlU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLm1lc3NhZ2VTdHJhdGVneSkpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zIHx8IChleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zID0ge30pKTtcbnZhciBDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJOZXdcIl0gPSAxXSA9IFwiTmV3XCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkxpc3RlbmluZ1wiXSA9IDJdID0gXCJMaXN0ZW5pbmdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiQ2xvc2VkXCJdID0gM10gPSBcIkNsb3NlZFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJEaXNwb3NlZFwiXSA9IDRdID0gXCJEaXNwb3NlZFwiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24obWVzc2FnZVJlYWRlciwgbWVzc2FnZVdyaXRlciwgX2xvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIgIT09IHVuZGVmaW5lZCA/IF9sb2dnZXIgOiBleHBvcnRzLk51bGxMb2dnZXI7XG4gICAgbGV0IHNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCB1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgY29uc3QgdmVyc2lvbiA9ICcyLjAnO1xuICAgIGxldCBzdGFyUmVxdWVzdEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub3RpZmljYXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9ncmVzc0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB0aW1lcjtcbiAgICBsZXQgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgIGxldCByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIGxldCBrbm93bkNhbmNlbGVkUmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHJlcXVlc3RUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRyYWNlID0gVHJhY2UuT2ZmO1xuICAgIGxldCB0cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgbGV0IHRyYWNlcjtcbiAgICBsZXQgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTmV3O1xuICAgIGNvbnN0IGVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGRpc3Bvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25TdHJhdGVneSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpID8gb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSA6IENhbmNlbGxhdGlvblN0cmF0ZWd5Lk1lc3NhZ2U7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzZW5kIHJlcXVlc3RzIHdpdGggaWQgbnVsbCBzaW5jZSB0aGUgcmVzcG9uc2UgY2FuJ3QgYmUgY29ycmVsYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3JlcS0nICsgaWQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLXVua25vd24tJyArICgrK3Vua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbm90LScgKyAoKytub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTWVzc2FnZVRvUXVldWUocXVldWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXF1ZXN0UXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsVW5kaXNwYXRjaGVkKF9tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTGlzdGVuaW5nKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc3Bvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUhhbmRsZXIoKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLk5ldyB8fCBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZykge1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgICAgICAgICAgY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpcyBkaXNwb3NlZCBkb24ndCBzZW50IGNsb3NlIGV2ZW50cy5cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShbZXJyb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRXJyb3JIYW5kbGVyKGRhdGEpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoZGF0YSk7XG4gICAgfVxuICAgIG1lc3NhZ2VSZWFkZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VSZWFkZXIub25FcnJvcihyZWFkRXJyb3JIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uRXJyb3Iod3JpdGVFcnJvckhhbmRsZXIpO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmICh0aW1lciB8fCBtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdHJhdGVneSA9IG9wdGlvbnM/Lm1lc3NhZ2VTdHJhdGVneTtcbiAgICAgICAgICAgIGlmIChNZXNzYWdlU3RyYXRlZ3kuaXMobWVzc2FnZVN0cmF0ZWd5KSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdHJhdGVneS5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgY2FuY2VsbGF0aW9uIG1lc3NhZ2UuIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIHN0aWxsIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgLy8gYW5kIGNhbmNlbCBpdCBpZiBhbGxvd2VkIHRvIGRvIHNvLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSAmJiBtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ2FuY2VsID0gbWVzc2FnZVF1ZXVlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KHRvQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IG9wdGlvbnM/LmNvbm5lY3Rpb25TdHJhdGVneTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoc3RyYXRlZ3kgJiYgc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKSA/IHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCwgY2FuY2VsVW5kaXNwYXRjaGVkKSA6IGNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2UuZXJyb3IgIT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gdG9DYW5jZWwuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShyZXNwb25zZSwgbWVzc2FnZS5tZXRob2QsIERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShyZXNwb25zZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZvciBjYW5jZWxlZCBtZXNzYWdlIGZhaWxlZC5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1ZXN0VG9rZW5zLmdldChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBydW5uaW5nLiBDYW5jZWwgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjYW5jZWwgYnV0IHN0aWxsIHF1ZXVlIHRoZSBtZXNzYWdlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIHN0YXRlIGluIHByb2Nlc3MgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmFkZChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkTWVzc2FnZVRvUXVldWUobWVzc2FnZVF1ZXVlLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBzaWxlbnRseSBzaW5jZSB3ZSBmaXJlZCBhbiBldmVudCB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHkocmVzdWx0T3JFcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0T3JFcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSByZXN1bHRPckVycm9yLnRvSnNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHRPckVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0T3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlFcnJvcihlcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnRvSnNvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseVN1Y2Nlc3MocmVzdWx0LCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIEpTT04gUlBDIGRlZmluZXMgdGhhdCBhIHJlc3BvbnNlIG11c3QgZWl0aGVyIGhhdmUgYSByZXN1bHQgb3IgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIHZhbGlkIHJlc3BvbnNlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZVJlY2VpdmVkUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3RNZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgcmVxdWVzdEhhbmRsZXI7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyIHx8IHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSByZXF1ZXN0TWVzc2FnZS5pZCA/PyBTdHJpbmcoRGF0ZS5ub3coKSk7IC8vXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Tb3VyY2UgPSBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIpXG4gICAgICAgICAgICAgICAgPyBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSh0b2tlbktleSlcbiAgICAgICAgICAgICAgICA6IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCAmJiBrbm93bkNhbmNlbGVkUmVxdWVzdHMuaGFzKHJlcXVlc3RNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblNvdXJjZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuc2V0KHRva2VuS2V5LCBjYW5jZWxsYXRpb25Tb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0TWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoLi4ucmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSBzdGFyUmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UubWV0aG9kLCByZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5U3VjY2VzcyhoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdE9yRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5KHJlc3VsdE9yRXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseShoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXBseShlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCwgYFVuaGFuZGxlZCBtZXRob2QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZDogRXJyb3IgaXM6IFxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2VNZXNzYWdlLmVycm9yLCB1bmRlZmluZWQsIDQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQuIE5vIGZ1cnRoZXIgZXJyb3IgaW5mb3JtYXRpb24gcHJvdmlkZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZFJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXNwb25zZU1lc3NhZ2UuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBub3RpZmljYXRpb25IYW5kbGVyO1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5kZWxldGUoY2FuY2VsSWQpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub3RpZmljYXRpb25IYW5kbGVycy5nZXQobWVzc2FnZS5tZXRob2QpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIgfHwgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyAhPT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIEpTT04tUlBDIGxpYnJhcmllcyB0aGF0IHNlbmQgcHJvZ3Jlc3MgbWVzc2FnZSBhcyBwb3NpdGlvbmFsIHBhcmFtcyBhbHRob3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGFzIG5hbWVkLiBTbyBjb252ZXJ0IHRoZW0gaWYgdGhpcyBpcyB0aGUgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCAmJiBwYXJhbXMubGVuZ3RoID09PSAyICYmIFByb2dyZXNzVG9rZW4uaXMocGFyYW1zWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoeyB0b2tlbjogcGFyYW1zWzBdLCB2YWx1ZTogcGFyYW1zWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSBtZXNzYWdlLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkICR7cGFyYW1zLmxlbmd0aH0gYXJndW1lbnRzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIuZmlyZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdSZWNlaXZlZCBlbXB0eSBtZXNzYWdlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSB3aGljaCBpcyBuZWl0aGVyIGEgcmVzcG9uc2Ugbm9yIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2U6XFxuJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCA0KX1gKTtcbiAgICAgICAgLy8gVGVzdCB3aGV0aGVyIHdlIGZpbmQgYW4gaWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChJcy5zdHJpbmcocmVzcG9uc2VNZXNzYWdlLmlkKSB8fCBJcy5udW1iZXIocmVzcG9uc2VNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIucmVqZWN0KG5ldyBFcnJvcignVGhlIHJlY2VpdmVkIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciBwcm9wZXJ0eS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5VHJhY2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cmFjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5WZXJib3NlOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDQpO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXNwb25zZSAnJHttZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy4gUHJvY2Vzc2luZyByZXF1ZXN0IHRvb2sgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlciB8fCBtZXNzYWdlLm1ldGhvZCA9PT0gTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShtZXNzYWdlLCByZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWVzc2FnZS5lcnJvciA/IGAgUmVxdWVzdCBmYWlsZWQ6ICR7bWVzc2FnZS5lcnJvci5tZXNzYWdlfSAoJHttZXNzYWdlLmVycm9yLmNvZGV9KS5gIDogJyc7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknIGluICR7RGF0ZS5ub3coKSAtIHJlc3BvbnNlUHJvbWlzZS50aW1lclN0YXJ0fW1zLiR7ZXJyb3J9YCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAke21lc3NhZ2UuaWR9IHdpdGhvdXQgYWN0aXZlIHJlc3BvbnNlIHByb21pc2UuYCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nTFNQTWVzc2FnZSh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdHJhY2VyIHx8IHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsc3BNZXNzYWdlID0ge1xuICAgICAgICAgICAgaXNMU1BNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgdHJhY2VyLmxvZyhsc3BNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKSB7XG4gICAgICAgIGlmIChpc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQ2xvc2VkLCAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkRpc3Bvc2VkLCAnQ29ubmVjdGlvbiBpcyBkaXNwb3NlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkFscmVhZHlMaXN0ZW5pbmcsICdDb25uZWN0aW9uIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZk5vdExpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKCFpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGwgbGlzdGVuKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5kZWZpbmVkVG9OdWxsKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBudWxsVG9VbmRlZmluZWQocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWRQYXJhbShwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gIT09IHVuZGVmaW5lZCAmJiBwYXJhbSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbSkgJiYgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtKSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW1ldGVyU3RydWN0dXJlcykge1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bzpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lOlxuICAgICAgICAgICAgICAgIGlmICghaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcGFyYW0gaXMgbm90IGFuIG9iamVjdCBsaXRlcmFsLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBzdHJ1Y3R1cmUgJHtwYXJhbWV0ZXJTdHJ1Y3R1cmVzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wdXRlU2luZ2xlUGFyYW0odHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGggJiYgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkVG9OdWxsKHBhcmFtc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8IG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgbm90aWZpY2F0aW9uIHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZVdyaXRlci53cml0ZShub3RpZmljYXRpb25NZXNzYWdlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgbm90aWZpY2F0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk5vdGlmaWNhdGlvbjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgaWYgKElzLmZ1bmModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZSwgeyB0eXBlOiB1bmRlZmluZWQsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0hhbmRsZXJzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyZXNzIGhhbmRsZXIgZm9yIHRva2VuICR7dG9rZW59IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5zZXQodG9rZW4sIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuZGVsZXRlKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYXdhaXQgYnV0IHNpbXBsZSByZXR1cm4gdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyXG4gICAgICAgICAgICAvLyBhc3luYyBzY2hlZHVsaW5nLiBPdGhlcndpc2Ugb25lIHNlbmQgY291bGQgb3ZlcnRha2UgYW5vdGhlciBzZW5kLlxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCB7IHRva2VuLCB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VbmhhbmRsZWRQcm9ncmVzczogdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmV2ZW50LFxuICAgICAgICBzZW5kUmVxdWVzdDogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICB0aHJvd0lmTm90TGlzdGVuaW5nKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1FbmQgPSBwYXJhbUVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgcmVxdWVzdCBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW251bWJlck9mUGFyYW1zXSkgPyBwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2FibGU7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLnNlbmRDYW5jZWxsYXRpb24oY29ubmVjdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZWNlaXZlZCBubyBwcm9taXNlIGZyb20gY2FuY2VsbGF0aW9uIHN0cmF0ZWd5IHdoZW4gY2FuY2VsbGluZyBpZCAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgY2FuY2VsbGF0aW9uIG1lc3NhZ2VzIGZvciBpZCAke2lkfSBmYWlsZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmVuYWJsZUNhbmNlbGxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24ocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlV2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdFdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHsgbWV0aG9kOiBtZXRob2QsIHRpbWVyU3RhcnQ6IERhdGUubm93KCksIHJlc29sdmU6IHJlc29sdmVXaXRoQ2xlYW51cCwgcmVqZWN0OiByZWplY3RXaXRoQ2xlYW51cCB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lc3NhZ2VXcml0ZXIud3JpdGUocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLnNldChpZCwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXF1ZXN0IGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGluZyB0aGUgbWVzc2FnZSBmYWlsZWQuIFNvIHdlIG5lZWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yLCBlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIHJlYXNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChTdGFyUmVxdWVzdEhhbmRsZXIuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUsIHsgaGFuZGxlcjogaGFuZGxlciwgdHlwZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUGVuZGluZ1Jlc3BvbnNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcy5zaXplID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2U6IGFzeW5jIChfdmFsdWUsIF90cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgbGV0IF9zZW5kTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgIGlmIChzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChJcy5ib29sZWFuKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdHJhY2VGb3JtYXQgPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMudHJhY2VGb3JtYXQgfHwgVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0ID0gX3RyYWNlRm9ybWF0O1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSBfdHJhY2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSwgeyB2YWx1ZTogVHJhY2UudG9TdHJpbmcoX3ZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZXJyb3JFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkNsb3NlOiBjbG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkRpc3Bvc2U6IGRpc3Bvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQsICdQZW5kaW5nIHJlc3BvbnNlIHJlamVjdGVkIHNpbmNlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgcmVzcG9uc2VQcm9taXNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZkxpc3RlbmluZygpO1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5saXN0ZW4oY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5sb2coJ2luc3BlY3QnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlID0gdHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHZlcmJvc2UgPyBwYXJhbXMudmVyYm9zZSA6IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9ncmVzc0hhbmRsZXJzLmdldChwYXJhbXMudG9rZW4pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmZpcmUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDM3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZvaWQgMDtcbnZhciBEaXNwb3NhYmxlO1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlID0gZXhwb3J0cy5EaXNwb3NhYmxlIHx8IChleHBvcnRzLkRpc3Bvc2FibGUgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MTY1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50ID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xudmFyIEV2ZW50O1xuKGZ1bmN0aW9uIChFdmVudCkge1xuICAgIGNvbnN0IF9kaXNwb3NhYmxlID0geyBkaXNwb3NlKCkgeyB9IH07XG4gICAgRXZlbnQuTm9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9kaXNwb3NhYmxlOyB9O1xufSkoRXZlbnQgPSBleHBvcnRzLkV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0ge30pKTtcbmNsYXNzIENhbGxiYWNrTGlzdCB7XG4gICAgYWRkKGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCwgYnVja2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWNrZXQpKSB7XG4gICAgICAgICAgICBidWNrZXQucHVzaCh7IGRpc3Bvc2U6ICgpID0+IHRoaXMucmVtb3ZlKGNhbGxiYWNrLCBjb250ZXh0KSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZXh0c1tpXSA9PT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayAmIGNvbnRleHQgbWF0Y2ggPT4gcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGFkZGluZyBhIGxpc3RlbmVyIHdpdGggYSBjb250ZXh0LCB5b3Ugc2hvdWxkIHJlbW92ZSBpdCB3aXRoIHRoZSBzYW1lIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IFtdLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3Muc2xpY2UoMCksIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHMuc2xpY2UoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goY2FsbGJhY2tzW2ldLmFwcGx5KGNvbnRleHRzW2ldLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2NhbGxiYWNrcyB8fCB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBwdWJsaWMgdG8gYWxsb3cgdG8gc3Vic2NyaWJlXG4gICAgICogdG8gZXZlbnRzIGZyb20gdGhpcyBFbWl0dGVyXG4gICAgICovXG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudCA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IENhbGxiYWNrTGlzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuYWRkKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3Bvc2FibGUgaXMgZGlzcG9zZWQgYWZ0ZXIgZW1pdHRlciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MucmVtb3ZlKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcG9zZSA9IEVtaXR0ZXIuX25vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGtlcHQgcHJpdmF0ZSB0byBmaXJlIGFuIGV2ZW50IHRvXG4gICAgICogc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5pbnZva2UuY2FsbCh0aGlzLl9jYWxsYmFja3MsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FbWl0dGVyID0gRW1pdHRlcjtcbkVtaXR0ZXIuX25vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg4MTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5mdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XG59XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNDA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5Ub3VjaCA9IHZvaWQgMDtcbnZhciBUb3VjaDtcbihmdW5jdGlvbiAoVG91Y2gpIHtcbiAgICBUb3VjaC5Ob25lID0gMDtcbiAgICBUb3VjaC5GaXJzdCA9IDE7XG4gICAgVG91Y2guQXNPbGQgPSBUb3VjaC5GaXJzdDtcbiAgICBUb3VjaC5MYXN0ID0gMjtcbiAgICBUb3VjaC5Bc05ldyA9IFRvdWNoLkxhc3Q7XG59KShUb3VjaCA9IGV4cG9ydHMuVG91Y2ggfHwgKGV4cG9ydHMuVG91Y2ggPSB7fSkpO1xuY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9hID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IFRvdWNoLkZpcnN0ICYmIHRvdWNoICE9PSBUb3VjaC5MYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gVG91Y2guRmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlIGF0IGhlYWRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkxhc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rZWRNYXAgPSBMaW5rZWRNYXA7XG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0IHJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgfVxuICAgIHNldCByYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guQXNOZXcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIFRvdWNoLk5vbmUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgVG91Y2guTGFzdCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjUyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRvQXBwZW5kID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IHRoaXMuZnJvbVN0cmluZyhjaHVuaywgdGhpcy5fZW5jb2RpbmcpIDogY2h1bms7XG4gICAgICAgIHRoaXMuX2NodW5rcy5wdXNoKHRvQXBwZW5kKTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggKz0gdG9BcHBlbmQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ5UmVhZEhlYWRlcnMobG93ZXJDYXNlS2V5cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHJvdzogd2hpbGUgKGNodW5rSW5kZXggPCB0aGlzLl9jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb2x1bW46IHdoaWxlIChvZmZzZXQgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rW29mZnNldF07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rQnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjaHVua0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWZmZXIgY29udGFpbnMgdGhlIHR3byBDUkxGIGF0IHRoZSBlbmQuIFNvIHdlIHdpbGxcbiAgICAgICAgLy8gaGF2ZSB0d28gZW1wdHkgbGluZXMgYWZ0ZXIgdGhlIHNwbGl0IGF0IHRoZSBlbmQgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZChjaHVua0J5dGVzUmVhZCArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMudG9TdHJpbmcoYnVmZmVyLCAnYXNjaWknKS5zcGxpdChDUkxGKTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBoZWFkZXIgbXVzdCBzZXBhcmF0ZSBrZXkgYW5kIHZhbHVlIHVzaW5nIDonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlci5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNldChsb3dlckNhc2VLZXlzID8ga2V5LnRvTG93ZXJDYXNlKCkgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnlSZWFkQm9keShsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsTGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBudW1iZXJPZkJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxMZW5ndGg7XG4gICAgfVxuICAgIF9yZWFkKGJ5dGVDb3VudCkge1xuICAgICAgICBpZiAoYnl0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlQ291bnQgPiB0aGlzLl90b3RhbExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCBzbyBtYW55IGJ5dGVzIWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA9PT0gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBzdXBlciBmYXN0IHBhdGgsIHByZWNpc2VseSBmaXJzdCBjaHVuayBtdXN0IGJlIHJldHVybmVkXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNOYXRpdmUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoLCB0aGUgcmVhZGluZyBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIGZpcnN0IGNodW5rXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNOYXRpdmUoY2h1bmssIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl9jaHVua3NbMF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG9jTmF0aXZlKGJ5dGVDb3VudCk7XG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChieXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIHN1cnZpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1BhcnQgPSBjaHVuay5zbGljZSgwLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmtQYXJ0LCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBiZSBlbnRpcmVseSByZWFkXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSBBYnN0cmFjdE1lc3NhZ2VCdWZmZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzA2KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTY1KTtcbmNvbnN0IHNlbWFwaG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzM5KTtcbnZhciBNZXNzYWdlUmVhZGVyO1xuKGZ1bmN0aW9uIChNZXNzYWdlUmVhZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmxpc3RlbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uQ2xvc2UpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uUGFydGlhbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlUmVhZGVyLmlzID0gaXM7XG59KShNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyIHx8IChleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKHRoaXMuYXNFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0IG9uUGFydGlhbE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZVBhcnRpYWxNZXNzYWdlKGluZm8pIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZmlyZShpbmZvKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgUmVhZGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gQWJzdHJhY3RNZXNzYWdlUmVhZGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGxldCBjaGFyc2V0O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgY29udGVudERlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnREZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGVEZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zID8/ICd1dGYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCc7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXIgPSBvcHRpb25zLmNvbnRlbnREZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoY29udGVudERlY29kZXIubmFtZSwgY29udGVudERlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50RGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZURlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmRlY29kZXI7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFyc2V0LCBjb250ZW50RGVjb2RlciwgY29udGVudERlY29kZXJzLCBjb250ZW50VHlwZURlY29kZXIsIGNvbnRlbnRUeXBlRGVjb2RlcnMgfTtcbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5tZXNzYWdlQnVmZmVyLmNyZWF0ZSh0aGlzLm9wdGlvbnMuY2hhcnNldCk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IDEwMDAwO1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICB9XG4gICAgc2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQ7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZGFibGUub25EYXRhKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuYnVmZmVyLnRyeVJlYWRIZWFkZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKCdIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcignQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQm9keSh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvKiogV2UgaGF2ZW4ndCByZWNlaXZlZCB0aGUgZnVsbCBtZXNzYWdlIHlldC4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgY29udmVydCBvbmUgcmVjZWl2ZWQgbWVzc2FnZSBhZnRlciB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyLiBPdGhlcndpc2UgaXQgY291bGQgaGFwcGVuIHRoYXQgYSBkZWNvZGluZyBvZiBhIHNlY29uZFxuICAgICAgICAgICAgLy8gc21hbGxlciBtZXNzYWdlIGZpbmlzaGVkIGJlZm9yZSB0aGUgZGVjb2Rpbmcgb2YgYSBmaXJzdCBsYXJnZXJcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgYW5kIHRoZW4gd2Ugd291bGQgZGVsaXZlciB0aGUgc2Vjb25kIG1lc3NhZ2UgZmlyc3QuXG4gICAgICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2Rlci5kZWNvZGUoYm9keSlcbiAgICAgICAgICAgICAgICAgICAgOiBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyLmRlY29kZShieXRlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMubWVzc2FnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTI1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcwNik7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODgxMSk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMzOSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTE2NSk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yLCBtZXNzYWdlLCBjb3VudCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKFt0aGlzLmFzRXJyb3IoZXJyb3IpLCBtZXNzYWdlLCBjb3VudF0pO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgV3JpdGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gQWJzdHJhY3RNZXNzYWdlV3JpdGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zID8/ICd1dGYtOCcsIGNvbnRlbnRUeXBlRW5jb2RlcjogKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnLCBjb250ZW50RW5jb2Rlcjogb3B0aW9ucy5jb250ZW50RW5jb2RlciwgY29udGVudFR5cGVFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRUeXBlRW5jb2RlciA/PyAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3Iod3JpdGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHdyaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgICAgICB0aGlzLndyaXRlU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShtc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRW5jb2Rlci5lbmNvZGUobXNnLCB0aGlzLm9wdGlvbnMpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyLmVuY29kZShidWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ29udGVudExlbmd0aCwgYnVmZmVyLmJ5dGVMZW5ndGgudG9TdHJpbmcoKSwgQ1JMRik7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENSTEYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvV3JpdGUobXNnLCBoZWFkZXJzLCBidWZmZXIpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb1dyaXRlKG1zZywgaGVhZGVycywgZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0YWJsZS53cml0ZShoZWFkZXJzLmpvaW4oJycpLCAnYXNjaWknKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRhYmxlLndyaXRlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1zZykge1xuICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLndyaXRhYmxlLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU4ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU1ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUyID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlOSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBleHBvcnRzLlJlcXVlc3RUeXBlNiA9IGV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBleHBvcnRzLlJlcXVlc3RUeXBlMyA9IGV4cG9ydHMuUmVxdWVzdFR5cGUyID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBleHBvcnRzLlJlcXVlc3RUeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSA9IGV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IHZvaWQgMDtcbmNvbnN0IGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODExKTtcbi8qKlxuICogUHJlZGVmaW5lZCBlcnJvciBjb2Rlcy5cbiAqL1xudmFyIEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEVycm9yQ29kZXMpIHtcbiAgICAvLyBEZWZpbmVkIGJ5IEpTT04gUlBDXG4gICAgRXJyb3JDb2Rlcy5QYXJzZUVycm9yID0gLTMyNzAwO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFJlcXVlc3QgPSAtMzI2MDA7XG4gICAgRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCA9IC0zMjYwMTtcbiAgICBFcnJvckNvZGVzLkludmFsaWRQYXJhbXMgPSAtMzI2MDI7XG4gICAgRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yID0gLTMyNjAzO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLiBObyBhcHBsaWNhdGlvbiBlcnJvciBjb2RlcyBzaG91bGRcbiAgICAgKiBiZSBkZWZpbmVkIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgcmFuZ2UuIEZvciBiYWNrd2FyZHNcbiAgICAgKiBjb21wYXRpYmlsaXR5IHRoZSBgU2VydmVyTm90SW5pdGlhbGl6ZWRgIGFuZCB0aGUgYFVua25vd25FcnJvckNvZGVgXG4gICAgICogYXJlIGxlZnQgaW4gdGhlIHJhbmdlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvclN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gd3JpdGUgYSBtZXNzYWdlIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHJlYWRpbmcgYSBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VSZWFkRXJyb3IgPSAtMzIwOTg7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkIG9yIGxvc3QgYW5kIGFsbCBwZW5kaW5nIHJlc3BvbnNlcyBnb3RcbiAgICAgKiByZWplY3RlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkID0gLTMyMDk3O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGluYWN0aXZlIGFuZCBhIHVzZSBvZiBpdCBmYWlsZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5Db25uZWN0aW9uSW5hY3RpdmUgPSAtMzIwOTY7XG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgYSBzZXJ2ZXIgcmVjZWl2ZWQgYSBub3RpZmljYXRpb24gb3JcbiAgICAgKiByZXF1ZXN0IGJlZm9yZSB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCB0aGUgYGluaXRpYWxpemVgIHJlcXVlc3QuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5TZXJ2ZXJOb3RJbml0aWFsaXplZCA9IC0zMjAwMjtcbiAgICBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGUgPSAtMzIwMDE7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgZW5kIHJhbmdlIG9mIEpTT04gUlBDIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgRXJyb3JDb2Rlcy5qc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kID0gLTMyMDAwO1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yRW5kID0gLTMyMDAwO1xufSkoRXJyb3JDb2RlcyA9IGV4cG9ydHMuRXJyb3JDb2RlcyB8fCAoZXhwb3J0cy5FcnJvckNvZGVzID0ge30pKTtcbi8qKlxuICogQW4gZXJyb3Igb2JqZWN0IHJldHVybiBpbiBhIHJlc3BvbnNlIGluIGNhc2UgYSByZXF1ZXN0XG4gKiBoYXMgZmFpbGVkLlxuICovXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGlzLm51bWJlcihjb2RlKSA/IGNvZGUgOiBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSZXNwb25zZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvSnNvbigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBSZXNwb25zZUVycm9yO1xuY2xhc3MgUGFyYW1ldGVyU3RydWN0dXJlcyB7XG4gICAgY29uc3RydWN0b3Ioa2luZCkge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8gfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lIHx8IHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXM7XG4vKipcbiAqIFRoZSBwYXJhbWV0ZXIgc3RydWN0dXJlIGlzIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgb24gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzXG4gKiBhbmQgdGhlIHBhcmFtZXRlciB0eXBlIGluIGNhc2Ugb2YgYSBzaW5nbGUgcGFyYW0uXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdhdXRvJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlQb3NpdGlvbmAgcGFyYW1ldGVyIHN0cnVjdHVyZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGhhdmUgYSBzaW5nbGVcbiAqIHBhcmFtZXRlciB3aGljaCBoYXMgYSBsaXRlcmFsIHR5cGUuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbiA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieVBvc2l0aW9uJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlOYW1lYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIG9ubHkgdXNlZnVsIHdoZW4gaGF2aW5nIGEgc2luZ2xlXG4gKiBwYXJhbWV0ZXIuIFRoZSBsaWJyYXJ5IHdpbGwgcmVwb3J0IGVycm9ycyBpZiB1c2VkIHdpdGggYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICovXG5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieU5hbWUnKTtcbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBNZXNzYWdlVHlwZS5cbiAqL1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLm51bWJlck9mUGFyYW1zID0gbnVtYmVyT2ZQYXJhbXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlO1xuLyoqXG4gKiBDbGFzc2VzIHRvIHR5cGUgcmVxdWVzdCByZXNwb25zZSBwYWlyc1xuICovXG5jbGFzcyBSZXF1ZXN0VHlwZTAgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUwID0gUmVxdWVzdFR5cGUwO1xuY2xhc3MgUmVxdWVzdFR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlO1xuY2xhc3MgUmVxdWVzdFR5cGUxIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUxID0gUmVxdWVzdFR5cGUxO1xuY2xhc3MgUmVxdWVzdFR5cGUyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMiA9IFJlcXVlc3RUeXBlMjtcbmNsYXNzIFJlcXVlc3RUeXBlMyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBSZXF1ZXN0VHlwZTM7XG5jbGFzcyBSZXF1ZXN0VHlwZTQgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gUmVxdWVzdFR5cGU0O1xuY2xhc3MgUmVxdWVzdFR5cGU1IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA1KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNSA9IFJlcXVlc3RUeXBlNTtcbmNsYXNzIFJlcXVlc3RUeXBlNiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBSZXF1ZXN0VHlwZTY7XG5jbGFzcyBSZXF1ZXN0VHlwZTcgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gUmVxdWVzdFR5cGU3O1xuY2xhc3MgUmVxdWVzdFR5cGU4IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA4KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOCA9IFJlcXVlc3RUeXBlODtcbmNsYXNzIFJlcXVlc3RUeXBlOSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBSZXF1ZXN0VHlwZTk7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IE5vdGlmaWNhdGlvblR5cGU7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IE5vdGlmaWNhdGlvblR5cGUwO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IE5vdGlmaWNhdGlvblR5cGUxO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBOb3RpZmljYXRpb25UeXBlMjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gTm90aWZpY2F0aW9uVHlwZTM7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IE5vdGlmaWNhdGlvblR5cGU0O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBOb3RpZmljYXRpb25UeXBlNTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gTm90aWZpY2F0aW9uVHlwZTY7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IE5vdGlmaWNhdGlvblR5cGU3O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBOb3RpZmljYXRpb25UeXBlODtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gTm90aWZpY2F0aW9uVHlwZTk7XG52YXIgTWVzc2FnZTtcbihmdW5jdGlvbiAoTWVzc2FnZSkge1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIGEgcmVxdWVzdCBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1JlcXVlc3QgPSBpc1JlcXVlc3Q7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSBub3RpZmljYXRpb24gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgbWVzc2FnZS5pZCA9PT0gdm9pZCAwO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzTm90aWZpY2F0aW9uID0gaXNOb3RpZmljYXRpb247XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXNwb25zZSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5yZXN1bHQgIT09IHZvaWQgMCB8fCAhIWNhbmRpZGF0ZS5lcnJvcikgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpIHx8IGNhbmRpZGF0ZS5pZCA9PT0gbnVsbCk7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNSZXNwb25zZSA9IGlzUmVzcG9uc2U7XG59KShNZXNzYWdlID0gZXhwb3J0cy5NZXNzYWdlIHx8IChleHBvcnRzLk1lc3NhZ2UgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NzA2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5sZXQgX3JhbDtcbmZ1bmN0aW9uIFJBTCgpIHtcbiAgICBpZiAoX3JhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBpbnN0YWxsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yYWw7XG59XG4oZnVuY3Rpb24gKFJBTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwocmFsKSB7XG4gICAgICAgIGlmIChyYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgX3JhbCA9IHJhbDtcbiAgICB9XG4gICAgUkFMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUkFMIHx8IChSQUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSQUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIzMzk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MDYpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjYXBhY2l0eSA9IDEpIHtcbiAgICAgICAgaWYgKGNhcGFjaXR5IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcbiAgICB9XG4gICAgbG9jayh0aHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZy5wdXNoKHsgdGh1bmssIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgcnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1J1bk5leHQoKSk7XG4gICAgfVxuICAgIGRvUnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA+IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvIG1hbnkgdGh1bmtzIGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXh0LnRodW5rKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNzg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gdm9pZCAwO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNSk7XG52YXIgQ2FuY2VsbGF0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0YXRlKSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWUgPSAwO1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCA9IDE7XG59KShDYW5jZWxsYXRpb25TdGF0ZSB8fCAoQ2FuY2VsbGF0aW9uU3RhdGUgPSB7fSkpO1xuY2xhc3MgU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBkYXRhWzBdID0gQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWU7XG4gICAgICAgIHRoaXMuYnVmZmVycy5zZXQocmVxdWVzdC5pZCwgYnVmZmVyKTtcbiAgICAgICAgcmVxdWVzdC4kY2FuY2VsbGF0aW9uRGF0YSA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgc2VuZENhbmNlbGxhdGlvbihfY29ubiwgaWQpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzLmdldChpZCk7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBBdG9taWNzLnN0b3JlKGRhdGEsIDAsIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCk7XG4gICAgfVxuICAgIGNsZWFudXAoaWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7XG5jbGFzcyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuZGF0YSwgMCkgPT09IENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbmNlbGxhdGlvbiBvdmVyIFNoYXJlZEFycmF5QnVmZmVyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxsYXRpb24gZXZlbnRzYCk7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbihidWZmZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3JlcXVlc3QnO1xuICAgIH1cbiAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShidWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTQ6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGJyb3dzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIwMCk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxMjAwKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg5MzcyKSwgZXhwb3J0cyk7XG5mdW5jdGlvbiBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24ocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgYnJvd3Nlcl8xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKShyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzcyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MU1BFcnJvckNvZGVzID0gZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg1OTUzKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0NzY3KSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2NTI1KSwgZXhwb3J0cyk7XG52YXIgY29ubmVjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzk4KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb247IH0gfSkpO1xudmFyIExTUEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKExTUEVycm9yQ29kZXMpIHtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIExTUCByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICpcbiAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIExTUEVycm9yQ29kZXMubHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzI4OTk7XG4gICAgLyoqXG4gICAgICogQSByZXF1ZXN0IGZhaWxlZCBidXQgaXQgd2FzIHN5bnRhY3RpY2FsbHkgY29ycmVjdCwgZS5nIHRoZVxuICAgICAqIG1ldGhvZCBuYW1lIHdhcyBrbm93biBhbmQgdGhlIHBhcmFtZXRlcnMgd2VyZSB2YWxpZC4gVGhlIGVycm9yXG4gICAgICogbWVzc2FnZSBzaG91bGQgY29udGFpbiBodW1hbiByZWFkYWJsZSBpbmZvcm1hdGlvbiBhYm91dCB3aHlcbiAgICAgKiB0aGUgcmVxdWVzdCBmYWlsZWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5SZXF1ZXN0RmFpbGVkID0gLTMyODAzO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgY2FuY2VsbGVkIHRoZSByZXF1ZXN0LiBUaGlzIGVycm9yIGNvZGUgc2hvdWxkXG4gICAgICogb25seSBiZSB1c2VkIGZvciByZXF1ZXN0cyB0aGF0IGV4cGxpY2l0bHkgc3VwcG9ydCBiZWluZ1xuICAgICAqIHNlcnZlciBjYW5jZWxsYWJsZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlNlcnZlckNhbmNlbGxlZCA9IC0zMjgwMjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGRldGVjdGVkIHRoYXQgdGhlIGNvbnRlbnQgb2YgYSBkb2N1bWVudCBnb3RcbiAgICAgKiBtb2RpZmllZCBvdXRzaWRlIG5vcm1hbCBjb25kaXRpb25zLiBBIHNlcnZlciBzaG91bGRcbiAgICAgKiBOT1Qgc2VuZCB0aGlzIGVycm9yIGNvZGUgaWYgaXQgZGV0ZWN0cyBhIGNvbnRlbnQgY2hhbmdlXG4gICAgICogaW4gaXQgdW5wcm9jZXNzZWQgbWVzc2FnZXMuIFRoZSByZXN1bHQgZXZlbiBjb21wdXRlZFxuICAgICAqIG9uIGFuIG9sZGVyIHN0YXRlIG1pZ2h0IHN0aWxsIGJlIHVzZWZ1bCBmb3IgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgY2xpZW50IGRlY2lkZXMgdGhhdCBhIHJlc3VsdCBpcyBub3Qgb2YgYW55IHVzZSBhbnltb3JlXG4gICAgICogdGhlIGNsaWVudCBzaG91bGQgY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuQ29udGVudE1vZGlmaWVkID0gLTMyODAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgaGFzIGNhbmNlbGVkIGEgcmVxdWVzdCBhbmQgYSBzZXJ2ZXIgYXMgZGV0ZWN0ZWRcbiAgICAgKiB0aGUgY2FuY2VsLlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdENhbmNlbGxlZCA9IC0zMjgwMDtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjgwMDtcbn0pKExTUEVycm9yQ29kZXMgPSBleHBvcnRzLkxTUEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3OTg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk1Myk7XG5mdW5jdGlvbiBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24oaW5wdXQsIG91dHB1dCwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKHZzY29kZV9qc29ucnBjXzEuQ29ubmVjdGlvblN0cmF0ZWd5LmlzKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IGNvbm5lY3Rpb25TdHJhdGVneTogb3B0aW9ucyB9O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHZzY29kZV9qc29ucnBjXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKGlucHV0LCBvdXRwdXQsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODU5OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBleHBvcnRzLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAgPSBleHBvcnRzLlByb3RvY29sUmVxdWVzdFR5cGUgPSBleHBvcnRzLlByb3RvY29sUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5NZXNzYWdlRGlyZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk1Myk7XG52YXIgTWVzc2FnZURpcmVjdGlvbjtcbihmdW5jdGlvbiAoTWVzc2FnZURpcmVjdGlvbikge1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJjbGllbnRUb1NlcnZlclwiXSA9IFwiY2xpZW50VG9TZXJ2ZXJcIjtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wic2VydmVyVG9DbGllbnRcIl0gPSBcInNlcnZlclRvQ2xpZW50XCI7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcImJvdGhcIl0gPSBcImJvdGhcIjtcbn0pKE1lc3NhZ2VEaXJlY3Rpb24gPSBleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gfHwgKGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiA9IHt9KSk7XG5jbGFzcyBSZWdpc3RyYXRpb25UeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgfVxufVxuZXhwb3J0cy5SZWdpc3RyYXRpb25UeXBlID0gUmVnaXN0cmF0aW9uVHlwZTtcbmNsYXNzIFByb3RvY29sUmVxdWVzdFR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5SZXF1ZXN0VHlwZTAge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZTAgPSBQcm90b2NvbFJlcXVlc3RUeXBlMDtcbmNsYXNzIFByb3RvY29sUmVxdWVzdFR5cGUgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCB2c2NvZGVfanNvbnJwY18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvY29sUmVxdWVzdFR5cGUgPSBQcm90b2NvbFJlcXVlc3RUeXBlO1xuY2xhc3MgUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZTAge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCA9IFByb3RvY29sTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLk5vdGlmaWNhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NDM0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgVHlwZUZveCwgTWljcm9zb2Z0IGFuZCBvdGhlcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzdWx0IGEgYENhbGxIaWVyYXJjaHlJdGVtYCBpbiBhIGRvY3VtZW50IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gKiBDYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCB0byBhbiBpbmNvbWluZyBvciBvdXRnb2luZyBjYWxsIGhpZXJhcmNoeS5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3ByZXBhcmVDYWxsSGllcmFyY2h5JztcbiAgICBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW5jb21pbmcgY2FsbHMgZm9yIGEgZ2l2ZW4gYENhbGxIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXRob2QgPSAnY2FsbEhpZXJhcmNoeS9pbmNvbWluZ0NhbGxzJztcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgb3V0Z29pbmcgY2FsbHMgZm9yIGEgZ2l2ZW4gYENhbGxIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXRob2QgPSAnY2FsbEhpZXJhcmNoeS9vdXRnb2luZ0NhbGxzJztcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTA4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIGNvbG9yIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRDb2xvclBhcmFtc30gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBDb2xvckluZm9ybWF0aW9uIENvbG9ySW5mb3JtYXRpb25bXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRDb2xvclJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50Q29sb3JSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudENvbG9yJztcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudENvbG9yUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgcHJlc2VudGF0aW9uIGZvciBhIGNvbG9yLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb25QYXJhbXN9IHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbiBDb2xvckluZm9ybWF0aW9uW119IG9yIGEgVGhlbmFibGVcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29sb3JQcmVzZW50YXRpb24nO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU0NDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8vLS0tLSBHZXQgQ29uZmlndXJhdGlvbiByZXF1ZXN0IC0tLS1cbi8qKlxuICogVGhlICd3b3Jrc3BhY2UvY29uZmlndXJhdGlvbicgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGZldGNoIGEgY2VydGFpblxuICogY29uZmlndXJhdGlvbiBzZXR0aW5nLlxuICpcbiAqIFRoaXMgcHVsbCBtb2RlbCByZXBsYWNlcyB0aGUgb2xkIHB1c2ggbW9kZWwgd2VyZSB0aGUgY2xpZW50IHNpZ25hbGVkIGNvbmZpZ3VyYXRpb24gY2hhbmdlIHZpYSBhblxuICogZXZlbnQuIElmIHRoZSBzZXJ2ZXIgc3RpbGwgbmVlZHMgdG8gcmVhY3QgdG8gY29uZmlndXJhdGlvbiBjaGFuZ2VzIChzaW5jZSB0aGUgc2VydmVyIGNhY2hlcyB0aGVcbiAqIHJlc3VsdCBvZiBgd29ya3NwYWNlL2NvbmZpZ3VyYXRpb25gIHJlcXVlc3RzKSB0aGUgc2VydmVyIHNob3VsZCByZWdpc3RlciBmb3IgYW4gZW1wdHkgY29uZmlndXJhdGlvblxuICogY2hhbmdlIGV2ZW50IGFuZCBlbXB0eSB0aGUgY2FjaGUgaWYgc3VjaCBhbiBldmVudCBpcyByZWNlaXZlZC5cbiAqL1xudmFyIENvbmZpZ3VyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb25maWd1cmF0aW9uUmVxdWVzdCkge1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvY29uZmlndXJhdGlvbic7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb25maWd1cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29uZmlndXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzIxMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgdHlwZSBkZWZpbml0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWNsYXJhdGlvbn1cbiAqIG9yIGEgdHlwZWQgYXJyYXkgb2Yge0BsaW5rIERlY2xhcmF0aW9uTGlua30gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzXG4gKiB0byBzdWNoLlxuICovXG52YXIgRGVjbGFyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChEZWNsYXJhdGlvblJlcXVlc3QpIHtcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kZWNsYXJhdGlvbic7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERlY2xhcmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoRGVjbGFyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuRGVjbGFyYXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY5Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0gZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NTMpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MjMpO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLnJldHJpZ2dlclJlcXVlc3QpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YS5pcyA9IGlzO1xufSkoRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhIHx8IChleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVwb3J0IGtpbmRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIGRpYWdub3N0aWMgcmVwb3J0IHdpdGggYSBmdWxsXG4gICAgICogc2V0IG9mIHByb2JsZW1zLlxuICAgICAqL1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQuRnVsbCA9ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBBIHJlcG9ydCBpbmRpY2F0aW5nIHRoYXQgdGhlIGxhc3RcbiAgICAgKiByZXR1cm5lZCByZXBvcnQgaXMgc3RpbGwgYWNjdXJhdGUuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5VbmNoYW5nZWQgPSAndW5jaGFuZ2VkJztcbn0pKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgfHwgKGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpYWdub3N0aWMnO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0LnBhcnRpYWxSZXN1bHQgPSBuZXcgdnNjb2RlX2pzb25ycGNfMS5Qcm9ncmVzc1R5cGUoKTtcbn0pKERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3b3Jrc3BhY2UgZGlhZ25vc3RpYyByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWFnbm9zdGljJztcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QucGFydGlhbFJlc3VsdCA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xufSkoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgcmVmcmVzaCByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9kaWFnbm9zdGljL3JlZnJlc2hgO1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5EaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTkwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxDcmVhdGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHBhdHRlcm4ga2luZCBkZXNjcmliaW5nIGlmIGEgZ2xvYiBwYXR0ZXJuIG1hdGNoZXMgYSBmaWxlIGEgZm9sZGVyIG9yXG4gKiBib3RoLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZDtcbihmdW5jdGlvbiAoRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdHRlcm4gbWF0Y2hlcyBhIGZpbGUgb25seS5cbiAgICAgKi9cbiAgICBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQuZmlsZSA9ICdmaWxlJztcbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiBtYXRjaGVzIGEgZm9sZGVyIG9ubHkuXG4gICAgICovXG4gICAgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kLmZvbGRlciA9ICdmb2xkZXInO1xufSkoRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgfHwgKGV4cG9ydHMuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0ge30pKTtcbi8qKlxuICogVGhlIHdpbGwgY3JlYXRlIGZpbGVzIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBiZWZvcmUgZmlsZXMgYXJlIGFjdHVhbGx5XG4gKiBjcmVhdGVkIGFzIGxvbmcgYXMgdGhlIGNyZWF0aW9uIGlzIHRyaWdnZXJlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYSBgV29ya3NwYWNlRWRpdGAgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHdvcmtzcGFjZSBiZWZvcmUgdGhlXG4gKiBmaWxlcyBhcmUgY3JlYXRlZC4gSGVuY2UgdGhlIGBXb3Jrc3BhY2VFZGl0YCBjYW4gbm90IG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGVcbiAqIHRvIGJlIGNyZWF0ZWQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsQ3JlYXRlRmlsZXMnO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLldpbGxDcmVhdGVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgY3JlYXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgY3JlYXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbikge1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ3JlYXRlRmlsZXMnO1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHdpbGwgcmVuYW1lIGZpbGVzIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciBiZWZvcmUgZmlsZXMgYXJlIGFjdHVhbGx5XG4gKiByZW5hbWVkIGFzIGxvbmcgYXMgdGhlIHJlbmFtZSBpcyB0cmlnZ2VyZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxSZW5hbWVGaWxlcyc7XG4gICAgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCByZW5hbWUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSByZW5hbWVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRSZW5hbWVGaWxlcyc7XG4gICAgRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBkZWxldGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGRlbGV0ZWQgYXMgbG9uZyBhcyB0aGUgZGVsZXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWREZWxldGVGaWxlcyc7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIGRlbGV0ZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIGRlbGV0ZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxEZWxldGVGaWxlcyc7XG4gICAgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzAyOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgZm9sZGluZyByYW5nZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEZvbGRpbmdSYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlTGlzdH0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRm9sZGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb2xkaW5nUmFuZ2UnO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBGb2xkaW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKEZvbGRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIGltcGxlbWVudGF0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhXG4gKiBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBJbXBsZW1lbnRhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKEltcGxlbWVudGF0aW9uUmVxdWVzdCkge1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2ltcGxlbWVudGF0aW9uJztcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShJbXBsZW1lbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MzE1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGF5IGhpbnRzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBJbmxheUhpbnRzUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxheUhpbnQgSW5sYXlIaW50W119IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGF5SGludFJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlcXVlc3QpIHtcbiAgICBJbmxheUhpbnRSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvaW5sYXlIaW50JztcbiAgICBJbmxheUhpbnRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5sYXlIaW50UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShJbmxheUhpbnRSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIGFuIGlubGF5IGhpbnQuXG4gKiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBJbmxheUhpbnR9LCB0aGUgcmVzcG9uc2UgaXNcbiAqIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2lubGF5SGludC9yZXNvbHZlJztcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QpIHtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2lubGF5SGludC9yZWZyZXNoYDtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzQyNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBpbmxpbmUgdmFsdWVzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBJbmxpbmVWYWx1ZVBhcmFtc30sIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgSW5saW5lVmFsdWUgSW5saW5lVmFsdWVbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVJlcXVlc3QpIHtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxpbmVWYWx1ZSc7XG4gICAgSW5saW5lVmFsdWVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5saW5lVmFsdWVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QpO1xufSkoSW5saW5lVmFsdWVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxpbmVWYWx1ZS9yZWZyZXNoYDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjUyNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVBY3Rpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCA9IGV4cG9ydHMuUmVmZXJlbmNlc1JlcXVlc3QgPSBleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0gZXhwb3J0cy5Ib3ZlclJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IGV4cG9ydHMuUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XYXRjaEtpbmQgPSBleHBvcnRzLlJlbGF0aXZlUGF0dGVybiA9IGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgPSBleHBvcnRzLkRpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0gZXhwb3J0cy5EaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRTeW5jS2luZCA9IGV4cG9ydHMuVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNob3dNZXNzYWdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLk1lc3NhZ2VUeXBlID0gZXhwb3J0cy5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgPSBleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Jbml0aWFsaXplRXJyb3JDb2RlcyA9IGV4cG9ydHMuSW5pdGlhbGl6ZVJlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCA9IGV4cG9ydHMuRmFpbHVyZUhhbmRsaW5nS2luZCA9IGV4cG9ydHMuUmVzb3VyY2VPcGVyYXRpb25LaW5kID0gZXhwb3J0cy5VbnJlZ2lzdHJhdGlvblJlcXVlc3QgPSBleHBvcnRzLlJlZ2lzdHJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U2VsZWN0b3IgPSBleHBvcnRzLk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudEZpbHRlciA9IGV4cG9ydHMuVGV4dERvY3VtZW50RmlsdGVyID0gdm9pZCAwO1xuZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyS2luZCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0gZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxDcmVhdGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBleHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBleHBvcnRzLlRva2VuRm9ybWF0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IGV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gdm9pZCAwO1xuZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZSA9IGV4cG9ydHMuRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudCA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsID0gZXhwb3J0cy5FeGVjdXRpb25TdW1tYXJ5ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxLaW5kID0gZXhwb3J0cy5EaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0gZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuY29uc3QgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3NjcpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MjMpO1xuY29uc3QgcHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTM4MCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBsZW1lbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xLkltcGxlbWVudGF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjQyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVEZWZpbml0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEuVHlwZURlZmluaXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDAyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDQyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbmZpZ3VyYXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xLkNvbmZpZ3VyYXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb2N1bWVudENvbG9yUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Eb2N1bWVudENvbG9yUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDI5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMS5Gb2xkaW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2RlY2xhcmF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMTApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyYXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZGVjbGFyYXRpb25fMS5EZWNsYXJhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VsZWN0aW9uUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM5Mik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZWxlY3Rpb25SYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xLlNlbGVjdGlvblJhbmdlUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9wcm9ncmVzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODk1KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtEb25lUHJvZ3Jlc3NcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9wcm9ncmVzc18xLldvcmtEb25lUHJvZ3Jlc3M7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9wcm9ncmVzc18xLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9wcm9ncmVzc18xLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb247IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDM0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0ODkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG9rZW5Gb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlRva2VuRm9ybWF0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZTsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zaG93RG9jdW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTU0MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaG93RG9jdW1lbnRSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2hvd0RvY3VtZW50XzEuU2hvd0RvY3VtZW50UmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTI3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxOTApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTY0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzE4KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzQyNSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzE1KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0NjApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgTm90ZWJvb2tEb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0RvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0RvY3VtZW50RmlsdGVyO1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubm90ZWJvb2tUeXBlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKSk7XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudEZpbHRlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5ub3RlYm9vaykgfHwgTm90ZWJvb2tEb2N1bWVudEZpbHRlci5pcyhjYW5kaWRhdGUubm90ZWJvb2spKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sYW5ndWFnZSA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvcmVnaXN0ZXJDYXBhYmlsaXR5YCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gcmVnaXN0ZXIgYSBuZXcgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBSZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZWdpc3RyYXRpb25SZXF1ZXN0KSB7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvdW5yZWdpc3RlckNhcGFiaWxpdHlgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgVW5yZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChVbnJlZ2lzdHJhdGlvblJlcXVlc3QpIHtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5VbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuUmVzb3VyY2VPcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IHt9KSk7XG52YXIgRmFpbHVyZUhhbmRsaW5nS2luZDtcbihmdW5jdGlvbiAoRmFpbHVyZUhhbmRsaW5nS2luZCkge1xuICAgIC8qKlxuICAgICAqIEFwcGx5aW5nIHRoZSB3b3Jrc3BhY2UgY2hhbmdlIGlzIHNpbXBseSBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgY2hhbmdlcyBwcm92aWRlZFxuICAgICAqIGZhaWxzLiBBbGwgb3BlcmF0aW9ucyBleGVjdXRlZCBiZWZvcmUgdGhlIGZhaWxpbmcgb3BlcmF0aW9uIHN0YXkgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5BYm9ydCA9ICdhYm9ydCc7XG4gICAgLyoqXG4gICAgICogQWxsIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkIHRyYW5zYWN0aW9uYWwuIFRoYXQgbWVhbnMgdGhleSBlaXRoZXIgYWxsXG4gICAgICogc3VjY2VlZCBvciBubyBjaGFuZ2VzIGF0IGFsbCBhcmUgYXBwbGllZCB0byB0aGUgd29ya3NwYWNlLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVHJhbnNhY3Rpb25hbCA9ICd0cmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgd29ya3NwYWNlIGVkaXQgY29udGFpbnMgb25seSB0ZXh0dWFsIGZpbGUgY2hhbmdlcyB0aGV5IGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLlxuICAgICAqIElmIHJlc291cmNlIGNoYW5nZXMgKGNyZWF0ZSwgcmVuYW1lIG9yIGRlbGV0ZSBmaWxlKSBhcmUgcGFydCBvZiB0aGUgY2hhbmdlIHRoZSBmYWlsdXJlXG4gICAgICogaGFuZGxpbmcgc3RyYXRlZ3kgaXMgYWJvcnQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5UZXh0T25seVRyYW5zYWN0aW9uYWwgPSAndGV4dE9ubHlUcmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRyaWVzIHRvIHVuZG8gdGhlIG9wZXJhdGlvbnMgYWxyZWFkeSBleGVjdXRlZC4gQnV0IHRoZXJlIGlzIG5vXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhpcyBpcyBzdWNjZWVkaW5nLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVW5kbyA9ICd1bmRvJztcbn0pKEZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgfHwgKGV4cG9ydHMuRmFpbHVyZUhhbmRsaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcG9zaXRpb24gZW5jb2Rpbmcga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgUG9zaXRpb25FbmNvZGluZ0tpbmQ7XG4oZnVuY3Rpb24gKFBvc2l0aW9uRW5jb2RpbmdLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTggY29kZSB1bml0cyAoZS5nLiBieXRlcykuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGOCA9ICd1dGYtOCc7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTE2IGNvZGUgdW5pdHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFuZCBtdXN0IGFsd2F5cyBiZSBzdXBwb3J0ZWRcbiAgICAgKiBieSBzZXJ2ZXJzXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMTYgPSAndXRmLTE2JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMzIgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGU6IHRoZXNlIGFyZSB0aGUgc2FtZSBhcyBVbmljb2RlIGNvZGVwb2ludHMsXG4gICAgICogc28gdGhpcyBgUG9zaXRpb25FbmNvZGluZ0tpbmRgIG1heSBhbHNvIGJlIHVzZWQgZm9yIGFuXG4gICAgICogZW5jb2RpbmctYWdub3N0aWMgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyIG9mZnNldHMuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMzIgPSAndXRmLTMyJztcbn0pKFBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCB8fCAoZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IgPT09IG51bGwgfHwgRG9jdW1lbnRTZWxlY3Rvci5pcyhjYW5kaWRhdGUuZG9jdW1lbnRTZWxlY3RvcikpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgV29ya0RvbmVQcm9ncmVzc09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc09wdGlvbnM7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcykpO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucy5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGhhc1dvcmtEb25lUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcyk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmhhc1dvcmtEb25lUHJvZ3Jlc3MgPSBoYXNXb3JrRG9uZVByb2dyZXNzO1xufSkoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCB8fCAoZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEtub3duIGVycm9yIGNvZGVzIGZvciBhbiBgSW5pdGlhbGl6ZUVycm9yQ29kZXNgO1xuICovXG52YXIgSW5pdGlhbGl6ZUVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHByb3RvY29sIHZlcnNpb24gcHJvdmlkZWQgYnkgdGhlIGNsaWVudCBjYW4ndCBiZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGluaXRpYWxpemUgZXJyb3IgZ290IHJlcGxhY2VkIGJ5IGNsaWVudCBjYXBhYmlsaXRpZXMuIFRoZXJlIGlzXG4gICAgICogbm8gdmVyc2lvbiBoYW5kc2hha2UgaW4gdmVyc2lvbiAzLjB4XG4gICAgICovXG4gICAgSW5pdGlhbGl6ZUVycm9yQ29kZXMudW5rbm93blByb3RvY29sVmVyc2lvbiA9IDE7XG59KShJbml0aWFsaXplRXJyb3JDb2RlcyA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgaW5pdGlhbGl6ZWQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZVxuICogc2VydmVyIGFmdGVyIHRoZSBjbGllbnQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgYW5kIHRoZSBzZXJ2ZXJcbiAqIGlzIGFsbG93ZWQgdG8gc2VuZCByZXF1ZXN0cyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudC5cbiAqL1xudmFyIEluaXRpYWxpemVkTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplZE5vdGlmaWNhdGlvbikge1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCA9ICdpbml0aWFsaXplZCc7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCB8fCAoZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIEV4aXQgTm90aWZpY2F0aW9uIC0tLS1cbi8qKlxuICogVGhlIGV4aXQgZXZlbnQgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0b1xuICogYXNrIHRoZSBzZXJ2ZXIgdG8gZXhpdCBpdHMgcHJvY2Vzcy5cbiAqL1xudmFyIEV4aXROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEV4aXROb3RpZmljYXRpb24pIHtcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdleGl0JztcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMChFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShFeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIHdoZW4gdGhlIGNsaWVudCdzIGNvbmZpZ3VyYXRpb24gaGFzIGNoYW5nZWQuIFRoZSBub3RpZmljYXRpb24gY29udGFpbnNcbiAqIHRoZSBjaGFuZ2VkIGNvbmZpZ3VyYXRpb24gYXMgZGVmaW5lZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbikge1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VDb25maWd1cmF0aW9uJztcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2hvdyBhIG1lc3NhZ2VcbiAqIGFuZCBhIHNldCBvZiBvcHRpb25zIGFjdGlvbnMgdG8gdGhlIHVzZXIuXG4gKi9cbnZhciBTaG93TWVzc2FnZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dNZXNzYWdlUmVxdWVzdCkge1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3Nob3dNZXNzYWdlUmVxdWVzdCc7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGxvZyBtZXNzYWdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBsb2cgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UuXG4gKi9cbnZhciBMb2dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dNZXNzYWdlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd2luZG93L2xvZ01lc3NhZ2UnO1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBob3cgdGhlIGhvc3QgKGVkaXRvcikgc2hvdWxkIHN5bmNcbiAqIGRvY3VtZW50IGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAqL1xudmFyIFRleHREb2N1bWVudFN5bmNLaW5kO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTeW5jS2luZCkge1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBzaG91bGQgbm90IGJlIHN5bmNlZCBhdCBhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSA9IDA7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgYWx3YXlzIHNlbmRpbmcgdGhlIGZ1bGwgY29udGVudFxuICAgICAqIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsID0gMTtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgYXJlIHN5bmNlZCBieSBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnQgb24gb3Blbi5cbiAgICAgKiBBZnRlciB0aGF0IG9ubHkgaW5jcmVtZW50YWwgdXBkYXRlcyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgICogc2VuZC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCA9IDI7XG59KShUZXh0RG9jdW1lbnRTeW5jS2luZCA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgb3BlbiBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIG5ld2x5IG9wZW5lZCB0ZXh0IGRvY3VtZW50cy4gVGhlIGRvY3VtZW50J3MgdHJ1dGggaXMgbm93IG1hbmFnZWQgYnkgdGhlIGNsaWVudFxuICogYW5kIHRoZSBzZXJ2ZXIgbXVzdCBub3QgdHJ5IHRvIHJlYWQgdGhlIGRvY3VtZW50J3MgdHJ1dGggdXNpbmcgdGhlIGRvY3VtZW50J3NcbiAqIHVyaS4gT3BlbiBpbiB0aGlzIHNlbnNlIG1lYW5zIGl0IGlzIG1hbmFnZWQgYnkgdGhlIGNsaWVudC4gSXQgZG9lc24ndCBuZWNlc3NhcmlseVxuICogbWVhbiB0aGF0IGl0cyBjb250ZW50IGlzIHByZXNlbnRlZCBpbiBhbiBlZGl0b3IuIEFuIG9wZW4gbm90aWZpY2F0aW9uIG11c3Qgbm90XG4gKiBiZSBzZW50IG1vcmUgdGhhbiBvbmNlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGNsb3NlIG5vdGlmaWNhdGlvbiBzZW5kIGJlZm9yZS5cbiAqIFRoaXMgbWVhbnMgb3BlbiBhbmQgY2xvc2Ugbm90aWZpY2F0aW9uIG11c3QgYmUgYmFsYW5jZWQgYW5kIHRoZSBtYXggb3BlbiBjb3VudFxuICogaXMgb25lLlxuICovXG52YXIgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIGNoYW5nZXMgdG8gYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNsb3NlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBkb2N1bWVudCBnb3QgY2xvc2VkIGluIHRoZSBjbGllbnQuIFRoZSBkb2N1bWVudCdzIHRydXRoIG5vdyBleGlzdHMgd2hlcmVcbiAqIHRoZSBkb2N1bWVudCdzIHVyaSBwb2ludHMgdG8gKGUuZy4gaWYgdGhlIGRvY3VtZW50J3MgdXJpIGlzIGEgZmlsZSB1cmkgdGhlXG4gKiB0cnV0aCBub3cgZXhpc3RzIG9uIGRpc2spLiBBcyB3aXRoIHRoZSBvcGVuIG5vdGlmaWNhdGlvbiB0aGUgY2xvc2Ugbm90aWZpY2F0aW9uXG4gKiBpcyBhYm91dCBtYW5hZ2luZyB0aGUgZG9jdW1lbnQncyBjb250ZW50LiBSZWNlaXZpbmcgYSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBkb2N1bWVudCB3YXMgb3BlbiBpbiBhbiBlZGl0b3IgYmVmb3JlLiBBIGNsb3NlXG4gKiBub3RpZmljYXRpb24gcmVxdWlyZXMgYSBwcmV2aW91cyBvcGVuIG5vdGlmaWNhdGlvbiB0byBiZSBzZW50LlxuICovXG52YXIgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyByZWFzb25zIHdoeSBhIHRleHQgZG9jdW1lbnQgaXMgc2F2ZWQuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTYXZlUmVhc29uO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTYXZlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgdHJpZ2dlcmVkLCBlLmcuIGJ5IHRoZSB1c2VyIHByZXNzaW5nIHNhdmUsIGJ5IHN0YXJ0aW5nIGRlYnVnZ2luZyxcbiAgICAgKiBvciBieSBhbiBBUEkgY2FsbC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLk1hbnVhbCA9IDE7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGFmdGVyIGEgZGVsYXkuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5BZnRlckRlbGF5ID0gMjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBlZGl0b3IgbG9zdCBmb2N1cy5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLkZvY3VzT3V0ID0gMztcbn0pKFRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgd2lsbCBzYXZlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZVxuICogdGhlIGRvY3VtZW50IGlzIGFjdHVhbGx5IHNhdmVkLlxuICovXG52YXIgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC93aWxsU2F2ZSc7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3YXRjaGVkIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBjbGllbnQgZGV0ZWN0cyBjaGFuZ2VzIHRvIGZpbGUgd2F0Y2hlZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXYXRjaGVkRmlsZXMnO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGZpbGUgZXZlbnQgdHlwZVxuICovXG52YXIgRmlsZUNoYW5nZVR5cGU7XG4oZnVuY3Rpb24gKEZpbGVDaGFuZ2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNyZWF0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNoYW5nZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ2hhbmdlZCA9IDI7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGRlbGV0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuRGVsZXRlZCA9IDM7XG59KShGaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgfHwgKGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLlJlbGF0aXZlUGF0dGVybiB8fCAoZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSB7fSkpO1xudmFyIFdhdGNoS2luZDtcbihmdW5jdGlvbiAoV2F0Y2hLaW5kKSB7XG4gICAgLyoqXG4gICAgICogSW50ZXJlc3RlZCBpbiBjcmVhdGUgZXZlbnRzLlxuICAgICAqL1xuICAgIFdhdGNoS2luZC5DcmVhdGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY2hhbmdlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5DaGFuZ2UgPSAyO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gZGVsZXRlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5EZWxldGUgPSA0O1xufSkoV2F0Y2hLaW5kID0gZXhwb3J0cy5XYXRjaEtpbmQgfHwgKGV4cG9ydHMuV2F0Y2hLaW5kID0ge30pKTtcbi8qKlxuICogRGlhZ25vc3RpY3Mgbm90aWZpY2F0aW9uIGFyZSBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNpZ25hbFxuICogcmVzdWx0cyBvZiB2YWxpZGF0aW9uIHJ1bnMuXG4gKi9cbnZhciBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbikge1xuICAgIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3B1Ymxpc2hEaWFnbm9zdGljcyc7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlcXVlc3QgY29tcGxldGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbSBDb21wbGV0aW9uSXRlbVtdfSBvciB7QGxpbmsgQ29tcGxldGlvbkxpc3R9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBUaGUgcmVxdWVzdCBjYW4gZGVsYXkgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZGV0YWlsIGBkZXRhaWxgfVxuICogYW5kIHtAbGluayBDb21wbGV0aW9uSXRlbS5kb2N1bWVudGF0aW9uIGBkb2N1bWVudGF0aW9uYH0gcHJvcGVydGllcyB0byB0aGUgYGNvbXBsZXRpb25JdGVtL3Jlc29sdmVgXG4gKiByZXF1ZXN0LiBIb3dldmVyLCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgc29ydGluZyBhbmQgZmlsdGVyaW5nLCBsaWtlIGBzb3J0VGV4dGAsXG4gKiBgZmlsdGVyVGV4dGAsIGBpbnNlcnRUZXh0YCwgYW5kIGB0ZXh0RWRpdGAsIG11c3Qgbm90IGJlIGNoYW5nZWQgZHVyaW5nIHJlc29sdmUuXG4gKi9cbnZhciBDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvbXBsZXRpb24nO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvbXBsZXRpb24gaXRlbS5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvbXBsZXRpb25JdGVtL3Jlc29sdmUnO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCB8fCAoZXhwb3J0cy5Ib3ZlclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBzaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIGludm9rZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIgb3IgYnkgYSBjb21tYW5kLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5JbnZva2VkID0gMTtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIgPSAyO1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIGN1cnNvciBtb3Zpbmcgb3IgYnkgdGhlIGRvY3VtZW50IGNvbnRlbnQgY2hhbmdpbmcuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkNvbnRlbnRDaGFuZ2UgPSAzO1xufSkoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTaWduYXR1cmVIZWxwUmVxdWVzdDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFJlcXVlc3QpIHtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NpZ25hdHVyZUhlbHAnO1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2lnbmF0dXJlSGVscFJlcXVlc3QubWV0aG9kKTtcbn0pKFNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlc1xuICogdG8gc3VjaC5cbiAqL1xudmFyIERlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVmaW5pdGlvbic7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhIHtAbGluayBEb2N1bWVudEhpZ2hsaWdodH0gZm9yIGEgZ2l2ZW5cbiAqIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlcXVlc3QgcmVzcG9uc2UgaXMgb2YgdHlwZSBbRG9jdW1lbnRIaWdobGlnaHRbXV1cbiAqICgjRG9jdW1lbnRIaWdobGlnaHQpIG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QpIHtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudEhpZ2hsaWdodCc7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgYW5kIHJhbmdlLlxuICovXG52YXIgQ29kZUFjdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25SZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2RlQWN0aW9uJztcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBjb2RlIGFjdGlvbi5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29kZUFjdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdjb2RlQWN0aW9uL3Jlc29sdmUnO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHJhbmdlIGluc2lkZSB0aGUgd29ya3NwYWNlXG4gKiBzeW1ib2wncyBsb2NhdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlU3ltYm9sL3Jlc29sdmUnO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGNvZGUgbGVucyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQuXG4gKi9cbnZhciBDb2RlTGVuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVMZW5zUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvZGVMZW5zJztcbiAgICBDb2RlTGVuc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZWZyZXNoIGFsbCBjb2RlIGFjdGlvbnNcbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2NvZGVMZW5zL3JlZnJlc2hgO1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBkb2N1bWVudCBsaW5rc1xuICovXG52YXIgRG9jdW1lbnRMaW5rUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudExpbmsnO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRvIGZvcm1hdCBhIHdob2xlIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gdG8gZm9ybWF0IGEgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcmFuZ2VGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IGEgZG9jdW1lbnQgb24gdHlwZS5cbiAqL1xudmFyIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvb25UeXBlRm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBSZW5hbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQncyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHNlbGVjdCB0aGUgaWRlbnRpZmllclxuICAgICAqIGFjY29yZGluZyB0aGUgdG8gbGFuZ3VhZ2UncyBzeW50YXggcnVsZS5cbiAgICAgKi9cbiAgICBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvci5JZGVudGlmaWVyID0gMTtcbn0pKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciB8fCAoZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRlc3QgYW5kIHBlcmZvcm0gdGhlIHNldHVwIG5lY2Vzc2FyeSBmb3IgYSByZW5hbWUuXG4gKlxuICogQHNpbmNlIDMuMTYgLSBzdXBwb3J0IGZvciBkZWZhdWx0IGJlaGF2aW9yXG4gKi9cbnZhciBQcmVwYXJlUmVuYW1lUmVxdWVzdDtcbihmdW5jdGlvbiAoUHJlcGFyZVJlbmFtZVJlcXVlc3QpIHtcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3ByZXBhcmVSZW5hbWUnO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kKTtcbn0pKFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCBzZW5kIGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGV4ZWN1dGUgYSBjb21tYW5kLiBUaGUgcmVxdWVzdCBtaWdodCByZXR1cm5cbiAqIGEgd29ya3NwYWNlIGVkaXQgd2hpY2ggdGhlIGNsaWVudCB3aWxsIGFwcGx5IHRvIHRoZSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBFeGVjdXRlQ29tbWFuZFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCkge1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2V4ZWN1dGVDb21tYW5kJztcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCk7XG59KShFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTI3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSByYW5nZXMgdGhhdCBjYW4gYmUgZWRpdGVkIHRvZ2V0aGVyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QpIHtcbiAgICBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvbGlua2VkRWRpdGluZ1JhbmdlJztcbiAgICBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG59KShMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTY0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyS2luZCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIE1vbmlrZXIgdW5pcXVlbmVzcyBsZXZlbCB0byBkZWZpbmUgc2NvcGUgb2YgdGhlIG1vbmlrZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgVW5pcXVlbmVzc0xldmVsO1xuKGZ1bmN0aW9uIChVbmlxdWVuZXNzTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyBvbmx5IHVuaXF1ZSBpbnNpZGUgYSBkb2N1bWVudFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5kb2N1bWVudCA9ICdkb2N1bWVudCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSBhIHByb2plY3QgZm9yIHdoaWNoIGEgZHVtcCBnb3QgY3JlYXRlZFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5wcm9qZWN0ID0gJ3Byb2plY3QnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgdGhlIGdyb3VwIHRvIHdoaWNoIGEgcHJvamVjdCBiZWxvbmdzXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdyb3VwID0gJ2dyb3VwJztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBtb25pa2VyIHNjaGVtZS5cbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuc2NoZW1lID0gJ3NjaGVtZSc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdsb2JhbCA9ICdnbG9iYWwnO1xufSkoVW5pcXVlbmVzc0xldmVsID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgfHwgKGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0ge30pKTtcbi8qKlxuICogVGhlIG1vbmlrZXIga2luZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBNb25pa2VyS2luZDtcbihmdW5jdGlvbiAoTW9uaWtlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciByZXByZXNlbnQgYSBzeW1ib2wgdGhhdCBpcyBpbXBvcnRlZCBpbnRvIGEgcHJvamVjdFxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLiRpbXBvcnQgPSAnaW1wb3J0JztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciByZXByZXNlbnRzIGEgc3ltYm9sIHRoYXQgaXMgZXhwb3J0ZWQgZnJvbSBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kZXhwb3J0ID0gJ2V4cG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGxvY2FsIHRvIGEgcHJvamVjdCAoZS5nLiBhIGxvY2FsXG4gICAgICogdmFyaWFibGUgb2YgYSBmdW5jdGlvbiwgYSBjbGFzcyBub3QgdmlzaWJsZSBvdXRzaWRlIHRoZSBwcm9qZWN0LCAuLi4pXG4gICAgICovXG4gICAgTW9uaWtlcktpbmQubG9jYWwgPSAnbG9jYWwnO1xufSkoTW9uaWtlcktpbmQgPSBleHBvcnRzLk1vbmlrZXJLaW5kIHx8IChleHBvcnRzLk1vbmlrZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGdldCB0aGUgbW9uaWtlciBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uXG4gKiBUaGUgcmVxdWVzdCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXN9LlxuICogVGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIE1vbmlrZXIgTW9uaWtlcltdfSBvciBgbnVsbGAuXG4gKi9cbnZhciBNb25pa2VyUmVxdWVzdDtcbihmdW5jdGlvbiAoTW9uaWtlclJlcXVlc3QpIHtcbiAgICBNb25pa2VyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L21vbmlrZXInO1xuICAgIE1vbmlrZXJSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgTW9uaWtlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoTW9uaWtlclJlcXVlc3QubWV0aG9kKTtcbn0pKE1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCB8fCAoZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ0NjA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzY3KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTIzKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIG5vdGVib29rIGNlbGwga2luZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxLaW5kO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSBtYXJrdXAtY2VsbCBpcyBmb3JtYXR0ZWQgc291cmNlIHRoYXQgaXMgdXNlZCBmb3IgZGlzcGxheS5cbiAgICAgKi9cbiAgICBOb3RlYm9va0NlbGxLaW5kLk1hcmt1cCA9IDE7XG4gICAgLyoqXG4gICAgICogQSBjb2RlLWNlbGwgaXMgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5Db2RlID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbEtpbmQuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbEtpbmQgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IHt9KSk7XG52YXIgRXhlY3V0aW9uU3VtbWFyeTtcbihmdW5jdGlvbiAoRXhlY3V0aW9uU3VtbWFyeSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShleGVjdXRpb25PcmRlciwgc3VjY2Vzcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGV4ZWN1dGlvbk9yZGVyIH07XG4gICAgICAgIGlmIChzdWNjZXNzID09PSB0cnVlIHx8IHN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VjY2VzcyA9IHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRXhlY3V0aW9uU3VtbWFyeS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEudWludGVnZXIuaXMoY2FuZGlkYXRlLmV4ZWN1dGlvbk9yZGVyKSAmJiAoY2FuZGlkYXRlLnN1Y2Nlc3MgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5zdWNjZXNzKSk7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlcikge1xuICAgICAgICBpZiAob25lID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZSA9PT0gbnVsbCB8fCBvbmUgPT09IHVuZGVmaW5lZCB8fCBvdGhlciA9PT0gbnVsbCB8fCBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9uZS5leGVjdXRpb25PcmRlciA9PT0gb3RoZXIuZXhlY3V0aW9uT3JkZXIgJiYgb25lLnN1Y2Nlc3MgPT09IG90aGVyLnN1Y2Nlc3M7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuZXF1YWxzID0gZXF1YWxzO1xufSkoRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSB8fCAoZXhwb3J0cy5FeGVjdXRpb25TdW1tYXJ5ID0ge30pKTtcbnZhciBOb3RlYm9va0NlbGw7XG4oZnVuY3Rpb24gKE5vdGVib29rQ2VsbCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShraW5kLCBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4geyBraW5kLCBkb2N1bWVudCB9O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGwuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIE5vdGVib29rQ2VsbEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLkRvY3VtZW50VXJpLmlzKGNhbmRpZGF0ZS5kb2N1bWVudCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZS5tZXRhZGF0YSkpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGwuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBkaWZmKG9uZSwgdHdvKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKG9uZS5kb2N1bWVudCAhPT0gdHdvLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdkb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUua2luZCAhPT0gdHdvLmtpbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2tpbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lLmV4ZWN1dGlvblN1bW1hcnkgIT09IHR3by5leGVjdXRpb25TdW1tYXJ5KSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdleGVjdXRpb25TdW1tYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvbmUubWV0YWRhdGEgIT09IHVuZGVmaW5lZCB8fCB0d28ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCkgJiYgIWVxdWFsc01ldGFkYXRhKG9uZS5tZXRhZGF0YSwgdHdvLm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnbWV0YWRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9uZS5leGVjdXRpb25TdW1tYXJ5ICE9PSB1bmRlZmluZWQgfHwgdHdvLmV4ZWN1dGlvblN1bW1hcnkgIT09IHVuZGVmaW5lZCkgJiYgIUV4ZWN1dGlvblN1bW1hcnkuZXF1YWxzKG9uZS5leGVjdXRpb25TdW1tYXJ5LCB0d28uZXhlY3V0aW9uU3VtbWFyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2V4ZWN1dGlvblN1bW1hcnknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGwuZGlmZiA9IGRpZmY7XG4gICAgZnVuY3Rpb24gZXF1YWxzTWV0YWRhdGEob25lLCBvdGhlcikge1xuICAgICAgICBpZiAob25lID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZSA9PT0gbnVsbCB8fCBvbmUgPT09IHVuZGVmaW5lZCB8fCBvdGhlciA9PT0gbnVsbCB8fCBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvbmUgIT09IHR5cGVvZiBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25lICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uZUFycmF5ID0gQXJyYXkuaXNBcnJheShvbmUpO1xuICAgICAgICBjb25zdCBvdGhlckFycmF5ID0gQXJyYXkuaXNBcnJheShvdGhlcik7XG4gICAgICAgIGlmIChvbmVBcnJheSAhPT0gb3RoZXJBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmVBcnJheSAmJiBvdGhlckFycmF5KSB7XG4gICAgICAgICAgICBpZiAob25lLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVxdWFsc01ldGFkYXRhKG9uZVtpXSwgb3RoZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLm9iamVjdExpdGVyYWwob25lKSAmJiBJcy5vYmplY3RMaXRlcmFsKG90aGVyKSkge1xuICAgICAgICAgICAgY29uc3Qgb25lS2V5cyA9IE9iamVjdC5rZXlzKG9uZSk7XG4gICAgICAgICAgICBjb25zdCBvdGhlcktleXMgPSBPYmplY3Qua2V5cyhvdGhlcik7XG4gICAgICAgICAgICBpZiAob25lS2V5cy5sZW5ndGggIT09IG90aGVyS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbmVLZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIG90aGVyS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICBpZiAoIWVxdWFsc01ldGFkYXRhKG9uZUtleXMsIG90aGVyS2V5cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gb25lS2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWVxdWFsc01ldGFkYXRhKG9uZVtwcm9wXSwgb3RoZXJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSkoTm90ZWJvb2tDZWxsID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50O1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbm90ZWJvb2tUeXBlLCB2ZXJzaW9uLCBjZWxscykge1xuICAgICAgICByZXR1cm4geyB1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLmludGVnZXIuaXMoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50LmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50IHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSB7fSkpO1xudmFyIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlKSB7XG4gICAgTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L3N5bmMnO1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUmVnaXN0cmF0aW9uVHlwZShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kKTtcbn0pKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlIHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIG9wZW5zLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZE9wZW4nO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxBcnJheUNoYW5nZSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5zdGFydCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEudWludGVnZXIuaXMoY2FuZGlkYXRlLmRlbGV0ZUNvdW50KSAmJiAoY2FuZGlkYXRlLmNlbGxzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY2VsbHMsIE5vdGVib29rQ2VsbC5pcykpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydCwgZGVsZXRlQ291bnQsIGNlbGxzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc3RhcnQsIGRlbGV0ZUNvdW50IH07XG4gICAgICAgIGlmIChjZWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2VsbHMgPSBjZWxscztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG59KShOb3RlYm9va0NlbGxBcnJheUNoYW5nZSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSB7fSkpO1xudmFyIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZENoYW5nZSc7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogQSBub3RpZmljYXRpb24gc2VudCB3aGVuIGEgbm90ZWJvb2sgZG9jdW1lbnQgaXMgc2F2ZWQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkU2F2ZSc7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGNsb3Nlcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3ODk1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk1Myk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbnZhciBXb3JrRG9uZVByb2dyZXNzO1xuKGZ1bmN0aW9uIChXb3JrRG9uZVByb2dyZXNzKSB7XG4gICAgV29ya0RvbmVQcm9ncmVzcy50eXBlID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBXb3JrRG9uZVByb2dyZXNzLnR5cGU7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3MuaXMgPSBpcztcbn0pKFdvcmtEb25lUHJvZ3Jlc3MgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgfHwgKGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd2luZG93L3dvcmtEb25lUHJvZ3Jlc3MvY3JlYXRlYCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gaW5pdGlhdGUgcHJvZ3Jlc3NcbiAqIHJlcG9ydGluZyBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbnZhciBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QpIHtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3dvcmtEb25lUHJvZ3Jlc3MvY3JlYXRlJztcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1ldGhvZCk7XG59KShXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgfHwgKGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbGAgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSAgdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGNhbmNlbCBhIHByb2dyZXNzXG4gKiBpbml0aWF0ZWQgb24gdGhlIHNlcnZlciBzaWRlLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbikge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbCc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzkyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIHNlbGVjdGlvbiByYW5nZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFNlbGVjdGlvblJhbmdlUGFyYW1zfSwgdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZSBTZWxlY3Rpb25SYW5nZVtdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBTZWxlY3Rpb25SYW5nZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbGVjdGlvblJhbmdlUmVxdWVzdCkge1xuICAgIFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbGVjdGlvblJhbmdlJztcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG59KShTZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDg5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLlRva2VuRm9ybWF0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vLy0tLS0tLS0gJ3RleHREb2N1bWVudC9zZW1hbnRpY1Rva2VucycgLS0tLS1cbnZhciBUb2tlbkZvcm1hdDtcbihmdW5jdGlvbiAoVG9rZW5Gb3JtYXQpIHtcbiAgICBUb2tlbkZvcm1hdC5SZWxhdGl2ZSA9ICdyZWxhdGl2ZSc7XG59KShUb2tlbkZvcm1hdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgfHwgKGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSB7fSkpO1xudmFyIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlKSB7XG4gICAgU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnO1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUmVnaXN0cmF0aW9uVHlwZShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlIHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZXF1ZXN0KSB7XG4gICAgU2VtYW50aWNUb2tlbnNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvZnVsbCc7XG4gICAgU2VtYW50aWNUb2tlbnNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QpO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0KSB7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZW1hbnRpY1Rva2Vucy9mdWxsL2RlbHRhJztcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvcmFuZ2UnO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9zZW1hbnRpY1Rva2Vucy9yZWZyZXNoYDtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU0MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TaG93RG9jdW1lbnRSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODU5OSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBzaG93IGEgZG9jdW1lbnQuIFRoaXMgcmVxdWVzdCBtaWdodCBvcGVuIGFuXG4gKiBleHRlcm5hbCBwcm9ncmFtIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgdGhlIFVSSSB0byBvcGVuLlxuICogRm9yIGV4YW1wbGUgYSByZXF1ZXN0IHRvIG9wZW4gYGh0dHBzOi8vY29kZS52aXN1YWxzdHVkaW8uY29tL2BcbiAqIHdpbGwgdmVyeSBsaWtlbHkgb3BlbiB0aGUgVVJJIGluIGEgV0VCIGJyb3dzZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuKi9cbnZhciBTaG93RG9jdW1lbnRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaG93RG9jdW1lbnRSZXF1ZXN0KSB7XG4gICAgU2hvd0RvY3VtZW50UmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3Nob3dEb2N1bWVudCc7XG4gICAgU2hvd0RvY3VtZW50UmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2hvd0RvY3VtZW50UmVxdWVzdC5tZXRob2QpO1xufSkoU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCB8fCAoZXhwb3J0cy5TaG93RG9jdW1lbnRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODY0Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTk5KTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGFcbiAqIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIFR5cGVEZWZpbml0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZURlZmluaXRpb25SZXF1ZXN0KSB7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvdHlwZURlZmluaXRpb24nO1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzMTg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzdWx0IGEgYFR5cGVIaWVyYXJjaHlJdGVtYCBpbiBhIGRvY3VtZW50IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gKiBDYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCB0byBhIHN1YnR5cGVzIG9yIHN1cGVydHlwZXMgdHlwZSBoaWVyYXJjaHkuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlVHlwZUhpZXJhcmNoeSc7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHN1cGVydHlwZXMgZm9yIGEgZ2l2ZW4gYFR5cGVIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCkge1xuICAgIFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QgPSAndHlwZUhpZXJhcmNoeS9zdXBlcnR5cGVzJztcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgc3VidHlwZXMgZm9yIGEgZ2l2ZW4gYFR5cGVIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0KSB7XG4gICAgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC5tZXRob2QgPSAndHlwZUhpZXJhcmNoeS9zdWJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQwMjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1OTkpO1xuLyoqXG4gKiBUaGUgYHdvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzYCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGZldGNoIHRoZSBvcGVuIHdvcmtzcGFjZSBmb2xkZXJzLlxuICovXG52YXIgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzJztcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGB3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc2Agbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlbiB0aGUgd29ya3NwYWNlXG4gKiBmb2xkZXIgY29uZmlndXJhdGlvbiBjaGFuZ2VzLlxuICovXG52YXIgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbikge1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzJztcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI1MjM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMub2JqZWN0TGl0ZXJhbCA9IGV4cG9ydHMudHlwZWRBcnJheSA9IGV4cG9ydHMuc3RyaW5nQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5mdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XG59XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XG5mdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShjaGVjayk7XG59XG5leHBvcnRzLnR5cGVkQXJyYXkgPSB0eXBlZEFycmF5O1xuZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgIC8vIFN0cmljdGx5IHNwZWFraW5nIGNsYXNzIGluc3RhbmNlcyBwYXNzIHRoaXMgY2hlY2sgYXMgd2VsbC4gU2luY2UgdGhlIExTUFxuICAgIC8vIGRvZXNuJ3QgdXNlIGNsYXNzZXMgd2UgaWdub3JlIHRoaXMgZm9yIG5vdy4gSWYgd2UgZG8gd2UgbmVlZCB0byBhZGQgc29tZXRoaW5nXG4gICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLm9iamVjdExpdGVyYWwgPSBvYmplY3RMaXRlcmFsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0ODgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIG46ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudClcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgX19zcHJlYWRBcnJheSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoYW5nZXNfMSA9IGNoYW5nZXM7IF9pIDwgY2hhbmdlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNfMVtfaV07XG4gICAgICAgICAgICBpZiAoRnVsbFRleHREb2N1bWVudC5pc0luY3JlbWVudGFsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlcyBzdXJlIHN0YXJ0IGlzIGJlZm9yZSBlbmRcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRXZWxsZm9ybWVkUmFuZ2UoY2hhbmdlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxuICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudCA9IHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGNoYW5nZS50ZXh0ICsgdGhpcy5fY29udGVudC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBvZmZzZXRzXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0LmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIHZhciBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIHZhciBhZGRlZExpbmVPZmZzZXRzID0gY29tcHV0ZUxpbmVPZmZzZXRzKGNoYW5nZS50ZXh0LCBmYWxzZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRMaW5lIC0gc3RhcnRMaW5lID09PSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHNbaSArIHN0YXJ0TGluZSArIDFdID0gYWRkZWRMaW5lT2Zmc2V0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkTGluZU9mZnNldHMubGVuZ3RoIDwgMTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnNwbGljZS5hcHBseShsaW5lT2Zmc2V0cywgX19zcHJlYWRBcnJheShbc3RhcnRMaW5lICsgMSwgZW5kTGluZSAtIHN0YXJ0TGluZV0sIGFkZGVkTGluZU9mZnNldHMsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGF2b2lkIHRvbyBtYW55IGFyZ3VtZW50cyBmb3Igc3BsaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzID0gbGluZU9mZnNldHMuc2xpY2UoMCwgc3RhcnRMaW5lICsgMSkuY29uY2F0KGFkZGVkTGluZU9mZnNldHMsIGxpbmVPZmZzZXRzLnNsaWNlKGVuZExpbmUgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5nZXRMaW5lT2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVPZmZzZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gY29tcHV0ZUxpbmVPZmZzZXRzKHRoaXMuX2NvbnRlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgICAgICAgaWYgKGxpbmVPZmZzZXRzW21pZF0gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsb3cgaXMgdGhlIGxlYXN0IHggZm9yIHdoaWNoIHRoZSBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgLy8gb3IgYXJyYXkubGVuZ3RoIGlmIG5vIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICB2YXIgbGluZSA9IGxvdyAtIDE7XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3Rlcjogb2Zmc2V0IC0gbGluZU9mZnNldHNbbGluZV0gfTtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLm9mZnNldEF0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZV07XG4gICAgICAgIHZhciBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KSwgbGluZU9mZnNldCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGluZUNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQuaXNJbmNyZW1lbnRhbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LmlzRnVsbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRleHQgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCAgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgaW5pdGlhbCB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIFRleHREb2N1bWVudCBieSBtb2RpZnlpbmcgaXRzIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgdGhlIGRvY3VtZW50IHRvIHVwZGF0ZS4gT25seSBkb2N1bWVudHMgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlIGFyZSB2YWxpZCBpbnB1dHMuXG4gICAgICogQHBhcmFtIGNoYW5nZXMgdGhlIGNoYW5nZXMgdG8gYXBwbHkgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIHRoZSBjaGFuZ2VzIHZlcnNpb24gZm9yIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUZXh0RG9jdW1lbnQuIE5vdGU6IFRoYXQncyB0aGUgc2FtZSBkb2N1bWVudCBpbnN0YW5jZSBwYXNzZWQgaW4gYXMgZmlyc3QgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKGRvY3VtZW50LCBjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIEZ1bGxUZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dERvY3VtZW50LnVwZGF0ZTogZG9jdW1lbnQgbXVzdCBiZSBjcmVhdGVkIGJ5IFRleHREb2N1bWVudC5jcmVhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQudXBkYXRlID0gdXBkYXRlO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMubWFwKGdldFdlbGxmb3JtZWRFZGl0KSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhc3RNb2RpZmllZE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvcnRlZEVkaXRzXzEgPSBzb3J0ZWRFZGl0czsgX2kgPCBzb3J0ZWRFZGl0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGUgPSBzb3J0ZWRFZGl0c18xW19pXTtcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0IDwgbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydE9mZnNldCA+IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2godGV4dC5zdWJzdHJpbmcobGFzdE1vZGlmaWVkT2Zmc2V0LCBzdGFydE9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUubmV3VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGUubmV3VGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cihsYXN0TW9kaWZpZWRPZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIHNwYW5zLmpvaW4oJycpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG5mdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIC8vIHNvcnRlZFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgdmFyIGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIHZhciByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgdmFyIGxlZnRJZHggPSAwO1xuICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgaWYgKHJldCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICB9XG4gICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lT2Zmc2V0cyh0ZXh0LCBpc0F0TGluZVN0YXJ0LCB0ZXh0T2Zmc2V0KSB7XG4gICAgaWYgKHRleHRPZmZzZXQgPT09IHZvaWQgMCkgeyB0ZXh0T2Zmc2V0ID0gMDsgfVxuICAgIHZhciByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyB8fCBjaCA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8gJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHRPZmZzZXQgKyBpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFdlbGxmb3JtZWRSYW5nZShyYW5nZSkge1xuICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIHZhciByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgaWYgKHJhbmdlICE9PSB0ZXh0RWRpdC5yYW5nZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiB0ZXh0RWRpdC5uZXdUZXh0LCByYW5nZTogcmFuZ2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRFZGl0O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzY3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFubm90YXRlZFRleHRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBBbm5vdGF0ZWRUZXh0RWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENoYW5nZUFubm90YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlQWN0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbkNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIENvZGVBY3Rpb25Db250ZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbktpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIENvZGVBY3Rpb25LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uVHJpZ2dlcktpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlRGVzY3JpcHRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvZGVEZXNjcmlwdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVMZW5zOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlTGVucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbG9yOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbG9ySW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9ySW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvclByZXNlbnRhdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3JQcmVzZW50YXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21tYW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21tYW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbUtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlsczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21wbGV0aW9uSXRlbVRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1UYWcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb21wbGV0aW9uTGlzdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkxpc3QpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDcmVhdGVGaWxlOiAoKSA9PiAoLyogYmluZGluZyAqLyBDcmVhdGVGaWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGVsZXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGVsZXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWM6ICgpID0+ICgvKiBiaW5kaW5nICovIERpYWdub3N0aWMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1NldmVyaXR5OiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljU2V2ZXJpdHkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljVGFnOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRIaWdobGlnaHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIERvY3VtZW50SGlnaGxpZ2h0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudExpbms6ICgpID0+ICgvKiBiaW5kaW5nICovIERvY3VtZW50TGluayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50U3ltYm9sOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudFN5bWJvbCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50VXJpOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudFVyaSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEVPTDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRU9MKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb2xkaW5nUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBGb2xkaW5nUmFuZ2VLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb2xkaW5nUmFuZ2VLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9ybWF0dGluZ09wdGlvbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIEZvcm1hdHRpbmdPcHRpb25zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSG92ZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIEhvdmVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxheUhpbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxheUhpbnRLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxheUhpbnRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50TGFiZWxQYXJ0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxheUhpbnRMYWJlbFBhcnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVGV4dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVUZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFJlcGxhY2VFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRSZXBsYWNlRWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFRleHRGb3JtYXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRGb3JtYXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0TW9kZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0VGV4dE1vZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTG9jYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbkxpbms6ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uTGluayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmtlZFN0cmluZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya2VkU3RyaW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTWFya3VwQ29udGVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya3VwQ29udGVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cEtpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBhcmFtZXRlckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXJhbWV0ZXJJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBvc2l0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQb3NpdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJhbmdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJlbmFtZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIFJlbmFtZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZWxlY3Rpb25SYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VsZWN0aW9uUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlblR5cGVzOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZW1hbnRpY1Rva2VuVHlwZXMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZW1hbnRpY1Rva2VuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTaWduYXR1cmVJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2lnbmF0dXJlSW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTeW1ib2xJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sSW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTeW1ib2xLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBTeW1ib2xLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sVGFnOiAoKSA9PiAoLyogYmluZGluZyAqLyBTeW1ib2xUYWcpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SXRlbTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFVSSTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVVJJKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUNoYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlQ2hhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgV29ya3NwYWNlRWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlRWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUZvbGRlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlRm9sZGVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgV29ya3NwYWNlU3ltYm9sOiAoKSA9PiAoLyogYmluZGluZyAqLyBXb3Jrc3BhY2VTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyBpbnRlZ2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgdWludGVnZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIHVpbnRlZ2VyKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBEb2N1bWVudFVyaTtcbihmdW5jdGlvbiAoRG9jdW1lbnRVcmkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgRG9jdW1lbnRVcmkuaXMgPSBpcztcbn0pKERvY3VtZW50VXJpIHx8IChEb2N1bWVudFVyaSA9IHt9KSk7XG52YXIgVVJJO1xuKGZ1bmN0aW9uIChVUkkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgVVJJLmlzID0gaXM7XG59KShVUkkgfHwgKFVSSSA9IHt9KSk7XG52YXIgaW50ZWdlcjtcbihmdW5jdGlvbiAoaW50ZWdlcikge1xuICAgIGludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG4gICAgaW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IGludGVnZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICBpbnRlZ2VyLmlzID0gaXM7XG59KShpbnRlZ2VyIHx8IChpbnRlZ2VyID0ge30pKTtcbnZhciB1aW50ZWdlcjtcbihmdW5jdGlvbiAodWludGVnZXIpIHtcbiAgICB1aW50ZWdlci5NSU5fVkFMVUUgPSAwO1xuICAgIHVpbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdWludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgdWludGVnZXIuaXMgPSBpcztcbn0pKHVpbnRlZ2VyIHx8ICh1aW50ZWdlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQb3NpdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQb3NpdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uIGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gbGluZSBhbmQgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSBsaW5lIFRoZSBwb3NpdGlvbidzIGxpbmUuXG4gICAgICogQHBhcmFtIGNoYXJhY3RlciBUaGUgcG9zaXRpb24ncyBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxpbmUsIGNoYXJhY3Rlcikge1xuICAgICAgICBpZiAobGluZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgbGluZSA9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY2hhcmFjdGVyOiBjaGFyYWN0ZXIgfTtcbiAgICB9XG4gICAgUG9zaXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUG9zaXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5jaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBQb3NpdGlvbi5pcyA9IGlzO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFJhbmdlfSBsaXRlcmFscy5cbiAqL1xudmFyIFJhbmdlO1xuKGZ1bmN0aW9uIChSYW5nZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbmUsIHR3bywgdGhyZWUsIGZvdXIpIHtcbiAgICAgICAgaWYgKElzLnVpbnRlZ2VyKG9uZSkgJiYgSXMudWludGVnZXIodHdvKSAmJiBJcy51aW50ZWdlcih0aHJlZSkgJiYgSXMudWludGVnZXIoZm91cikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBQb3NpdGlvbi5jcmVhdGUob25lLCB0d28pLCBlbmQ6IFBvc2l0aW9uLmNyZWF0ZSh0aHJlZSwgZm91cikgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQb3NpdGlvbi5pcyhvbmUpICYmIFBvc2l0aW9uLmlzKHR3bykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBvbmUsIGVuZDogdHdvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSNjcmVhdGUgY2FsbGVkIHdpdGggaW52YWxpZCBhcmd1bWVudHNbXCIuY29uY2F0KG9uZSwgXCIsIFwiKS5jb25jYXQodHdvLCBcIiwgXCIpLmNvbmNhdCh0aHJlZSwgXCIsIFwiKS5jb25jYXQoZm91ciwgXCJdXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbiBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnVyaSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbi5pcyA9IGlzO1xufSkoTG9jYXRpb24gfHwgKExvY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uTGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbkxpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpOiB0YXJnZXRVcmksIHRhcmdldFJhbmdlOiB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2U6IHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZTogb3JpZ2luU2VsZWN0aW9uUmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9uTGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFNlbGVjdGlvblJhbmdlKVxuICAgICAgICAgICAgJiYgKFJhbmdlLmlzKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbkxpbmsuaXMgPSBpcztcbn0pKExvY2F0aW9uTGluayB8fCAoTG9jYXRpb25MaW5rID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9yO1xuKGZ1bmN0aW9uIChDb2xvcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3IgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZDogcmVkLFxuICAgICAgICAgICAgZ3JlZW46IGdyZWVuLFxuICAgICAgICAgICAgYmx1ZTogYmx1ZSxcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLnJlZCwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ncmVlbiwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ibHVlLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmFscGhhLCAwLCAxKTtcbiAgICB9XG4gICAgQ29sb3IuaXMgPSBpcztcbn0pKENvbG9yIHx8IChDb2xvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvckluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgQ29sb3JJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoQ29sb3JJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgQ29sb3IuaXMoY2FuZGlkYXRlLmNvbG9yKTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JJbmZvcm1hdGlvbiB8fCAoQ29sb3JJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvclByZXNlbnRhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvclByZXNlbnRhdGlvbjtcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIHRleHRFZGl0LCBhZGRpdGlvbmFsVGV4dEVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICB0ZXh0RWRpdDogdGV4dEVkaXQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsVGV4dEVkaXRzOiBhZGRpdGlvbmFsVGV4dEVkaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50ZXh0RWRpdCkgfHwgVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmFkZGl0aW9uYWxUZXh0RWRpdHMpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmFkZGl0aW9uYWxUZXh0RWRpdHMsIFRleHRFZGl0LmlzKSk7XG4gICAgfVxuICAgIENvbG9yUHJlc2VudGF0aW9uLmlzID0gaXM7XG59KShDb2xvclByZXNlbnRhdGlvbiB8fCAoQ29sb3JQcmVzZW50YXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHJhbmdlIGtpbmRzLlxuICovXG52YXIgRm9sZGluZ1JhbmdlS2luZDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlS2luZCkge1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgY29tbWVudFxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudCA9ICdjb21tZW50JztcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhbiBpbXBvcnQgb3IgaW5jbHVkZVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cyA9ICdpbXBvcnRzJztcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIHJlZ2lvbiAoZS5nLiBgI3JlZ2lvbmApXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5SZWdpb24gPSAncmVnaW9uJztcbn0pKEZvbGRpbmdSYW5nZUtpbmQgfHwgKEZvbGRpbmdSYW5nZUtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZm9sZGluZyByYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb2xkaW5nUmFuZ2V9IGxpdGVyYWxzLlxuICovXG52YXIgRm9sZGluZ1JhbmdlO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvbGRpbmdSYW5nZSBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q2hhcmFjdGVyLCBlbmRDaGFyYWN0ZXIsIGtpbmQsIGNvbGxhcHNlZFRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgZW5kTGluZTogZW5kTGluZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzdGFydENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGVuZENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmRDaGFyYWN0ZXIgPSBlbmRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChjb2xsYXBzZWRUZXh0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbGxhcHNlZFRleHQgPSBjb2xsYXBzZWRUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEZvbGRpbmdSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb2xkaW5nUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmtpbmQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpO1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuaXMgPSBpcztcbn0pKEZvbGRpbmdSYW5nZSB8fCAoRm9sZGluZ1JhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxvY2F0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSk7XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gfHwgKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxuICovXG52YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGVycm9yLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgaGludC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XG59KShEaWFnbm9zdGljU2V2ZXJpdHkgfHwgKERpYWdub3N0aWNTZXZlcml0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgRGlhZ25vc3RpY1RhZztcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1RhZykge1xuICAgIC8qKlxuICAgICAqIFVudXNlZCBvciB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgKiBhbiBlcnJvciBzcXVpZ2dsZS5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG9yIG9ic29sZXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlcmVkIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgc3RyaWtlIHRocm91Z2guXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbn0pKERpYWdub3N0aWNUYWcgfHwgKERpYWdub3N0aWNUYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlRGVzY3JpcHRpb247XG4oZnVuY3Rpb24gKENvZGVEZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmhyZWYpO1xuICAgIH1cbiAgICBDb2RlRGVzY3JpcHRpb24uaXMgPSBpcztcbn0pKENvZGVEZXNjcmlwdGlvbiB8fCAoQ29kZURlc2NyaXB0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIERpYWdub3N0aWMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRGlhZ25vc3RpY30gbGl0ZXJhbHMuXG4gKi9cbnZhciBEaWFnbm9zdGljO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBtZXNzYWdlLCBzZXZlcml0eSwgY29kZSwgc291cmNlLCByZWxhdGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHNldmVyaXR5KSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29kZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHJlbGF0ZWRJbmZvcm1hdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWxhdGVkSW5mb3JtYXRpb24gPSByZWxhdGVkSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEaWFnbm9zdGljfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSlcbiAgICAgICAgICAgICYmIChJcy5udW1iZXIoY2FuZGlkYXRlLnNldmVyaXR5KSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnNldmVyaXR5KSlcbiAgICAgICAgICAgICYmIChJcy5pbnRlZ2VyKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvZGUpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pIHx8IChJcy5zdHJpbmcoKF9hID0gY2FuZGlkYXRlLmNvZGVEZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpKSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnNvdXJjZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zb3VyY2UpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5yZWxhdGVkSW5mb3JtYXRpb24sIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMpKTtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5pcyA9IGlzO1xufSkoRGlhZ25vc3RpYyB8fCAoRGlhZ25vc3RpYyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21tYW5kIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbW1hbmR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWFuZCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0geyB0aXRsZTogdGl0bGUsIGNvbW1hbmQ6IGNvbW1hbmQgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb21tYW5kLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbW1hbmR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb21tYW5kKTtcbiAgICB9XG4gICAgQ29tbWFuZC5pcyA9IGlzO1xufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSByZXBsYWNlLFxuICogaW5zZXJ0IGFuZCBkZWxldGUgZWRpdHMgbW9yZSBlYXNpbHkuXG4gKi9cbnZhciBUZXh0RWRpdDtcbihmdW5jdGlvbiAoVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc2VydCB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0Lmluc2VydCA9IGluc2VydDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJyB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xuICAgIH1cbiAgICBUZXh0RWRpdC5pcyA9IGlzO1xufSkoVGV4dEVkaXQgfHwgKFRleHRFZGl0ID0ge30pKTtcbnZhciBDaGFuZ2VBbm5vdGF0aW9uO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBuZWVkc0NvbmZpcm1hdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChuZWVkc0NvbmZpcm1hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQubmVlZHNDb25maXJtYXRpb24gPSBuZWVkc0NvbmZpcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpICYmXG4gICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI7XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciB8fCAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgPSB7fSkpO1xudmFyIEFubm90YXRlZFRleHRFZGl0O1xuKGZ1bmN0aW9uIChBbm5vdGF0ZWRUZXh0RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIHJlcGxhY2UgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogbmV3VGV4dCwgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGluc2VydCB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6ICcnLCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkgJiYgKENoYW5nZUFubm90YXRpb24uaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5pcyA9IGlzO1xufSkoQW5ub3RhdGVkVGV4dEVkaXQgfHwgKEFubm90YXRlZFRleHRFZGl0ID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGVcbiAqIGFuIGVkaXQgdGhhdCBtYW5pcHVsYXRlcyBhIHRleHQgZG9jdW1lbnQuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGV4dERvY3VtZW50RWRpdGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGV4dERvY3VtZW50LCBlZGl0cykge1xuICAgICAgICByZXR1cm4geyB0ZXh0RG9jdW1lbnQ6IHRleHREb2N1bWVudCwgZWRpdHM6IGVkaXRzIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS50ZXh0RG9jdW1lbnQpXG4gICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5lZGl0cyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEVkaXQuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEVkaXQgfHwgKFRleHREb2N1bWVudEVkaXQgPSB7fSkpO1xudmFyIENyZWF0ZUZpbGU7XG4oZnVuY3Rpb24gKENyZWF0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuaXMgPSBpcztcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xudmFyIFJlbmFtZUZpbGU7XG4oZnVuY3Rpb24gKFJlbmFtZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdyZW5hbWUnLFxuICAgICAgICAgICAgb2xkVXJpOiBvbGRVcmksXG4gICAgICAgICAgICBuZXdVcmk6IG5ld1VyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBSZW5hbWVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdyZW5hbWUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUub2xkVXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1VyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5pcyA9IGlzO1xufSkoUmVuYW1lRmlsZSB8fCAoUmVuYW1lRmlsZSA9IHt9KSk7XG52YXIgRGVsZXRlRmlsZTtcbihmdW5jdGlvbiAoRGVsZXRlRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdkZWxldGUnLFxuICAgICAgICAgICAgdXJpOiB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5yZWN1cnNpdmUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xufSkoRGVsZXRlRmlsZSB8fCAoRGVsZXRlRmlsZSA9IHt9KSk7XG52YXIgV29ya3NwYWNlRWRpdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRWRpdC5pcyA9IGlzO1xufSkoV29ya3NwYWNlRWRpdCB8fCAoV29ya3NwYWNlRWRpdCA9IHt9KSk7XG52YXIgVGV4dEVkaXRDaGFuZ2VJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgY2hhbmdlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xuICAgICAgICB0aGlzLmNoYW5nZUFubm90YXRpb25zID0gY2hhbmdlQW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIGVkaXQ7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LmRlbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlZGl0KSB7XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0cztcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWRpdHMuc3BsaWNlKDAsIHRoaXMuZWRpdHMubGVuZ3RoKTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRleHQgZWRpdCBjaGFuZ2UgaXMgbm90IGNvbmZpZ3VyZWQgdG8gbWFuYWdlIGNoYW5nZSBhbm5vdGF0aW9ucy5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUZXh0RWRpdENoYW5nZUltcGw7XG59KCkpO1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzc1xuICovXG52YXIgQ2hhbmdlQW5ub3RhdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubWFuYWdlID0gZnVuY3Rpb24gKGlkT3JBbm5vdGF0aW9uLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGlkT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklkIFwiLmNvbmNhdChpZCwgXCIgaXMgYWxyZWFkeSBpbiB1c2UuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhbm5vdGF0aW9uIHByb3ZpZGVkIGZvciBpZCBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uc1tpZF0gPSBhbm5vdGF0aW9uO1xuICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50ZXIudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFuZ2VBbm5vdGF0aW9ucztcbn0oKSk7XG4vKipcbiAqIEEgd29ya3NwYWNlIGNoYW5nZSBoZWxwcyBjb25zdHJ1Y3RpbmcgY2hhbmdlcyB0byBhIHdvcmtzcGFjZS5cbiAqL1xudmFyIFdvcmtzcGFjZUNoYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXb3Jrc3BhY2VDaGFuZ2Uod29ya3NwYWNlRWRpdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAod29ya3NwYWNlRWRpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0gd29ya3NwYWNlRWRpdDtcbiAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChjaGFuZ2UuZWRpdHMsIF90aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2NoYW5nZS50ZXh0RG9jdW1lbnQudXJpXSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKHdvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUsIFwiZWRpdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIHtAbGluayBXb3Jrc3BhY2VFZGl0fSBsaXRlcmFsXG4gICAgICAgICAqIHVzZSB0byBiZSByZXR1cm5lZCBmcm9tIGEgd29ya3NwYWNlIGVkaXQgb3BlcmF0aW9uIGxpa2UgcmVuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUFubm90YXRpb25zLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd29ya3NwYWNlRWRpdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuZ2V0VGV4dEVkaXRDaGFuZ2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGV4dERvY3VtZW50ID0geyB1cmk6IGtleS51cmksIHZlcnNpb246IGtleS52ZXJzaW9uIH07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dERvY3VtZW50RWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiB0ZXh0RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGVkaXRzOiBlZGl0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaCh0ZXh0RG9jdW1lbnRFZGl0KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIG5vcm1hbCB0ZXh0IGVkaXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0gPSBlZGl0cztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuaW5pdERvY3VtZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmluaXRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5jcmVhdGVGaWxlID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRpb247XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLnJlbmFtZUZpbGUgPSBmdW5jdGlvbiAob2xkVXJpLCBuZXdVcmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gUmVuYW1lRmlsZS5jcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuZGVsZXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdvcmtzcGFjZUNoYW5nZTtcbn0oKSk7XG5cbi8qKlxuICogVGhlIFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbik7XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUudmVyc2lvbiA9PT0gbnVsbCB8fCBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSk7XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50SXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudEl0ZW07XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudEl0ZW0gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSBkb2N1bWVudCdzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCwgdmVyc2lvbjogdmVyc2lvbiwgdGV4dDogdGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFRleHREb2N1bWVudEl0ZW19IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SXRlbSB8fCAoVGV4dERvY3VtZW50SXRlbSA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyB0aGUgY29udGVudCB0eXBlIHRoYXQgYSBjbGllbnQgc3VwcG9ydHMgaW4gdmFyaW91c1xuICogcmVzdWx0IGxpdGVyYWxzIGxpa2UgYEhvdmVyYCwgYFBhcmFtZXRlckluZm9gIG9yIGBDb21wbGV0aW9uSXRlbWAuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCBgTWFya3VwS2luZHNgIG11c3Qgbm90IHN0YXJ0IHdpdGggYSBgJGAuIFRoaXMga2luZHNcbiAqIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gKi9cbnZhciBNYXJrdXBLaW5kO1xuKGZ1bmN0aW9uIChNYXJrdXBLaW5kKSB7XG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dCBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuUGxhaW5UZXh0ID0gJ3BsYWludGV4dCc7XG4gICAgLyoqXG4gICAgICogTWFya2Rvd24gaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLk1hcmtkb3duID0gJ21hcmtkb3duJztcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWx1ZSBvZiB0aGUge0BsaW5rIE1hcmt1cEtpbmR9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLlBsYWluVGV4dCB8fCBjYW5kaWRhdGUgPT09IE1hcmt1cEtpbmQuTWFya2Rvd247XG4gICAgfVxuICAgIE1hcmt1cEtpbmQuaXMgPSBpcztcbn0pKE1hcmt1cEtpbmQgfHwgKE1hcmt1cEtpbmQgPSB7fSkpO1xudmFyIE1hcmt1cENvbnRlbnQ7XG4oZnVuY3Rpb24gKE1hcmt1cENvbnRlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrdXBDb250ZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ID0gMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kID0gMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciA9IDQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkID0gNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyA9IDc7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSA9IDg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID0gMTA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgPSAxMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSA9IDEzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkID0gMTQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgPSAxNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSA9IDE3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyID0gMTk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgPSAyMDtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0ID0gMjI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50ID0gMjM7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNTtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAqIHBsYWluIHRleHQgb3IgYSBzbmlwcGV0LlxuICovXG52YXIgSW5zZXJ0VGV4dEZvcm1hdDtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlBsYWluVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgc25pcHBldC5cbiAgICAgKlxuICAgICAqIEEgc25pcHBldCBjYW4gZGVmaW5lIHRhYiBzdG9wcyBhbmQgcGxhY2Vob2xkZXJzIHdpdGggYCQxYCwgYCQyYFxuICAgICAqIGFuZCBgJHszOmZvb31gLiBgJDBgIGRlZmluZXMgdGhlIGZpbmFsIHRhYiBzdG9wLCBpdCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBlbmQgb2YgdGhlIHNuaXBwZXQuIFBsYWNlaG9sZGVycyB3aXRoIGVxdWFsIGlkZW50aWZpZXJzIGFyZSBsaW5rZWQsXG4gICAgICogdGhhdCBpcyB0eXBpbmcgaW4gb25lIHdpbGwgdXBkYXRlIG90aGVycyB0b28uXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL2xhbmd1YWdlLXNlcnZlci1wcm90b2NvbC9zcGVjaWZpY2F0aW9ucy9zcGVjaWZpY2F0aW9uLWN1cnJlbnQvI3NuaXBwZXRfc3ludGF4XG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0ID0gMjtcbn0pKEluc2VydFRleHRGb3JtYXQgfHwgKEluc2VydFRleHRGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBDb21wbGV0aW9uIGl0ZW0gdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgY29tcGxldGlvblxuICogaXRlbS5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEluc2VydFJlcGxhY2VFZGl0O1xuKGZ1bmN0aW9uIChJbnNlcnRSZXBsYWNlRWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zZXJ0IC8gcmVwbGFjZSBlZGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiBuZXdUZXh0LCBpbnNlcnQ6IGluc2VydCwgcmVwbGFjZTogcmVwbGFjZSB9O1xuICAgIH1cbiAgICBJbnNlcnRSZXBsYWNlRWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbnNlcnRSZXBsYWNlRWRpdH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRUZXh0TW9kZTtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zZXJ0aW9uIG9yIHJlcGxhY2Ugc3RyaW5ncyBpcyB0YWtlbiBhcyBpdCBpcy4gSWYgdGhlXG4gICAgICogdmFsdWUgaXMgbXVsdGkgbGluZSB0aGUgbGluZXMgYmVsb3cgdGhlIGN1cnNvciB3aWxsIGJlXG4gICAgICogaW5zZXJ0ZWQgdXNpbmcgdGhlIGluZGVudGF0aW9uIGRlZmluZWQgaW4gdGhlIHN0cmluZyB2YWx1ZS5cbiAgICAgKiBUaGUgY2xpZW50IHdpbGwgbm90IGFwcGx5IGFueSBraW5kIG9mIGFkanVzdG1lbnRzIHRvIHRoZVxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hc0lzID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGFkanVzdHMgbGVhZGluZyB3aGl0ZXNwYWNlIG9mIG5ldyBsaW5lcyBzbyB0aGF0XG4gICAgICogdGhleSBtYXRjaCB0aGUgaW5kZW50YXRpb24gdXAgdG8gdGhlIGN1cnNvciBvZiB0aGUgbGluZSBmb3JcbiAgICAgKiB3aGljaCB0aGUgaXRlbSBpcyBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIGEgbGluZSBsaWtlIHRoaXM6IDwydGFicz48Y3Vyc29yPjwzdGFicz5mb28uIEFjY2VwdGluZyBhXG4gICAgICogbXVsdGkgbGluZSBjb21wbGV0aW9uIGl0ZW0gaXMgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFuZCBhbGxcbiAgICAgKiBmb2xsb3dpbmcgbGluZXMgaW5zZXJ0ZWQgd2lsbCBiZSBpbmRlbnRlZCB1c2luZyAyIHRhYnMgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hZGp1c3RJbmRlbnRhdGlvbiA9IDI7XG59KShJbnNlcnRUZXh0TW9kZSB8fCAoSW5zZXJ0VGV4dE1vZGUgPSB7fSkpO1xudmFyIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpIHx8IGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzLmlzID0gaXM7XG59KShDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyB8fCAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gaXRlbXMuXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbTtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb21wbGV0aW9uIGl0ZW0gYW5kIHNlZWQgaXQgd2l0aCBhIGxhYmVsLlxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgY29tcGxldGlvbiBpdGVtJ3MgbGFiZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25JdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25JdGVtIHx8IChDb21wbGV0aW9uSXRlbSA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21wbGV0aW9uTGlzdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICogY29tcGxldGlvbiBsaXN0cy5cbiAqL1xudmFyIENvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uTGlzdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBjb21wbGV0aW9uIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcywgaXNJbmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkxpc3QgfHwgKENvbXBsZXRpb25MaXN0ID0ge30pKTtcbnZhciBNYXJrZWRTdHJpbmc7XG4oZnVuY3Rpb24gKE1hcmtlZFN0cmluZykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXJrZWQgc3RyaW5nIGZyb20gcGxhaW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbGFpblRleHQgVGhlIHBsYWluIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBsYWluVGV4dChwbGFpblRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBsYWluVGV4dC5yZXBsYWNlKC9bXFxcXGAqX3t9W1xcXSgpIytcXC0uIV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgbWFya2Rvd24gc3ludGF4IHRva2VuczogaHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjYmFja3NsYXNoXG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5mcm9tUGxhaW5UZXh0ID0gZnJvbVBsYWluVGV4dDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrZWRTdHJpbmd9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5pcyA9IGlzO1xufSkoTWFya2VkU3RyaW5nIHx8IChNYXJrZWRTdHJpbmcgPSB7fSkpO1xudmFyIEhvdmVyO1xuKGZ1bmN0aW9uIChIb3Zlcikge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgIE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICB9XG4gICAgSG92ZXIuaXMgPSBpcztcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQYXJhbWV0ZXJJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQYXJhbWV0ZXJJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoUGFyYW1ldGVySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhcmFtZXRlciBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhYmVsIEEgbGFiZWwgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudGF0aW9uIEEgZG9jIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb24gPyB7IGxhYmVsOiBsYWJlbCwgZG9jdW1lbnRhdGlvbjogZG9jdW1lbnRhdGlvbiB9IDogeyBsYWJlbDogbGFiZWwgfTtcbiAgICB9XG4gICAgUGFyYW1ldGVySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoUGFyYW1ldGVySW5mb3JtYXRpb24gfHwgKFBhcmFtZXRlckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFNpZ25hdHVyZUluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFNpZ25hdHVyZUluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIFNpZ25hdHVyZUluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTaWduYXR1cmVJbmZvcm1hdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbikge1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcGFyYW1ldGVyc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0geyBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTaWduYXR1cmVJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTaWduYXR1cmVJbmZvcm1hdGlvbiB8fCAoU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA9IDM7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIERvY3VtZW50SGlnaGxpZ2h0IG5hbWVzcGFjZSB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9jdW1lbnRIaWdobGlnaHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdGhlIGhpZ2hsaWdodCBhcHBsaWVzIHRvLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBoaWdobGlnaHQga2luZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwga2luZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLm51bWJlcihraW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50SGlnaGxpZ2h0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKERvY3VtZW50SGlnaGxpZ2h0IHx8IChEb2N1bWVudEhpZ2hsaWdodCA9IHt9KSk7XG4vKipcbiAqIEEgc3ltYm9sIGtpbmQuXG4gKi9cbnZhciBTeW1ib2xLaW5kO1xuKGZ1bmN0aW9uIChTeW1ib2xLaW5kKSB7XG4gICAgU3ltYm9sS2luZC5GaWxlID0gMTtcbiAgICBTeW1ib2xLaW5kLk1vZHVsZSA9IDI7XG4gICAgU3ltYm9sS2luZC5OYW1lc3BhY2UgPSAzO1xuICAgIFN5bWJvbEtpbmQuUGFja2FnZSA9IDQ7XG4gICAgU3ltYm9sS2luZC5DbGFzcyA9IDU7XG4gICAgU3ltYm9sS2luZC5NZXRob2QgPSA2O1xuICAgIFN5bWJvbEtpbmQuUHJvcGVydHkgPSA3O1xuICAgIFN5bWJvbEtpbmQuRmllbGQgPSA4O1xuICAgIFN5bWJvbEtpbmQuQ29uc3RydWN0b3IgPSA5O1xuICAgIFN5bWJvbEtpbmQuRW51bSA9IDEwO1xuICAgIFN5bWJvbEtpbmQuSW50ZXJmYWNlID0gMTE7XG4gICAgU3ltYm9sS2luZC5GdW5jdGlvbiA9IDEyO1xuICAgIFN5bWJvbEtpbmQuVmFyaWFibGUgPSAxMztcbiAgICBTeW1ib2xLaW5kLkNvbnN0YW50ID0gMTQ7XG4gICAgU3ltYm9sS2luZC5TdHJpbmcgPSAxNTtcbiAgICBTeW1ib2xLaW5kLk51bWJlciA9IDE2O1xuICAgIFN5bWJvbEtpbmQuQm9vbGVhbiA9IDE3O1xuICAgIFN5bWJvbEtpbmQuQXJyYXkgPSAxODtcbiAgICBTeW1ib2xLaW5kLk9iamVjdCA9IDE5O1xuICAgIFN5bWJvbEtpbmQuS2V5ID0gMjA7XG4gICAgU3ltYm9sS2luZC5OdWxsID0gMjE7XG4gICAgU3ltYm9sS2luZC5FbnVtTWVtYmVyID0gMjI7XG4gICAgU3ltYm9sS2luZC5TdHJ1Y3QgPSAyMztcbiAgICBTeW1ib2xLaW5kLkV2ZW50ID0gMjQ7XG4gICAgU3ltYm9sS2luZC5PcGVyYXRvciA9IDI1O1xuICAgIFN5bWJvbEtpbmQuVHlwZVBhcmFtZXRlciA9IDI2O1xufSkoU3ltYm9sS2luZCB8fCAoU3ltYm9sS2luZCA9IHt9KSk7XG4vKipcbiAqIFN5bWJvbCB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBzeW1ib2wuXG4gKlxuICogQHNpbmNlIDMuMTZcbiAqL1xudmFyIFN5bWJvbFRhZztcbihmdW5jdGlvbiAoU3ltYm9sVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc3ltYm9sIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBTeW1ib2xUYWcuRGVwcmVjYXRlZCA9IDE7XG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XG52YXIgU3ltYm9sSW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFN5bWJvbEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzeW1ib2wgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNvbnRhaW5lck5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbCBjb250YWluaW5nIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHJhbmdlLCB1cmksIGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgbG9jYXRpb246IHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb250YWluZXJOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQuY29udGFpbmVyTmFtZSA9IGNvbnRhaW5lck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU3ltYm9sSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU3ltYm9sSW5mb3JtYXRpb24gfHwgKFN5bWJvbEluZm9ybWF0aW9uID0ge30pKTtcbnZhciBXb3Jrc3BhY2VTeW1ib2w7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZVN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB3b3Jrc3BhY2Ugc3ltYm9sLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBBbiBvcHRpb25zIHJhbmdlIG9mIHRoZSBsb2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIFdvcmtzcGFjZVN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwga2luZCwgdXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfSB9XG4gICAgICAgICAgICA6IHsgbmFtZTogbmFtZSwga2luZDoga2luZCwgbG9jYXRpb246IHsgdXJpOiB1cmkgfSB9O1xuICAgIH1cbiAgICBXb3Jrc3BhY2VTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xufSkoV29ya3NwYWNlU3ltYm9sIHx8IChXb3Jrc3BhY2VTeW1ib2wgPSB7fSkpO1xudmFyIERvY3VtZW50U3ltYm9sO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25SYW5nZSBUaGUgc2VsZWN0aW9uUmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwgZGV0YWlsLCBraW5kLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2U6IHNlbGVjdGlvblJhbmdlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudFN5bWJvbH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKSAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmtpbmQpICYmXG4gICAgICAgICAgICBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5zZWxlY3Rpb25SYW5nZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXByZWNhdGVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuZGVwcmVjYXRlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuY2hpbGRyZW4pKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS50YWdzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUudGFncykpO1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5pcyA9IGlzO1xufSkoRG9jdW1lbnRTeW1ib2wgfHwgKERvY3VtZW50U3ltYm9sID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBjb2RlIGFjdGlvbiBraW5kc1xuICovXG52YXIgQ29kZUFjdGlvbktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25LaW5kKSB7XG4gICAgLyoqXG4gICAgICogRW1wdHkga2luZC5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5FbXB0eSA9ICcnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcXVpY2tmaXggYWN0aW9uczogJ3F1aWNrZml4J1xuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlF1aWNrRml4ID0gJ3F1aWNrZml4JztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGFjdGlvbnM6ICdyZWZhY3RvcidcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvciA9ICdyZWZhY3Rvcic7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBleHRyYWN0aW9uIGFjdGlvbnM6ICdyZWZhY3Rvci5leHRyYWN0J1xuICAgICAqXG4gICAgICogRXhhbXBsZSBleHRyYWN0IGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIEV4dHJhY3QgbWV0aG9kXG4gICAgICogLSBFeHRyYWN0IGZ1bmN0aW9uXG4gICAgICogLSBFeHRyYWN0IHZhcmlhYmxlXG4gICAgICogLSBFeHRyYWN0IGludGVyZmFjZSBmcm9tIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvckV4dHJhY3QgPSAncmVmYWN0b3IuZXh0cmFjdCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBpbmxpbmUgYWN0aW9uczogJ3JlZmFjdG9yLmlubGluZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgaW5saW5lIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIElubGluZSBmdW5jdGlvblxuICAgICAqIC0gSW5saW5lIHZhcmlhYmxlXG4gICAgICogLSBJbmxpbmUgY29uc3RhbnRcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9ySW5saW5lID0gJ3JlZmFjdG9yLmlubGluZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyByZXdyaXRlIGFjdGlvbnM6ICdyZWZhY3Rvci5yZXdyaXRlJ1xuICAgICAqXG4gICAgICogRXhhbXBsZSByZXdyaXRlIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIENvbnZlcnQgSmF2YVNjcmlwdCBmdW5jdGlvbiB0byBjbGFzc1xuICAgICAqIC0gQWRkIG9yIHJlbW92ZSBwYXJhbWV0ZXJcbiAgICAgKiAtIEVuY2Fwc3VsYXRlIGZpZWxkXG4gICAgICogLSBNYWtlIG1ldGhvZCBzdGF0aWNcbiAgICAgKiAtIE1vdmUgbWV0aG9kIHRvIGJhc2UgY2xhc3NcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yUmV3cml0ZSA9ICdyZWZhY3Rvci5yZXdyaXRlJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHNvdXJjZSBhY3Rpb25zOiBgc291cmNlYFxuICAgICAqXG4gICAgICogU291cmNlIGNvZGUgYWN0aW9ucyBhcHBseSB0byB0aGUgZW50aXJlIGZpbGUuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlID0gJ3NvdXJjZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhbiBvcmdhbml6ZSBpbXBvcnRzIHNvdXJjZSBhY3Rpb246IGBzb3VyY2Uub3JnYW5pemVJbXBvcnRzYFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZU9yZ2FuaXplSW1wb3J0cyA9ICdzb3VyY2Uub3JnYW5pemVJbXBvcnRzJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGF1dG8tZml4IHNvdXJjZSBhY3Rpb25zOiBgc291cmNlLmZpeEFsbGAuXG4gICAgICpcbiAgICAgKiBGaXggYWxsIGFjdGlvbnMgYXV0b21hdGljYWxseSBmaXggZXJyb3JzIHRoYXQgaGF2ZSBhIGNsZWFyIGZpeCB0aGF0IGRvIG5vdCByZXF1aXJlIHVzZXIgaW5wdXQuXG4gICAgICogVGhleSBzaG91bGQgbm90IHN1cHByZXNzIGVycm9ycyBvciBwZXJmb3JtIHVuc2FmZSBmaXhlcyBzdWNoIGFzIGdlbmVyYXRpbmcgbmV3IHR5cGVzIG9yIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNS4wXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlRml4QWxsID0gJ3NvdXJjZS5maXhBbGwnO1xufSkoQ29kZUFjdGlvbktpbmQgfHwgKENvZGVBY3Rpb25LaW5kID0ge30pKTtcbi8qKlxuICogVGhlIHJlYXNvbiB3aHkgY29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIENvZGVBY3Rpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgZXhwbGljaXRseSByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIgb3IgYnkgYW4gZXh0ZW5zaW9uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5JbnZva2VkID0gMTtcbiAgICAvKipcbiAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSByZXF1ZXN0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIFRoaXMgdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiBjdXJyZW50IHNlbGVjdGlvbiBpbiBhIGZpbGUgY2hhbmdlcywgYnV0IGNhblxuICAgICAqIGFsc28gYmUgdHJpZ2dlcmVkIHdoZW4gZmlsZSBjb250ZW50IGNoYW5nZXMuXG4gICAgICovXG4gICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyA9IDI7XG59KShDb2RlQWN0aW9uVHJpZ2dlcktpbmQgfHwgKENvZGVBY3Rpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlQWN0aW9uQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2RlQWN0aW9uQ29udGV4dDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbkNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVBY3Rpb25Db250ZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGRpYWdub3N0aWNzLCBvbmx5LCB0cmlnZ2VyS2luZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBkaWFnbm9zdGljczogZGlhZ25vc3RpY3MgfTtcbiAgICAgICAgaWYgKG9ubHkgIT09IHVuZGVmaW5lZCAmJiBvbmx5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQub25seSA9IG9ubHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaWdnZXJLaW5kICE9PSB1bmRlZmluZWQgJiYgdHJpZ2dlcktpbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50cmlnZ2VyS2luZCA9IHRyaWdnZXJLaW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVBY3Rpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5vbmx5ID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUub25seSwgSXMuc3RyaW5nKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5JbnZva2VkIHx8IGNhbmRpZGF0ZS50cmlnZ2VyS2luZCA9PT0gQ29kZUFjdGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyk7XG4gICAgfVxuICAgIENvZGVBY3Rpb25Db250ZXh0LmlzID0gaXM7XG59KShDb2RlQWN0aW9uQ29udGV4dCB8fCAoQ29kZUFjdGlvbkNvbnRleHQgPSB7fSkpO1xudmFyIENvZGVBY3Rpb247XG4oZnVuY3Rpb24gKENvZGVBY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGtpbmRPckNvbW1hbmRPckVkaXQsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlIH07XG4gICAgICAgIHZhciBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVja0tpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21tYW5kLmlzKGtpbmRPckNvbW1hbmRPckVkaXQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrS2luZCAmJiBraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCA9PT0gdW5kZWZpbmVkIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2RlTGVuc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVMZW5zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvZGVMZW5zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29tbWFuZCkgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBDb2RlTGVucy5pcyA9IGlzO1xufSkoQ29kZUxlbnMgfHwgKENvZGVMZW5zID0ge30pKTtcbi8qKlxuICogVGhlIEZvcm1hdHRpbmdPcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIEZvcm1hdHRpbmdPcHRpb25zO1xuKGZ1bmN0aW9uIChGb3JtYXR0aW5nT3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRm9ybWF0dGluZ09wdGlvbnMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFiU2l6ZSwgaW5zZXJ0U3BhY2VzKSB7XG4gICAgICAgIHJldHVybiB7IHRhYlNpemU6IHRhYlNpemUsIGluc2VydFNwYWNlczogaW5zZXJ0U3BhY2VzIH07XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5pcyA9IGlzO1xufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRMaW5rO1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERvY3VtZW50TGluayBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGFyZ2V0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgdGFyZ2V0OiB0YXJnZXQsIGRhdGE6IGRhdGEgfTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50TGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRhcmdldCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50YXJnZXQpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmlzID0gaXM7XG59KShEb2N1bWVudExpbmsgfHwgKERvY3VtZW50TGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBTZWxlY3Rpb25SYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIHdvcmsgd2l0aFxuICogU2VsZWN0aW9uUmFuZ2UgbGl0ZXJhbHMuXG4gKi9cbnZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHBhcmVudDogcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoY2FuZGlkYXRlLnBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IFNlbGVjdGlvblJhbmdlLmlzKGNhbmRpZGF0ZS5wYXJlbnQpKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuaXMgPSBpcztcbn0pKFNlbGVjdGlvblJhbmdlIHx8IChTZWxlY3Rpb25SYW5nZSA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gdHlwZXMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICogYW4gY2xpZW50cyBjYW4gc3BlY2lmeSBhZGRpdGlvbmFsIHRva2VuIHR5cGVzIHZpYSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5UeXBlcykge1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm5hbWVzcGFjZVwiXSA9IFwibmFtZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGdlbmVyaWMgdHlwZS4gQWN0cyBhcyBhIGZhbGxiYWNrIGZvciB0eXBlcyB3aGljaCBjYW4ndCBiZSBtYXBwZWQgdG9cbiAgICAgKiBhIHNwZWNpZmljIHR5cGUgbGlrZSBjbGFzcyBvciBlbnVtLlxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVcIl0gPSBcInR5cGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiaW50ZXJmYWNlXCJdID0gXCJpbnRlcmZhY2VcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwYXJhbWV0ZXJcIl0gPSBcInBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1NZW1iZXJcIl0gPSBcImVudW1NZW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtZXRob2RcIl0gPSBcIm1ldGhvZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtb2RpZmllclwiXSA9IFwibW9kaWZpZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImRlY29yYXRvclwiXSA9IFwiZGVjb3JhdG9yXCI7XG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbk1vZGlmaWVycztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbk1vZGlmaWVycykge1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWNsYXJhdGlvblwiXSA9IFwiZGVjbGFyYXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmaW5pdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJyZWFkb25seVwiXSA9IFwicmVhZG9ubHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wic3RhdGljXCJdID0gXCJzdGF0aWNcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVwcmVjYXRlZFwiXSA9IFwiZGVwcmVjYXRlZFwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhYnN0cmFjdFwiXSA9IFwiYWJzdHJhY3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYXN5bmNcIl0gPSBcImFzeW5jXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcIm1vZGlmaWNhdGlvblwiXSA9IFwibW9kaWZpY2F0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRvY3VtZW50YXRpb25cIl0gPSBcImRvY3VtZW50YXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmYXVsdExpYnJhcnlcIl0gPSBcImRlZmF1bHRMaWJyYXJ5XCI7XG59KShTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIHx8IChTZW1hbnRpY1Rva2VuTW9kaWZpZXJzID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChjYW5kaWRhdGUucmVzdWx0SWQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJlc3VsdElkID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmRhdGEpICYmIChjYW5kaWRhdGUuZGF0YS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGNhbmRpZGF0ZS5kYXRhWzBdID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFNlbWFudGljVG9rZW5zLmlzID0gaXM7XG59KShTZW1hbnRpY1Rva2VucyB8fCAoU2VtYW50aWNUb2tlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVUZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVGV4dHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVUZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHRleHQ6IHRleHQgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVGV4dCB8fCAoSW5saW5lVmFsdWVUZXh0ID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXApIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB2YXJpYWJsZU5hbWU6IHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cDogY2FzZVNlbnNpdGl2ZUxvb2t1cCB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5jYXNlU2Vuc2l0aXZlTG9va3VwKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudmFyaWFibGVOYW1lKSB8fCBjYW5kaWRhdGUudmFyaWFibGVOYW1lID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIHx8IChJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uO1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBleHByZXNzaW9uOiBleHByZXNzaW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZXhwcmVzc2lvbikgfHwgY2FuZGlkYXRlLmV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiB8fCAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVDb250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVDb250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZnJhbWVJZDogZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uOiBzdG9wcGVkTG9jYXRpb24gfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoSW5saW5lVmFsdWVDb250ZXh0ID0ge30pKTtcbi8qKlxuICogSW5sYXkgaGludCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQW4gaW5sYXkgaGludCB0aGF0IGZvciBhIHR5cGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBJbmxheUhpbnRLaW5kLlR5cGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBpcyBmb3IgYSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5QYXJhbWV0ZXIgPSAyO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSB8fCB2YWx1ZSA9PT0gMjtcbiAgICB9XG4gICAgSW5sYXlIaW50S2luZC5pcyA9IGlzO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG52YXIgSW5sYXlIaW50TGFiZWxQYXJ0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRMYWJlbFBhcnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIElubGF5SGludExhYmVsUGFydC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRvb2x0aXAgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRvb2x0aXApIHx8IE1hcmt1cENvbnRlbnQuaXMoY2FuZGlkYXRlLnRvb2x0aXApKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIElubGF5SGludExhYmVsUGFydC5pcyA9IGlzO1xufSkoSW5sYXlIaW50TGFiZWxQYXJ0IHx8IChJbmxheUhpbnRMYWJlbFBhcnQgPSB7fSkpO1xudmFyIElubGF5SGludDtcbihmdW5jdGlvbiAoSW5sYXlIaW50KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHBvc2l0aW9uLCBsYWJlbCwga2luZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBwb3NpdGlvbjogcG9zaXRpb24sIGxhYmVsOiBsYWJlbCB9O1xuICAgICAgICBpZiAoa2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgSW5sYXlIaW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmxhYmVsLCBJbmxheUhpbnRMYWJlbFBhcnQuaXMpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRleHRFZGl0cyA9PT0gdW5kZWZpbmVkKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbnZhciBXb3Jrc3BhY2VGb2xkZXI7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBVUkkuaXMoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRm9sZGVyLmlzID0gaXM7XG59KShXb3Jrc3BhY2VGb2xkZXIgfHwgKFdvcmtzcGFjZUZvbGRlciA9IHt9KSk7XG52YXIgRU9MID0gWydcXG4nLCAnXFxyXFxuJywgJ1xcciddO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJVGV4dERvY3VtZW50IGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gdXJpIGFuZCBjb250ZW50LlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSVRleHREb2N1bWVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmVDb3VudClcbiAgICAgICAgICAgICYmIElzLmZ1bmMoY2FuZGlkYXRlLmdldFRleHQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLnBvc2l0aW9uQXQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9mZnNldEF0KSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gYXBwbHlFZGl0cyhkb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIHZhciBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhc3RNb2RpZmllZE9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gc29ydGVkRWRpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBlID0gc29ydGVkRWRpdHNbaV07XG4gICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgICAgICBpZiAoZW5kT2Zmc2V0IDw9IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydE9mZnNldCkgKyBlLm5ld1RleHQgKyB0ZXh0LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcmxhcHBpbmcgZWRpdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgLy8gc29ydGVkXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IChkYXRhLmxlbmd0aCAvIDIpIHwgMDtcbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICB2YXIgcmlnaHQgPSBkYXRhLnNsaWNlKHApO1xuICAgICAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgICAgIHZhciBsZWZ0SWR4ID0gMDtcbiAgICAgICAgdmFyIHJpZ2h0SWR4ID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoICYmIHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gY29tcGFyZShsZWZ0W2xlZnRJZHhdLCByaWdodFtyaWdodElkeF0pO1xuICAgICAgICAgICAgaWYgKHJldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBncmVhdGVyIC0+IHRha2UgcmlnaHRcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG52YXIgRnVsbFRleHREb2N1bWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwidXJpXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxhbmd1YWdlSWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZUlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInZlcnNpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChldmVudCwgdmVyc2lvbikge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZXZlbnQudGV4dDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0TGluZU9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lT2Zmc2V0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbGluZU9mZnNldHMgPSBbXTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fY29udGVudDtcbiAgICAgICAgICAgIHZhciBpc0xpbmVTdGFydCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgaXNMaW5lU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaXNMaW5lU3RhcnQgPSAoY2ggPT09ICdcXHInIHx8IGNoID09PSAnXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0xpbmVTdGFydCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0cy5wdXNoKHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gbGluZU9mZnNldHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUucG9zaXRpb25BdCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgdmFyIGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLm9mZnNldEF0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZV07XG4gICAgICAgIHZhciBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KSwgbGluZU9mZnNldCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGluZUNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBGdWxsVGV4dERvY3VtZW50O1xufSgpKTtcbnZhciBJcztcbihmdW5jdGlvbiAoSXMpIHtcbiAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIGZ1bmN0aW9uIGRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLmRlZmluZWQgPSBkZWZpbmVkO1xuICAgIGZ1bmN0aW9uIHVuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgSXMudW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICB9XG4gICAgSXMuYm9vbGVhbiA9IGJvb2xlYW47XG4gICAgZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfVxuICAgIElzLnN0cmluZyA9IHN0cmluZztcbiAgICBmdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG4gICAgSXMubnVtYmVyID0gbnVtYmVyO1xuICAgIGZ1bmN0aW9uIG51bWJlclJhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXg7XG4gICAgfVxuICAgIElzLm51bWJlclJhbmdlID0gbnVtYmVyUmFuZ2U7XG4gICAgZnVuY3Rpb24gaW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIC0yMTQ3NDgzNjQ4IDw9IHZhbHVlICYmIHZhbHVlIDw9IDIxNDc0ODM2NDc7XG4gICAgfVxuICAgIElzLmludGVnZXIgPSBpbnRlZ2VyO1xuICAgIGZ1bmN0aW9uIHVpbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy51aW50ZWdlciA9IHVpbnRlZ2VyO1xuICAgIGZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cbiAgICBJcy5mdW5jID0gZnVuYztcbiAgICBmdW5jdGlvbiBvYmplY3RMaXRlcmFsKHZhbHVlKSB7XG4gICAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nIGNsYXNzIGluc3RhbmNlcyBwYXNzIHRoaXMgY2hlY2sgYXMgd2VsbC4gU2luY2UgdGhlIExTUFxuICAgICAgICAvLyBkb2Vzbid0IHVzZSBjbGFzc2VzIHdlIGlnbm9yZSB0aGlzIGZvciBub3cuIElmIHdlIGRvIHdlIG5lZWQgdG8gYWRkIHNvbWV0aGluZ1xuICAgICAgICAvLyBsaWtlIHRoaXM6IGBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpKSA9PT0gbnVsbGBcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIElzLm9iamVjdExpdGVyYWwgPSBvYmplY3RMaXRlcmFsO1xuICAgIGZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShjaGVjayk7XG4gICAgfVxuICAgIElzLnR5cGVkQXJyYXkgPSB0eXBlZEFycmF5O1xufSkoSXMgfHwgKElzID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA5NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyNDMpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTkxKTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyOSk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjgwKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjYpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMjYpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX3JlcXVpcmVfXy5nIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciBjYWNoZSA9IHsgX19wcm90b19fOiBudWxsIH07XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChkZXNjcmlwdG9yLmdldCk7XG5cdFx0fVxuXHR9KTtcbn0gZWxzZSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChhcnIuc2xpY2UpO1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoJyQnICsgZ2V0dGVyKHZhbHVlKSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kID0gJHNsaWNlKHR5cGVkQXJyYXksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbnZhciB0cnlTbGljZXMgPSBmdW5jdGlvbiB0cnlBbGxTbGljZXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIG5hbWUpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRnZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHRmb3VuZCA9ICRzbGljZShuYW1lLCAxKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0aWYgKCRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTEpIHtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fVxuXHRcdGlmICh0YWcgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIG5vZGUgPCAwLjYgaGl0cyBoZXJlIG9uIHJlYWwgVHlwZWQgQXJyYXlzXG5cdFx0cmV0dXJuIHRyeVNsaWNlcyh2YWx1ZSk7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBudWxsOyB9IC8vIHVua25vd24gZW5naW5lXG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgcG9zc2libGVOYW1lcyA9IFtcblx0J0JpZ0ludDY0QXJyYXknLFxuXHQnQmlnVWludDY0QXJyYXknLFxuXHQnRmxvYXQzMkFycmF5Jyxcblx0J0Zsb2F0NjRBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnSW50OEFycmF5Jyxcblx0J1VpbnQxNkFycmF5Jyxcblx0J1VpbnQzMkFycmF5Jyxcblx0J1VpbnQ4QXJyYXknLFxuXHQnVWludDhDbGFtcGVkQXJyYXknXG5dO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdFx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG4vKioqKioqLyBcdFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8qKioqKiovIFx0XHRcdH0gY2F0Y2ggKGUpIHtcbi8qKioqKiovIFx0XHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH0pKCk7XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4oKCkgPT4ge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgSnNvblNlcnZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIEpzb25TZXJ2aWNlKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc2VydmljZXMvYmFzZS1zZXJ2aWNlLnRzXG52YXIgYmFzZV9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDg3KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9zY2FubmVyLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBzY2FubmVyIG9uIHRoZSBnaXZlbiB0ZXh0LlxuICogSWYgaWdub3JlVHJpdmlhIGlzIHNldCwgd2hpdGVzcGFjZXMgb3IgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNjYW5uZXIodGV4dCwgaWdub3JlVHJpdmlhID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICBsZXQgcG9zID0gMCwgdmFsdWUgPSAnJywgdG9rZW5PZmZzZXQgPSAwLCB0b2tlbiA9IDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLywgbGluZU51bWJlciA9IDAsIGxpbmVTdGFydE9mZnNldCA9IDAsIHRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gMCwgcHJldlRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gMCwgc2NhbkVycm9yID0gMCAvKiBTY2FuRXJyb3IuTm9uZSAqLztcbiAgICBmdW5jdGlvbiBzY2FuSGV4RGlnaXRzKGNvdW50LCBleGFjdCkge1xuICAgICAgICBsZXQgZGlnaXRzID0gMDtcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgd2hpbGUgKGRpZ2l0cyA8IGNvdW50IHx8ICFleGFjdCkge1xuICAgICAgICAgICAgbGV0IGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoY2ggPj0gNDggLyogQ2hhcmFjdGVyQ29kZXMuXzAgKi8gJiYgY2ggPD0gNTcgLyogQ2hhcmFjdGVyQ29kZXMuXzkgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogMTYgKyBjaCAtIDQ4IC8qIENoYXJhY3RlckNvZGVzLl8wICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gNjUgLyogQ2hhcmFjdGVyQ29kZXMuQSAqLyAmJiBjaCA8PSA3MCAvKiBDaGFyYWN0ZXJDb2Rlcy5GICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA2NSAvKiBDaGFyYWN0ZXJDb2Rlcy5BICovICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA+PSA5NyAvKiBDaGFyYWN0ZXJDb2Rlcy5hICovICYmIGNoIDw9IDEwMiAvKiBDaGFyYWN0ZXJDb2Rlcy5mICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA5NyAvKiBDaGFyYWN0ZXJDb2Rlcy5hICovICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgZGlnaXRzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZ2l0cyA8IGNvdW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UG9zaXRpb24obmV3UG9zaXRpb24pIHtcbiAgICAgICAgcG9zID0gbmV3UG9zaXRpb247XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIHRva2VuT2Zmc2V0ID0gMDtcbiAgICAgICAgdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgIHNjYW5FcnJvciA9IDAgLyogU2NhbkVycm9yLk5vbmUgKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OdW1iZXIoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcztcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChwb3MpID09PSA0OCAvKiBDaGFyYWN0ZXJDb2Rlcy5fMCAqLykge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDYgLyogQ2hhcmFjdGVyQ29kZXMuZG90ICovKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAzIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBlbmQgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiAodGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDY5IC8qIENoYXJhY3RlckNvZGVzLkUgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwMSAvKiBDaGFyYWN0ZXJDb2Rlcy5lICovKSkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQzIC8qIENoYXJhY3RlckNvZGVzLnBsdXMgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ1IC8qIENoYXJhY3RlckNvZGVzLm1pbnVzICovKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDMgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJywgc3RhcnQgPSBwb3M7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocG9zID49IGxlbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAyIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAzNCAvKiBDaGFyYWN0ZXJDb2Rlcy5kb3VibGVRdW90ZSAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gOTIgLyogQ2hhcmFjdGVyQ29kZXMuYmFja3NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDIgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoMiA9IHRleHQuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNCAvKiBDaGFyYWN0ZXJDb2Rlcy5kb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5MiAvKiBDaGFyYWN0ZXJDb2Rlcy5iYWNrc2xhc2ggKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDcgLyogQ2hhcmFjdGVyQ29kZXMuc2xhc2ggKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTggLyogQ2hhcmFjdGVyQ29kZXMuYiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMiAvKiBDaGFyYWN0ZXJDb2Rlcy5mICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTEwIC8qIENoYXJhY3RlckNvZGVzLm4gKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTQgLyogQ2hhcmFjdGVyQ29kZXMuciAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNiAvKiBDaGFyYWN0ZXJDb2Rlcy50ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3IC8qIENoYXJhY3RlckNvZGVzLnUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaDMgPSBzY2FuSGV4RGlnaXRzKDQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoMyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDQgLyogU2NhbkVycm9yLkludmFsaWRVbmljb2RlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSA1IC8qIFNjYW5FcnJvci5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA+PSAwICYmIGNoIDw9IDB4MWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMiAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDYgLyogU2NhbkVycm9yLkludmFsaWRDaGFyYWN0ZXIgKi87XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgZXJyb3IgYnV0IGNvbnRpbnVlIHdpdGggc3RyaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIHNjYW5FcnJvciA9IDAgLyogU2NhbkVycm9yLk5vbmUgKi87XG4gICAgICAgIHRva2VuT2Zmc2V0ID0gcG9zO1xuICAgICAgICBsaW5lU3RhcnRPZmZzZXQgPSBsaW5lTnVtYmVyO1xuICAgICAgICBwcmV2VG9rZW5MaW5lU3RhcnRPZmZzZXQgPSB0b2tlbkxpbmVTdGFydE9mZnNldDtcbiAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgIC8vIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRva2VuT2Zmc2V0ID0gbGVuO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTcgLyogU3ludGF4S2luZC5FT0YgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgLy8gdHJpdmlhOiB3aGl0ZXNwYWNlXG4gICAgICAgIGlmIChpc1doaXRlU3BhY2UoY29kZSkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGlzV2hpdGVTcGFjZShjb2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNSAvKiBTeW50YXhLaW5kLlRyaXZpYSAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyB0cml2aWE6IG5ld2xpbmVzXG4gICAgICAgIGlmIChpc0xpbmVCcmVhayhjb2RlKSkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEzIC8qIENoYXJhY3RlckNvZGVzLmNhcnJpYWdlUmV0dXJuICovICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCAvKiBDaGFyYWN0ZXJDb2Rlcy5saW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZU51bWJlcisrO1xuICAgICAgICAgICAgdG9rZW5MaW5lU3RhcnRPZmZzZXQgPSBwb3M7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNCAvKiBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYSAqLztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIC8vIHRva2VuczogW117fTosXG4gICAgICAgICAgICBjYXNlIDEyMyAvKiBDaGFyYWN0ZXJDb2Rlcy5vcGVuQnJhY2UgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovO1xuICAgICAgICAgICAgY2FzZSAxMjUgLyogQ2hhcmFjdGVyQ29kZXMuY2xvc2VCcmFjZSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovO1xuICAgICAgICAgICAgY2FzZSA5MSAvKiBDaGFyYWN0ZXJDb2Rlcy5vcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAzIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgOTMgLyogQ2hhcmFjdGVyQ29kZXMuY2xvc2VCcmFja2V0ICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgNTggLyogQ2hhcmFjdGVyQ29kZXMuY29sb24gKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gNiAvKiBTeW50YXhLaW5kLkNvbG9uVG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDQ0IC8qIENoYXJhY3RlckNvZGVzLmNvbW1hICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovO1xuICAgICAgICAgICAgLy8gc3RyaW5nc1xuICAgICAgICAgICAgY2FzZSAzNCAvKiBDaGFyYWN0ZXJDb2Rlcy5kb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi87XG4gICAgICAgICAgICAvLyBjb21tZW50c1xuICAgICAgICAgICAgY2FzZSA0NyAvKiBDaGFyYWN0ZXJDb2Rlcy5zbGFzaCAqLzpcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHBvcyAtIDE7XG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlLWxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIENoYXJhY3RlckNvZGVzLnNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBNdWx0aS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0MiAvKiBDaGFyYWN0ZXJDb2Rlcy5hc3RlcmlzayAqLykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FmZUxlbmd0aCA9IGxlbiAtIDE7IC8vIEZvciBsb29rYWhlYWQuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tZW50Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBzYWZlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0MiAvKiBDaGFyYWN0ZXJDb2Rlcy5hc3RlcmlzayAqLyAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIENoYXJhY3RlckNvZGVzLnNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudENsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmVCcmVhayhjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJhY3RlckNvZGVzLmNhcnJpYWdlUmV0dXJuICovICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCAvKiBDaGFyYWN0ZXJDb2Rlcy5saW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudENsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAxIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBqdXN0IGEgc2luZ2xlIHNsYXNoXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgICAgICBjYXNlIDQ1IC8qIENoYXJhY3RlckNvZGVzLm1pbnVzICovOlxuICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gbGVuIHx8ICFpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm91bmQgYSBtaW51cywgZm9sbG93ZWQgYnkgYSBudW1iZXIgc29cbiAgICAgICAgICAgIC8vIHdlIGZhbGwgdGhyb3VnaCB0byBwcm9jZWVkIHdpdGggc2Nhbm5pbmdcbiAgICAgICAgICAgIC8vIG51bWJlcnNcbiAgICAgICAgICAgIGNhc2UgNDggLyogQ2hhcmFjdGVyQ29kZXMuXzAgKi86XG4gICAgICAgICAgICBjYXNlIDQ5IC8qIENoYXJhY3RlckNvZGVzLl8xICovOlxuICAgICAgICAgICAgY2FzZSA1MCAvKiBDaGFyYWN0ZXJDb2Rlcy5fMiAqLzpcbiAgICAgICAgICAgIGNhc2UgNTEgLyogQ2hhcmFjdGVyQ29kZXMuXzMgKi86XG4gICAgICAgICAgICBjYXNlIDUyIC8qIENoYXJhY3RlckNvZGVzLl80ICovOlxuICAgICAgICAgICAgY2FzZSA1MyAvKiBDaGFyYWN0ZXJDb2Rlcy5fNSAqLzpcbiAgICAgICAgICAgIGNhc2UgNTQgLyogQ2hhcmFjdGVyQ29kZXMuXzYgKi86XG4gICAgICAgICAgICBjYXNlIDU1IC8qIENoYXJhY3RlckNvZGVzLl83ICovOlxuICAgICAgICAgICAgY2FzZSA1NiAvKiBDaGFyYWN0ZXJDb2Rlcy5fOCAqLzpcbiAgICAgICAgICAgIGNhc2UgNTcgLyogQ2hhcmFjdGVyQ29kZXMuXzkgKi86XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gc2Nhbk51bWJlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDExIC8qIFN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWwgKi87XG4gICAgICAgICAgICAvLyBsaXRlcmFscyBhbmQgdW5rbm93biBzeW1ib2xzXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlzIGEgbGl0ZXJhbD8gUmVhZCB0aGUgZnVsbCB3b3JkLlxuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBsZW4gJiYgaXNVbmtub3duQ29udGVudENoYXJhY3Rlcihjb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5PZmZzZXQgIT09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHRva2VuT2Zmc2V0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXl3b3JkczogdHJ1ZSwgZmFsc2UsIG51bGxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6IHJldHVybiB0b2tlbiA9IDggLyogU3ludGF4S2luZC5UcnVlS2V5d29yZCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzogcmV0dXJuIHRva2VuID0gOSAvKiBTeW50YXhLaW5kLkZhbHNlS2V5d29yZCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOiByZXR1cm4gdG9rZW4gPSA3IC8qIFN5bnRheEtpbmQuTnVsbEtleXdvcmQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogU3ludGF4S2luZC5Vbmtub3duICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNVbmtub3duQ29udGVudENoYXJhY3Rlcihjb2RlKSB7XG4gICAgICAgIGlmIChpc1doaXRlU3BhY2UoY29kZSkgfHwgaXNMaW5lQnJlYWsoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTI1IC8qIENoYXJhY3RlckNvZGVzLmNsb3NlQnJhY2UgKi86XG4gICAgICAgICAgICBjYXNlIDkzIC8qIENoYXJhY3RlckNvZGVzLmNsb3NlQnJhY2tldCAqLzpcbiAgICAgICAgICAgIGNhc2UgMTIzIC8qIENoYXJhY3RlckNvZGVzLm9wZW5CcmFjZSAqLzpcbiAgICAgICAgICAgIGNhc2UgOTEgLyogQ2hhcmFjdGVyQ29kZXMub3BlbkJyYWNrZXQgKi86XG4gICAgICAgICAgICBjYXNlIDM0IC8qIENoYXJhY3RlckNvZGVzLmRvdWJsZVF1b3RlICovOlxuICAgICAgICAgICAgY2FzZSA1OCAvKiBDaGFyYWN0ZXJDb2Rlcy5jb2xvbiAqLzpcbiAgICAgICAgICAgIGNhc2UgNDQgLyogQ2hhcmFjdGVyQ29kZXMuY29tbWEgKi86XG4gICAgICAgICAgICBjYXNlIDQ3IC8qIENoYXJhY3RlckNvZGVzLnNsYXNoICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nhbk5leHROb25Ucml2aWEoKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNjYW5OZXh0KCk7XG4gICAgICAgIH0gd2hpbGUgKHJlc3VsdCA+PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovICYmIHJlc3VsdCA8PSAxNSAvKiBTeW50YXhLaW5kLlRyaXZpYSAqLyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldFBvc2l0aW9uOiBzZXRQb3NpdGlvbixcbiAgICAgICAgZ2V0UG9zaXRpb246ICgpID0+IHBvcyxcbiAgICAgICAgc2NhbjogaWdub3JlVHJpdmlhID8gc2Nhbk5leHROb25Ucml2aWEgOiBzY2FuTmV4dCxcbiAgICAgICAgZ2V0VG9rZW46ICgpID0+IHRva2VuLFxuICAgICAgICBnZXRUb2tlblZhbHVlOiAoKSA9PiB2YWx1ZSxcbiAgICAgICAgZ2V0VG9rZW5PZmZzZXQ6ICgpID0+IHRva2VuT2Zmc2V0LFxuICAgICAgICBnZXRUb2tlbkxlbmd0aDogKCkgPT4gcG9zIC0gdG9rZW5PZmZzZXQsXG4gICAgICAgIGdldFRva2VuU3RhcnRMaW5lOiAoKSA9PiBsaW5lU3RhcnRPZmZzZXQsXG4gICAgICAgIGdldFRva2VuU3RhcnRDaGFyYWN0ZXI6ICgpID0+IHRva2VuT2Zmc2V0IC0gcHJldlRva2VuTGluZVN0YXJ0T2Zmc2V0LFxuICAgICAgICBnZXRUb2tlbkVycm9yOiAoKSA9PiBzY2FuRXJyb3IsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgIHJldHVybiBjaCA9PT0gMzIgLyogQ2hhcmFjdGVyQ29kZXMuc3BhY2UgKi8gfHwgY2ggPT09IDkgLyogQ2hhcmFjdGVyQ29kZXMudGFiICovO1xufVxuZnVuY3Rpb24gaXNMaW5lQnJlYWsoY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IDEwIC8qIENoYXJhY3RlckNvZGVzLmxpbmVGZWVkICovIHx8IGNoID09PSAxMyAvKiBDaGFyYWN0ZXJDb2Rlcy5jYXJyaWFnZVJldHVybiAqLztcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gNDggLyogQ2hhcmFjdGVyQ29kZXMuXzAgKi8gJiYgY2ggPD0gNTcgLyogQ2hhcmFjdGVyQ29kZXMuXzkgKi87XG59XG52YXIgQ2hhcmFjdGVyQ29kZXM7XG4oZnVuY3Rpb24gKENoYXJhY3RlckNvZGVzKSB7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJsaW5lRmVlZFwiXSA9IDEwXSA9IFwibGluZUZlZWRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNhcnJpYWdlUmV0dXJuXCJdID0gMTNdID0gXCJjYXJyaWFnZVJldHVyblwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wic3BhY2VcIl0gPSAzMl0gPSBcInNwYWNlXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfMFwiXSA9IDQ4XSA9IFwiXzBcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl8xXCJdID0gNDldID0gXCJfMVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzJcIl0gPSA1MF0gPSBcIl8yXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfM1wiXSA9IDUxXSA9IFwiXzNcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl80XCJdID0gNTJdID0gXCJfNFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzVcIl0gPSA1M10gPSBcIl81XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfNlwiXSA9IDU0XSA9IFwiXzZcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl83XCJdID0gNTVdID0gXCJfN1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzhcIl0gPSA1Nl0gPSBcIl84XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfOVwiXSA9IDU3XSA9IFwiXzlcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImFcIl0gPSA5N10gPSBcImFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImJcIl0gPSA5OF0gPSBcImJcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNcIl0gPSA5OV0gPSBcImNcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImRcIl0gPSAxMDBdID0gXCJkXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJlXCJdID0gMTAxXSA9IFwiZVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiZlwiXSA9IDEwMl0gPSBcImZcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImdcIl0gPSAxMDNdID0gXCJnXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJoXCJdID0gMTA0XSA9IFwiaFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiaVwiXSA9IDEwNV0gPSBcImlcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImpcIl0gPSAxMDZdID0gXCJqXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJrXCJdID0gMTA3XSA9IFwia1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wibFwiXSA9IDEwOF0gPSBcImxcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIm1cIl0gPSAxMDldID0gXCJtXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJuXCJdID0gMTEwXSA9IFwiblwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wib1wiXSA9IDExMV0gPSBcIm9cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInBcIl0gPSAxMTJdID0gXCJwXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJxXCJdID0gMTEzXSA9IFwicVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiclwiXSA9IDExNF0gPSBcInJcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInNcIl0gPSAxMTVdID0gXCJzXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ0XCJdID0gMTE2XSA9IFwidFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1widVwiXSA9IDExN10gPSBcInVcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInZcIl0gPSAxMThdID0gXCJ2XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ3XCJdID0gMTE5XSA9IFwid1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wieFwiXSA9IDEyMF0gPSBcInhcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInlcIl0gPSAxMjFdID0gXCJ5XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ6XCJdID0gMTIyXSA9IFwielwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiQVwiXSA9IDY1XSA9IFwiQVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiQlwiXSA9IDY2XSA9IFwiQlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiQ1wiXSA9IDY3XSA9IFwiQ1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiRFwiXSA9IDY4XSA9IFwiRFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiRVwiXSA9IDY5XSA9IFwiRVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiRlwiXSA9IDcwXSA9IFwiRlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiR1wiXSA9IDcxXSA9IFwiR1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiSFwiXSA9IDcyXSA9IFwiSFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiSVwiXSA9IDczXSA9IFwiSVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiSlwiXSA9IDc0XSA9IFwiSlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiS1wiXSA9IDc1XSA9IFwiS1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiTFwiXSA9IDc2XSA9IFwiTFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiTVwiXSA9IDc3XSA9IFwiTVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiTlwiXSA9IDc4XSA9IFwiTlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiT1wiXSA9IDc5XSA9IFwiT1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiUFwiXSA9IDgwXSA9IFwiUFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiUVwiXSA9IDgxXSA9IFwiUVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiUlwiXSA9IDgyXSA9IFwiUlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiU1wiXSA9IDgzXSA9IFwiU1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiVFwiXSA9IDg0XSA9IFwiVFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiVVwiXSA9IDg1XSA9IFwiVVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiVlwiXSA9IDg2XSA9IFwiVlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiV1wiXSA9IDg3XSA9IFwiV1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiWFwiXSA9IDg4XSA9IFwiWFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiWVwiXSA9IDg5XSA9IFwiWVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiWlwiXSA9IDkwXSA9IFwiWlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiYXN0ZXJpc2tcIl0gPSA0Ml0gPSBcImFzdGVyaXNrXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJiYWNrc2xhc2hcIl0gPSA5Ml0gPSBcImJhY2tzbGFzaFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiY2xvc2VCcmFjZVwiXSA9IDEyNV0gPSBcImNsb3NlQnJhY2VcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNsb3NlQnJhY2tldFwiXSA9IDkzXSA9IFwiY2xvc2VCcmFja2V0XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJjb2xvblwiXSA9IDU4XSA9IFwiY29sb25cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNvbW1hXCJdID0gNDRdID0gXCJjb21tYVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiZG90XCJdID0gNDZdID0gXCJkb3RcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImRvdWJsZVF1b3RlXCJdID0gMzRdID0gXCJkb3VibGVRdW90ZVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wibWludXNcIl0gPSA0NV0gPSBcIm1pbnVzXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJvcGVuQnJhY2VcIl0gPSAxMjNdID0gXCJvcGVuQnJhY2VcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIm9wZW5CcmFja2V0XCJdID0gOTFdID0gXCJvcGVuQnJhY2tldFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wicGx1c1wiXSA9IDQzXSA9IFwicGx1c1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wic2xhc2hcIl0gPSA0N10gPSBcInNsYXNoXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJmb3JtRmVlZFwiXSA9IDEyXSA9IFwiZm9ybUZlZWRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInRhYlwiXSA9IDldID0gXCJ0YWJcIjtcbn0pKENoYXJhY3RlckNvZGVzIHx8IChDaGFyYWN0ZXJDb2RlcyA9IHt9KSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9mb3JtYXQuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdF9mb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucykge1xuICAgIGxldCBpbml0aWFsSW5kZW50TGV2ZWw7XG4gICAgbGV0IGZvcm1hdFRleHQ7XG4gICAgbGV0IGZvcm1hdFRleHRTdGFydDtcbiAgICBsZXQgcmFuZ2VTdGFydDtcbiAgICBsZXQgcmFuZ2VFbmQ7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlU3RhcnQgPSByYW5nZS5vZmZzZXQ7XG4gICAgICAgIHJhbmdlRW5kID0gcmFuZ2VTdGFydCArIHJhbmdlLmxlbmd0aDtcbiAgICAgICAgZm9ybWF0VGV4dFN0YXJ0ID0gcmFuZ2VTdGFydDtcbiAgICAgICAgd2hpbGUgKGZvcm1hdFRleHRTdGFydCA+IDAgJiYgIWZvcm1hdF9pc0VPTChkb2N1bWVudFRleHQsIGZvcm1hdFRleHRTdGFydCAtIDEpKSB7XG4gICAgICAgICAgICBmb3JtYXRUZXh0U3RhcnQtLTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5kT2Zmc2V0ID0gcmFuZ2VFbmQ7XG4gICAgICAgIHdoaWxlIChlbmRPZmZzZXQgPCBkb2N1bWVudFRleHQubGVuZ3RoICYmICFmb3JtYXRfaXNFT0woZG9jdW1lbnRUZXh0LCBlbmRPZmZzZXQpKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXRUZXh0ID0gZG9jdW1lbnRUZXh0LnN1YnN0cmluZyhmb3JtYXRUZXh0U3RhcnQsIGVuZE9mZnNldCk7XG4gICAgICAgIGluaXRpYWxJbmRlbnRMZXZlbCA9IGNvbXB1dGVJbmRlbnRMZXZlbChmb3JtYXRUZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvcm1hdFRleHQgPSBkb2N1bWVudFRleHQ7XG4gICAgICAgIGluaXRpYWxJbmRlbnRMZXZlbCA9IDA7XG4gICAgICAgIGZvcm1hdFRleHRTdGFydCA9IDA7XG4gICAgICAgIHJhbmdlU3RhcnQgPSAwO1xuICAgICAgICByYW5nZUVuZCA9IGRvY3VtZW50VGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGVvbCA9IGdldEVPTChvcHRpb25zLCBkb2N1bWVudFRleHQpO1xuICAgIGxldCBudW1iZXJMaW5lQnJlYWtzID0gMDtcbiAgICBsZXQgaW5kZW50TGV2ZWwgPSAwO1xuICAgIGxldCBpbmRlbnRWYWx1ZTtcbiAgICBpZiAob3B0aW9ucy5pbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgaW5kZW50VmFsdWUgPSByZXBlYXQoJyAnLCBvcHRpb25zLnRhYlNpemUgfHwgNCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbmRlbnRWYWx1ZSA9ICdcXHQnO1xuICAgIH1cbiAgICBsZXQgc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIoZm9ybWF0VGV4dCwgZmFsc2UpO1xuICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG5ld0xpbmVzQW5kSW5kZW50KCkge1xuICAgICAgICBpZiAobnVtYmVyTGluZUJyZWFrcyA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBlYXQoZW9sLCBudW1iZXJMaW5lQnJlYWtzKSArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVvbCArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgbnVtYmVyTGluZUJyZWFrcyA9IDA7XG4gICAgICAgIHdoaWxlICh0b2tlbiA9PT0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi8gfHwgdG9rZW4gPT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovICYmIG9wdGlvbnMua2VlcExpbmVzKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTGluZUJyZWFrcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTGluZUJyZWFrcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0Vycm9yID0gdG9rZW4gPT09IDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLyB8fCBzY2FubmVyLmdldFRva2VuRXJyb3IoKSAhPT0gMCAvKiBTY2FuRXJyb3IuTm9uZSAqLztcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0T3BlcmF0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFkZEVkaXQodGV4dCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoIWhhc0Vycm9yICYmICghcmFuZ2UgfHwgKHN0YXJ0T2Zmc2V0IDwgcmFuZ2VFbmQgJiYgZW5kT2Zmc2V0ID4gcmFuZ2VTdGFydCkpICYmIGRvY3VtZW50VGV4dC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkgIT09IHRleHQpIHtcbiAgICAgICAgICAgIGVkaXRPcGVyYXRpb25zLnB1c2goeyBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBsZW5ndGg6IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0LCBjb250ZW50OiB0ZXh0IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBmaXJzdFRva2VuID0gc2Nhbk5leHQoKTtcbiAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgYWRkRWRpdChyZXBlYXQoZW9sLCBudW1iZXJMaW5lQnJlYWtzKSwgMCwgMCk7XG4gICAgfVxuICAgIGlmIChmaXJzdFRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICBsZXQgZmlyc3RUb2tlblN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xuICAgICAgICBsZXQgaW5pdGlhbEluZGVudCA9IHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsKTtcbiAgICAgICAgYWRkRWRpdChpbml0aWFsSW5kZW50LCBmb3JtYXRUZXh0U3RhcnQsIGZpcnN0VG9rZW5TdGFydCk7XG4gICAgfVxuICAgIHdoaWxlIChmaXJzdFRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICBsZXQgZmlyc3RUb2tlbkVuZCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgbGV0IHNlY29uZFRva2VuID0gc2Nhbk5leHQoKTtcbiAgICAgICAgbGV0IHJlcGxhY2VDb250ZW50ID0gJyc7XG4gICAgICAgIGxldCBuZWVkc0xpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobnVtYmVyTGluZUJyZWFrcyA9PT0gMCAmJiAoc2Vjb25kVG9rZW4gPT09IDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgc2Vjb25kVG9rZW4gPT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSkge1xuICAgICAgICAgICAgbGV0IGNvbW1lbnRUb2tlblN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xuICAgICAgICAgICAgYWRkRWRpdCgnICcsIGZpcnN0VG9rZW5FbmQsIGNvbW1lbnRUb2tlblN0YXJ0KTtcbiAgICAgICAgICAgIGZpcnN0VG9rZW5FbmQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZWVkc0xpbmVCcmVhayA9IHNlY29uZFRva2VuID09PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZWVkc0xpbmVCcmVhayA/IG5ld0xpbmVzQW5kSW5kZW50KCkgOiAnJztcbiAgICAgICAgICAgIHNlY29uZFRva2VuID0gc2Nhbk5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kVG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRva2VuICE9PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpbmRlbnRMZXZlbC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2VlcExpbmVzICYmIG51bWJlckxpbmVCcmVha3MgPiAwIHx8ICFvcHRpb25zLmtlZXBMaW5lcyAmJiBmaXJzdFRva2VuICE9PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmtlZXBMaW5lcykge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlY29uZFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRva2VuICE9PSAzIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGluZGVudExldmVsLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDAgfHwgIW9wdGlvbnMua2VlcExpbmVzICYmIGZpcnN0VG9rZW4gIT09IDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RUb2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGluZGVudExldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBTeW50YXhLaW5kLkNvbG9uVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFuZWVkc0xpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFRva2VuID09PSA2IC8qIFN5bnRheEtpbmQuQ29sb25Ub2tlbiAqLyAmJiAhbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3IC8qIFN5bnRheEtpbmQuTnVsbEtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA4IC8qIFN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA5IC8qIFN5bnRheEtpbmQuRmFsc2VLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMTEgLyogU3ludGF4S2luZC5OdW1lcmljTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZWNvbmRUb2tlbiA9PT0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLyB8fCBzZWNvbmRUb2tlbiA9PT0gMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi8pICYmICFuZWVkc0xpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Vjb25kVG9rZW4gIT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovICYmIHNlY29uZFRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1iZXJMaW5lQnJlYWtzID4gMCAmJiAoc2Vjb25kVG9rZW4gPT09IDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgc2Vjb25kVG9rZW4gPT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vjb25kVG9rZW4gPT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG9wdGlvbnMuaW5zZXJ0RmluYWxOZXdsaW5lID8gZW9sIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vjb25kVG9rZW5TdGFydCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgYWRkRWRpdChyZXBsYWNlQ29udGVudCwgZmlyc3RUb2tlbkVuZCwgc2Vjb25kVG9rZW5TdGFydCk7XG4gICAgICAgIGZpcnN0VG9rZW4gPSBzZWNvbmRUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRPcGVyYXRpb25zO1xufVxuZnVuY3Rpb24gcmVwZWF0KHMsIGNvdW50KSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbmRlbnRMZXZlbChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBuQ2hhcnMgPSAwO1xuICAgIGNvbnN0IHRhYlNpemUgPSBvcHRpb25zLnRhYlNpemUgfHwgNDtcbiAgICB3aGlsZSAoaSA8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjaCA9IGNvbnRlbnQuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09ICcgJykge1xuICAgICAgICAgICAgbkNoYXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBuQ2hhcnMgKz0gdGFiU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobkNoYXJzIC8gdGFiU2l6ZSk7XG59XG5mdW5jdGlvbiBnZXRFT0wob3B0aW9ucywgdGV4dCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHJcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdcXHInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXG4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAob3B0aW9ucyAmJiBvcHRpb25zLmVvbCkgfHwgJ1xcbic7XG59XG5mdW5jdGlvbiBmb3JtYXRfaXNFT0wodGV4dCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuICdcXHJcXG4nLmluZGV4T2YodGV4dC5jaGFyQXQob2Zmc2V0KSkgIT09IC0xO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL2ltcGwvcGFyc2VyLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG52YXIgUGFyc2VPcHRpb25zO1xuKGZ1bmN0aW9uIChQYXJzZU9wdGlvbnMpIHtcbiAgICBQYXJzZU9wdGlvbnMuREVGQVVMVCA9IHtcbiAgICAgICAgYWxsb3dUcmFpbGluZ0NvbW1hOiBmYWxzZVxuICAgIH07XG59KShQYXJzZU9wdGlvbnMgfHwgKFBhcnNlT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIEZvciBhIGdpdmVuIG9mZnNldCwgZXZhbHVhdGUgdGhlIGxvY2F0aW9uIGluIHRoZSBKU09OIGRvY3VtZW50LiBFYWNoIHNlZ21lbnQgaW4gdGhlIGxvY2F0aW9uIHBhdGggaXMgZWl0aGVyIGEgcHJvcGVydHkgbmFtZSBvciBhbiBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYXRpb24odGV4dCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IFtdOyAvLyBzdHJpbmdzIG9yIG51bWJlcnNcbiAgICBjb25zdCBlYXJseVJldHVybkV4Y2VwdGlvbiA9IG5ldyBPYmplY3QoKTtcbiAgICBsZXQgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZUluc3QgPSB7XG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwYXJlbnQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgbGV0IGlzQXRQcm9wZXJ0eUtleSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHNldFByZXZpb3VzTm9kZSh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgsIHR5cGUpIHtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0Lm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3QudHlwZSA9IHR5cGU7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3QuY29sb25PZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHByZXZpb3VzTm9kZSA9IHByZXZpb3VzTm9kZUluc3Q7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHZpc2l0KHRleHQsIHtcbiAgICAgICAgICAgIG9uT2JqZWN0QmVnaW46IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpc0F0UHJvcGVydHlLZXkgPSBwb3NpdGlvbiA+IG9mZnNldDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKCcnKTsgLy8gcHVzaCBhIHBsYWNlaG9sZGVyICh3aWxsIGJlIHJlcGxhY2VkKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uT2JqZWN0UHJvcGVydHk6IChuYW1lLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJldmlvdXNOb2RlKG5hbWUsIG9mZnNldCwgbGVuZ3RoLCAncHJvcGVydHknKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PYmplY3RFbmQ6IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkFycmF5QmVnaW46IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQXJyYXlFbmQ6IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZTogKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJldmlvdXNOb2RlKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCwgZ2V0Tm9kZVR5cGUodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlcGFyYXRvcjogKHNlcCwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwID09PSAnOicgJiYgcHJldmlvdXNOb2RlICYmIHByZXZpb3VzTm9kZS50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZS5jb2xvbk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VwID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IGxhc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlICE9PSBlYXJseVJldHVybkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBzZWdtZW50cyxcbiAgICAgICAgcHJldmlvdXNOb2RlLFxuICAgICAgICBpc0F0UHJvcGVydHlLZXksXG4gICAgICAgIG1hdGNoZXM6IChwYXR0ZXJuKSA9PiB7XG4gICAgICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgayA8IHBhdHRlcm4ubGVuZ3RoICYmIGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuW2tdID09PSBzZWdtZW50c1tpXSB8fCBwYXR0ZXJuW2tdID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXR0ZXJuW2tdICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgdGhlIG9iamVjdCB0aGUgSlNPTiBjb250ZW50IHJlcHJlc2VudHMuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKiBUaGVyZWZvcmUgYWx3YXlzIGNoZWNrIHRoZSBlcnJvcnMgbGlzdCB0byBmaW5kIG91dCBpZiB0aGUgaW5wdXQgd2FzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBwYXJzZSh0ZXh0LCBlcnJvcnMgPSBbXSwgb3B0aW9ucyA9IFBhcnNlT3B0aW9ucy5ERUZBVUxUKSB7XG4gICAgbGV0IGN1cnJlbnRQcm9wZXJ0eSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRQYXJlbnQgPSBbXTtcbiAgICBjb25zdCBwcmV2aW91c1BhcmVudHMgPSBbXTtcbiAgICBmdW5jdGlvbiBvblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRQYXJlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRQcm9wZXJ0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudFtjdXJyZW50UHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmlzaXRvciA9IHtcbiAgICAgICAgb25PYmplY3RCZWdpbjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBvblZhbHVlKG9iamVjdCk7XG4gICAgICAgICAgICBwcmV2aW91c1BhcmVudHMucHVzaChjdXJyZW50UGFyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvYmplY3Q7XG4gICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdFByb3BlcnR5OiAobmFtZSkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RFbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwcmV2aW91c1BhcmVudHMucG9wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlCZWdpbjogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIG9uVmFsdWUoYXJyYXkpO1xuICAgICAgICAgICAgcHJldmlvdXNQYXJlbnRzLnB1c2goY3VycmVudFBhcmVudCk7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gYXJyYXk7XG4gICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5RW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcHJldmlvdXNQYXJlbnRzLnBvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkxpdGVyYWxWYWx1ZTogb25WYWx1ZSxcbiAgICAgICAgb25FcnJvcjogKGVycm9yLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBlcnJvciwgb2Zmc2V0LCBsZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjdXJyZW50UGFyZW50WzBdO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgYSB0cmVlIHJlcHJlc2VudGF0aW9uIHRoZSBKU09OIGNvbnRlbnQuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlcl9wYXJzZVRyZWUodGV4dCwgZXJyb3JzID0gW10sIG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVCkge1xuICAgIGxldCBjdXJyZW50UGFyZW50ID0geyB0eXBlOiAnYXJyYXknLCBvZmZzZXQ6IC0xLCBsZW5ndGg6IC0xLCBjaGlsZHJlbjogW10sIHBhcmVudDogdW5kZWZpbmVkIH07IC8vIGFydGlmaWNpYWwgcm9vdFxuICAgIGZ1bmN0aW9uIGVuc3VyZVByb3BlcnR5Q29tcGxldGUoZW5kT2Zmc2V0KSB7XG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQubGVuZ3RoID0gZW5kT2Zmc2V0IC0gY3VycmVudFBhcmVudC5vZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25WYWx1ZSh2YWx1ZU5vZGUpIHtcbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHZhbHVlTm9kZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZU5vZGU7XG4gICAgfVxuICAgIGNvbnN0IHZpc2l0b3IgPSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW46IChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvblZhbHVlKHsgdHlwZTogJ29iamVjdCcsIG9mZnNldCwgbGVuZ3RoOiAtMSwgcGFyZW50OiBjdXJyZW50UGFyZW50LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT2JqZWN0UHJvcGVydHk6IChuYW1lLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IG9uVmFsdWUoeyB0eXBlOiAncHJvcGVydHknLCBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBuYW1lLCBvZmZzZXQsIGxlbmd0aCwgcGFyZW50OiBjdXJyZW50UGFyZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdEVuZDogKG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7IC8vIGluIGNhc2Ugb2YgYSBtaXNzaW5nIHZhbHVlIGZvciBhIHByb3BlcnR5OiBtYWtlIHN1cmUgcHJvcGVydHkgaXMgY29tcGxldGVcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQubGVuZ3RoID0gb2Zmc2V0ICsgbGVuZ3RoIC0gY3VycmVudFBhcmVudC5vZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlCZWdpbjogKG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gb25WYWx1ZSh7IHR5cGU6ICdhcnJheScsIG9mZnNldCwgbGVuZ3RoOiAtMSwgcGFyZW50OiBjdXJyZW50UGFyZW50LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlFbmQ6IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5sZW5ndGggPSBvZmZzZXQgKyBsZW5ndGggLSBjdXJyZW50UGFyZW50Lm9mZnNldDtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGVuc3VyZVByb3BlcnR5Q29tcGxldGUob2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MaXRlcmFsVmFsdWU6ICh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIG9uVmFsdWUoeyB0eXBlOiBnZXROb2RlVHlwZSh2YWx1ZSksIG9mZnNldCwgbGVuZ3RoLCBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBvblNlcGFyYXRvcjogKHNlcCwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VwID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jb2xvbk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VwID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKGVycm9yLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBlcnJvciwgb2Zmc2V0LCBsZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBkZWxldGUgcmVzdWx0LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBhdGggaW4gYSBKU09OIERPTS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VyX2ZpbmROb2RlQXRMb2NhdGlvbihyb290LCBwYXRoKSB7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBub2RlID0gcm9vdDtcbiAgICBmb3IgKGxldCBzZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ29iamVjdCcgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5Tm9kZSBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlOb2RlLmNoaWxkcmVuKSAmJiBwcm9wZXJ0eU5vZGUuY2hpbGRyZW5bMF0udmFsdWUgPT09IHNlZ21lbnQgJiYgcHJvcGVydHlOb2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcHJvcGVydHlOb2RlLmNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzZWdtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ2FycmF5JyB8fCBpbmRleCA8IDAgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgfHwgaW5kZXggPj0gbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBKU09OIHBhdGggb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZVBhdGgobm9kZSkge1xuICAgIGlmICghbm9kZS5wYXJlbnQgfHwgIW5vZGUucGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGdldE5vZGVQYXRoKG5vZGUucGFyZW50KTtcbiAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICBjb25zdCBrZXkgPSBub2RlLnBhcmVudC5jaGlsZHJlblswXS52YWx1ZTtcbiAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBub2RlLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIEphdmFTY3JpcHQgb2JqZWN0IG9mIHRoZSBnaXZlbiBKU09OIERPTSBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVWYWx1ZShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGdldE5vZGVWYWx1ZSk7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gcHJvcC5jaGlsZHJlblsxXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wLmNoaWxkcmVuWzBdLnZhbHVlXSA9IGdldE5vZGVWYWx1ZSh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kID0gZmFsc2UpIHtcbiAgICByZXR1cm4gKG9mZnNldCA+PSBub2RlLm9mZnNldCAmJiBvZmZzZXQgPCAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpIHx8IGluY2x1ZGVSaWdodEJvdW5kICYmIChvZmZzZXQgPT09IChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBtb3N0IGlubmVyIG5vZGUgYXQgdGhlIGdpdmVuIG9mZnNldC4gSWYgaW5jbHVkZVJpZ2h0Qm91bmQgaXMgc2V0LCBhbHNvIGZpbmRzIG5vZGVzIHRoYXQgZW5kIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmROb2RlQXRPZmZzZXQobm9kZSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlKSB7XG4gICAgaWYgKGNvbnRhaW5zKG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltpXS5vZmZzZXQgPD0gb2Zmc2V0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gZmluZE5vZGVBdE9mZnNldChjaGlsZHJlbltpXSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuZnVuY3Rpb24gdmlzaXQodGV4dCwgdmlzaXRvciwgb3B0aW9ucyA9IFBhcnNlT3B0aW9ucy5ERUZBVUxUKSB7XG4gICAgY29uc3QgX3NjYW5uZXIgPSBjcmVhdGVTY2FubmVyKHRleHQsIGZhbHNlKTtcbiAgICAvLyBJbXBvcnRhbnQ6IE9ubHkgcGFzcyBjb3BpZXMgb2YgdGhpcyB0byB2aXNpdG9yIGZ1bmN0aW9ucyB0byBwcmV2ZW50IGFjY2lkZW50YWwgbW9kaWZpY2F0aW9uLCBhbmRcbiAgICAvLyB0byBub3QgYWZmZWN0IHZpc2l0b3IgZnVuY3Rpb25zIHdoaWNoIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBhIHByZXZpb3VzIEpTT05QYXRoXG4gICAgY29uc3QgX2pzb25QYXRoID0gW107XG4gICAgZnVuY3Rpb24gdG9Ob0FyZ1Zpc2l0KHZpc2l0RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyAoKSA9PiB2aXNpdEZ1bmN0aW9uKF9zY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIF9zY2FubmVyLmdldFRva2VuTGVuZ3RoKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRDaGFyYWN0ZXIoKSkgOiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b05vQXJnVmlzaXRXaXRoUGF0aCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gKCkgPT4gdmlzaXRGdW5jdGlvbihfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCksICgpID0+IF9qc29uUGF0aC5zbGljZSgpKSA6ICgpID0+IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvT25lQXJnVmlzaXQodmlzaXRGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdmlzaXRGdW5jdGlvbiA/IChhcmcpID0+IHZpc2l0RnVuY3Rpb24oYXJnLCBfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpIDogKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9PbmVBcmdWaXNpdFdpdGhQYXRoKHZpc2l0RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyAoYXJnKSA9PiB2aXNpdEZ1bmN0aW9uKGFyZywgX3NjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwgX3NjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSwgX3NjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKSwgX3NjYW5uZXIuZ2V0VG9rZW5TdGFydENoYXJhY3RlcigpLCAoKSA9PiBfanNvblBhdGguc2xpY2UoKSkgOiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvbk9iamVjdEJlZ2luID0gdG9Ob0FyZ1Zpc2l0V2l0aFBhdGgodmlzaXRvci5vbk9iamVjdEJlZ2luKSwgb25PYmplY3RQcm9wZXJ0eSA9IHRvT25lQXJnVmlzaXRXaXRoUGF0aCh2aXNpdG9yLm9uT2JqZWN0UHJvcGVydHkpLCBvbk9iamVjdEVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0RW5kKSwgb25BcnJheUJlZ2luID0gdG9Ob0FyZ1Zpc2l0V2l0aFBhdGgodmlzaXRvci5vbkFycmF5QmVnaW4pLCBvbkFycmF5RW5kID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25BcnJheUVuZCksIG9uTGl0ZXJhbFZhbHVlID0gdG9PbmVBcmdWaXNpdFdpdGhQYXRoKHZpc2l0b3Iub25MaXRlcmFsVmFsdWUpLCBvblNlcGFyYXRvciA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vblNlcGFyYXRvciksIG9uQ29tbWVudCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uQ29tbWVudCksIG9uRXJyb3IgPSB0b09uZUFyZ1Zpc2l0KHZpc2l0b3Iub25FcnJvcik7XG4gICAgY29uc3QgZGlzYWxsb3dDb21tZW50cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhbGxvd0NvbW1lbnRzO1xuICAgIGNvbnN0IGFsbG93VHJhaWxpbmdDb21tYSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd1RyYWlsaW5nQ29tbWE7XG4gICAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IF9zY2FubmVyLnNjYW4oKTtcbiAgICAgICAgICAgIHN3aXRjaCAoX3NjYW5uZXIuZ2V0VG9rZW5FcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFNjYW5FcnJvci5JbnZhbGlkVW5pY29kZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTQgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZFVuaWNvZGUgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogU2NhbkVycm9yLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE1IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTMgLyogUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FsbG93Q29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDExIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMiAvKiBQYXJzZUVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYgLyogU2NhbkVycm9yLkludmFsaWRDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE2IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRDaGFyYWN0ZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FsbG93Q29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDEwIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRDb21tZW50VG9rZW4gKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDEgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZFN5bWJvbCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNCAvKiBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBza2lwVW50aWxBZnRlciA9IFtdLCBza2lwVW50aWwgPSBbXSkge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmxlbmd0aCArIHNraXBVbnRpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBfc2Nhbm5lci5nZXRUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgICAgIGlmIChza2lwVW50aWxBZnRlci5pbmRleE9mKHRva2VuKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nhbk5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNraXBVbnRpbC5pbmRleE9mKHRva2VuKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gc2Nhbk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZyhpc1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gX3NjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICBpZiAoaXNWYWx1ZSkge1xuICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25PYmplY3RQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBhZGQgcHJvcGVydHkgbmFtZSBhZnRlcndhcmRzXG4gICAgICAgICAgICBfanNvblBhdGgucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbk5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbCgpIHtcbiAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbigpKSB7XG4gICAgICAgICAgICBjYXNlIDExIC8qIFN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5WYWx1ZSA9IF9zY2FubmVyLmdldFRva2VuVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBOdW1iZXIodG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigyIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWROdW1iZXJGb3JtYXQgKi8pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBTeW50YXhLaW5kLk51bGxLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4IC8qIFN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkgLyogU3ludGF4S2luZC5GYWxzZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbk5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHkoKSB7XG4gICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi8pIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKDMgLyogUGFyc2VFcnJvckNvZGUuUHJvcGVydHlOYW1lRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVN0cmluZyhmYWxzZSk7XG4gICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA2IC8qIFN5bnRheEtpbmQuQ29sb25Ub2tlbiAqLykge1xuICAgICAgICAgICAgb25TZXBhcmF0b3IoJzonKTtcbiAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29sb25cbiAgICAgICAgICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgWzIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcig1IC8qIFBhcnNlRXJyb3JDb2RlLkNvbG9uRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgfVxuICAgICAgICBfanNvblBhdGgucG9wKCk7IC8vIHJlbW92ZSBwcm9jZXNzZWQgcHJvcGVydHkgbmFtZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3QoKSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW4oKTtcbiAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBvcGVuIGJyYWNlXG4gICAgICAgIGxldCBuZWVkc0NvbW1hID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovICYmIF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNlcGFyYXRvcignLCcpO1xuICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29tbWFcbiAgICAgICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLyAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDYgLyogUGFyc2VFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VQcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgWzIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvbk9iamVjdEVuZCgpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoNyAvKiBQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNlRXhwZWN0ZWQgKi8sIFsyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjbG9zZSBicmFjZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUFycmF5KCkge1xuICAgICAgICBvbkFycmF5QmVnaW4oKTtcbiAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBvcGVuIGJyYWNrZXRcbiAgICAgICAgbGV0IGlzRmlyc3RFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgPT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25TZXBhcmF0b3IoJywnKTtcbiAgICAgICAgICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNvbW1hXG4gICAgICAgICAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDYgLyogUGFyc2VFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF9qc29uUGF0aC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfanNvblBhdGhbX2pzb25QYXRoLmxlbmd0aCAtIDFdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnNlVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLywgW10sIFs0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8sIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvbkFycmF5RW5kKCk7XG4gICAgICAgIGlmICghaXNGaXJzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIF9qc29uUGF0aC5wb3AoKTsgLy8gcmVtb3ZlIGFycmF5IGluZGV4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoOCAvKiBQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNrZXRFeHBlY3RlZCAqLywgWzQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqL10sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY2xvc2UgYnJhY2tldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKCkge1xuICAgICAgICBzd2l0Y2ggKF9zY2FubmVyLmdldFRva2VuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXkoKTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdCgpO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKHRydWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VMaXRlcmFsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbk5leHQoKTtcbiAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dFbXB0eUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUVycm9yKDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcnNlVmFsdWUoKSkge1xuICAgICAgICBoYW5kbGVFcnJvcig0IC8qIFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKDkgLyogUGFyc2VFcnJvckNvZGUuRW5kT2ZGaWxlRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBUYWtlcyBKU09OIHdpdGggSmF2YVNjcmlwdC1zdHlsZSBjb21tZW50cyBhbmQgcmVtb3ZlXG4gKiB0aGVtLiBPcHRpb25hbGx5IHJlcGxhY2VzIGV2ZXJ5IG5vbmUtbmV3bGluZSBjaGFyYWN0ZXJcbiAqIG9mIGNvbW1lbnRzIHdpdGggYSByZXBsYWNlQ2hhcmFjdGVyXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHModGV4dCwgcmVwbGFjZUNoKSB7XG4gICAgbGV0IF9zY2FubmVyID0gY3JlYXRlU2Nhbm5lcih0ZXh0KSwgcGFydHMgPSBbXSwga2luZCwgb2Zmc2V0ID0gMCwgcG9zO1xuICAgIGRvIHtcbiAgICAgICAgcG9zID0gX3NjYW5uZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAga2luZCA9IF9zY2FubmVyLnNjYW4oKTtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgY2FzZSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLzpcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0ZXh0LnN1YnN0cmluZyhvZmZzZXQsIHBvcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZUNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCkucmVwbGFjZSgvW15cXHJcXG5dL2csIHJlcGxhY2VDaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfc2Nhbm5lci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoa2luZCAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICdudWxsJztcbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vaW1wbC9lZGl0LmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KHRleHQsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc2V0UHJvcGVydHkodGV4dCwgcGF0aCwgdm9pZCAwLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNldFByb3BlcnR5KHRleHQsIG9yaWdpbmFsUGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXRoID0gb3JpZ2luYWxQYXRoLnNsaWNlKCk7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3Qgcm9vdCA9IHBhcnNlVHJlZSh0ZXh0LCBlcnJvcnMpO1xuICAgIGxldCBwYXJlbnQgPSB2b2lkIDA7XG4gICAgbGV0IGxhc3RTZWdtZW50ID0gdm9pZCAwO1xuICAgIHdoaWxlIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGFzdFNlZ21lbnQgPSBwYXRoLnBvcCgpO1xuICAgICAgICBwYXJlbnQgPSBmaW5kTm9kZUF0TG9jYXRpb24ocm9vdCwgcGF0aCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0geyBbbGFzdFNlZ21lbnRdOiB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgLy8gZW1wdHkgZG9jdW1lbnRcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgLy8gZGVsZXRlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGVsZXRlIGluIGVtcHR5IGRvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIHsgb2Zmc2V0OiByb290ID8gcm9vdC5vZmZzZXQgOiAwLCBsZW5ndGg6IHJvb3QgPyByb290Lmxlbmd0aCA6IDAsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50LnR5cGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXN0U2VnbWVudCA9PT0gJ3N0cmluZycgJiYgQXJyYXkuaXNBcnJheShwYXJlbnQuY2hpbGRyZW4pKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gZmluZE5vZGVBdExvY2F0aW9uKHBhcmVudCwgW2xhc3RTZWdtZW50XSk7XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBBU1QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlJbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGV4aXN0aW5nLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbW92ZUJlZ2luO1xuICAgICAgICAgICAgICAgIGxldCByZW1vdmVFbmQgPSBleGlzdGluZy5wYXJlbnQub2Zmc2V0ICsgZXhpc3RpbmcucGFyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb21tYSBvZiB0aGUgcHJldmlvdXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5bcHJvcGVydHlJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVCZWdpbiA9IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUJlZ2luID0gcGFyZW50Lm9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb21tYSBvZiB0aGUgbmV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcmVudC5jaGlsZHJlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUVuZCA9IG5leHQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCB7IG9mZnNldDogcmVtb3ZlQmVnaW4sIGxlbmd0aDogcmVtb3ZlRW5kIC0gcmVtb3ZlQmVnaW4sIGNvbnRlbnQ6ICcnIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlIG9mIGV4aXN0aW5nIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIHsgb2Zmc2V0OiBleGlzdGluZy5vZmZzZXQsIGxlbmd0aDogZXhpc3RpbmcubGVuZ3RoLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICByZXR1cm4gW107IC8vIHByb3BlcnR5IGRvZXMgbm90IGV4aXN0LCBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wZXJ0eSA9IGAke0pTT04uc3RyaW5naWZ5KGxhc3RTZWdtZW50KX06ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG9wdGlvbnMuZ2V0SW5zZXJ0aW9uSW5kZXggPyBvcHRpb25zLmdldEluc2VydGlvbkluZGV4KHBhcmVudC5jaGlsZHJlbi5tYXAocCA9PiBwLmNoaWxkcmVuWzBdLnZhbHVlKSkgOiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwcmV2aW91cy5vZmZzZXQgKyBwcmV2aW91cy5sZW5ndGgsIGxlbmd0aDogMCwgY29udGVudDogJywnICsgbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5ICsgJywnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgZWRpdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50LnR5cGUgPT09ICdhcnJheScgJiYgdHlwZW9mIGxhc3RTZWdtZW50ID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KHBhcmVudC5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSBsYXN0U2VnbWVudDtcbiAgICAgICAgaWYgKGluc2VydEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wZXJ0eSA9IGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICAgICAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcGFyZW50Lm9mZnNldCArIDEsIGxlbmd0aDogMCwgY29udGVudDogbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmFsXG4gICAgICAgICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBsYXN0U2VnbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gcGFyZW50LmNoaWxkcmVuW3JlbW92YWxJbmRleF07XG4gICAgICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBpdGVtXG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiBwYXJlbnQubGVuZ3RoIC0gMiwgY29udGVudDogJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxID09PSByZW1vdmFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50RW5kT2Zmc2V0ID0gcGFyZW50Lm9mZnNldCArIHBhcmVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0LCBsZW5ndGg6IHBhcmVudEVuZE9mZnNldCAtIDIgLSBvZmZzZXQsIGNvbnRlbnQ6ICcnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHRvUmVtb3ZlLm9mZnNldCwgbGVuZ3RoOiBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4ICsgMV0ub2Zmc2V0IC0gdG9SZW1vdmUub2Zmc2V0LCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxldCBlZGl0O1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvcGVydHkgPSBgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5pc0FycmF5SW5zZXJ0aW9uICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiBsYXN0U2VnbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvTW9kaWZ5ID0gcGFyZW50LmNoaWxkcmVuW2xhc3RTZWdtZW50XTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHRvTW9kaWZ5Lm9mZnNldCwgbGVuZ3RoOiB0b01vZGlmeS5sZW5ndGgsIGNvbnRlbnQ6IG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGxhc3RTZWdtZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gbmV3UHJvcGVydHkgOiBuZXdQcm9wZXJ0eSArICcsJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsYXN0U2VnbWVudCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPyBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIDogbGFzdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90ICR7dmFsdWUgPT09IHZvaWQgMCA/ICdyZW1vdmUnIDogKG9wdGlvbnMuaXNBcnJheUluc2VydGlvbiA/ICdpbnNlcnQnIDogJ21vZGlmeScpfSBBcnJheSBpbmRleCAke2luc2VydEluZGV4fSBhcyBsZW5ndGggaXMgbm90IHN1ZmZpY2llbnRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGFkZCAke3R5cGVvZiBsYXN0U2VnbWVudCAhPT0gJ251bWJlcicgPyAnaW5kZXgnIDogJ3Byb3BlcnR5J30gdG8gcGFyZW50IG9mIHR5cGUgJHtwYXJlbnQudHlwZX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBbZWRpdF07XG4gICAgfVxuICAgIC8vIGFwcGx5IHRoZSBlZGl0XG4gICAgbGV0IG5ld1RleHQgPSBhcHBseUVkaXQodGV4dCwgZWRpdCk7XG4gICAgLy8gZm9ybWF0IHRoZSBuZXcgdGV4dFxuICAgIGxldCBiZWdpbiA9IGVkaXQub2Zmc2V0O1xuICAgIGxldCBlbmQgPSBlZGl0Lm9mZnNldCArIGVkaXQuY29udGVudC5sZW5ndGg7XG4gICAgaWYgKGVkaXQubGVuZ3RoID09PSAwIHx8IGVkaXQuY29udGVudC5sZW5ndGggPT09IDApIHsgLy8gaW5zZXJ0IG9yIHJlbW92ZVxuICAgICAgICB3aGlsZSAoYmVnaW4gPiAwICYmICFpc0VPTChuZXdUZXh0LCBiZWdpbiAtIDEpKSB7XG4gICAgICAgICAgICBiZWdpbi0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBuZXdUZXh0Lmxlbmd0aCAmJiAhaXNFT0wobmV3VGV4dCwgZW5kKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRpdHMgPSBmb3JtYXQobmV3VGV4dCwgeyBvZmZzZXQ6IGJlZ2luLCBsZW5ndGg6IGVuZCAtIGJlZ2luIH0sIHsgLi4ub3B0aW9ucy5mb3JtYXR0aW5nT3B0aW9ucywga2VlcExpbmVzOiBmYWxzZSB9KTtcbiAgICAvLyBhcHBseSB0aGUgZm9ybWF0dGluZyBlZGl0cyBhbmQgdHJhY2sgdGhlIGJlZ2luIGFuZCBlbmQgb2Zmc2V0cyBvZiB0aGUgY2hhbmdlc1xuICAgIGZvciAobGV0IGkgPSBlZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlZGl0ID0gZWRpdHNbaV07XG4gICAgICAgIG5ld1RleHQgPSBhcHBseUVkaXQobmV3VGV4dCwgZWRpdCk7XG4gICAgICAgIGJlZ2luID0gTWF0aC5taW4oYmVnaW4sIGVkaXQub2Zmc2V0KTtcbiAgICAgICAgZW5kID0gTWF0aC5tYXgoZW5kLCBlZGl0Lm9mZnNldCArIGVkaXQubGVuZ3RoKTtcbiAgICAgICAgZW5kICs9IGVkaXQuY29udGVudC5sZW5ndGggLSBlZGl0Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGEgc2luZ2xlIGVkaXQgd2l0aCBhbGwgY2hhbmdlc1xuICAgIGNvbnN0IGVkaXRMZW5ndGggPSB0ZXh0Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCAtIGVuZCkgLSBiZWdpbjtcbiAgICByZXR1cm4gW3sgb2Zmc2V0OiBiZWdpbiwgbGVuZ3RoOiBlZGl0TGVuZ3RoLCBjb250ZW50OiBuZXdUZXh0LnN1YnN0cmluZyhiZWdpbiwgZW5kKSB9XTtcbn1cbmZ1bmN0aW9uIGFwcGx5RWRpdCh0ZXh0LCBlZGl0KSB7XG4gICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKDAsIGVkaXQub2Zmc2V0KSArIGVkaXQuY29udGVudCArIHRleHQuc3Vic3RyaW5nKGVkaXQub2Zmc2V0ICsgZWRpdC5sZW5ndGgpO1xufVxuZnVuY3Rpb24gaXNXUyh0ZXh0LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gJ1xcclxcbiBcXHQnLmluZGV4T2YodGV4dC5jaGFyQXQob2Zmc2V0KSkgIT09IC0xO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL21haW4uanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIEpTT04gc2Nhbm5lciBvbiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIElmIGlnbm9yZVRyaXZpYSBpcyBzZXQsIHdoaXRlc3BhY2VzIG9yIGNvbW1lbnRzIGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBtYWluX2NyZWF0ZVNjYW5uZXIgPSBjcmVhdGVTY2FubmVyO1xudmFyIFNjYW5FcnJvcjtcbihmdW5jdGlvbiAoU2NhbkVycm9yKSB7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMV0gPSBcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIjtcbiAgICBTY2FuRXJyb3JbU2NhbkVycm9yW1wiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCJdID0gMl0gPSBcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIl0gPSAzXSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIkludmFsaWRVbmljb2RlXCJdID0gNF0gPSBcIkludmFsaWRVbmljb2RlXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIl0gPSA1XSA9IFwiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJJbnZhbGlkQ2hhcmFjdGVyXCJdID0gNl0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbn0pKFNjYW5FcnJvciB8fCAoU2NhbkVycm9yID0ge30pKTtcbnZhciBTeW50YXhLaW5kO1xuKGZ1bmN0aW9uIChTeW50YXhLaW5kKSB7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiT3BlbkJyYWNlVG9rZW5cIl0gPSAxXSA9IFwiT3BlbkJyYWNlVG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJDbG9zZUJyYWNlVG9rZW5cIl0gPSAyXSA9IFwiQ2xvc2VCcmFjZVRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiT3BlbkJyYWNrZXRUb2tlblwiXSA9IDNdID0gXCJPcGVuQnJhY2tldFRva2VuXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiQ2xvc2VCcmFja2V0VG9rZW5cIl0gPSA0XSA9IFwiQ2xvc2VCcmFja2V0VG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJDb21tYVRva2VuXCJdID0gNV0gPSBcIkNvbW1hVG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJDb2xvblRva2VuXCJdID0gNl0gPSBcIkNvbG9uVG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJOdWxsS2V5d29yZFwiXSA9IDddID0gXCJOdWxsS2V5d29yZFwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIlRydWVLZXl3b3JkXCJdID0gOF0gPSBcIlRydWVLZXl3b3JkXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiRmFsc2VLZXl3b3JkXCJdID0gOV0gPSBcIkZhbHNlS2V5d29yZFwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIlN0cmluZ0xpdGVyYWxcIl0gPSAxMF0gPSBcIlN0cmluZ0xpdGVyYWxcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJOdW1lcmljTGl0ZXJhbFwiXSA9IDExXSA9IFwiTnVtZXJpY0xpdGVyYWxcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJMaW5lQ29tbWVudFRyaXZpYVwiXSA9IDEyXSA9IFwiTGluZUNvbW1lbnRUcml2aWFcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJCbG9ja0NvbW1lbnRUcml2aWFcIl0gPSAxM10gPSBcIkJsb2NrQ29tbWVudFRyaXZpYVwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkxpbmVCcmVha1RyaXZpYVwiXSA9IDE0XSA9IFwiTGluZUJyZWFrVHJpdmlhXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiVHJpdmlhXCJdID0gMTVdID0gXCJUcml2aWFcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJVbmtub3duXCJdID0gMTZdID0gXCJVbmtub3duXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiRU9GXCJdID0gMTddID0gXCJFT0ZcIjtcbn0pKFN5bnRheEtpbmQgfHwgKFN5bnRheEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBGb3IgYSBnaXZlbiBvZmZzZXQsIGV2YWx1YXRlIHRoZSBsb2NhdGlvbiBpbiB0aGUgSlNPTiBkb2N1bWVudC4gRWFjaCBzZWdtZW50IGluIHRoZSBsb2NhdGlvbiBwYXRoIGlzIGVpdGhlciBhIHByb3BlcnR5IG5hbWUgb3IgYW4gYXJyYXkgaW5kZXguXG4gKi9cbmNvbnN0IG1haW5fZ2V0TG9jYXRpb24gPSBnZXRMb2NhdGlvbjtcbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIHRoZSBvYmplY3QgdGhlIEpTT04gY29udGVudCByZXByZXNlbnRzLiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICogVGhlcmVmb3JlLCBhbHdheXMgY2hlY2sgdGhlIGVycm9ycyBsaXN0IHRvIGZpbmQgb3V0IGlmIHRoZSBpbnB1dCB3YXMgdmFsaWQuXG4gKi9cbmNvbnN0IG1haW5fcGFyc2UgPSBwYXJzZTtcbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIGEgdHJlZSByZXByZXNlbnRhdGlvbiB0aGUgSlNPTiBjb250ZW50LiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICovXG5jb25zdCBtYWluX3BhcnNlVHJlZSA9IHBhcnNlcl9wYXJzZVRyZWU7XG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwYXRoIGluIGEgSlNPTiBET00uXG4gKi9cbmNvbnN0IG1haW5fZmluZE5vZGVBdExvY2F0aW9uID0gcGFyc2VyX2ZpbmROb2RlQXRMb2NhdGlvbjtcbi8qKlxuICogRmluZHMgdGhlIGlubmVybW9zdCBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuIElmIGluY2x1ZGVSaWdodEJvdW5kIGlzIHNldCwgYWxzbyBmaW5kcyBub2RlcyB0aGF0IGVuZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICovXG5jb25zdCBtYWluX2ZpbmROb2RlQXRPZmZzZXQgPSBmaW5kTm9kZUF0T2Zmc2V0O1xuLyoqXG4gKiBHZXRzIHRoZSBKU09OIHBhdGggb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuY29uc3QgbWFpbl9nZXROb2RlUGF0aCA9IGdldE5vZGVQYXRoO1xuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIEphdmFTY3JpcHQgb2JqZWN0IG9mIHRoZSBnaXZlbiBKU09OIERPTSBub2RlXG4gKi9cbmNvbnN0IG1haW5fZ2V0Tm9kZVZhbHVlID0gZ2V0Tm9kZVZhbHVlO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuY29uc3QgbWFpbl92aXNpdCA9IHZpc2l0O1xuLyoqXG4gKiBUYWtlcyBKU09OIHdpdGggSmF2YVNjcmlwdC1zdHlsZSBjb21tZW50cyBhbmQgcmVtb3ZlXG4gKiB0aGVtLiBPcHRpb25hbGx5IHJlcGxhY2VzIGV2ZXJ5IG5vbmUtbmV3bGluZSBjaGFyYWN0ZXJcbiAqIG9mIGNvbW1lbnRzIHdpdGggYSByZXBsYWNlQ2hhcmFjdGVyXG4gKi9cbmNvbnN0IG1haW5fc3RyaXBDb21tZW50cyA9IHN0cmlwQ29tbWVudHM7XG52YXIgUGFyc2VFcnJvckNvZGU7XG4oZnVuY3Rpb24gKFBhcnNlRXJyb3JDb2RlKSB7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkU3ltYm9sXCJdID0gMV0gPSBcIkludmFsaWRTeW1ib2xcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWROdW1iZXJGb3JtYXRcIl0gPSAyXSA9IFwiSW52YWxpZE51bWJlckZvcm1hdFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiUHJvcGVydHlOYW1lRXhwZWN0ZWRcIl0gPSAzXSA9IFwiUHJvcGVydHlOYW1lRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIlZhbHVlRXhwZWN0ZWRcIl0gPSA0XSA9IFwiVmFsdWVFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiQ29sb25FeHBlY3RlZFwiXSA9IDVdID0gXCJDb2xvbkV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJDb21tYUV4cGVjdGVkXCJdID0gNl0gPSBcIkNvbW1hRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkNsb3NlQnJhY2VFeHBlY3RlZFwiXSA9IDddID0gXCJDbG9zZUJyYWNlRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkNsb3NlQnJhY2tldEV4cGVjdGVkXCJdID0gOF0gPSBcIkNsb3NlQnJhY2tldEV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJFbmRPZkZpbGVFeHBlY3RlZFwiXSA9IDldID0gXCJFbmRPZkZpbGVFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiSW52YWxpZENvbW1lbnRUb2tlblwiXSA9IDEwXSA9IFwiSW52YWxpZENvbW1lbnRUb2tlblwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiXSA9IDExXSA9IFwiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCJdID0gMTJdID0gXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiXSA9IDEzXSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkVW5pY29kZVwiXSA9IDE0XSA9IFwiSW52YWxpZFVuaWNvZGVcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIl0gPSAxNV0gPSBcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRDaGFyYWN0ZXJcIl0gPSAxNl0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbn0pKFBhcnNlRXJyb3JDb2RlIHx8IChQYXJzZUVycm9yQ29kZSA9IHt9KSk7XG5mdW5jdGlvbiBwcmludFBhcnNlRXJyb3JDb2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRTeW1ib2wgKi86IHJldHVybiAnSW52YWxpZFN5bWJvbCc7XG4gICAgICAgIGNhc2UgMiAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkTnVtYmVyRm9ybWF0ICovOiByZXR1cm4gJ0ludmFsaWROdW1iZXJGb3JtYXQnO1xuICAgICAgICBjYXNlIDMgLyogUGFyc2VFcnJvckNvZGUuUHJvcGVydHlOYW1lRXhwZWN0ZWQgKi86IHJldHVybiAnUHJvcGVydHlOYW1lRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLzogcmV0dXJuICdWYWx1ZUV4cGVjdGVkJztcbiAgICAgICAgY2FzZSA1IC8qIFBhcnNlRXJyb3JDb2RlLkNvbG9uRXhwZWN0ZWQgKi86IHJldHVybiAnQ29sb25FeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgNiAvKiBQYXJzZUVycm9yQ29kZS5Db21tYUV4cGVjdGVkICovOiByZXR1cm4gJ0NvbW1hRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDcgLyogUGFyc2VFcnJvckNvZGUuQ2xvc2VCcmFjZUV4cGVjdGVkICovOiByZXR1cm4gJ0Nsb3NlQnJhY2VFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOCAvKiBQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNrZXRFeHBlY3RlZCAqLzogcmV0dXJuICdDbG9zZUJyYWNrZXRFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOSAvKiBQYXJzZUVycm9yQ29kZS5FbmRPZkZpbGVFeHBlY3RlZCAqLzogcmV0dXJuICdFbmRPZkZpbGVFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgMTAgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZENvbW1lbnRUb2tlbiAqLzogcmV0dXJuICdJbnZhbGlkQ29tbWVudFRva2VuJztcbiAgICAgICAgY2FzZSAxMSAvKiBQYXJzZUVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOiByZXR1cm4gJ1VuZXhwZWN0ZWRFbmRPZkNvbW1lbnQnO1xuICAgICAgICBjYXNlIDEyIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZTdHJpbmcnO1xuICAgICAgICBjYXNlIDEzIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZOdW1iZXInO1xuICAgICAgICBjYXNlIDE0IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRVbmljb2RlICovOiByZXR1cm4gJ0ludmFsaWRVbmljb2RlJztcbiAgICAgICAgY2FzZSAxNSAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyICovOiByZXR1cm4gJ0ludmFsaWRFc2NhcGVDaGFyYWN0ZXInO1xuICAgICAgICBjYXNlIDE2IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRDaGFyYWN0ZXIgKi86IHJldHVybiAnSW52YWxpZENoYXJhY3Rlcic7XG4gICAgfVxuICAgIHJldHVybiAnPHVua25vd24gUGFyc2VFcnJvckNvZGU+Jztcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGVkaXQgb3BlcmF0aW9ucyBuZWVkZWQgdG8gZm9ybWF0IGEgSlNPTiBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnRUZXh0IFRoZSBpbnB1dCB0ZXh0XG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIGZvcm1hdCBvciBgdW5kZWZpbmVkYCB0byBmb3JtYXQgdGhlIGZ1bGwgY29udGVudFxuICogQHBhcmFtIG9wdGlvbnMgVGhlIGZvcm1hdHRpbmcgb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGVkaXQgb3BlcmF0aW9ucyBkZXNjcmliaW5nIHRoZSBmb3JtYXR0aW5nIGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50IGZvbGxvd2luZyB0aGUgZm9ybWF0IGRlc2NyaWJlZCBpbiB7QGxpbmtjb2RlIEVkaXRSZXN1bHR9LlxuICogVG8gYXBwbHkgdGhlIGVkaXQgb3BlcmF0aW9ucyB0byB0aGUgaW5wdXQsIHVzZSB7QGxpbmtjb2RlIGFwcGx5RWRpdHN9LlxuICovXG5mdW5jdGlvbiBtYWluX2Zvcm1hdChkb2N1bWVudFRleHQsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZvcm1hdF9mb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBlZGl0IG9wZXJhdGlvbnMgbmVlZGVkIHRvIG1vZGlmeSBhIHZhbHVlIGluIHRoZSBKU09OIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudFRleHQgVGhlIGlucHV0IHRleHRcbiAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIHRoZSB2YWx1ZSB0byBjaGFuZ2UuIFRoZSBwYXRoIHJlcHJlc2VudHMgZWl0aGVyIHRvIHRoZSBkb2N1bWVudCByb290LCBhIHByb3BlcnR5IG9yIGFuIGFycmF5IGl0ZW0uXG4gKiBJZiB0aGUgcGF0aCBwb2ludHMgdG8gYW4gbm9uLWV4aXN0aW5nIHByb3BlcnR5IG9yIGl0ZW0sIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG9yIGl0ZW0uIElmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsXG4gKiB0aGUgcHJvcGVydHkgb3IgaXRlbSB3aWxsIGJlIHJlbW92ZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZWRpdCBvcGVyYXRpb25zIGRlc2NyaWJpbmcgdGhlIGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50LCBmb2xsb3dpbmcgdGhlIGZvcm1hdCBkZXNjcmliZWQgaW4ge0BsaW5rY29kZSBFZGl0UmVzdWx0fS5cbiAqIFRvIGFwcGx5IHRoZSBlZGl0IG9wZXJhdGlvbnMgdG8gdGhlIGlucHV0LCB1c2Uge0BsaW5rY29kZSBhcHBseUVkaXRzfS5cbiAqL1xuZnVuY3Rpb24gbW9kaWZ5KHRleHQsIHBhdGgsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXQuc2V0UHJvcGVydHkodGV4dCwgcGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBBcHBsaWVzIGVkaXRzIHRvIGFuIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSB0ZXh0IFRoZSBpbnB1dCB0ZXh0XG4gKiBAcGFyYW0gZWRpdHMgRWRpdCBvcGVyYXRpb25zIGZvbGxvd2luZyB0aGUgZm9ybWF0IGRlc2NyaWJlZCBpbiB7QGxpbmtjb2RlIEVkaXRSZXN1bHR9LlxuICogQHJldHVybnMgVGhlIHRleHQgd2l0aCB0aGUgYXBwbGllZCBlZGl0cy5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGVkaXQgb3BlcmF0aW9ucyBhcmUgbm90IHdlbGwtZm9ybWVkIGFzIGRlc2NyaWJlZCBpbiB7QGxpbmtjb2RlIEVkaXRSZXN1bHR9LlxuICovXG5mdW5jdGlvbiBhcHBseUVkaXRzKHRleHQsIGVkaXRzKSB7XG4gICAgbGV0IHNvcnRlZEVkaXRzID0gZWRpdHMuc2xpY2UoMCkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBkaWZmID0gYS5vZmZzZXQgLSBiLm9mZnNldDtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH0pO1xuICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gc29ydGVkRWRpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgaWYgKGUub2Zmc2V0ICsgZS5sZW5ndGggPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gZWRpdC5hcHBseUVkaXQodGV4dCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBlLm9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvb2JqZWN0cy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlcikge1xuICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gdHlwZW9mIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChBcnJheS5pc0FycmF5KG9uZSkpICE9PSAoQXJyYXkuaXNBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGksIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvbmUpKSB7XG4gICAgICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25lS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvbmUpIHtcbiAgICAgICAgICAgIG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG9uZUtleXMuc29ydCgpO1xuICAgICAgICBjb25zdCBvdGhlcktleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb3RoZXIpIHtcbiAgICAgICAgICAgIG90aGVyS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJLZXlzLnNvcnQoKTtcbiAgICAgICAgaWYgKCFlcXVhbHMob25lS2V5cywgb3RoZXJLZXlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhvbmVbb25lS2V5c1tpXV0sIG90aGVyW29uZUtleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9zdHJpbmdzLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIGlmIChoYXlzdGFjay5sZW5ndGggPCBuZWVkbGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhheXN0YWNrW2ldICE9PSBuZWVkbGVbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBoYXlzdGFjayBlbmRzIHdpdGggbmVlZGxlLlxuICovXG5mdW5jdGlvbiBlbmRzV2l0aChoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgY29uc3QgZGlmZiA9IGhheXN0YWNrLmxlbmd0aCAtIG5lZWRsZS5sZW5ndGg7XG4gICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjay5sYXN0SW5kZXhPZihuZWVkbGUpID09PSBkaWZmO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjayA9PT0gbmVlZGxlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvW1xcLVxcXFxcXHtcXH1cXCtcXD9cXHxcXF5cXCRcXC5cXCxcXFtcXF1cXChcXClcXCNcXHNdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9bXFwqXS9nLCAnLionKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ3NfcmVwZWF0KHZhbHVlLCBjb3VudCkge1xuICAgIGxldCBzID0gJyc7XG4gICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICAgIHMgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIGNvdW50ID0gY291bnQgPj4+IDE7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gZXh0ZW5kZWRSZWdFeHAocGF0dGVybikge1xuICAgIGxldCBmbGFncyA9ICcnO1xuICAgIGlmIChzdGFydHNXaXRoKHBhdHRlcm4sICcoP2kpJykpIHtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyaW5nKDQpO1xuICAgICAgICBmbGFncyA9ICdpJztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MgKyAndScpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBjb3VsZCBiZSBhbiBleGNlcHRpb24gZHVlIHRvIHRoZSAndSAnIGZsYWdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBwYXR0ZXJuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gZnJvbSBodHRwczovL3RhbmlzaGlraW5nLmdpdGh1Yi5pby9wb3N0cy9jb3VudC11bmljb2RlLWNvZGVwb2ludC8jd29yay1oYXJkLXdpdGgtZm9yLXN0YXRlbWVudHNcbmZ1bmN0aW9uIHN0cmluZ0xlbmd0aChzdHIpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIC8vIG9idGFpbiB0aGUgaS10aCAxNi1iaXRcbiAgICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBpLXRoIDE2Yml0IGlzIGFuIHVwcGVyIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgLy8gc2tpcCB0aGUgbmV4dCAxNiBiaXRzIChsb3dlciBzdXJyb2dhdGUpXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMvbGliL2VzbS9tYWluLmpzXG52YXIgbWFpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDc2Nyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50L2xpYi9lc20vbWFpbi5qc1xudmFyIGVzbV9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODgxKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vanNvbkxhbmd1YWdlVHlwZXMuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuLyoqXG4gKiBFcnJvciBjb2RlcyB1c2VkIGJ5IGRpYWdub3N0aWNzXG4gKi9cbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmRlZmluZWRcIl0gPSAwXSA9IFwiVW5kZWZpbmVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVudW1WYWx1ZU1pc21hdGNoXCJdID0gMV0gPSBcIkVudW1WYWx1ZU1pc21hdGNoXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkRlcHJlY2F0ZWRcIl0gPSAyXSA9IFwiRGVwcmVjYXRlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMjU3XSA9IFwiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAyNThdID0gXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCJdID0gMjU5XSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludmFsaWRVbmljb2RlXCJdID0gMjYwXSA9IFwiSW52YWxpZFVuaWNvZGVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDI2MV0gPSBcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZENoYXJhY3RlclwiXSA9IDI2Ml0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUHJvcGVydHlFeHBlY3RlZFwiXSA9IDUxM10gPSBcIlByb3BlcnR5RXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWFFeHBlY3RlZFwiXSA9IDUxNF0gPSBcIkNvbW1hRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29sb25FeHBlY3RlZFwiXSA9IDUxNV0gPSBcIkNvbG9uRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVmFsdWVFeHBlY3RlZFwiXSA9IDUxNl0gPSBcIlZhbHVlRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWRcIl0gPSA1MTddID0gXCJDb21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkXCJdID0gNTE4XSA9IFwiQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJUcmFpbGluZ0NvbW1hXCJdID0gNTE5XSA9IFwiVHJhaWxpbmdDb21tYVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJEdXBsaWNhdGVLZXlcIl0gPSA1MjBdID0gXCJEdXBsaWNhdGVLZXlcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWVudE5vdFBlcm1pdHRlZFwiXSA9IDUyMV0gPSBcIkNvbW1lbnROb3RQZXJtaXR0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU2NoZW1hUmVzb2x2ZUVycm9yXCJdID0gNzY4XSA9IFwiU2NoZW1hUmVzb2x2ZUVycm9yXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZVwiXSA9IDc2OV0gPSBcIlNjaGVtYVVuc3VwcG9ydGVkRmVhdHVyZVwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xudmFyIFNjaGVtYURyYWZ0O1xuKGZ1bmN0aW9uIChTY2hlbWFEcmFmdCkge1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjNcIl0gPSAzXSA9IFwidjNcIjtcbiAgICBTY2hlbWFEcmFmdFtTY2hlbWFEcmFmdFtcInY0XCJdID0gNF0gPSBcInY0XCI7XG4gICAgU2NoZW1hRHJhZnRbU2NoZW1hRHJhZnRbXCJ2NlwiXSA9IDZdID0gXCJ2NlwiO1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjdcIl0gPSA3XSA9IFwidjdcIjtcbiAgICBTY2hlbWFEcmFmdFtTY2hlbWFEcmFmdFtcInYyMDE5XzA5XCJdID0gMTldID0gXCJ2MjAxOV8wOVwiO1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjIwMjBfMTJcIl0gPSAyMF0gPSBcInYyMDIwXzEyXCI7XG59KShTY2hlbWFEcmFmdCB8fCAoU2NoZW1hRHJhZnQgPSB7fSkpO1xudmFyIENsaWVudENhcGFiaWxpdGllcztcbihmdW5jdGlvbiAoQ2xpZW50Q2FwYWJpbGl0aWVzKSB7XG4gICAgQ2xpZW50Q2FwYWJpbGl0aWVzLkxBVEVTVCA9IHtcbiAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbkZvcm1hdDogW21haW4uTWFya3VwS2luZC5NYXJrZG93biwgbWFpbi5NYXJrdXBLaW5kLlBsYWluVGV4dF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdENoYXJhY3RlcnNTdXBwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbERldGFpbHNTdXBwb3J0OiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pKENsaWVudENhcGFiaWxpdGllcyB8fCAoQ2xpZW50Q2FwYWJpbGl0aWVzID0ge30pKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvbm9kZV9tb2R1bGVzL0B2c2NvZGUvbDEwbi9kaXN0L2Jyb3dzZXIuanNcbi8vIHNyYy9icm93c2VyL3JlYWRlci50c1xuYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVGcm9tVXJpKHVyaSkge1xuICBpZiAodXJpLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJpKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzLnRleHQoKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwcm90b2NvbFwiKTtcbn1cbmZ1bmN0aW9uIHJlYWRGaWxlRnJvbUZzUGF0aChfKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGluIGJyb3dzZXJcIik7XG59XG5cbi8vIHNyYy9tYWluLnRzXG52YXIgYnVuZGxlO1xuZnVuY3Rpb24gY29uZmlnKGNvbmZpZzIpIHtcbiAgaWYgKFwiY29udGVudHNcIiBpbiBjb25maWcyKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcyLmNvbnRlbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBidW5kbGUgPSBKU09OLnBhcnNlKGNvbmZpZzIuY29udGVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidW5kbGUgPSBjb25maWcyLmNvbnRlbnRzO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKFwiZnNQYXRoXCIgaW4gY29uZmlnMikge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gcmVhZEZpbGVGcm9tRnNQYXRoKGNvbmZpZzIuZnNQYXRoKTtcbiAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShmaWxlQ29udGVudCk7XG4gICAgYnVuZGxlID0gaXNCdWlsdGluRXh0ZW5zaW9uKGNvbnRlbnQpID8gY29udGVudC5jb250ZW50cy5idW5kbGUgOiBjb250ZW50O1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY29uZmlnMi51cmkpIHtcbiAgICBsZXQgdXJpID0gY29uZmlnMi51cmk7XG4gICAgaWYgKHR5cGVvZiBjb25maWcyLnVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdXJpID0gbmV3IFVSTChjb25maWcyLnVyaSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwID0gcmVhZEZpbGVGcm9tVXJpKHVyaSkudGhlbigodXJpQ29udGVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKHVyaUNvbnRlbnQpO1xuICAgICAgICAgIGJ1bmRsZSA9IGlzQnVpbHRpbkV4dGVuc2lvbihjb250ZW50KSA/IGNvbnRlbnQuY29udGVudHMuYnVuZGxlIDogY29udGVudDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHJlc29sdmUocCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHQoLi4uYXJncykge1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGxldCBrZXk7XG4gIGxldCBtZXNzYWdlO1xuICBsZXQgZm9ybWF0QXJncztcbiAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGtleSA9IGZpcnN0QXJnO1xuICAgIG1lc3NhZ2UgPSBmaXJzdEFyZztcbiAgICBhcmdzLnNwbGljZSgwLCAxKTtcbiAgICBmb3JtYXRBcmdzID0gIWFyZ3MgfHwgdHlwZW9mIGFyZ3NbMF0gIT09IFwib2JqZWN0XCIgPyBhcmdzIDogYXJnc1swXTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gZmlyc3RBcmcubWVzc2FnZTtcbiAgICBrZXkgPSBtZXNzYWdlO1xuICAgIGlmIChmaXJzdEFyZy5jb21tZW50ICYmIGZpcnN0QXJnLmNvbW1lbnQubGVuZ3RoID4gMCkge1xuICAgICAga2V5ICs9IGAvJHtBcnJheS5pc0FycmF5KGZpcnN0QXJnLmNvbW1lbnQpID8gZmlyc3RBcmcuY29tbWVudC5qb2luKFwiXCIpIDogZmlyc3RBcmcuY29tbWVudH1gO1xuICAgIH1cbiAgICBmb3JtYXRBcmdzID0gZmlyc3RBcmcuYXJncyA/PyB7fTtcbiAgfVxuICBpZiAoIWJ1bmRsZSkge1xuICAgIHJldHVybiBicm93c2VyX2Zvcm1hdChtZXNzYWdlLCBmb3JtYXRBcmdzKTtcbiAgfVxuICBjb25zdCBtZXNzYWdlRnJvbUJ1bmRsZSA9IGJ1bmRsZVtrZXldO1xuICBpZiAoIW1lc3NhZ2VGcm9tQnVuZGxlKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJfZm9ybWF0KG1lc3NhZ2UsIGZvcm1hdEFyZ3MpO1xuICB9XG4gIGlmICh0eXBlb2YgbWVzc2FnZUZyb21CdW5kbGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYnJvd3Nlcl9mb3JtYXQobWVzc2FnZUZyb21CdW5kbGUsIGZvcm1hdEFyZ3MpO1xuICB9XG4gIGlmIChtZXNzYWdlRnJvbUJ1bmRsZS5jb21tZW50KSB7XG4gICAgcmV0dXJuIGJyb3dzZXJfZm9ybWF0KG1lc3NhZ2VGcm9tQnVuZGxlLm1lc3NhZ2UsIGZvcm1hdEFyZ3MpO1xuICB9XG4gIHJldHVybiBicm93c2VyX2Zvcm1hdChtZXNzYWdlLCBmb3JtYXRBcmdzKTtcbn1cbnZhciBfZm9ybWF0MlJlZ2V4cCA9IC97KFtefV0rKX0vZztcbmZ1bmN0aW9uIGJyb3dzZXJfZm9ybWF0KHRlbXBsYXRlLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoX2Zvcm1hdDJSZWdleHAsIChtYXRjaCwgZ3JvdXApID0+IHZhbHVlc1tncm91cF0gPz8gbWF0Y2gpO1xufVxuZnVuY3Rpb24gaXNCdWlsdGluRXh0ZW5zaW9uKGpzb24pIHtcbiAgcmV0dXJuICEhKHR5cGVvZiBqc29uPy5jb250ZW50cz8uYnVuZGxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBqc29uPy52ZXJzaW9uID09PSBcInN0cmluZ1wiKTtcbn1cblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3BhcnNlci9qc29uUGFyc2VyLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cblxuXG5jb25zdCBmb3JtYXRzID0ge1xuICAgICdjb2xvci1oZXgnOiB7IGVycm9yTWVzc2FnZTogdCgnSW52YWxpZCBjb2xvciBmb3JtYXQuIFVzZSAjUkdCLCAjUkdCQSwgI1JSR0dCQiBvciAjUlJHR0JCQUEuJyksIHBhdHRlcm46IC9eIyhbMC05QS1GYS1mXXszLDR9fChbMC05QS1GYS1mXXsyfSl7Myw0fSkkLyB9LFxuICAgICdkYXRlLXRpbWUnOiB7IGVycm9yTWVzc2FnZTogdCgnU3RyaW5nIGlzIG5vdCBhIFJGQzMzMzkgZGF0ZS10aW1lLicpLCBwYXR0ZXJuOiAvXihcXGR7NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlUKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkoXFwuWzAtOV0rKT8oWnwoXFwrfC0pKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKSkkL2kgfSxcbiAgICAnZGF0ZSc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSBkYXRlLicpLCBwYXR0ZXJuOiAvXihcXGR7NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSkkL2kgfSxcbiAgICAndGltZSc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSB0aW1lLicpLCBwYXR0ZXJuOiAvXihbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSk6KFswLTVdWzAtOV18NjApKFxcLlswLTldKyk/KFp8KFxcK3wtKShbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSkpJC9pIH0sXG4gICAgJ2VtYWlsJzogeyBlcnJvck1lc3NhZ2U6IHQoJ1N0cmluZyBpcyBub3QgYW4gZS1tYWlsIGFkZHJlc3MuJyksIHBhdHRlcm46IC9eKChbXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfV0pfCgoW2EtekEtWjAtOS1dK1xcLikrW2EtekEtWl17Mix9KSkkLyB9LFxuICAgICdob3N0bmFtZSc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGEgaG9zdG5hbWUuJyksIHBhdHRlcm46IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2kgfSxcbiAgICAnaXB2NCc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGFuIElQdjQgYWRkcmVzcy4nKSwgcGF0dGVybjogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZClcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpJC8gfSxcbiAgICAnaXB2Nic6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGFuIElQdjYgYWRkcmVzcy4nKSwgcGF0dGVybjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2kgfSxcbn07XG5jbGFzcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQsIGxlbmd0aCA9IDApIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ3R5cGU6ICcgKyB0aGlzLnR5cGUgKyAnICgnICsgdGhpcy5vZmZzZXQgKyAnLycgKyB0aGlzLmxlbmd0aCArICcpJyArICh0aGlzLnBhcmVudCA/ICcgcGFyZW50OiB7JyArIHRoaXMucGFyZW50LnRvU3RyaW5nKCkgKyAnfScgOiAnJyk7XG4gICAgfVxufVxuY2xhc3MgTnVsbEFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ251bGwnO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCb29sZWFuQVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBib29sVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG9mZnNldCk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdib29sZWFuJztcbiAgICAgICAgdGhpcy52YWx1ZSA9IGJvb2xWYWx1ZTtcbiAgICB9XG59XG5jbGFzcyBBcnJheUFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2FycmF5JztcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgIH1cbn1cbmNsYXNzIE51bWJlckFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ251bWJlcic7XG4gICAgICAgIHRoaXMuaXNJbnRlZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IE51bWJlci5OYU47XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nQVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0cmluZyc7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICB9XG59XG5jbGFzcyBQcm9wZXJ0eUFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0LCBrZXlOb2RlKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Byb3BlcnR5JztcbiAgICAgICAgdGhpcy5jb2xvbk9mZnNldCA9IC0xO1xuICAgICAgICB0aGlzLmtleU5vZGUgPSBrZXlOb2RlO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlTm9kZSA/IFt0aGlzLmtleU5vZGUsIHRoaXMudmFsdWVOb2RlXSA6IFt0aGlzLmtleU5vZGVdO1xuICAgIH1cbn1cbmNsYXNzIE9iamVjdEFTVE5vZGVJbXBsIGV4dGVuZHMgQVNUTm9kZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ29iamVjdCc7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFtdO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNTY2hlbWEoc2NoZW1hKSB7XG4gICAgaWYgKGlzQm9vbGVhbihzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEgPyB7fSA6IHsgXCJub3RcIjoge30gfTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbnZhciBFbnVtTWF0Y2g7XG4oZnVuY3Rpb24gKEVudW1NYXRjaCkge1xuICAgIEVudW1NYXRjaFtFbnVtTWF0Y2hbXCJLZXlcIl0gPSAwXSA9IFwiS2V5XCI7XG4gICAgRW51bU1hdGNoW0VudW1NYXRjaFtcIkVudW1cIl0gPSAxXSA9IFwiRW51bVwiO1xufSkoRW51bU1hdGNoIHx8IChFbnVtTWF0Y2ggPSB7fSkpO1xuY29uc3Qgc2NoZW1hRHJhZnRGcm9tSWQgPSB7XG4gICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDMvc2NoZW1hIyc6IFNjaGVtYURyYWZ0LnYzLFxuICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnOiBTY2hlbWFEcmFmdC52NCxcbiAgICAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNi9zY2hlbWEjJzogU2NoZW1hRHJhZnQudjYsXG4gICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIyc6IFNjaGVtYURyYWZ0LnY3LFxuICAgICdodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L3NjaGVtYSc6IFNjaGVtYURyYWZ0LnYyMDE5XzA5LFxuICAgICdodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDIwLTEyL3NjaGVtYSc6IFNjaGVtYURyYWZ0LnYyMDIwXzEyXG59O1xuY2xhc3MgRXZhbHVhdGlvbkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYURyYWZ0KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hRHJhZnQgPSBzY2hlbWFEcmFmdDtcbiAgICB9XG59XG5jbGFzcyBTY2hlbWFDb2xsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGZvY3VzT2Zmc2V0ID0gLTEsIGV4Y2x1ZGUpIHtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgICAgICB0aGlzLmV4Y2x1ZGUgPSBleGNsdWRlO1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSBbXTtcbiAgICB9XG4gICAgYWRkKHNjaGVtYSkge1xuICAgICAgICB0aGlzLnNjaGVtYXMucHVzaChzY2hlbWEpO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnNjaGVtYXMsIG90aGVyLnNjaGVtYXMpO1xuICAgIH1cbiAgICBpbmNsdWRlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvY3VzT2Zmc2V0ID09PSAtMSB8fCBqc29uUGFyc2VyX2NvbnRhaW5zKG5vZGUsIHRoaXMuZm9jdXNPZmZzZXQpKSAmJiAobm9kZSAhPT0gdGhpcy5leGNsdWRlKTtcbiAgICB9XG4gICAgbmV3U3ViKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYUNvbGxlY3RvcigtMSwgdGhpcy5leGNsdWRlKTtcbiAgICB9XG59XG5jbGFzcyBOb09wU2NoZW1hQ29sbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIGdldCBzY2hlbWFzKCkgeyByZXR1cm4gW107IH1cbiAgICBhZGQoX3NjaGVtYSkgeyB9XG4gICAgbWVyZ2UoX290aGVyKSB7IH1cbiAgICBpbmNsdWRlKF9ub2RlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgbmV3U3ViKCkgeyByZXR1cm4gdGhpczsgfVxufVxuTm9PcFNjaGVtYUNvbGxlY3Rvci5pbnN0YW5jZSA9IG5ldyBOb09wU2NoZW1hQ29sbGVjdG9yKCk7XG5jbGFzcyBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9ibGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNNYXRjaGVzID0gMDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLmVudW1WYWx1ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW51bVZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzUHJvYmxlbXMoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHJvYmxlbXMubGVuZ3RoO1xuICAgIH1cbiAgICBtZXJnZSh2YWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHRoaXMucHJvYmxlbXMgPSB0aGlzLnByb2JsZW1zLmNvbmNhdCh2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcyArPSB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgKz0gdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xuICAgICAgICB0aGlzLm1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyh2YWxpZGF0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgbWVyZ2VFbnVtVmFsdWVzKHZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVudW1WYWx1ZU1hdGNoICYmICF2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoICYmIHRoaXMuZW51bVZhbHVlcyAmJiB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW51bVZhbHVlcyA9IHRoaXMuZW51bVZhbHVlcy5jb25jYXQodmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgdGhpcy5wcm9ibGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBFcnJvckNvZGUuRW51bVZhbHVlTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IHQoJ1ZhbHVlIGlzIG5vdCBhY2NlcHRlZC4gVmFsaWQgdmFsdWVzOiB7MH0uJywgdGhpcy5lbnVtVmFsdWVzLm1hcCh2ID0+IEpTT04uc3RyaW5naWZ5KHYpKS5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICB0aGlzLnByb2JsZW1zID0gdGhpcy5wcm9ibGVtcy5jb25jYXQocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcysrO1xuICAgICAgICBpZiAocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoIHx8ICFwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSAmJiBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggJiYgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMgJiYgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVByb2Nlc3NlZFByb3BlcnRpZXModmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuZm9yRWFjaChwID0+IHRoaXMucHJvY2Vzc2VkUHJvcGVydGllcy5hZGQocCkpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGhhc1Byb2JsZW1zID0gdGhpcy5oYXNQcm9ibGVtcygpO1xuICAgICAgICBpZiAoaGFzUHJvYmxlbXMgIT09IG90aGVyLmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNQcm9ibGVtcyA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbnVtVmFsdWVNYXRjaCAhPT0gb3RoZXIuZW51bVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5lbnVtVmFsdWVNYXRjaCA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5VmFsdWVNYXRjaGVzICE9PSBvdGhlci5wcmltYXJ5VmFsdWVNYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5VmFsdWVNYXRjaGVzIC0gb3RoZXIucHJpbWFyeVZhbHVlTWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICE9PSBvdGhlci5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzIC0gb3RoZXIucHJvcGVydGllc1ZhbHVlTWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcyAtIG90aGVyLnByb3BlcnRpZXNNYXRjaGVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld0pTT05Eb2N1bWVudChyb290LCBkaWFnbm9zdGljcyA9IFtdKSB7XG4gICAgcmV0dXJuIG5ldyBKU09ORG9jdW1lbnQocm9vdCwgZGlhZ25vc3RpY3MsIFtdKTtcbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlKG5vZGUpIHtcbiAgICByZXR1cm4gbWFpbl9nZXROb2RlVmFsdWUobm9kZSk7XG59XG5mdW5jdGlvbiBqc29uUGFyc2VyX2dldE5vZGVQYXRoKG5vZGUpIHtcbiAgICByZXR1cm4gbWFpbl9nZXROb2RlUGF0aChub2RlKTtcbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfY29udGFpbnMobm9kZSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9mZnNldCA+PSBub2RlLm9mZnNldCAmJiBvZmZzZXQgPCAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkgfHwgaW5jbHVkZVJpZ2h0Qm91bmQgJiYgb2Zmc2V0ID09PSAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCk7XG59XG5jbGFzcyBKU09ORG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIHN5bnRheEVycm9ycyA9IFtdLCBjb21tZW50cyA9IFtdKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuc3ludGF4RXJyb3JzID0gc3ludGF4RXJyb3JzO1xuICAgICAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHM7XG4gICAgfVxuICAgIGdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFpbl9maW5kTm9kZUF0T2Zmc2V0KHRoaXMucm9vdCwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICBjb25zdCBkb1Zpc2l0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3RuID0gdmlzaXRvcihub2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGN0bjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG4gPSBkb1Zpc2l0KGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3RuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvVmlzaXQodGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZSh0ZXh0RG9jdW1lbnQsIHNjaGVtYSwgc2V2ZXJpdHkgPSBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nLCBzY2hlbWFEcmFmdCkge1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICB2YWxpZGF0ZSh0aGlzLnJvb3QsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgTm9PcFNjaGVtYUNvbGxlY3Rvci5pbnN0YW5jZSwgbmV3IEV2YWx1YXRpb25Db250ZXh0KHNjaGVtYURyYWZ0ID8/IGdldFNjaGVtYURyYWZ0KHNjaGVtYSkpKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHAubG9jYXRpb24ub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQocC5sb2NhdGlvbi5vZmZzZXQgKyBwLmxvY2F0aW9uLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkRpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBwLm1lc3NhZ2UsIHAuc2V2ZXJpdHkgPz8gc2V2ZXJpdHksIHAuY29kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLCBmb2N1c09mZnNldCA9IC0xLCBleGNsdWRlKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgJiYgc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ1NjaGVtYXMgPSBuZXcgU2NoZW1hQ29sbGVjdG9yKGZvY3VzT2Zmc2V0LCBleGNsdWRlKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYURyYWZ0ID0gZ2V0U2NoZW1hRHJhZnQoc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgRXZhbHVhdGlvbkNvbnRleHQoc2NoZW1hRHJhZnQpO1xuICAgICAgICAgICAgdmFsaWRhdGUodGhpcy5yb290LCBzY2hlbWEsIG5ldyBWYWxpZGF0aW9uUmVzdWx0KCksIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdTY2hlbWFzLnNjaGVtYXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaGVtYURyYWZ0KHNjaGVtYSwgZmFsbEJhY2sgPSBTY2hlbWFEcmFmdC52MjAyMF8xMikge1xuICAgIGxldCBzY2hlbWFJZCA9IHNjaGVtYS4kc2NoZW1hO1xuICAgIGlmIChzY2hlbWFJZCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hRHJhZnRGcm9tSWRbc2NoZW1hSWRdID8/IGZhbGxCYWNrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbEJhY2s7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShuLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCkge1xuICAgIGlmICghbiB8fCAhbWF0Y2hpbmdTY2hlbWFzLmluY2x1ZGUobikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobi50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShuLnZhbHVlTm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gbjtcbiAgICBfdmFsaWRhdGVOb2RlKCk7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIF92YWxpZGF0ZU9iamVjdE5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgX3ZhbGlkYXRlQXJyYXlOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBfdmFsaWRhdGVTdHJpbmdOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBfdmFsaWRhdGVOdW1iZXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1hdGNoaW5nU2NoZW1hcy5hZGQoeyBub2RlOiBub2RlLCBzY2hlbWE6IHNjaGVtYSB9KTtcbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVOb2RlKCkge1xuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzVHlwZSh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSB0eXBlIHx8ICh0eXBlID09PSAnaW50ZWdlcicgJiYgbm9kZS50eXBlID09PSAnbnVtYmVyJyAmJiBub2RlLmlzSW50ZWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYS50eXBlLnNvbWUobWF0Y2hlc1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0luY29ycmVjdCB0eXBlLiBFeHBlY3RlZCBvbmUgb2YgezB9LicsIHNjaGVtYS50eXBlLmpvaW4oJywgJykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlc1R5cGUoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0luY29ycmVjdCB0eXBlLiBFeHBlY3RlZCBcInswfVwiLicsIHNjaGVtYS50eXBlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViU2NoZW1hUmVmIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBhc1NjaGVtYShzdWJTY2hlbWFSZWYpLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2Uoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLm1lcmdlKHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90U2NoZW1hID0gYXNTY2hlbWEoc2NoZW1hLm5vdCk7XG4gICAgICAgIGlmIChub3RTY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgbm90U2NoZW1hLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdChcIk1hdGNoZXMgYSBzY2hlbWEgdGhhdCBpcyBub3QgYWxsb3dlZC5cIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbXMgb2Ygc3ViTWF0Y2hpbmdTY2hlbWFzLnNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICBtcy5pbnZlcnRlZCA9ICFtcy5pbnZlcnRlZDtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMuYWRkKG1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXN0QWx0ZXJuYXRpdmVzID0gKGFsdGVybmF0aXZlcywgbWF4T25lTWF0Y2gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBiZXN0IG1hdGNoIHRoYXQgaXMgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNjaGVtYVJlZiBvZiBhbHRlcm5hdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShzdWJTY2hlbWFSZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBzdWJTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YlNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmVzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHsgc2NoZW1hOiBzdWJTY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQ6IHN1YlZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hczogc3ViTWF0Y2hpbmdTY2hlbWFzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heE9uZU1hdGNoICYmICFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkgJiYgIWJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGVycm9ycywgYm90aCBhcmUgZXF1YWxseSBnb29kIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyhzdWJWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVSZXN1bHQgPSBzdWJWYWxpZGF0aW9uUmVzdWx0LmNvbXBhcmUoYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3VyIG5vZGUgaXMgdGhlIGJlc3QgbWF0Y2hpbmcgc28gZmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0geyBzY2hlbWE6IHN1YlNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdDogc3ViVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzOiBzdWJNYXRjaGluZ1NjaGVtYXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBhcmVSZXN1bHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIGFscmVhZHkgYSBiZXN0IG1hdGNoaW5nIGJ1dCB3ZSBhcmUgYXMgZ29vZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5tZXJnZUVudW1WYWx1ZXMoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAxICYmIG1heE9uZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiAxIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoXCJNYXRjaGVzIG11bHRpcGxlIHNjaGVtYXMgd2hlbiBvbmx5IG9uZSBtdXN0IHZhbGlkYXRlLlwiKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2UoYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5tZXJnZShiZXN0TWF0Y2gubWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkge1xuICAgICAgICAgICAgdGVzdEFsdGVybmF0aXZlcyhzY2hlbWEuYW55T2YsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgICAgICB0ZXN0QWx0ZXJuYXRpdmVzKHNjaGVtYS5vbmVPZiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVzdEJyYW5jaCA9IChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgYXNTY2hlbWEoc2NoZW1hKSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2Uoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGVzdENvbmRpdGlvbiA9IChpZlNjaGVtYSwgdGhlblNjaGVtYSwgZWxzZVNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ViU2NoZW1hID0gYXNTY2hlbWEoaWZTY2hlbWEpO1xuICAgICAgICAgICAgY29uc3Qgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XG4gICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBzdWJTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9jZXNzZWRQcm9wZXJ0aWVzKHN1YlZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhlblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0QnJhbmNoKHRoZW5TY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsc2VTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICB0ZXN0QnJhbmNoKGVsc2VTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpZlNjaGVtYSA9IGFzU2NoZW1hKHNjaGVtYS5pZik7XG4gICAgICAgIGlmIChpZlNjaGVtYSkge1xuICAgICAgICAgICAgdGVzdENvbmRpdGlvbihpZlNjaGVtYSwgYXNTY2hlbWEoc2NoZW1hLnRoZW4pLCBhc1NjaGVtYShzY2hlbWEuZWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0ganNvblBhcnNlcl9nZXROb2RlVmFsdWUobm9kZSk7XG4gICAgICAgICAgICBsZXQgZW51bVZhbHVlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBzY2hlbWEuZW51bSkge1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbHModmFsLCBlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWVNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcyA9IHNjaGVtYS5lbnVtO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IGVudW1WYWx1ZU1hdGNoO1xuICAgICAgICAgICAgaWYgKCFlbnVtVmFsdWVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkVudW1WYWx1ZU1pc21hdGNoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1ZhbHVlIGlzIG5vdCBhY2NlcHRlZC4gVmFsaWQgdmFsdWVzOiB7MH0uJywgc2NoZW1hLmVudW0ubWFwKHYgPT4gSlNPTi5zdHJpbmdpZnkodikpLmpvaW4oJywgJykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZChzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKHZhbCwgc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkVudW1WYWx1ZU1pc21hdGNoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1ZhbHVlIG11c3QgYmUgezB9LicsIEpTT04uc3RyaW5naWZ5KHNjaGVtYS5jb25zdCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMgPSBbc2NoZW1hLmNvbnN0XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVwcmVjYXRpb25NZXNzYWdlID0gc2NoZW1hLmRlcHJlY2F0aW9uTWVzc2FnZTtcbiAgICAgICAgaWYgKChkZXByZWNhdGlvbk1lc3NhZ2UgfHwgc2NoZW1hLmRlcHJlY2F0ZWQpICYmIG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbk1lc3NhZ2UgPSBkZXByZWNhdGlvbk1lc3NhZ2UgfHwgdCgnVmFsdWUgaXMgZGVwcmVjYXRlZCcpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUucGFyZW50Lm9mZnNldCwgbGVuZ3RoOiBub2RlLnBhcmVudC5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZXByZWNhdGlvbk1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkRlcHJlY2F0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCB2YWwgPSBub2RlLnZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVGbG9hdHMoZmxvYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gL14oLT9cXGQrKSg/OlxcLihcXGQrKSk/KD86ZShbLStdXFxkKykpPyQvLmV4ZWMoZmxvYXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHMgJiYge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIocGFydHNbMV0gKyAocGFydHNbMl0gfHwgJycpKSxcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyOiAocGFydHNbMl0/Lmxlbmd0aCB8fCAwKSAtIChwYXJzZUludChwYXJ0c1szXSkgfHwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpKSB7XG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gLTE7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihzY2hlbWEubXVsdGlwbGVPZikpIHtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSB2YWwgJSBzY2hlbWEubXVsdGlwbGVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBub3JtTXVsdGlwbGVPZiA9IG5vcm1hbGl6ZUZsb2F0cyhzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1WYWx1ZSA9IG5vcm1hbGl6ZUZsb2F0cyh2YWwpO1xuICAgICAgICAgICAgICAgIGlmIChub3JtTXVsdGlwbGVPZiAmJiBub3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IDEwICoqIE1hdGguYWJzKG5vcm1WYWx1ZS5tdWx0aXBsaWVyIC0gbm9ybU11bHRpcGxlT2YubXVsdGlwbGllcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtVmFsdWUubXVsdGlwbGllciA8IG5vcm1NdWx0aXBsZU9mLm11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1WYWx1ZS52YWx1ZSAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybU11bHRpcGxlT2YudmFsdWUgKj0gbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBub3JtVmFsdWUudmFsdWUgJSBub3JtTXVsdGlwbGVPZi52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluZGVyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdWYWx1ZSBpcyBub3QgZGl2aXNpYmxlIGJ5IHswfS4nLCBzY2hlbWEubXVsdGlwbGVPZilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRFeGNsdXNpdmVMaW1pdChsaW1pdCwgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdXNpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCb29sZWFuKGV4Y2x1c2l2ZSkgJiYgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRMaW1pdChsaW1pdCwgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihleGNsdXNpdmUpIHx8ICFleGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2x1c2l2ZU1pbmltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWluaW11bSkgJiYgdmFsIDw9IGV4Y2x1c2l2ZU1pbmltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGJlbG93IHRoZSBleGNsdXNpdmUgbWluaW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWluaW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2x1c2l2ZU1heGltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWF4aW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWF4aW11bSkgJiYgdmFsID49IGV4Y2x1c2l2ZU1heGltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGFib3ZlIHRoZSBleGNsdXNpdmUgbWF4aW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWF4aW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbmltdW0gPSBnZXRMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIobWluaW11bSkgJiYgdmFsIDwgbWluaW11bSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnVmFsdWUgaXMgYmVsb3cgdGhlIG1pbmltdW0gb2YgezB9LicsIG1pbmltdW0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhpbXVtID0gZ2V0TGltaXQoc2NoZW1hLm1heGltdW0sIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG1heGltdW0pICYmIHZhbCA+IG1heGltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGFib3ZlIHRoZSBtYXhpbXVtIG9mIHswfS4nLCBtYXhpbXVtKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlU3RyaW5nTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluTGVuZ3RoKSAmJiBzdHJpbmdMZW5ndGgobm9kZS52YWx1ZSkgPCBzY2hlbWEubWluTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdTdHJpbmcgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiB7MH0uJywgc2NoZW1hLm1pbkxlbmd0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4TGVuZ3RoKSAmJiBzdHJpbmdMZW5ndGgobm9kZS52YWx1ZSkgPiBzY2hlbWEubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdTdHJpbmcgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW0gbGVuZ3RoIG9mIHswfS4nLCBzY2hlbWEubWF4TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHNjaGVtYS5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChzY2hlbWEucGF0dGVybik7XG4gICAgICAgICAgICBpZiAoIShyZWdleD8udGVzdChub2RlLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5wYXR0ZXJuRXJyb3JNZXNzYWdlIHx8IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnU3RyaW5nIGRvZXMgbm90IG1hdGNoIHRoZSBwYXR0ZXJuIG9mIFwiezB9XCIuJywgc2NoZW1hLnBhdHRlcm4pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VyaSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndXJpLXJlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IC9eKChbXjovPyNdKz8pOik/KFxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8vLmV4ZWMobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFtYXRjaFsyXSAmJiBzY2hlbWEuZm9ybWF0ID09PSAndXJpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgd2l0aCBhIHNjaGVtZSBpcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1N0cmluZyBpcyBub3QgYSBVUkk6IHswfScsIGVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb2xvci1oZXgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcHY0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcHY2JzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0c1tzY2hlbWEuZm9ybWF0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnZhbHVlIHx8ICFmb3JtYXQucGF0dGVybi5leGVjKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGZvcm1hdC5lcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVBcnJheU5vZGUobm9kZSkge1xuICAgICAgICBsZXQgcHJlZml4SXRlbXNTY2hlbWFzO1xuICAgICAgICBsZXQgYWRkaXRpb25hbEl0ZW1TY2hlbWE7XG4gICAgICAgIGlmIChjb250ZXh0LnNjaGVtYURyYWZ0ID49IFNjaGVtYURyYWZ0LnYyMDIwXzEyKSB7XG4gICAgICAgICAgICBwcmVmaXhJdGVtc1NjaGVtYXMgPSBzY2hlbWEucHJlZml4SXRlbXM7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbVNjaGVtYSA9ICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmVmaXhJdGVtc1NjaGVtYXMgPSBBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbVNjaGVtYSA9ICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGlmIChwcmVmaXhJdGVtc1NjaGVtYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4ocHJlZml4SXRlbXNTY2hlbWFzLmxlbmd0aCwgbm9kZS5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViU2NoZW1hUmVmID0gcHJlZml4SXRlbXNTY2hlbWFzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShzdWJTY2hlbWFSZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbm9kZS5pdGVtc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoaXRlbSwgc3ViU2NoZW1hLCBpdGVtVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2goaXRlbVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsSXRlbVNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIGluZGV4IDwgbm9kZS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbEl0ZW1TY2hlbWEgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsSXRlbVNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ0FycmF5IGhhcyB0b28gbWFueSBpdGVtcyBhY2NvcmRpbmcgdG8gc2NoZW1hLiBFeHBlY3RlZCB7MH0gb3IgZmV3ZXIuJywgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUuaXRlbXNbaW5kZXhdLCBhZGRpdGlvbmFsSXRlbVNjaGVtYSwgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKGl0ZW1WYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbnNTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEuY29udGFpbnMpO1xuICAgICAgICBpZiAoY29udGFpbnNTY2hlbWEpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluc0NvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoaXRlbSwgY29udGFpbnNTY2hlbWEsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1WYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zY2hlbWFEcmFmdCA+PSBTY2hlbWFEcmFmdC52MjAyMF8xMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWluc0NvdW50ID09PSAwICYmICFpc051bWJlcihzY2hlbWEubWluQ29udGFpbnMpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0FycmF5IGRvZXMgbm90IGNvbnRhaW4gcmVxdWlyZWQgaXRlbS4nKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5Db250YWlucykgJiYgY29udGFpbnNDb3VudCA8IHNjaGVtYS5taW5Db250YWlucykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnQXJyYXkgaGFzIHRvbyBmZXcgaXRlbXMgdGhhdCBtYXRjaCB0aGUgY29udGFpbnMgY29udHJhaW50LiBFeHBlY3RlZCB7MH0gb3IgbW9yZS4nLCBzY2hlbWEubWluQ29udGFpbnMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1heENvbnRhaW5zKSAmJiBjb250YWluc0NvdW50ID4gc2NoZW1hLm1heENvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgdG9vIG1hbnkgaXRlbXMgdGhhdCBtYXRjaCB0aGUgY29udGFpbnMgY29udHJhaW50LiBFeHBlY3RlZCB7MH0gb3IgbGVzcy4nLCBzY2hlbWEubWF4Q29udGFpbnMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5ldmFsdWF0ZWRJdGVtcyA9IHNjaGVtYS51bmV2YWx1YXRlZEl0ZW1zO1xuICAgICAgICBpZiAodW5ldmFsdWF0ZWRJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5oYXMoU3RyaW5nKGkpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5ldmFsdWF0ZWRJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ0l0ZW0gZG9lcyBub3QgbWF0Y2ggYW55IHZhbGlkYXRpb24gcnVsZSBmcm9tIHRoZSBhcnJheS4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLml0ZW1zW2ldLCBzY2hlbWEudW5ldmFsdWF0ZWRJdGVtcywgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChpdGVtVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaSkpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmIG5vZGUuaXRlbXMubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgdG9vIGZldyBpdGVtcy4gRXhwZWN0ZWQgezB9IG9yIG1vcmUuJywgc2NoZW1hLm1pbkl0ZW1zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhJdGVtcykgJiYgbm9kZS5pdGVtcy5sZW5ndGggPiBzY2hlbWEubWF4SXRlbXMpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ0FycmF5IGhhcyB0b28gbWFueSBpdGVtcy4gRXhwZWN0ZWQgezB9IG9yIGZld2VyLicsIHNjaGVtYS5tYXhJdGVtcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEudW5pcXVlSXRlbXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlcyA9IHZhbHVlcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggIT09IHZhbHVlcy5sYXN0SW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgZHVwbGljYXRlIGl0ZW1zLicpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlT2JqZWN0Tm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHNlZW5LZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5Tm9kZSBvZiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BlcnR5Tm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgc2VlbktleXNba2V5XSA9IHByb3BlcnR5Tm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2Ygc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuS2V5c1twcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIG5vZGUucGFyZW50LmtleU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ga2V5Tm9kZSA/IHsgb2Zmc2V0OiBrZXlOb2RlLm9mZnNldCwgbGVuZ3RoOiBrZXlOb2RlLmxlbmd0aCB9IDogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ01pc3NpbmcgcHJvcGVydHkgXCJ7MH1cIi4nLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0eVByb2Nlc3NlZCA9IChwcm9wKSA9PiB7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVByb2Nlc3NlZChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ocHJvcGVydHlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOb2RlID0gY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1Byb3BlcnR5IHswfSBpcyBub3QgYWxsb3dlZC4nLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHByb3BlcnR5U2NoZW1hLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlQYXR0ZXJuIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4dGVuZGVkUmVnRXhwKHByb3BlcnR5UGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiB1bnByb2Nlc3NlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gc2VlbktleXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcHJvcGVydHlQYXR0ZXJuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihwcm9wZXJ0eVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkLmZvckVhY2gocHJvcGVydHlQcm9jZXNzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIHVucHJvY2Vzc2VkUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5UHJvY2Vzc2VkKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzZWVuS2V5c1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuZXZhbHVhdGVkUHJvcGVydGllcyA9IHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXM7XG4gICAgICAgIGlmICh1bmV2YWx1YXRlZFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiB1bnByb2Nlc3NlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5oYXMocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVuZXZhbHVhdGVkUHJvcGVydGllcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHVuZXZhbHVhdGVkUHJvcGVydGllcywgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzZWQuZm9yRWFjaChwcm9wZXJ0eVByb2Nlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPiBzY2hlbWEubWF4UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnT2JqZWN0IGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBsaW1pdCBvZiB7MH0uJywgc2NoZW1hLm1heFByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPCBzY2hlbWEubWluUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnT2JqZWN0IGhhcyBmZXdlciBwcm9wZXJ0aWVzIHRoYW4gdGhlIHJlcXVpcmVkIG51bWJlciBvZiB7MH0nLCBzY2hlbWEubWluUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVudFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gc2VlbktleXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiBBcnJheS5pc0FycmF5KHByb3BlcnR5RGVwcykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVudFNjaGVtYXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5kZXBlbmRlbnRTY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHNlZW5LZXlzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlEZXBzID0gc2NoZW1hLmRlcGVuZGVudFNjaGVtYXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiBpc09iamVjdChwcm9wZXJ0eURlcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWxpZGF0ZVByb3BlcnR5RGVwZW5kZW5jaWVzKGtleSwgcHJvcGVydHlEZXBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gc2VlbktleXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBfdmFsaWRhdGVQcm9wZXJ0eURlcGVuZGVuY2llcyhrZXksIHNjaGVtYS5kZXBlbmRlbmNpZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBhc1NjaGVtYShzY2hlbWEucHJvcGVydHlOYW1lcyk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2Ygbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZi5rZXlOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoa2V5LCBwcm9wZXJ0eU5hbWVzLCB2YWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlEZXApKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZFByb3Agb2YgcHJvcGVydHlEZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuS2V5c1tyZXF1aXJlZFByb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdPYmplY3QgaXMgbWlzc2luZyBwcm9wZXJ0eSB7MH0gcmVxdWlyZWQgYnkgcHJvcGVydHkgezF9LicsIHJlcXVpcmVkUHJvcCwga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gYXNTY2hlbWEocHJvcGVydHlEZXApO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBwcm9wZXJ0eVNjaGVtYSwgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfcGFyc2UodGV4dERvY3VtZW50LCBjb25maWcpIHtcbiAgICBjb25zdCBwcm9ibGVtcyA9IFtdO1xuICAgIGxldCBsYXN0UHJvYmxlbU9mZnNldCA9IC0xO1xuICAgIGNvbnN0IHRleHQgPSB0ZXh0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIGNvbnN0IHNjYW5uZXIgPSBtYWluX2NyZWF0ZVNjYW5uZXIodGV4dCwgZmFsc2UpO1xuICAgIGNvbnN0IGNvbW1lbnRSYW5nZXMgPSBjb25maWcgJiYgY29uZmlnLmNvbGxlY3RDb21tZW50cyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGZ1bmN0aW9uIF9zY2FuTmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgICAgICBfY2hlY2tTY2FuRXJyb3IoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIEpzb24uU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIEpzb24uU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1lbnRSYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50UmFuZ2VzLnB1c2gobWFpbi5SYW5nZS5jcmVhdGUodGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTUgLyogSnNvbi5TeW50YXhLaW5kLlRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDE0IC8qIEpzb24uU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfYWNjZXB0KHRva2VuKSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IHRva2VuKSB7XG4gICAgICAgICAgICBfc2Nhbk5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vycm9yQXRSYW5nZShtZXNzYWdlLCBjb2RlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBzZXZlcml0eSA9IG1haW4uRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yKSB7XG4gICAgICAgIGlmIChwcm9ibGVtcy5sZW5ndGggPT09IDAgfHwgc3RhcnRPZmZzZXQgIT09IGxhc3RQcm9ibGVtT2Zmc2V0KSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHN0YXJ0T2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoZW5kT2Zmc2V0KSk7XG4gICAgICAgICAgICBwcm9ibGVtcy5wdXNoKG1haW4uRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCB0ZXh0RG9jdW1lbnQubGFuZ3VhZ2VJZCkpO1xuICAgICAgICAgICAgbGFzdFByb2JsZW1PZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZXJyb3IobWVzc2FnZSwgY29kZSwgbm9kZSA9IHVuZGVmaW5lZCwgc2tpcFVudGlsQWZ0ZXIgPSBbXSwgc2tpcFVudGlsID0gW10pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICBsZXQgZW5kID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCAmJiBzdGFydCA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIC9cXHMvLnRlc3QodGV4dC5jaGFyQXQoc3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgX2Vycm9yQXRSYW5nZShtZXNzYWdlLCBjb2RlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIF9maW5hbGl6ZShub2RlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmxlbmd0aCArIHNraXBVbnRpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLmdldFRva2VuKCk7XG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gIT09IDE3IC8qIEpzb24uU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIuaW5kZXhPZih0b2tlbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2tpcFVudGlsLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBfc2Nhbk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NoZWNrU2NhbkVycm9yKCkge1xuICAgICAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpKSB7XG4gICAgICAgICAgICBjYXNlIDQgLyogSnNvbi5TY2FuRXJyb3IuSW52YWxpZFVuaWNvZGUgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ0ludmFsaWQgdW5pY29kZSBzZXF1ZW5jZSBpbiBzdHJpbmcuJyksIEVycm9yQ29kZS5JbnZhbGlkVW5pY29kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDUgLyogSnNvbi5TY2FuRXJyb3IuSW52YWxpZEVzY2FwZUNoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnSW52YWxpZCBlc2NhcGUgY2hhcmFjdGVyIGluIHN0cmluZy4nKSwgRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAzIC8qIEpzb24uU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnVW5leHBlY3RlZCBlbmQgb2YgbnVtYmVyLicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBKc29uLlNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdVbmV4cGVjdGVkIGVuZCBvZiBjb21tZW50LicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDIgLyogSnNvbi5TY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdVbmV4cGVjdGVkIGVuZCBvZiBzdHJpbmcuJyksIEVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSA2IC8qIEpzb24uU2NhbkVycm9yLkludmFsaWRDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ0ludmFsaWQgY2hhcmFjdGVycyBpbiBzdHJpbmcuIENvbnRyb2wgY2hhcmFjdGVycyBtdXN0IGJlIGVzY2FwZWQuJyksIEVycm9yQ29kZS5JbnZhbGlkQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9maW5hbGl6ZShub2RlLCBzY2FuTmV4dCkge1xuICAgICAgICBub2RlLmxlbmd0aCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSAtIG5vZGUub2Zmc2V0O1xuICAgICAgICBpZiAoc2Nhbk5leHQpIHtcbiAgICAgICAgICAgIF9zY2FuTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VBcnJheShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMyAvKiBKc29uLlN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gbmV3IEFycmF5QVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBPcGVuQnJhY2tldFRva2VuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8gJiYgc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvcih0KCdWYWx1ZSBleHBlY3RlZCcpLCBFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNvbW1hXG4gICAgICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNCAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UodCgnVHJhaWxpbmcgY29tbWEnKSwgRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEsIGNvbW1hT2Zmc2V0LCBjb21tYU9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnRXhwZWN0ZWQgY29tbWEnKSwgRXJyb3JDb2RlLkNvbW1hRXhwZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IF9wYXJzZVZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ1ZhbHVlIGV4cGVjdGVkJyksIEVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkLCB1bmRlZmluZWQsIFtdLCBbNCAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8sIDUgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDQgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICByZXR1cm4gX2Vycm9yKHQoJ0V4cGVjdGVkIGNvbW1hIG9yIGNsb3NpbmcgYnJhY2tldCcpLCBFcnJvckNvZGUuQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGtleVBsYWNlaG9sZGVyID0gbmV3IFN0cmluZ0FTVE5vZGVJbXBsKHVuZGVmaW5lZCwgMCwgMCk7XG4gICAgZnVuY3Rpb24gX3BhcnNlUHJvcGVydHkocGFyZW50LCBrZXlzU2Vlbikge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFByb3BlcnR5QVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIGtleVBsYWNlaG9sZGVyKTtcbiAgICAgICAgbGV0IGtleSA9IF9wYXJzZVN0cmluZyhub2RlKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDE2IC8qIEpzb24uU3ludGF4S2luZC5Vbmtub3duICovKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2l2ZSBhIG1vcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ1Byb3BlcnR5IGtleXMgbXVzdCBiZSBkb3VibGVxdW90ZWQnKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5Tm9kZSA9IG5ldyBTdHJpbmdBU1ROb2RlSW1wbChub2RlLCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAga2V5Tm9kZS52YWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGtleSA9IGtleU5vZGU7XG4gICAgICAgICAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgVW5rbm93blxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLmtleU5vZGUgPSBrZXk7XG4gICAgICAgIC8vIEZvciBKU09OIGZpbGVzIHRoYXQgZm9yYmlkIGNvZGUgY29tbWVudHMsIHRoZXJlIGlzIGEgY29udmVudGlvbiB0byB1c2UgdGhlIGtleSBuYW1lIFwiLy9cIiB0byBhZGQgY29tbWVudHMuXG4gICAgICAgIC8vIE11bHRpcGxlIGluc3RhbmNlcyBvZiBcIi8vXCIgYXJlIG9rYXkuXG4gICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiLy9cIikge1xuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IGtleXNTZWVuW2tleS52YWx1ZV07XG4gICAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UodChcIkR1cGxpY2F0ZSBvYmplY3Qga2V5XCIpLCBFcnJvckNvZGUuRHVwbGljYXRlS2V5LCBub2RlLmtleU5vZGUub2Zmc2V0LCBub2RlLmtleU5vZGUub2Zmc2V0ICsgbm9kZS5rZXlOb2RlLmxlbmd0aCwgbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UodChcIkR1cGxpY2F0ZSBvYmplY3Qga2V5XCIpLCBFcnJvckNvZGUuRHVwbGljYXRlS2V5LCBzZWVuLmtleU5vZGUub2Zmc2V0LCBzZWVuLmtleU5vZGUub2Zmc2V0ICsgc2Vlbi5rZXlOb2RlLmxlbmd0aCwgbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleXNTZWVuW2tleS52YWx1ZV0gPSB0cnVlOyAvLyBpZiB0aGUgc2FtZSBrZXkgaXMgZHVwbGljYXRlIGFnYWluLCBhdm9pZCBkdXBsaWNhdGUgZXJyb3IgcmVwb3J0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzU2VlbltrZXkudmFsdWVdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA2IC8qIEpzb24uU3ludGF4S2luZC5Db2xvblRva2VuICovKSB7XG4gICAgICAgICAgICBub2RlLmNvbG9uT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgQ29sb25Ub2tlblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2Vycm9yKHQoJ0NvbG9uIGV4cGVjdGVkJyksIEVycm9yQ29kZS5Db2xvbkV4cGVjdGVkKTtcbiAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDEwIC8qIEpzb24uU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovICYmIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGtleS5vZmZzZXQgKyBrZXkubGVuZ3RoKS5saW5lIDwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sZW5ndGggPSBrZXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gX3BhcnNlVmFsdWUobm9kZSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXJyb3IodCgnVmFsdWUgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIG5vZGUsIFtdLCBbMiAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS52YWx1ZU5vZGUgPSB2YWx1ZTtcbiAgICAgICAgbm9kZS5sZW5ndGggPSB2YWx1ZS5vZmZzZXQgKyB2YWx1ZS5sZW5ndGggLSBub2RlLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZU9iamVjdChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMSAvKiBKc29uLlN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBPYmplY3RBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XG4gICAgICAgIGNvbnN0IGtleXNTZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgT3BlbkJyYWNlVG9rZW5cbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMiAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogSnNvbi5TeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBKc29uLlN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGlmICghbmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBfZXJyb3IodCgnUHJvcGVydHkgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDIgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yQXRSYW5nZSh0KCdUcmFpbGluZyBjb21tYScpLCBFcnJvckNvZGUuVHJhaWxpbmdDb21tYSwgY29tbWFPZmZzZXQsIGNvbW1hT2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdFeHBlY3RlZCBjb21tYScpLCBFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IF9wYXJzZVByb3BlcnR5KG5vZGUsIGtleXNTZWVuKTtcbiAgICAgICAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnUHJvcGVydHkgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQsIHVuZGVmaW5lZCwgW10sIFsyIC8qIEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDIgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcih0KCdFeHBlY3RlZCBjb21tYSBvciBjbG9zaW5nIGJyYWNlJyksIEVycm9yQ29kZS5Db21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VTdHJpbmcocGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDEwIC8qIEpzb24uU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU3RyaW5nQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBub2RlLnZhbHVlID0gc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZU51bWJlcihwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTEgLyogSnNvbi5TeW50YXhLaW5kLk51bWVyaWNMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTnVtYmVyQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkgPT09IDAgLyogSnNvbi5TY2FuRXJyb3IuTm9uZSAqLykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5WYWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9IEpTT04ucGFyc2UodG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihudW1iZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lcnJvcih0KCdJbnZhbGlkIG51bWJlciBmb3JtYXQuJyksIEVycm9yQ29kZS5VbmRlZmluZWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVtYmVyVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXJyb3IodCgnSW52YWxpZCBudW1iZXIgZm9ybWF0LicpLCBFcnJvckNvZGUuVW5kZWZpbmVkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaXNJbnRlZ2VyID0gdG9rZW5WYWx1ZS5pbmRleE9mKCcuJykgPT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZUxpdGVyYWwocGFyZW50KSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW4oKSkge1xuICAgICAgICAgICAgY2FzZSA3IC8qIEpzb24uU3ludGF4S2luZC5OdWxsS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBOdWxsQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgOCAvKiBKc29uLlN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShuZXcgQm9vbGVhbkFTVE5vZGVJbXBsKHBhcmVudCwgdHJ1ZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIDkgLyogSnNvbi5TeW50YXhLaW5kLkZhbHNlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBCb29sZWFuQVNUTm9kZUltcGwocGFyZW50LCBmYWxzZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VBcnJheShwYXJlbnQpIHx8IF9wYXJzZU9iamVjdChwYXJlbnQpIHx8IF9wYXJzZVN0cmluZyhwYXJlbnQpIHx8IF9wYXJzZU51bWJlcihwYXJlbnQpIHx8IF9wYXJzZUxpdGVyYWwocGFyZW50KTtcbiAgICB9XG4gICAgbGV0IF9yb290ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRva2VuID0gX3NjYW5OZXh0KCk7XG4gICAgaWYgKHRva2VuICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIF9yb290ID0gX3BhcnNlVmFsdWUoX3Jvb3QpO1xuICAgICAgICBpZiAoIV9yb290KSB7XG4gICAgICAgICAgICBfZXJyb3IodCgnRXhwZWN0ZWQgYSBKU09OIG9iamVjdCwgYXJyYXkgb3IgbGl0ZXJhbC4nKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBfZXJyb3IodCgnRW5kIG9mIGZpbGUgZXhwZWN0ZWQuJyksIEVycm9yQ29kZS5VbmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSlNPTkRvY3VtZW50KF9yb290LCBwcm9ibGVtcywgY29tbWVudFJhbmdlcyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvanNvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3Qob2JqLCBpbmRlbnQsIHN0cmluZ2lmeUxpdGVyYWwpIHtcbiAgICBpZiAob2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGVudCA9IGluZGVudCArICdcXHQnO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICdbXFxuJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5ld0luZGVudCArIHN0cmluZ2lmeU9iamVjdChvYmpbaV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBvYmoubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5kZW50ICsgJ10nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJ3tcXG4nO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbmV3SW5kZW50ICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6ICcgKyBzdHJpbmdpZnlPYmplY3Qob2JqW2tleV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IGluZGVudCArICd9JztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeUxpdGVyYWwob2JqKTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uQ29tcGxldGlvbi5qc1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcxNik7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cblxuXG5cblxuY29uc3QgdmFsdWVDb21taXRDaGFyYWN0ZXJzID0gWycsJywgJ30nLCAnXSddO1xuY29uc3QgcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzID0gWyc6J107XG5jbGFzcyBKU09OQ29tcGxldGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hU2VydmljZSwgY29udHJpYnV0aW9ucyA9IFtdLCBwcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlLCBjbGllbnRDYXBhYmlsaXRpZXMgPSB7fSkge1xuICAgICAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMgPSBjb250cmlidXRpb25zO1xuICAgICAgICB0aGlzLnByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMgPSBjbGllbnRDYXBhYmlsaXRpZXM7XG4gICAgfVxuICAgIGRvUmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVDb21wbGV0aW9uID0gdGhpcy5jb250cmlidXRpb25zW2ldLnJlc29sdmVDb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSByZXNvbHZlQ29tcGxldGlvbihpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlQ29uc3RydWN0b3IucmVzb2x2ZShpdGVtKTtcbiAgICB9XG4gICAgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICBpc0luY29tcGxldGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbkNvbW1lbnQoZG9jdW1lbnQsIG5vZGUgPyBub2RlLm9mZnNldCA6IDAsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAmJiAob2Zmc2V0ID09PSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHRleHRbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0JyAmJiBjaCA9PT0gJ30nIHx8IG5vZGUudHlwZSA9PT0gJ2FycmF5JyAmJiBjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgXSBvciB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXb3JkID0gdGhpcy5nZXRDdXJyZW50V29yZChkb2N1bWVudCwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IG92ZXJ3cml0ZVJhbmdlO1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb3ZlcndyaXRlUmFuZ2UgPSBtYWluLlJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0KSwgZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgb3ZlcndyaXRlU3RhcnQgPSBvZmZzZXQgLSBjdXJyZW50V29yZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlU3RhcnQgPiAwICYmIHRleHRbb3ZlcndyaXRlU3RhcnQgLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIG92ZXJ3cml0ZVN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVyd3JpdGVSYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQob3ZlcndyaXRlU3RhcnQpLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzID0gZmFsc2U7IC8vdGhpcy5kb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKCk7IGRpc2FibGVkIGZvciBub3csIHdhaXRpbmcgZm9yIG5ldyBBUEk6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvdnNjb2RlL2lzc3Vlcy80MjU0NFxuICAgICAgICBjb25zdCBwcm9wb3NlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY29sbGVjdG9yID0ge1xuICAgICAgICAgICAgYWRkOiAoc3VnZ2VzdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IHN1Z2dlc3Rpb24ubGFiZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBwcm9wb3NlZC5nZXQobGFiZWwpO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC5yZXBsYWNlKC9bXFxuXS9nLCAn4oa1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbC5sZW5ndGggPiA2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvcnRlbmRlZExhYmVsID0gbGFiZWwuc3Vic3RyKDAsIDU3KS50cmltKCkgKyAnLi4uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcG9zZWQuaGFzKHNob3J0ZW5kZWRMYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHNob3J0ZW5kZWRMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLnRleHRFZGl0ID0gbWFpbi5UZXh0RWRpdC5yZXBsYWNlKG92ZXJ3cml0ZVJhbmdlLCBzdWdnZXN0aW9uLmluc2VydFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLmNvbW1pdENoYXJhY3RlcnMgPSBzdWdnZXN0aW9uLmtpbmQgPT09IG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID8gcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzIDogdmFsdWVDb21taXRDaGFyYWN0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24ubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWQuc2V0KGxhYmVsLCBzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lml0ZW1zLnB1c2goc3VnZ2VzdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRvY3VtZW50YXRpb24gPSBzdWdnZXN0aW9uLmRvY3VtZW50YXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZy5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRldGFpbCA9IHN1Z2dlc3Rpb24uZGV0YWlsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcubGFiZWxEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sYWJlbERldGFpbHMgPSBzdWdnZXN0aW9uLmxhYmVsRGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRBc0luY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaXNJbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE51bWJlck9mUHJvcG9zYWxzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblByb21pc2VzID0gW107XG4gICAgICAgICAgICBsZXQgYWRkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRLZXkgPSAnJztcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZSA9ICFwYXJlbnQudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEtleSA9IHRleHQuc3Vic3RyKG5vZGUub2Zmc2V0ICsgMSwgbm9kZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3Bvc2FscyBmb3IgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3Qga2V5cyB3aGVuIHRoZSBjdXJzb3IgaXMganVzdCBiZWZvcmUgdGhlIG9wZW5pbmcgY3VybHkgYnJhY2VcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdWdnZXN0IHByb3BlcnRpZXMgdGhhdCBhcmUgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb3BlcnR5IHx8IGN1cnJlbnRQcm9wZXJ0eSAhPT0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWQuc2V0KHAua2V5Tm9kZS52YWx1ZSwgbWFpbi5Db21wbGV0aW9uSXRlbS5jcmVhdGUoJ19fJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlcGFyYXRvckFmdGVyID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGFkZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvckFmdGVyID0gdGhpcy5ldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBkb2N1bWVudC5vZmZzZXRBdChvdmVyd3JpdGVSYW5nZS5lbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBwcm9wb3NhbHMgd2l0aCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eUNvbXBsZXRpb25zKHNjaGVtYSwgZG9jLCBub2RlLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBwcm9wb3NhbHMgd2l0aG91dCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyhkb2MsIG5vZGUsIGN1cnJlbnRLZXksIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ganNvblBhcnNlcl9nZXROb2RlUGF0aChub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMuZm9yRWFjaCgoY29udHJpYnV0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RQcm9taXNlID0gY29udHJpYnV0aW9uLmNvbGxlY3RQcm9wZXJ0eUNvbXBsZXRpb25zKGRvY3VtZW50LnVyaSwgbG9jYXRpb24sIGN1cnJlbnRXb3JkLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIgPT09ICcnLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Qcm9taXNlcy5wdXNoKGNvbGxlY3RQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICgoIXNjaGVtYSAmJiBjdXJyZW50V29yZC5sZW5ndGggPiAwICYmIHRleHQuY2hhckF0KG9mZnNldCAtIGN1cnJlbnRXb3JkLmxlbmd0aCAtIDEpICE9PSAnXCInKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShjdXJyZW50V29yZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShjdXJyZW50V29yZCwgdW5kZWZpbmVkLCBmYWxzZSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLnNldEFzSW5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3Bvc2FscyBmb3IgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHByb3Bvc2FscyB3aXRoIHNjaGVtYVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBwcm9wb3NhbHMgd2l0aG91dCBzY2hlbWFcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29udHJpYnV0ZWRWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCBjb2xsZWN0aW9uUHJvbWlzZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yLmFsbChjb2xsZWN0aW9uUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0b3IuZ2V0TnVtYmVyT2ZQcm9wb3NhbHMoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgb2Zmc2V0Rm9yU2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxsZXJWYWx1ZUNvbXBsZXRpb25zKHR5cGVzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UHJvcGVydHlDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XG4gICAgICAgIG1hdGNoaW5nU2NoZW1hcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUHJvcGVydGllcyA9IHMuc2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hUHJvcGVydGllcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYVByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlTY2hlbWEgPT09ICdvYmplY3QnICYmICFwcm9wZXJ0eVNjaGVtYS5kZXByZWNhdGlvbk1lc3NhZ2UgJiYgIXByb3BlcnR5U2NoZW1hLmRvTm90U3VnZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3Bvc2FsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkoa2V5LCBwcm9wZXJ0eVNjaGVtYSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IHRoaXMuZ2V0RmlsdGVyVGV4dEZvclZhbHVlKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHRoaXMuZnJvbU1hcmt1cChwcm9wZXJ0eVNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBwcm9wZXJ0eVNjaGVtYS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5zdWdnZXN0U29ydFRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5zb3J0VGV4dCA9IHByb3BlcnR5U2NoZW1hLnN1Z2dlc3RTb3J0VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3Bvc2FsLmluc2VydFRleHQgJiYgZW5kc1dpdGgocHJvcG9zYWwuaW5zZXJ0VGV4dCwgYCQxJHtzZXBhcmF0b3JBZnRlcn1gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5jb21tYW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTdWdnZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdlZGl0b3IuYWN0aW9uLnRyaWdnZXJTdWdnZXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHByb3Bvc2FsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYVByb3BlcnR5TmFtZXMgPSBzLnNjaGVtYS5wcm9wZXJ0eU5hbWVzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hUHJvcGVydHlOYW1lcyA9PT0gJ29iamVjdCcgJiYgIXNjaGVtYVByb3BlcnR5TmFtZXMuZGVwcmVjYXRpb25NZXNzYWdlICYmICFzY2hlbWFQcm9wZXJ0eU5hbWVzLmRvTm90U3VnZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbSA9IChuYW1lLCBlbnVtRGVzY3JpcHRpb24gPSB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3Bvc2FsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KG5hbWUsIHVuZGVmaW5lZCwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiBlbnVtRGVzY3JpcHRpb24gfHwgdGhpcy5mcm9tTWFya3VwKHNjaGVtYVByb3BlcnR5TmFtZXMubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hUHJvcGVydHlOYW1lcy5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5zdWdnZXN0U29ydFRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsLnNvcnRUZXh0ID0gc2NoZW1hUHJvcGVydHlOYW1lcy5zdWdnZXN0U29ydFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcG9zYWwuaW5zZXJ0VGV4dCAmJiBlbmRzV2l0aChwcm9wb3NhbC5pbnNlcnRUZXh0LCBgJDEke3NlcGFyYXRvckFmdGVyfWApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwuY29tbWFuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTdWdnZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ2VkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQocHJvcG9zYWwpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbnVtRGVzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXMubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bURlc2NyaXB0aW9uID0gdGhpcy5mcm9tTWFya3VwKHNjaGVtYVByb3BlcnR5TmFtZXMubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzLmVudW1EZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1EZXNjcmlwdGlvbiA9IHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bURlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0oc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtW2ldLCBlbnVtRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0eU5hbWVzLmNvbnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbShzY2hlbWFQcm9wZXJ0eU5hbWVzLmNvbnN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNjaGVtYUxlc3NQcm9wZXJ0eUNvbXBsZXRpb25zKGRvYywgbm9kZSwgY3VycmVudEtleSwgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RDb21wbGV0aW9uc0ZvclNpbWlsYXJPYmplY3QgPSAob2JqKSA9PiB7XG4gICAgICAgICAgICBvYmoucHJvcGVydGllcy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcC5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoa2V5LCAnJyksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgcHJvcGVydHkgdmFsdWUsIGNoZWNrIHRoZSB0cmVlIGZvciBvdGhlciBvYmplY3RzIHRoYXQgaGFuZyB1bmRlciBhIHByb3BlcnR5IG9mIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBub2RlLnBhcmVudC5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvYy52aXNpdChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuICE9PSBub2RlLnBhcmVudCAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSAmJiBuLnZhbHVlTm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdChuLnZhbHVlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBpbiBhbiBhcnJheSwgdXNlIGFsbCBvdGhlciBhcnJheSBlbGVtZW50cyBhcyBzaW1pbGFyIG9iamVjdHNcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5pdGVtcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09PSAnb2JqZWN0JyAmJiBuICE9PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0Q29tcGxldGlvbnNGb3JTaW1pbGFyT2JqZWN0KG4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICckc2NoZW1hJyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eSgnJHNjaGVtYScsIHVuZGVmaW5lZCwgdHJ1ZSwgJycpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LCBkb2N1bWVudGF0aW9uOiAnJyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShcIiRzY2hlbWFcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKSB7XG4gICAgICAgIGxldCBvZmZzZXRGb3JTZXBhcmF0b3IgPSBvZmZzZXQ7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpKSB7XG4gICAgICAgICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnb2JqZWN0JyksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFbXB0eSBvYmplY3QnLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHt9LCAnJyksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnYXJyYXknKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0VtcHR5IGFycmF5JyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShbXSwgJycpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgb2Zmc2V0Rm9yU2VwYXJhdG9yKTtcbiAgICAgICAgY29uc3QgY29sbGVjdFN1Z2dlc3Rpb25zRm9yVmFsdWVzID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUucGFyZW50ICYmICFqc29uUGFyc2VyX2NvbnRhaW5zKHZhbHVlLnBhcmVudCwgb2Zmc2V0LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHZhbHVlLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbFRleHRGb3JNYXRjaGluZ05vZGUodmFsdWUsIGRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yTWF0Y2hpbmdOb2RlKHZhbHVlLCBkb2N1bWVudCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCwgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24oIXZhbHVlLnZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IChub2RlLmNvbG9uT2Zmc2V0IHx8IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSAmJiAob2Zmc2V0ID4gKHZhbHVlTm9kZS5vZmZzZXQgKyB2YWx1ZU5vZGUubGVuZ3RoKSB8fCB2YWx1ZU5vZGUudHlwZSA9PT0gJ29iamVjdCcgfHwgdmFsdWVOb2RlLnR5cGUgPT09ICdhcnJheScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdCB2YWx1ZXMgYXQgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvYy52aXNpdChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdFN1Z2dlc3Rpb25zRm9yVmFsdWVzKG4udmFsdWVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50S2V5ID09PSAnJHNjaGVtYScgJiYgbm9kZS5wYXJlbnQgJiYgIW5vZGUucGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3QgaXRlbXMgb2YgYW4gYXJyYXkgYXQgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5wYXJlbnQua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb2MudmlzaXQoKG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleSAmJiBuLnZhbHVlTm9kZSAmJiBuLnZhbHVlTm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnZhbHVlTm9kZS5pdGVtcy5mb3JFYWNoKGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0IGl0ZW1zIGluIHRoZSBzYW1lIGFycmF5XG4gICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCB0eXBlcykge1xuICAgICAgICBsZXQgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xuICAgICAgICBsZXQgcGFyZW50S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWVOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLnNjaGVtYSwgJycsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobm9kZS50eXBlID09PSAncHJvcGVydHknKSAmJiBvZmZzZXQgPiAobm9kZS5jb2xvbk9mZnNldCB8fCAwKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICBpZiAodmFsdWVOb2RlICYmIG9mZnNldCA+ICh2YWx1ZU5vZGUub2Zmc2V0ICsgdmFsdWVOb2RlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGFyZSBwYXN0IHRoZSB2YWx1ZSBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRLZXkgPSBub2RlLmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgJiYgKHBhcmVudEtleSAhPT0gdW5kZWZpbmVkIHx8IG5vZGUudHlwZSA9PT0gJ2FycmF5JykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckFmdGVyID0gdGhpcy5ldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBvZmZzZXRGb3JTZXBhcmF0b3IpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCwgdmFsdWVOb2RlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBtYXRjaGluZ1NjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkICYmIHMuc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhcnJheScgJiYgcy5zY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjID0gY29sbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnVuaXF1ZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlICE9PSAnYXJyYXknICYmIG4udHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWVzLmFkZCh0aGlzLmdldExhYmVsRm9yVmFsdWUoanNvblBhcnNlcl9nZXROb2RlVmFsdWUobikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbGxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHN1Z2dlc3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdWYWx1ZXMuaGFzKHN1Z2dlc3Rpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZChzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzLnNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEl0ZW1BdE9mZnNldChub2RlLCBkb2N1bWVudCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBzLnNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMuc2NoZW1hLml0ZW1zW2luZGV4XSwgc2VwYXJhdG9yQWZ0ZXIsIGMsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocy5zY2hlbWEuaXRlbXMsIHNlcGFyYXRvckFmdGVyLCBjLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gcy5zY2hlbWEucHJvcGVydGllc1twYXJlbnRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocHJvcGVydHlTY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMgJiYgIXByb3BlcnR5TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBPYmplY3Qua2V5cyhzLnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4Py50ZXN0KHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgIXByb3BlcnR5TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gcy5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50S2V5ID09PSAnJHNjaGVtYScgJiYgIW5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyhzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlc1snYm9vbGVhbiddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uKHRydWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbihmYWxzZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZXNbJ251bGwnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTnVsbFZhbHVlQ29tcGxldGlvbihzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb250cmlidXRlZFZhbHVlQ29tcGxldGlvbnMoZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IsIGNvbGxlY3Rpb25Qcm9taXNlcykge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9ucy5mb3JFYWNoKChjb250cmlidXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0UHJvbWlzZSA9IGNvbnRyaWJ1dGlvbi5jb2xsZWN0RGVmYXVsdENvbXBsZXRpb25zKGRvY3VtZW50LnVyaSwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3N0cmluZycgfHwgbm9kZS50eXBlID09PSAnbnVtYmVyJyB8fCBub2RlLnR5cGUgPT09ICdib29sZWFuJyB8fCBub2RlLnR5cGUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdwcm9wZXJ0eScpICYmIG9mZnNldCA+IChub2RlLmNvbG9uT2Zmc2V0IHx8IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGUudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgIGlmICgoIXZhbHVlTm9kZSB8fCBvZmZzZXQgPD0gKHZhbHVlTm9kZS5vZmZzZXQgKyB2YWx1ZU5vZGUubGVuZ3RoKSkgJiYgbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBqc29uUGFyc2VyX2dldE5vZGVQYXRoKG5vZGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cmlidXRpb25zLmZvckVhY2goKGNvbnRyaWJ1dGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdFByb21pc2UgPSBjb250cmlidXRpb24uY29sbGVjdFZhbHVlQ29tcGxldGlvbnMoZG9jdW1lbnQudXJpLCBsb2NhdGlvbiwgcGFyZW50S2V5LCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5hZGRFbnVtVmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5hZGREZWZhdWx0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0VHlwZXMoc2NoZW1hLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLmFsbE9mLmZvckVhY2gocyA9PiB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuYW55T2YuZm9yRWFjaChzID0+IHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYS5vbmVPZi5mb3JFYWNoKHMgPT4gdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCBhcnJheURlcHRoID0gMCkge1xuICAgICAgICBsZXQgaGFzUHJvcG9zYWxzID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NoZW1hLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gc2NoZW1hLmRlZmF1bHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25JdGVtID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvZXNTdXBwb3J0c0xhYmVsRGV0YWlscygpKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW0ubGFiZWxEZXRhaWxzID0geyBkZXNjcmlwdGlvbjogdCgnRGVmYXVsdCB2YWx1ZScpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uSXRlbS5kZXRhaWwgPSB0KCdEZWZhdWx0IHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKGNvbXBsZXRpb25JdGVtKTtcbiAgICAgICAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmV4YW1wbGVzKSkge1xuICAgICAgICAgICAgc2NoZW1hLmV4YW1wbGVzLmZvckVhY2goZXhhbXBsZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBleGFtcGxlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdhcnJheSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoYXNQcm9wb3NhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmRlZmF1bHRTbmlwcGV0cykpIHtcbiAgICAgICAgICAgIHNjaGVtYS5kZWZhdWx0U25pcHBldHMuZm9yRWFjaChzID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHMuYm9keTtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBzLmxhYmVsO1xuICAgICAgICAgICAgICAgIGxldCBpbnNlcnRUZXh0O1xuICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJUZXh0O1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0ID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQgPSB0aGlzLmdldEZpbHRlclRleHRGb3JTbmlwcGV0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsIHx8IHRoaXMuZ2V0TGFiZWxGb3JTbmlwcGV0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcy5ib2R5VGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeCA9ICcnLCBzdWZmaXggPSAnJywgaW5kZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXggKyBpbmRlbnQgKyAnW1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBzdWZmaXggKyAnXFxuJyArIGluZGVudCArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQgPSBwcmVmaXggKyBpbmRlbnQgKyBzLmJvZHlUZXh0LnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgaW5kZW50KSArIHN1ZmZpeCArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsIHx8IGluc2VydFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0ID0gaW5zZXJ0VGV4dC5yZXBsYWNlKC9bXFxuXS9nLCAnJyk7IC8vIHJlbW92ZSBuZXcgbGluZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiB0aGlzLmZyb21NYXJrdXAocy5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc1Byb3Bvc2FscyAmJiB0eXBlb2Ygc2NoZW1hLml0ZW1zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpICYmIGFycmF5RGVwdGggPCA1IC8qIGJld2FyZSBvZiByZWN1cnNpb24gKi8pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLml0ZW1zLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCBhcnJheURlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRW51bVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChzY2hlbWEudHlwZSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWEuY29uc3QpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHNjaGVtYS5jb25zdCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzY2hlbWEuZW51bS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVubSA9IHNjaGVtYS5lbnVtW2ldO1xuICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudGF0aW9uID0gdGhpcy5mcm9tTWFya3VwKHNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBzY2hlbWEuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMgJiYgaSA8IHNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMubGVuZ3RoICYmIHRoaXMuZG9lc1N1cHBvcnRNYXJrZG93bigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb24gPSB0aGlzLmZyb21NYXJrdXAoc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYS5lbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWEuZW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbiA9IHNjaGVtYS5lbnVtRGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChzY2hlbWEudHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsRm9yVmFsdWUoZW5tKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoZW5tLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGVjdFR5cGVzKHNjaGVtYSwgdHlwZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pIHx8IGlzRGVmaW5lZChzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgdHlwZS5mb3JFYWNoKHQgPT4gdHlwZXNbdF0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmlsbGVyVmFsdWVDb21wbGV0aW9ucyh0eXBlcywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICBpZiAodHlwZXNbJ29iamVjdCddKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdvYmplY3QnKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ3t9JyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUoe30sIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluLkluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHQoJ05ldyBvYmplY3QnKSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzWydhcnJheSddKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdhcnJheScpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnW10nLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShbXSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRldGFpbDogdCgnTmV3IGFycmF5JyksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24odmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdib29sZWFuJyksXG4gICAgICAgICAgICBsYWJlbDogdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZE51bGxWYWx1ZUNvbXBsZXRpb24oc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoJ251bGwnKSxcbiAgICAgICAgICAgIGxhYmVsOiAnbnVsbCcsXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiAnbnVsbCcgKyBzZXBhcmF0b3JBZnRlcixcbiAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW4uSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hSWRzID0gdGhpcy5zY2hlbWFTZXJ2aWNlLmdldFJlZ2lzdGVyZWRTY2hlbWFJZHMoc2NoZW1hID0+IHNjaGVtYSA9PT0gJ2h0dHAnIHx8IHNjaGVtYSA9PT0gJ2h0dHBzJyk7XG4gICAgICAgIHNjaGVtYUlkcy5mb3JFYWNoKHNjaGVtYUlkID0+IGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAga2luZDogbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWFJZCksXG4gICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShzY2hlbWFJZCksXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShzY2hlbWFJZCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbi5JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBnZXRWYWx1ZUZyb21MYWJlbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldEZpbHRlclRleHRGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXFwkXFx7XFxkKzooW159XSspXFx9fFxcJFxcZCsvZywgJyQxJyk7XG4gICAgfVxuICAgIGdldExhYmVsRm9yU25pcHBldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICByZXR1cm4gbGFiZWwucmVwbGFjZSgvXFwkXFx7XFxkKzooW159XSspXFx9fFxcJFxcZCsvZywgJyQxJyk7XG4gICAgfVxuICAgIGdldEluc2VydFRleHRGb3JQbGFpblRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXFxcXFxcJFxcfV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgJCwgXFwgYW5kIH1cbiAgICB9XG4gICAgZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsICdcXHQnKTtcbiAgICAgICAgaWYgKHRleHQgPT09ICd7fScpIHtcbiAgICAgICAgICAgIHJldHVybiAneyQxfScgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09PSAnW10nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1skMV0nICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dCh0ZXh0ICsgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgIH1cbiAgICBnZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xuICAgICAgICBjb25zdCByZXBsYWNlciA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUsICcnLCByZXBsYWNlcikgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICB9XG4gICAgZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJHsxOm51bGx9JyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgbGV0IHNuaXBwZXRWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBzbmlwcGV0VmFsdWUgPSBzbmlwcGV0VmFsdWUuc3Vic3RyKDEsIHNuaXBwZXRWYWx1ZS5sZW5ndGggLSAyKTsgLy8gcmVtb3ZlIHF1b3Rlc1xuICAgICAgICAgICAgICAgIHNuaXBwZXRWYWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dChzbmlwcGV0VmFsdWUpOyAvLyBlc2NhcGUgXFwgYW5kIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJHsxOicgKyBzbmlwcGV0VmFsdWUgKyAnfVwiJyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJHsxOicgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnfScgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKTtcbiAgICB9XG4gICAgZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSB0eXBlO1xuICAgICAgICAgICAgdHlwZSA9IGFycmF5Lmxlbmd0aCA+IDAgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMYWJlbFRleHRGb3JNYXRjaGluZ05vZGUobm9kZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tdJztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5nZXRUZXh0KCkuc3Vic3RyKG5vZGUub2Zmc2V0LCBub2RlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SW5zZXJ0VGV4dEZvck1hdGNoaW5nTm9kZShub2RlLCBkb2N1bWVudCwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoW10sIHNlcGFyYXRvckFmdGVyKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHt9LCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5nZXRUZXh0KCkuc3Vic3RyKG5vZGUub2Zmc2V0LCBub2RlLmxlbmd0aCkgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUGxhaW5UZXh0KGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEluc2VydFRleHRGb3JQcm9wZXJ0eShrZXksIHByb3BlcnR5U2NoZW1hLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlUZXh0ID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoa2V5LCAnJyk7XG4gICAgICAgIGlmICghYWRkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eVRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0VGV4dCA9IHByb3BlcnR5VGV4dCArICc6ICc7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgbGV0IG5WYWx1ZVByb3Bvc2FscyA9IDA7XG4gICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHNbMF0uYm9keTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChib2R5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUoYm9keSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlICYmIHByb3BlcnR5U2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmVudW1bMF0sICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgblZhbHVlUHJvcG9zYWxzICs9IHByb3BlcnR5U2NoZW1hLmVudW0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0eVNjaGVtYS5jb25zdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmNvbnN0LCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUocHJvcGVydHlTY2hlbWEuZGVmYXVsdCwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5U2NoZW1hLmV4YW1wbGVzKSAmJiBwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmV4YW1wbGVzWzBdLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoblZhbHVlUHJvcG9zYWxzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBBcnJheS5pc0FycmF5KHByb3BlcnR5U2NoZW1hLnR5cGUpID8gcHJvcGVydHlTY2hlbWEudHlwZVswXSA6IHByb3BlcnR5U2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHlTY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyQxJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnXCIkMVwiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAneyQxfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnWyQxXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICckezE6MH0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJHsxOm51bGx9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBuVmFsdWVQcm9wb3NhbHMgPiAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICckMSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFRleHQgKyB2YWx1ZSArIHNlcGFyYXRvckFmdGVyO1xuICAgIH1cbiAgICBnZXRDdXJyZW50V29yZChkb2N1bWVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBpID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAnIFxcdFxcblxcclxcdlwiOntbLF19Jy5pbmRleE9mKHRleHQuY2hhckF0KGkpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoaSArIDEsIG9mZnNldCk7XG4gICAgfVxuICAgIGV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBzY2FubmVyID0gbWFpbl9jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgdHJ1ZSk7XG4gICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24ob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovOlxuICAgICAgICAgICAgY2FzZSAyIC8qIEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovOlxuICAgICAgICAgICAgY2FzZSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcsJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSXRlbUF0T2Zmc2V0KG5vZGUsIGRvY3VtZW50LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc2Nhbm5lciA9IG1haW5fY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIHRydWUpO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjaGlsZC5vZmZzZXQgKyBjaGlsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKGNoaWxkLm9mZnNldCArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IDUgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi8gJiYgb2Zmc2V0ID49IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID49IGNoaWxkLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpc0luQ29tbWVudChkb2N1bWVudCwgc3RhcnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBzY2FubmVyID0gbWFpbl9jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgZmFsc2UpO1xuICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICAgICAgbGV0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAhPT0gMTcgLyogSnNvbi5TeW50YXhLaW5kLkVPRiAqLyAmJiAoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpIDwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRva2VuID09PSAxMiAvKiBKc29uLlN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgdG9rZW4gPT09IDEzIC8qIEpzb24uU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi8pICYmIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSA8PSBvZmZzZXQ7XG4gICAgfVxuICAgIGZyb21NYXJrdXAobWFya3VwU3RyaW5nKSB7XG4gICAgICAgIGlmIChtYXJrdXBTdHJpbmcgJiYgdGhpcy5kb2VzU3VwcG9ydE1hcmtkb3duKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogbWFpbi5NYXJrdXBLaW5kLk1hcmtkb3duLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXJrdXBTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZG9lc1N1cHBvcnRNYXJrZG93bigpIHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGhpcy5zdXBwb3J0c01hcmtkb3duKSkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRhdGlvbkZvcm1hdCA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudD8uY29tcGxldGlvbj8uY29tcGxldGlvbkl0ZW0/LmRvY3VtZW50YXRpb25Gb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzTWFya2Rvd24gPSBBcnJheS5pc0FycmF5KGRvY3VtZW50YXRpb25Gb3JtYXQpICYmIGRvY3VtZW50YXRpb25Gb3JtYXQuaW5kZXhPZihtYWluLk1hcmt1cEtpbmQuTWFya2Rvd24pICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c01hcmtkb3duO1xuICAgIH1cbiAgICBkb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycykpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxEZXRhaWxzU3VwcG9ydCA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudD8uY29tcGxldGlvbj8uY29tcGxldGlvbkl0ZW0/LmNvbW1pdENoYXJhY3RlcnNTdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycztcbiAgICB9XG4gICAgZG9lc1N1cHBvcnRzTGFiZWxEZXRhaWxzKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQpKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQgPSB0aGlzLmNsaWVudENhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnQ/LmNvbXBsZXRpb24/LmNvbXBsZXRpb25JdGVtPy5sYWJlbERldGFpbHNTdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQ7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25Ib3Zlci5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuY2xhc3MgSlNPTkhvdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWFTZXJ2aWNlLCBjb250cmlidXRpb25zID0gW10sIHByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMgPSBjb250cmlidXRpb25zO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlQ29uc3RydWN0b3IgfHwgUHJvbWlzZTtcbiAgICB9XG4gICAgZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChwb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gZG9jLmdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIGlmICghbm9kZSB8fCAobm9kZS50eXBlID09PSAnb2JqZWN0JyB8fCBub2RlLnR5cGUgPT09ICdhcnJheScpICYmIG9mZnNldCA+IG5vZGUub2Zmc2V0ICsgMSAmJiBvZmZzZXQgPCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyUmFuZ2VOb2RlID0gbm9kZTtcbiAgICAgICAgLy8gdXNlIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdGlvbiB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IGtleVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJSYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQoaG92ZXJSYW5nZU5vZGUub2Zmc2V0KSwgZG9jdW1lbnQucG9zaXRpb25BdChob3ZlclJhbmdlTm9kZS5vZmZzZXQgKyBob3ZlclJhbmdlTm9kZS5sZW5ndGgpKTtcbiAgICAgICAgY29uc3QgY3JlYXRlSG92ZXIgPSAoY29udGVudHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50czogY29udGVudHMsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGhvdmVyUmFuZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGpzb25QYXJzZXJfZ2V0Tm9kZVBhdGgobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyaWJ1dGlvbiA9IHRoaXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBjb250cmlidXRpb24uZ2V0SW5mb0NvbnRyaWJ1dGlvbihkb2N1bWVudC51cmksIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihodG1sQ29udGVudCA9PiBjcmVhdGVIb3ZlcihodG1sQ29udGVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBub2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZG93bkRlc2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uID0gdW5kZWZpbmVkLCBlbnVtVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLmV2ZXJ5KChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm5vZGUgPT09IG5vZGUgJiYgIXMuaW52ZXJ0ZWQgJiYgcy5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUgfHwgcy5zY2hlbWEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bkRlc2NyaXB0aW9uID0gbWFya2Rvd25EZXNjcmlwdGlvbiB8fCBzLnNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uIHx8IHRvTWFya2Rvd24ocy5zY2hlbWEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBzLnNjaGVtYS5lbnVtLmluZGV4T2YoanNvblBhcnNlcl9nZXROb2RlVmFsdWUobm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbiA9IHMuc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzLnNjaGVtYS5lbnVtRGVzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb24gPSB0b01hcmtkb3duKHMuc2NoZW1hLmVudW1EZXNjcmlwdGlvbnNbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1WYWx1ZSA9IHMuc2NoZW1hLmVudW1baWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnVtVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWUgPSBKU09OLnN0cmluZ2lmeShlbnVtVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9NYXJrZG93bih0aXRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG1hcmtkb3duRGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGBcXGAke3RvTWFya2Rvd25Db2RlQmxvY2soZW51bVZhbHVlKX1cXGA6ICR7bWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSG92ZXIoW3Jlc3VsdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvTWFya2Rvd24ocGxhaW4pIHtcbiAgICBpZiAocGxhaW4pIHtcbiAgICAgICAgY29uc3QgcmVzID0gcGxhaW4ucmVwbGFjZSgvKFteXFxuXFxyXSkoXFxyP1xcbikoW15cXG5cXHJdKS9nbSwgJyQxXFxuXFxuJDMnKTsgLy8gc2luZ2xlIG5ldyBsaW5lcyB0byBcXG5cXG4gKE1hcmtkb3duIHBhcmFncmFwaClcbiAgICAgICAgcmV0dXJuIHJlcy5yZXBsYWNlKC9bXFxcXGAqX3t9W1xcXSgpIytcXC0uIV0vZywgXCJcXFxcJCZcIik7IC8vIGVzY2FwZSBtYXJrZG93biBzeW50YXggdG9rZW5zOiBodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duL3N5bnRheCNiYWNrc2xhc2hcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRvTWFya2Rvd25Db2RlQmxvY2soY29udGVudCkge1xuICAgIC8vIHNlZSBodHRwczovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjcHJlY29kZVxuICAgIGlmIChjb250ZW50LmluZGV4T2YoJ2AnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICdgYCAnICsgY29udGVudCArICcgYGAnO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uVmFsaWRhdGlvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXG5jbGFzcyBKU09OVmFsaWRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoanNvblNjaGVtYVNlcnZpY2UsIHByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmpzb25TY2hlbWFTZXJ2aWNlID0ganNvblNjaGVtYVNlcnZpY2U7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShyYXcpIHtcbiAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uRW5hYmxlZCA9IHJhdy52YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbW1lbnRTZXZlcml0eSA9IHJhdy5hbGxvd0NvbW1lbnRzID8gdW5kZWZpbmVkIDogbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9WYWxpZGF0aW9uKHRleHREb2N1bWVudCwganNvbkRvY3VtZW50LCBkb2N1bWVudFNldHRpbmdzLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0gW107XG4gICAgICAgIGNvbnN0IGFkZGVkID0ge307XG4gICAgICAgIGNvbnN0IGFkZFByb2JsZW0gPSAocHJvYmxlbSkgPT4ge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZWQgbWVzc2FnZXNcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHByb2JsZW0ucmFuZ2Uuc3RhcnQubGluZSArICcgJyArIHByb2JsZW0ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyICsgJyAnICsgcHJvYmxlbS5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFhZGRlZFtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgYWRkZWRbc2lnbmF0dXJlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MucHVzaChwcm9ibGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0RGlhZ25vc3RpY3MgPSAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmdDb21tYVNldmVyaXR5ID0gZG9jdW1lbnRTZXR0aW5ncz8udHJhaWxpbmdDb21tYXMgPyB0b0RpYWdub3N0aWNTZXZlcml0eShkb2N1bWVudFNldHRpbmdzLnRyYWlsaW5nQ29tbWFzKSA6IG1haW4uRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yO1xuICAgICAgICAgICAgbGV0IGNvbW1lbnRTZXZlcml0eSA9IGRvY3VtZW50U2V0dGluZ3M/LmNvbW1lbnRzID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy5jb21tZW50cykgOiB0aGlzLmNvbW1lbnRTZXZlcml0eTtcbiAgICAgICAgICAgIGxldCBzY2hlbWFWYWxpZGF0aW9uID0gZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hVmFsaWRhdGlvbiA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3Muc2NoZW1hVmFsaWRhdGlvbikgOiBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICAgICAgbGV0IHNjaGVtYVJlcXVlc3QgPSBkb2N1bWVudFNldHRpbmdzPy5zY2hlbWFSZXF1ZXN0ID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy5zY2hlbWFSZXF1ZXN0KSA6IG1haW4uRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc7XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkU2NoZW1hUHJvYmxlbSA9IChlcnJvck1lc3NhZ2UsIGVycm9yQ29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkRvY3VtZW50LnJvb3QgJiYgc2NoZW1hUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXN0Um9vdCA9IGpzb25Eb2N1bWVudC5yb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBhc3RSb290LnR5cGUgPT09ICdvYmplY3QnID8gYXN0Um9vdC5wcm9wZXJ0aWVzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmtleU5vZGUudmFsdWUgPT09ICckc2NoZW1hJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwcm9wZXJ0eS52YWx1ZU5vZGUgfHwgcHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBtYWluLlJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKG1haW4uRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIGVycm9yTWVzc2FnZSwgc2NoZW1hUmVxdWVzdCwgZXJyb3JDb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGFzdFJvb3Qub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoYXN0Um9vdC5vZmZzZXQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUHJvYmxlbShtYWluLkRpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBlcnJvck1lc3NhZ2UsIHNjaGVtYVJlcXVlc3QsIGVycm9yQ29kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2NoZW1hUHJvYmxlbShzY2hlbWEuZXJyb3JzWzBdLCBFcnJvckNvZGUuU2NoZW1hUmVzb2x2ZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHdhcm5pbmcgb2Ygc2NoZW1hLndhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTY2hlbWFQcm9ibGVtKHdhcm5pbmcsIEVycm9yQ29kZS5TY2hlbWFVbnN1cHBvcnRlZEZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbWFudGljRXJyb3JzID0ganNvbkRvY3VtZW50LnZhbGlkYXRlKHRleHREb2N1bWVudCwgc2NoZW1hLnNjaGVtYSwgc2NoZW1hVmFsaWRhdGlvbiwgZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hRHJhZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VtYW50aWNFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbWFudGljRXJyb3JzLmZvckVhY2goYWRkUHJvYmxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYUFsbG93c0NvbW1lbnRzKHNjaGVtYS5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRTZXZlcml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYS5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWFTZXZlcml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YganNvbkRvY3VtZW50LnN5bnRheEVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmIChwLmNvZGUgPT09IEVycm9yQ29kZS5UcmFpbGluZ0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhaWxpbmdDb21tYVNldmVyaXR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcC5zZXZlcml0eSA9IHRyYWlsaW5nQ29tbWFTZXZlcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkUHJvYmxlbShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudFNldmVyaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0KCdDb21tZW50cyBhcmUgbm90IHBlcm1pdHRlZCBpbiBKU09OLicpO1xuICAgICAgICAgICAgICAgIGpzb25Eb2N1bWVudC5jb21tZW50cy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKG1haW4uRGlhZ25vc3RpYy5jcmVhdGUoYywgbWVzc2FnZSwgY29tbWVudFNldmVyaXR5LCBFcnJvckNvZGUuQ29tbWVudE5vdFBlcm1pdHRlZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBzY2hlbWEuaWQgfHwgKCdzY2hlbWFzZXJ2aWNlOi8vdW50aXRsZWQvJyArIGlkQ291bnRlcisrKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuanNvblNjaGVtYVNlcnZpY2UucmVnaXN0ZXJFeHRlcm5hbFNjaGVtYSh7IHVyaSwgc2NoZW1hIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpLnRoZW4ocmVzb2x2ZWRTY2hlbWEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXREaWFnbm9zdGljcyhyZXNvbHZlZFNjaGVtYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5qc29uU2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZSh0ZXh0RG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpLnRoZW4oc2NoZW1hID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZXREaWFnbm9zdGljcyhzY2hlbWEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGFuZ3VhZ2VTdGF0dXModGV4dERvY3VtZW50LCBqc29uRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hczogdGhpcy5qc29uU2NoZW1hU2VydmljZS5nZXRTY2hlbWFVUklzRm9yUmVzb3VyY2UodGV4dERvY3VtZW50LnVyaSwganNvbkRvY3VtZW50KSB9O1xuICAgIH1cbn1cbmxldCBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hUmVmKSB7XG4gICAgaWYgKHNjaGVtYVJlZiAmJiB0eXBlb2Ygc2NoZW1hUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNCb29sZWFuKHNjaGVtYVJlZi5hbGxvd0NvbW1lbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYVJlZi5hbGxvd0NvbW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFSZWYuYWxsT2YpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYVJlZi5hbGxPZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ID0gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCb29sZWFuKGFsbG93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzY2hlbWFBbGxvd3NUcmFpbGluZ0NvbW1hcyhzY2hlbWFSZWYpIHtcbiAgICBpZiAoc2NoZW1hUmVmICYmIHR5cGVvZiBzY2hlbWFSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oc2NoZW1hUmVmLmFsbG93VHJhaWxpbmdDb21tYXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hUmVmLmFsbG93VHJhaWxpbmdDb21tYXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwclNjaGVtYVJlZiA9IHNjaGVtYVJlZjtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihkZXByU2NoZW1hUmVmWydhbGxvd3NUcmFpbGluZ0NvbW1hcyddKSkgeyAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICByZXR1cm4gZGVwclNjaGVtYVJlZlsnYWxsb3dzVHJhaWxpbmdDb21tYXMnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hUmVmLmFsbE9mKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBzY2hlbWFSZWYuYWxsT2YpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvdyA9IHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihhbGxvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdG9EaWFnbm9zdGljU2V2ZXJpdHkoc2V2ZXJpdHlMZXZlbCkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHlMZXZlbCkge1xuICAgICAgICBjYXNlICdlcnJvcic6IHJldHVybiBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcbiAgICAgICAgY2FzZSAnd2FybmluZyc6IHJldHVybiBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICBjYXNlICdpZ25vcmUnOiByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2NvbG9ycy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jb25zdCBEaWdpdDAgPSA0ODtcbmNvbnN0IERpZ2l0OSA9IDU3O1xuY29uc3QgQSA9IDY1O1xuY29uc3QgYSA9IDk3O1xuY29uc3QgZiA9IDEwMjtcbmZ1bmN0aW9uIGhleERpZ2l0KGNoYXJDb2RlKSB7XG4gICAgaWYgKGNoYXJDb2RlIDwgRGlnaXQwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUgPD0gRGlnaXQ5KSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZSAtIERpZ2l0MDtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlIDwgYSkge1xuICAgICAgICBjaGFyQ29kZSArPSAoYSAtIEEpO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUgPj0gYSAmJiBjaGFyQ29kZSA8PSBmKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZSAtIGEgKyAxMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb2xvckZyb21IZXgodGV4dCkge1xuICAgIGlmICh0ZXh0WzBdICE9PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpdGNoICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDcpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoOCkpKSAvIDI1NS4wXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY29sb3JGcm9tMjU2UkdCKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhID0gMS4wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiByZWQgLyAyNTUuMCxcbiAgICAgICAgZ3JlZW46IGdyZWVuIC8gMjU1LjAsXG4gICAgICAgIGJsdWU6IGJsdWUgLyAyNTUuMCxcbiAgICAgICAgYWxwaGFcbiAgICB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25Eb2N1bWVudFN5bWJvbHMuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cbmNsYXNzIEpTT05Eb2N1bWVudFN5bWJvbHMge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFTZXJ2aWNlID0gc2NoZW1hU2VydmljZTtcbiAgICB9XG4gICAgZmluZERvY3VtZW50U3ltYm9scyhkb2N1bWVudCwgZG9jLCBjb250ZXh0ID0geyByZXN1bHRMaW1pdDogTnVtYmVyLk1BWF9WQUxVRSB9KSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBkb2Mucm9vdDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbWl0ID0gY29udGV4dC5yZXN1bHRMaW1pdCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBrZXkgYmluZGluZ3NcbiAgICAgICAgY29uc3QgcmVzb3VyY2VTdHJpbmcgPSBkb2N1bWVudC51cmk7XG4gICAgICAgIGlmICgocmVzb3VyY2VTdHJpbmcgPT09ICd2c2NvZGU6Ly9kZWZhdWx0c2V0dGluZ3Mva2V5YmluZGluZ3MuanNvbicpIHx8IGVuZHNXaXRoKHJlc291cmNlU3RyaW5nLnRvTG93ZXJDYXNlKCksICcvdXNlci9rZXliaW5kaW5ncy5qc29uJykpIHtcbiAgICAgICAgICAgIGlmIChyb290LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygcm9vdC5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBpdGVtLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gJ2tleScgJiYgcHJvcGVydHkudmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbWFpbi5Mb2NhdGlvbi5jcmVhdGUoZG9jdW1lbnQudXJpLCBnZXRSYW5nZShkb2N1bWVudCwgaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGdldE5hbWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogbWFpbi5TeW1ib2xLaW5kLkZ1bmN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1Zpc2l0ID0gW1xuICAgICAgICAgICAgeyBub2RlOiByb290LCBjb250YWluZXJOYW1lOiAnJyB9XG4gICAgICAgIF07XG4gICAgICAgIGxldCBuZXh0VG9WaXNpdCA9IDA7XG4gICAgICAgIGxldCBsaW1pdEV4Y2VlZGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBjb2xsZWN0T3V0bGluZUVudHJpZXMgPSAobm9kZSwgY29udGFpbmVyTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IG5vZGUsIGNvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gcHJvcGVydHkudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG1haW4uTG9jYXRpb24uY3JlYXRlKGRvY3VtZW50LnVyaSwgZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZSA/IGNvbnRhaW5lck5hbWUgKyAnLicgKyBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlIDogcHJvcGVydHkua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IHRoaXMuZ2V0S2V5TGFiZWwocHJvcGVydHkpLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQodmFsdWVOb2RlLnR5cGUpLCBsb2NhdGlvbjogbG9jYXRpb24sIGNvbnRhaW5lck5hbWU6IGNvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9WaXNpdC5wdXNoKHsgbm9kZTogdmFsdWVOb2RlLCBjb250YWluZXJOYW1lOiBjaGlsZENvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdEV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBicmVhdGggZmlyc3QgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChuZXh0VG9WaXNpdCA8IHRvVmlzaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdG9WaXNpdFtuZXh0VG9WaXNpdCsrXTtcbiAgICAgICAgICAgIGNvbGxlY3RPdXRsaW5lRW50cmllcyhuZXh0Lm5vZGUsIG5leHQuY29udGFpbmVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0RXhjZWVkZWQgJiYgY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmREb2N1bWVudFN5bWJvbHMyKGRvY3VtZW50LCBkb2MsIGNvbnRleHQgPSB7IHJlc3VsdExpbWl0OiBOdW1iZXIuTUFYX1ZBTFVFIH0pIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGRvYy5yb290O1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGltaXQgPSBjb250ZXh0LnJlc3VsdExpbWl0IHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGtleSBiaW5kaW5nc1xuICAgICAgICBjb25zdCByZXNvdXJjZVN0cmluZyA9IGRvY3VtZW50LnVyaTtcbiAgICAgICAgaWYgKChyZXNvdXJjZVN0cmluZyA9PT0gJ3ZzY29kZTovL2RlZmF1bHRzZXR0aW5ncy9rZXliaW5kaW5ncy5qc29uJykgfHwgZW5kc1dpdGgocmVzb3VyY2VTdHJpbmcudG9Mb3dlckNhc2UoKSwgJy91c2VyL2tleWJpbmRpbmdzLmpzb24nKSkge1xuICAgICAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByb290Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGl0ZW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlID09PSAna2V5JyAmJiBwcm9wZXJ0eS52YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5LmtleU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGdldE5hbWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogbWFpbi5TeW1ib2xLaW5kLkZ1bmN0aW9uLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgdG9WaXNpdCA9IFtcbiAgICAgICAgICAgIHsgbm9kZTogcm9vdCwgcmVzdWx0IH1cbiAgICAgICAgXTtcbiAgICAgICAgbGV0IG5leHRUb1Zpc2l0ID0gMDtcbiAgICAgICAgbGV0IGxpbWl0RXhjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY29sbGVjdE91dGxpbmVFbnRyaWVzID0gKG5vZGUsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0geyBuYW1lLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQobm9kZS50eXBlKSwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbjogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IHJlc3VsdDogc3ltYm9sLmNoaWxkcmVuLCBub2RlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gcHJvcGVydHkudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcHJvcGVydHkua2V5Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSB7IG5hbWU6IHRoaXMuZ2V0S2V5TGFiZWwocHJvcGVydHkpLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQodmFsdWVOb2RlLnR5cGUpLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuLCBkZXRhaWw6IHRoaXMuZ2V0RGV0YWlsKHZhbHVlTm9kZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IHJlc3VsdDogY2hpbGRyZW4sIG5vZGU6IHZhbHVlTm9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0RXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGJyZWF0aCBmaXJzdCB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5leHRUb1Zpc2l0IDwgdG9WaXNpdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0b1Zpc2l0W25leHRUb1Zpc2l0KytdO1xuICAgICAgICAgICAgY29sbGVjdE91dGxpbmVFbnRyaWVzKG5leHQubm9kZSwgbmV4dC5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdEV4Y2VlZGVkICYmIGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRTeW1ib2xLaW5kKG5vZGVUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uU3ltYm9sS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLlN5bWJvbEtpbmQuU3RyaW5nO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5TeW1ib2xLaW5kLk51bWJlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5TeW1ib2xLaW5kLkFycmF5O1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uU3ltYm9sS2luZC5Cb29sZWFuO1xuICAgICAgICAgICAgZGVmYXVsdDogLy8gJ251bGwnXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uU3ltYm9sS2luZC5WYXJpYWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRLZXlMYWJlbChwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgbmFtZSA9IHByb3BlcnR5LmtleU5vZGUudmFsdWU7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxuXS9nLCAn4oa1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXCIke25hbWV9XCJgO1xuICAgIH1cbiAgICBnZXREZXRhaWwobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcgfHwgbm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhub2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5sZW5ndGggPyB1bmRlZmluZWQgOiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IHVuZGVmaW5lZCA6ICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZmluZERvY3VtZW50Q29sb3JzKGRvY3VtZW50LCBkb2MsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZShkb2N1bWVudC51cmksIGRvYykudGhlbihzY2hlbWEgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5yZXN1bHRMaW1pdCA9PT0gJ251bWJlcicgPyBjb250ZXh0LnJlc3VsdExpbWl0IDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ1NjaGVtYXMgPSBkb2MuZ2V0TWF0Y2hpbmdTY2hlbWFzKHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2l0ZWROb2RlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIG1hdGNoaW5nU2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXMuaW52ZXJ0ZWQgJiYgcy5zY2hlbWEgJiYgKHMuc2NoZW1hLmZvcm1hdCA9PT0gJ2NvbG9yJyB8fCBzLnNjaGVtYS5mb3JtYXQgPT09ICdjb2xvci1oZXgnKSAmJiBzLm5vZGUgJiYgcy5ub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlSWQgPSBTdHJpbmcocy5ub2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWROb2RlW25vZGVJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yRnJvbUhleChqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShzLm5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcy5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBjb2xvciwgcmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWROb2RlW25vZGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29sb3JQcmVzZW50YXRpb25zKGRvY3VtZW50LCBkb2MsIGNvbG9yLCByYW5nZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgcmVkMjU2ID0gTWF0aC5yb3VuZChjb2xvci5yZWQgKiAyNTUpLCBncmVlbjI1NiA9IE1hdGgucm91bmQoY29sb3IuZ3JlZW4gKiAyNTUpLCBibHVlMjU2ID0gTWF0aC5yb3VuZChjb2xvci5ibHVlICogMjU1KTtcbiAgICAgICAgZnVuY3Rpb24gdG9Ud29EaWdpdEhleChuKSB7XG4gICAgICAgICAgICBjb25zdCByID0gbi50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gci5sZW5ndGggIT09IDIgPyAnMCcgKyByIDogcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgIGlmIChjb2xvci5hbHBoYSA9PT0gMSkge1xuICAgICAgICAgICAgbGFiZWwgPSBgIyR7dG9Ud29EaWdpdEhleChyZWQyNTYpfSR7dG9Ud29EaWdpdEhleChncmVlbjI1Nil9JHt0b1R3b0RpZ2l0SGV4KGJsdWUyNTYpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCA9IGAjJHt0b1R3b0RpZ2l0SGV4KHJlZDI1Nil9JHt0b1R3b0RpZ2l0SGV4KGdyZWVuMjU2KX0ke3RvVHdvRGlnaXRIZXgoYmx1ZTI1Nil9JHt0b1R3b0RpZ2l0SGV4KE1hdGgucm91bmQoY29sb3IuYWxwaGEgKiAyNTUpKX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgbGFiZWw6IGxhYmVsLCB0ZXh0RWRpdDogbWFpbi5UZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBKU09OLnN0cmluZ2lmeShsYWJlbCkpIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJhbmdlKGRvY3VtZW50LCBub2RlKSB7XG4gICAgcmV0dXJuIG1haW4uUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQpLCBkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGdldE5hbWUobm9kZSkge1xuICAgIHJldHVybiBqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShub2RlKSB8fCB0KCc8ZW1wdHk+Jyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvY29uZmlndXJhdGlvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmNvbnN0IHNjaGVtYUNvbnRyaWJ1dGlvbnMgPSB7XG4gICAgc2NoZW1hQXNzb2NpYXRpb25zOiBbXSxcbiAgICBzY2hlbWFzOiB7XG4gICAgICAgIC8vIHJlZmVyIHRvIHRoZSBsYXRlc3Qgc2NoZW1hXG4gICAgICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYSMnOiB7XG4gICAgICAgICAgICAkcmVmOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJ1xuICAgICAgICB9LFxuICAgICAgICAvLyBidW5kbGUgdGhlIHNjaGVtYS1zY2hlbWEgdG8gaW5jbHVkZSAobG9jYWxpemVkKSBkZXNjcmlwdGlvbnNcbiAgICAgICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIyc6IHtcbiAgICAgICAgICAgICckc2NoZW1hJzogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIycsXG4gICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgJ3NjaGVtYUFycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwb3NpdGl2ZUludGVnZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ludGVnZXInLFxuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSc6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwb3NpdGl2ZUludGVnZXJEZWZhdWx0MCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3NpbXBsZVR5cGVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZW51bSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3N0cmluZ0FycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgJ2lkJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckc2NoZW1hJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0aXRsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9LFxuICAgICAgICAgICAgICAgICdtdWx0aXBsZU9mJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNYXhpbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21pbmltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heExlbmd0aCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWluTGVuZ3RoJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm4nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAncmVnZXgnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbEl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heEl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDAnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5Qcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm5Qcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVwZW5kZW5jaWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2VudW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb3JtYXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbnVtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0ZS10aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VyaScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbWFpbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdob3N0bmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpcHY0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lwdjYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVnZXgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhbGxPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhbnlPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdvbmVPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdub3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZXBlbmRlbmNpZXMnOiB7XG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICdtYXhpbXVtJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgIH0sXG4gICAgICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSMnOiB7XG4gICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgJ3NjaGVtYUFycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHsgJyRyZWYnOiAnIycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ25vbk5lZ2F0aXZlSW50ZWdlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJzogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyAnZGVmYXVsdCc6IDAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc2ltcGxlVHlwZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdlbnVtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc3RyaW5nQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzogeyAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3R5cGUnOiBbJ29iamVjdCcsICdib29sZWFuJ10sXG4gICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAnJGlkJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaS1yZWZlcmVuY2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHNjaGVtYSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHJlZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmktcmVmZXJlbmNlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyRjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndGl0bGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdyZWFkT25seSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGFtcGxlcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbXVsdGlwbGVPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4aW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWluaW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heExlbmd0aCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXInIH0sXG4gICAgICAgICAgICAgICAgJ21pbkxlbmd0aCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCcgfSxcbiAgICAgICAgICAgICAgICAncGF0dGVybic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICdyZWdleCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsSXRlbXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4SXRlbXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCcgfSxcbiAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnY29udGFpbnMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ21heFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICdtaW5Qcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJyB9LFxuICAgICAgICAgICAgICAgICdyZXF1aXJlZCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYXR0ZXJuUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlOYW1lcyc6IHsgJ2Zvcm1hdCc6ICdyZWdleCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlcGVuZGVuY2llcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXknIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnR5TmFtZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2NvbnN0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZW51bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndHlwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb3JtYXQnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAnY29udGVudE1lZGlhVHlwZSc6IHsgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICdjb250ZW50RW5jb2RpbmcnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAnaWYnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ3RoZW4nOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2FsbE9mJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5JyB9LFxuICAgICAgICAgICAgICAgICdhbnlPZic6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnb25lT2YnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH0sXG4gICAgICAgICAgICAgICAgJ25vdCc6IHsgJyRyZWYnOiAnIycgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWZhdWx0JzogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRlc2NyaXB0aW9ucyA9IHtcbiAgICBpZDogdChcIkEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzY2hlbWEuXCIpLFxuICAgICRzY2hlbWE6IHQoXCJUaGUgc2NoZW1hIHRvIHZlcmlmeSB0aGlzIGRvY3VtZW50IGFnYWluc3QuXCIpLFxuICAgIHRpdGxlOiB0KFwiQSBkZXNjcmlwdGl2ZSB0aXRsZSBvZiB0aGUgZWxlbWVudC5cIiksXG4gICAgZGVzY3JpcHRpb246IHQoXCJBIGxvbmcgZGVzY3JpcHRpb24gb2YgdGhlIGVsZW1lbnQuIFVzZWQgaW4gaG92ZXIgbWVudXMgYW5kIHN1Z2dlc3Rpb25zLlwiKSxcbiAgICBkZWZhdWx0OiB0KFwiQSBkZWZhdWx0IHZhbHVlLiBVc2VkIGJ5IHN1Z2dlc3Rpb25zLlwiKSxcbiAgICBtdWx0aXBsZU9mOiB0KFwiQSBudW1iZXIgdGhhdCBzaG91bGQgY2xlYW5seSBkaXZpZGUgdGhlIGN1cnJlbnQgdmFsdWUgKGkuZS4gaGF2ZSBubyByZW1haW5kZXIpLlwiKSxcbiAgICBtYXhpbXVtOiB0KFwiVGhlIG1heGltdW0gbnVtZXJpY2FsIHZhbHVlLCBpbmNsdXNpdmUgYnkgZGVmYXVsdC5cIiksXG4gICAgZXhjbHVzaXZlTWF4aW11bTogdChcIk1ha2VzIHRoZSBtYXhpbXVtIHByb3BlcnR5IGV4Y2x1c2l2ZS5cIiksXG4gICAgbWluaW11bTogdChcIlRoZSBtaW5pbXVtIG51bWVyaWNhbCB2YWx1ZSwgaW5jbHVzaXZlIGJ5IGRlZmF1bHQuXCIpLFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHQoXCJNYWtlcyB0aGUgbWluaW11bSBwcm9wZXJ0eSBleGNsdXNpdmUuXCIpLFxuICAgIG1heExlbmd0aDogdChcIlRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhIHN0cmluZy5cIiksXG4gICAgbWluTGVuZ3RoOiB0KFwiVGhlIG1pbmltdW0gbGVuZ3RoIG9mIGEgc3RyaW5nLlwiKSxcbiAgICBwYXR0ZXJuOiB0KFwiQSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggdGhlIHN0cmluZyBhZ2FpbnN0LiBJdCBpcyBub3QgaW1wbGljaXRseSBhbmNob3JlZC5cIiksXG4gICAgYWRkaXRpb25hbEl0ZW1zOiB0KFwiRm9yIGFycmF5cywgb25seSB3aGVuIGl0ZW1zIGlzIHNldCBhcyBhbiBhcnJheS4gSWYgaXQgaXMgYSBzY2hlbWEsIHRoZW4gdGhpcyBzY2hlbWEgdmFsaWRhdGVzIGl0ZW1zIGFmdGVyIHRoZSBvbmVzIHNwZWNpZmllZCBieSB0aGUgaXRlbXMgYXJyYXkuIElmIGl0IGlzIGZhbHNlLCB0aGVuIGFkZGl0aW9uYWwgaXRlbXMgd2lsbCBjYXVzZSB2YWxpZGF0aW9uIHRvIGZhaWwuXCIpLFxuICAgIGl0ZW1zOiB0KFwiRm9yIGFycmF5cy4gQ2FuIGVpdGhlciBiZSBhIHNjaGVtYSB0byB2YWxpZGF0ZSBldmVyeSBlbGVtZW50IGFnYWluc3Qgb3IgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB2YWxpZGF0ZSBlYWNoIGl0ZW0gYWdhaW5zdCBpbiBvcmRlciAodGhlIGZpcnN0IHNjaGVtYSB3aWxsIHZhbGlkYXRlIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgc2Vjb25kIHNjaGVtYSB3aWxsIHZhbGlkYXRlIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlwiKSxcbiAgICBtYXhJdGVtczogdChcIlRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBpbnNpZGUgYW4gYXJyYXkuIEluY2x1c2l2ZS5cIiksXG4gICAgbWluSXRlbXM6IHQoXCJUaGUgbWluaW11bSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgaW5zaWRlIGFuIGFycmF5LiBJbmNsdXNpdmUuXCIpLFxuICAgIHVuaXF1ZUl0ZW1zOiB0KFwiSWYgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXkgbXVzdCBiZSB1bmlxdWUuIERlZmF1bHRzIHRvIGZhbHNlLlwiKSxcbiAgICBtYXhQcm9wZXJ0aWVzOiB0KFwiVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb3BlcnRpZXMgYW4gb2JqZWN0IGNhbiBoYXZlLiBJbmNsdXNpdmUuXCIpLFxuICAgIG1pblByb3BlcnRpZXM6IHQoXCJUaGUgbWluaW11bSBudW1iZXIgb2YgcHJvcGVydGllcyBhbiBvYmplY3QgY2FuIGhhdmUuIEluY2x1c2l2ZS5cIiksXG4gICAgcmVxdWlyZWQ6IHQoXCJBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgbGlzdHMgdGhlIG5hbWVzIG9mIGFsbCBwcm9wZXJ0aWVzIHJlcXVpcmVkIG9uIHRoaXMgb2JqZWN0LlwiKSxcbiAgICBhZGRpdGlvbmFsUHJvcGVydGllczogdChcIkVpdGhlciBhIHNjaGVtYSBvciBhIGJvb2xlYW4uIElmIGEgc2NoZW1hLCB0aGVuIHVzZWQgdG8gdmFsaWRhdGUgYWxsIHByb3BlcnRpZXMgbm90IG1hdGNoZWQgYnkgJ3Byb3BlcnRpZXMnIG9yICdwYXR0ZXJuUHJvcGVydGllcycuIElmIGZhbHNlLCB0aGVuIGFueSBwcm9wZXJ0aWVzIG5vdCBtYXRjaGVkIGJ5IGVpdGhlciB3aWxsIGNhdXNlIHRoaXMgc2NoZW1hIHRvIGZhaWwuXCIpLFxuICAgIGRlZmluaXRpb25zOiB0KFwiTm90IHVzZWQgZm9yIHZhbGlkYXRpb24uIFBsYWNlIHN1YnNjaGVtYXMgaGVyZSB0aGF0IHlvdSB3aXNoIHRvIHJlZmVyZW5jZSBpbmxpbmUgd2l0aCAkcmVmLlwiKSxcbiAgICBwcm9wZXJ0aWVzOiB0KFwiQSBtYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gc2NoZW1hcyBmb3IgZWFjaCBwcm9wZXJ0eS5cIiksXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IHQoXCJBIG1hcCBvZiByZWd1bGFyIGV4cHJlc3Npb25zIG9uIHByb3BlcnR5IG5hbWVzIHRvIHNjaGVtYXMgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMuXCIpLFxuICAgIGRlcGVuZGVuY2llczogdChcIkEgbWFwIG9mIHByb3BlcnR5IG5hbWVzIHRvIGVpdGhlciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvciBhIHNjaGVtYS4gQW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgbWVhbnMgdGhlIHByb3BlcnR5IG5hbWVkIGluIHRoZSBrZXkgZGVwZW5kcyBvbiB0aGUgcHJvcGVydGllcyBpbiB0aGUgYXJyYXkgYmVpbmcgcHJlc2VudCBpbiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGJlIHZhbGlkLiBJZiB0aGUgdmFsdWUgaXMgYSBzY2hlbWEsIHRoZW4gdGhlIHNjaGVtYSBpcyBvbmx5IGFwcGxpZWQgdG8gdGhlIG9iamVjdCBpZiB0aGUgcHJvcGVydHkgaW4gdGhlIGtleSBleGlzdHMgb24gdGhlIG9iamVjdC5cIiksXG4gICAgZW51bTogdChcIlRoZSBzZXQgb2YgbGl0ZXJhbCB2YWx1ZXMgdGhhdCBhcmUgdmFsaWQuXCIpLFxuICAgIHR5cGU6IHQoXCJFaXRoZXIgYSBzdHJpbmcgb2Ygb25lIG9mIHRoZSBiYXNpYyBzY2hlbWEgdHlwZXMgKG51bWJlciwgaW50ZWdlciwgbnVsbCwgYXJyYXksIG9iamVjdCwgYm9vbGVhbiwgc3RyaW5nKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHNwZWNpZnlpbmcgYSBzdWJzZXQgb2YgdGhvc2UgdHlwZXMuXCIpLFxuICAgIGZvcm1hdDogdChcIkRlc2NyaWJlcyB0aGUgZm9ybWF0IGV4cGVjdGVkIGZvciB0aGUgdmFsdWUuXCIpLFxuICAgIGFsbE9mOiB0KFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgYWxsIG9mIHdoaWNoIG11c3QgbWF0Y2guXCIpLFxuICAgIGFueU9mOiB0KFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgd2hlcmUgYXQgbGVhc3Qgb25lIG11c3QgbWF0Y2guXCIpLFxuICAgIG9uZU9mOiB0KFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgZXhhY3RseSBvbmUgb2Ygd2hpY2ggbXVzdCBtYXRjaC5cIiksXG4gICAgbm90OiB0KFwiQSBzY2hlbWEgd2hpY2ggbXVzdCBub3QgbWF0Y2guXCIpLFxuICAgICRpZDogdChcIkEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzY2hlbWEuXCIpLFxuICAgICRyZWY6IHQoXCJSZWZlcmVuY2UgYSBkZWZpbml0aW9uIGhvc3RlZCBvbiBhbnkgbG9jYXRpb24uXCIpLFxuICAgICRjb21tZW50OiB0KFwiQ29tbWVudHMgZnJvbSBzY2hlbWEgYXV0aG9ycyB0byByZWFkZXJzIG9yIG1haW50YWluZXJzIG9mIHRoZSBzY2hlbWEuXCIpLFxuICAgIHJlYWRPbmx5OiB0KFwiSW5kaWNhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBpbnN0YW5jZSBpcyBtYW5hZ2VkIGV4Y2x1c2l2ZWx5IGJ5IHRoZSBvd25pbmcgYXV0aG9yaXR5LlwiKSxcbiAgICBleGFtcGxlczogdChcIlNhbXBsZSBKU09OIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIHNjaGVtYSwgZm9yIHRoZSBwdXJwb3NlIG9mIGlsbHVzdHJhdGluZyB1c2FnZS5cIiksXG4gICAgY29udGFpbnM6IHQoXCJBbiBhcnJheSBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFxcXCJjb250YWluc1xcXCIgaWYgYXQgbGVhc3Qgb25lIG9mIGl0cyBlbGVtZW50cyBpcyB2YWxpZCBhZ2FpbnN0IHRoZSBnaXZlbiBzY2hlbWEuXCIpLFxuICAgIHByb3BlcnR5TmFtZXM6IHQoXCJJZiB0aGUgaW5zdGFuY2UgaXMgYW4gb2JqZWN0LCB0aGlzIGtleXdvcmQgdmFsaWRhdGVzIGlmIGV2ZXJ5IHByb3BlcnR5IG5hbWUgaW4gdGhlIGluc3RhbmNlIHZhbGlkYXRlcyBhZ2FpbnN0IHRoZSBwcm92aWRlZCBzY2hlbWEuXCIpLFxuICAgIGNvbnN0OiB0KFwiQW4gaW5zdGFuY2UgdmFsaWRhdGVzIHN1Y2Nlc3NmdWxseSBhZ2FpbnN0IHRoaXMga2V5d29yZCBpZiBpdHMgdmFsdWUgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIHRoZSBrZXl3b3JkLlwiKSxcbiAgICBjb250ZW50TWVkaWFUeXBlOiB0KFwiRGVzY3JpYmVzIHRoZSBtZWRpYSB0eXBlIG9mIGEgc3RyaW5nIHByb3BlcnR5LlwiKSxcbiAgICBjb250ZW50RW5jb2Rpbmc6IHQoXCJEZXNjcmliZXMgdGhlIGNvbnRlbnQgZW5jb2Rpbmcgb2YgYSBzdHJpbmcgcHJvcGVydHkuXCIpLFxuICAgIGlmOiB0KFwiVGhlIHZhbGlkYXRpb24gb3V0Y29tZSBvZiB0aGUgXFxcImlmXFxcIiBzdWJzY2hlbWEgY29udHJvbHMgd2hpY2ggb2YgdGhlIFxcXCJ0aGVuXFxcIiBvciBcXFwiZWxzZVxcXCIga2V5d29yZHMgYXJlIGV2YWx1YXRlZC5cIiksXG4gICAgdGhlbjogdChcIlRoZSBcXFwiaWZcXFwiIHN1YnNjaGVtYSBpcyB1c2VkIGZvciB2YWxpZGF0aW9uIHdoZW4gdGhlIFxcXCJpZlxcXCIgc3Vic2NoZW1hIHN1Y2NlZWRzLlwiKSxcbiAgICBlbHNlOiB0KFwiVGhlIFxcXCJlbHNlXFxcIiBzdWJzY2hlbWEgaXMgdXNlZCBmb3IgdmFsaWRhdGlvbiB3aGVuIHRoZSBcXFwiaWZcXFwiIHN1YnNjaGVtYSBmYWlscy5cIilcbn07XG5mb3IgKGNvbnN0IHNjaGVtYU5hbWUgaW4gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzW3NjaGVtYU5hbWVdO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IHByb3BlcnR5T2JqZWN0ID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5T2JqZWN0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHByb3BlcnR5T2JqZWN0ID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbnNbcHJvcGVydHldO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHByb3BlcnR5T2JqZWN0WydkZXNjcmlwdGlvbiddID0gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICB9XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXVyaS9saWIvZXNtL2luZGV4LmpzXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDA2KTtcbnZhciBMSUI7KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezQ3MDp0PT57ZnVuY3Rpb24gZSh0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0KSl9ZnVuY3Rpb24gcih0LGUpe2Zvcih2YXIgcixuPVwiXCIsbz0wLGk9LTEsYT0wLGg9MDtoPD10Lmxlbmd0aDsrK2gpe2lmKGg8dC5sZW5ndGgpcj10LmNoYXJDb2RlQXQoaCk7ZWxzZXtpZig0Nz09PXIpYnJlYWs7cj00N31pZig0Nz09PXIpe2lmKGk9PT1oLTF8fDE9PT1hKTtlbHNlIGlmKGkhPT1oLTEmJjI9PT1hKXtpZihuLmxlbmd0aDwyfHwyIT09b3x8NDYhPT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSl8fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTIpKWlmKG4ubGVuZ3RoPjIpe3ZhciBzPW4ubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT1uLmxlbmd0aC0xKXstMT09PXM/KG49XCJcIixvPTApOm89KG49bi5zbGljZSgwLHMpKS5sZW5ndGgtMS1uLmxhc3RJbmRleE9mKFwiL1wiKSxpPWgsYT0wO2NvbnRpbnVlfX1lbHNlIGlmKDI9PT1uLmxlbmd0aHx8MT09PW4ubGVuZ3RoKXtuPVwiXCIsbz0wLGk9aCxhPTA7Y29udGludWV9ZSYmKG4ubGVuZ3RoPjA/bis9XCIvLi5cIjpuPVwiLi5cIixvPTIpfWVsc2Ugbi5sZW5ndGg+MD9uKz1cIi9cIit0LnNsaWNlKGkrMSxoKTpuPXQuc2xpY2UoaSsxLGgpLG89aC1pLTE7aT1oLGE9MH1lbHNlIDQ2PT09ciYmLTEhPT1hPysrYTphPS0xfXJldHVybiBufXZhciBuPXtyZXNvbHZlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LG49XCJcIixvPSExLGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhbztpLS0pe3ZhciBhO2k+PTA/YT1hcmd1bWVudHNbaV06KHZvaWQgMD09PXQmJih0PXByb2Nlc3MuY3dkKCkpLGE9dCksZShhKSwwIT09YS5sZW5ndGgmJihuPWErXCIvXCIrbixvPTQ3PT09YS5jaGFyQ29kZUF0KDApKX1yZXR1cm4gbj1yKG4sIW8pLG8/bi5sZW5ndGg+MD9cIi9cIituOlwiL1wiOm4ubGVuZ3RoPjA/bjpcIi5cIn0sbm9ybWFsaXplOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO3ZhciBuPTQ3PT09dC5jaGFyQ29kZUF0KDApLG89NDc9PT10LmNoYXJDb2RlQXQodC5sZW5ndGgtMSk7cmV0dXJuIDAhPT0odD1yKHQsIW4pKS5sZW5ndGh8fG58fCh0PVwiLlwiKSx0Lmxlbmd0aD4wJiZvJiYodCs9XCIvXCIpLG4/XCIvXCIrdDp0fSxpc0Fic29sdXRlOmZ1bmN0aW9uKHQpe3JldHVybiBlKHQpLHQubGVuZ3RoPjAmJjQ3PT09dC5jaGFyQ29kZUF0KDApfSxqb2luOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciB0LHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7KytyKXt2YXIgbz1hcmd1bWVudHNbcl07ZShvKSxvLmxlbmd0aD4wJiYodm9pZCAwPT09dD90PW86dCs9XCIvXCIrbyl9cmV0dXJuIHZvaWQgMD09PXQ/XCIuXCI6bi5ub3JtYWxpemUodCl9LHJlbGF0aXZlOmZ1bmN0aW9uKHQscil7aWYoZSh0KSxlKHIpLHQ9PT1yKXJldHVyblwiXCI7aWYoKHQ9bi5yZXNvbHZlKHQpKT09PShyPW4ucmVzb2x2ZShyKSkpcmV0dXJuXCJcIjtmb3IodmFyIG89MTtvPHQubGVuZ3RoJiY0Nz09PXQuY2hhckNvZGVBdChvKTsrK28pO2Zvcih2YXIgaT10Lmxlbmd0aCxhPWktbyxoPTE7aDxyLmxlbmd0aCYmNDc9PT1yLmNoYXJDb2RlQXQoaCk7KytoKTtmb3IodmFyIHM9ci5sZW5ndGgtaCxjPWE8cz9hOnMsZj0tMSx1PTA7dTw9YzsrK3Upe2lmKHU9PT1jKXtpZihzPmMpe2lmKDQ3PT09ci5jaGFyQ29kZUF0KGgrdSkpcmV0dXJuIHIuc2xpY2UoaCt1KzEpO2lmKDA9PT11KXJldHVybiByLnNsaWNlKGgrdSl9ZWxzZSBhPmMmJig0Nz09PXQuY2hhckNvZGVBdChvK3UpP2Y9dTowPT09dSYmKGY9MCkpO2JyZWFrfXZhciBsPXQuY2hhckNvZGVBdChvK3UpO2lmKGwhPT1yLmNoYXJDb2RlQXQoaCt1KSlicmVhazs0Nz09PWwmJihmPXUpfXZhciBwPVwiXCI7Zm9yKHU9bytmKzE7dTw9aTsrK3UpdSE9PWkmJjQ3IT09dC5jaGFyQ29kZUF0KHUpfHwoMD09PXAubGVuZ3RoP3ArPVwiLi5cIjpwKz1cIi8uLlwiKTtyZXR1cm4gcC5sZW5ndGg+MD9wK3Iuc2xpY2UoaCtmKTooaCs9Ziw0Nz09PXIuY2hhckNvZGVBdChoKSYmKytoLHIuc2xpY2UoaCkpfSxfbWFrZUxvbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGRpcm5hbWU6ZnVuY3Rpb24odCl7aWYoZSh0KSwwPT09dC5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciByPXQuY2hhckNvZGVBdCgwKSxuPTQ3PT09cixvPS0xLGk9ITAsYT10Lmxlbmd0aC0xO2E+PTE7LS1hKWlmKDQ3PT09KHI9dC5jaGFyQ29kZUF0KGEpKSl7aWYoIWkpe289YTticmVha319ZWxzZSBpPSExO3JldHVybi0xPT09bz9uP1wiL1wiOlwiLlwiOm4mJjE9PT1vP1wiLy9cIjp0LnNsaWNlKDAsbyl9LGJhc2VuYW1lOmZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7ZSh0KTt2YXIgbixvPTAsaT0tMSxhPSEwO2lmKHZvaWQgMCE9PXImJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD10Lmxlbmd0aCl7aWYoci5sZW5ndGg9PT10Lmxlbmd0aCYmcj09PXQpcmV0dXJuXCJcIjt2YXIgaD1yLmxlbmd0aC0xLHM9LTE7Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGM9dC5jaGFyQ29kZUF0KG4pO2lmKDQ3PT09Yyl7aWYoIWEpe289bisxO2JyZWFrfX1lbHNlLTE9PT1zJiYoYT0hMSxzPW4rMSksaD49MCYmKGM9PT1yLmNoYXJDb2RlQXQoaCk/LTE9PS0taCYmKGk9bik6KGg9LTEsaT1zKSl9cmV0dXJuIG89PT1pP2k9czotMT09PWkmJihpPXQubGVuZ3RoKSx0LnNsaWNlKG8saSl9Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbilpZig0Nz09PXQuY2hhckNvZGVBdChuKSl7aWYoIWEpe289bisxO2JyZWFrfX1lbHNlLTE9PT1pJiYoYT0hMSxpPW4rMSk7cmV0dXJuLTE9PT1pP1wiXCI6dC5zbGljZShvLGkpfSxleHRuYW1lOmZ1bmN0aW9uKHQpe2UodCk7Zm9yKHZhciByPS0xLG49MCxvPS0xLGk9ITAsYT0wLGg9dC5sZW5ndGgtMTtoPj0wOy0taCl7dmFyIHM9dC5jaGFyQ29kZUF0KGgpO2lmKDQ3IT09cyktMT09PW8mJihpPSExLG89aCsxKSw0Nj09PXM/LTE9PT1yP3I9aDoxIT09YSYmKGE9MSk6LTEhPT1yJiYoYT0tMSk7ZWxzZSBpZighaSl7bj1oKzE7YnJlYWt9fXJldHVybi0xPT09cnx8LTE9PT1vfHwwPT09YXx8MT09PWEmJnI9PT1vLTEmJnI9PT1uKzE/XCJcIjp0LnNsaWNlKHIsbyl9LGZvcm1hdDpmdW5jdGlvbih0KXtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kaXJ8fGUucm9vdCxuPWUuYmFzZXx8KGUubmFtZXx8XCJcIikrKGUuZXh0fHxcIlwiKTtyZXR1cm4gcj9yPT09ZS5yb290P3IrbjpyK1wiL1wiK246bn0oMCx0KX0scGFyc2U6ZnVuY3Rpb24odCl7ZSh0KTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gcjt2YXIgbixvPXQuY2hhckNvZGVBdCgwKSxpPTQ3PT09bztpPyhyLnJvb3Q9XCIvXCIsbj0xKTpuPTA7Zm9yKHZhciBhPS0xLGg9MCxzPS0xLGM9ITAsZj10Lmxlbmd0aC0xLHU9MDtmPj1uOy0tZilpZig0NyE9PShvPXQuY2hhckNvZGVBdChmKSkpLTE9PT1zJiYoYz0hMSxzPWYrMSksNDY9PT1vPy0xPT09YT9hPWY6MSE9PXUmJih1PTEpOi0xIT09YSYmKHU9LTEpO2Vsc2UgaWYoIWMpe2g9ZisxO2JyZWFrfXJldHVybi0xPT09YXx8LTE9PT1zfHwwPT09dXx8MT09PXUmJmE9PT1zLTEmJmE9PT1oKzE/LTEhPT1zJiYoci5iYXNlPXIubmFtZT0wPT09aCYmaT90LnNsaWNlKDEscyk6dC5zbGljZShoLHMpKTooMD09PWgmJmk/KHIubmFtZT10LnNsaWNlKDEsYSksci5iYXNlPXQuc2xpY2UoMSxzKSk6KHIubmFtZT10LnNsaWNlKGgsYSksci5iYXNlPXQuc2xpY2UoaCxzKSksci5leHQ9dC5zbGljZShhLHMpKSxoPjA/ci5kaXI9dC5zbGljZSgwLGgtMSk6aSYmKHIuZGlyPVwiL1wiKSxyfSxzZXA6XCIvXCIsZGVsaW1pdGVyOlwiOlwiLHdpbjMyOm51bGwscG9zaXg6bnVsbH07bi5wb3NpeD1uLHQuZXhwb3J0cz1ufX0sZT17fTtmdW5jdGlvbiByKG4pe3ZhciBvPWVbbl07aWYodm9pZCAwIT09bylyZXR1cm4gby5leHBvcnRzO3ZhciBpPWVbbl09e2V4cG9ydHM6e319O3JldHVybiB0W25dKGksaS5leHBvcnRzLHIpLGkuZXhwb3J0c31yLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlyLm8oZSxuKSYmIXIubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksci5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgbj17fTsoKCk9Pnt2YXIgdDtpZihyLnIobiksci5kKG4se1VSSTooKT0+ZyxVdGlsczooKT0+T30pLFwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzKXQ9XCJ3aW4zMlwiPT09cHJvY2Vzcy5wbGF0Zm9ybTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3Ipe3ZhciBlPW5hdmlnYXRvci51c2VyQWdlbnQ7dD1lLmluZGV4T2YoXCJXaW5kb3dzXCIpPj0wfXZhciBvLGksYT0obz1mdW5jdGlvbih0LGUpe3JldHVybiBvPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgciBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKX0sbyh0LGUpfSxmdW5jdGlvbih0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhlKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPXR9byh0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KHIucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyByKX0pLGg9L15cXHdbXFx3XFxkKy4tXSokLyxzPS9eXFwvLyxjPS9eXFwvXFwvLztmdW5jdGlvbiBmKHQsZSl7aWYoIXQuc2NoZW1lJiZlKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCInLmNvbmNhdCh0LmF1dGhvcml0eSwnXCIsIHBhdGg6IFwiJykuY29uY2F0KHQucGF0aCwnXCIsIHF1ZXJ5OiBcIicpLmNvbmNhdCh0LnF1ZXJ5LCdcIiwgZnJhZ21lbnQ6IFwiJykuY29uY2F0KHQuZnJhZ21lbnQsJ1wifScpKTtpZih0LnNjaGVtZSYmIWgudGVzdCh0LnNjaGVtZSkpdGhyb3cgbmV3IEVycm9yKFwiW1VyaUVycm9yXTogU2NoZW1lIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycy5cIik7aWYodC5wYXRoKWlmKHQuYXV0aG9yaXR5KXtpZighcy50ZXN0KHQucGF0aCkpdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKX1lbHNlIGlmKGMudGVzdCh0LnBhdGgpKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpbiB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpJyl9dmFyIHU9XCJcIixsPVwiL1wiLHA9L14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy8sZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxlLHIsbixvLGkpe3ZvaWQgMD09PWkmJihpPSExKSxcIm9iamVjdFwiPT10eXBlb2YgdD8odGhpcy5zY2hlbWU9dC5zY2hlbWV8fHUsdGhpcy5hdXRob3JpdHk9dC5hdXRob3JpdHl8fHUsdGhpcy5wYXRoPXQucGF0aHx8dSx0aGlzLnF1ZXJ5PXQucXVlcnl8fHUsdGhpcy5mcmFnbWVudD10LmZyYWdtZW50fHx1KToodGhpcy5zY2hlbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZT90OlwiZmlsZVwifSh0LGkpLHRoaXMuYXV0aG9yaXR5PWV8fHUsdGhpcy5wYXRoPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2VcImh0dHBzXCI6Y2FzZVwiaHR0cFwiOmNhc2VcImZpbGVcIjplP2VbMF0hPT1sJiYoZT1sK2UpOmU9bH1yZXR1cm4gZX0odGhpcy5zY2hlbWUscnx8dSksdGhpcy5xdWVyeT1ufHx1LHRoaXMuZnJhZ21lbnQ9b3x8dSxmKHRoaXMsaSkpfXJldHVybiBlLmlzVXJpPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZXx8ISF0JiZcInN0cmluZ1wiPT10eXBlb2YgdC5hdXRob3JpdHkmJlwic3RyaW5nXCI9PXR5cGVvZiB0LmZyYWdtZW50JiZcInN0cmluZ1wiPT10eXBlb2YgdC5wYXRoJiZcInN0cmluZ1wiPT10eXBlb2YgdC5xdWVyeSYmXCJzdHJpbmdcIj09dHlwZW9mIHQuc2NoZW1lJiZcInN0cmluZ1wiPT10eXBlb2YgdC5mc1BhdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQud2l0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC50b1N0cmluZ30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiZnNQYXRoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBDKHRoaXMsITEpfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLndpdGg9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIHRoaXM7dmFyIGU9dC5zY2hlbWUscj10LmF1dGhvcml0eSxuPXQucGF0aCxvPXQucXVlcnksaT10LmZyYWdtZW50O3JldHVybiB2b2lkIDA9PT1lP2U9dGhpcy5zY2hlbWU6bnVsbD09PWUmJihlPXUpLHZvaWQgMD09PXI/cj10aGlzLmF1dGhvcml0eTpudWxsPT09ciYmKHI9dSksdm9pZCAwPT09bj9uPXRoaXMucGF0aDpudWxsPT09biYmKG49dSksdm9pZCAwPT09bz9vPXRoaXMucXVlcnk6bnVsbD09PW8mJihvPXUpLHZvaWQgMD09PWk/aT10aGlzLmZyYWdtZW50Om51bGw9PT1pJiYoaT11KSxlPT09dGhpcy5zY2hlbWUmJnI9PT10aGlzLmF1dGhvcml0eSYmbj09PXRoaXMucGF0aCYmbz09PXRoaXMucXVlcnkmJmk9PT10aGlzLmZyYWdtZW50P3RoaXM6bmV3IHYoZSxyLG4sbyxpKX0sZS5wYXJzZT1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj1wLmV4ZWModCk7cmV0dXJuIHI/bmV3IHYoclsyXXx8dSxfKHJbNF18fHUpLF8ocls1XXx8dSksXyhyWzddfHx1KSxfKHJbOV18fHUpLGUpOm5ldyB2KHUsdSx1LHUsdSl9LGUuZmlsZT1mdW5jdGlvbihlKXt2YXIgcj11O2lmKHQmJihlPWUucmVwbGFjZSgvXFxcXC9nLGwpKSxlWzBdPT09bCYmZVsxXT09PWwpe3ZhciBuPWUuaW5kZXhPZihsLDIpOy0xPT09bj8ocj1lLnN1YnN0cmluZygyKSxlPWwpOihyPWUuc3Vic3RyaW5nKDIsbiksZT1lLnN1YnN0cmluZyhuKXx8bCl9cmV0dXJuIG5ldyB2KFwiZmlsZVwiLHIsZSx1LHUpfSxlLmZyb209ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHYodC5zY2hlbWUsdC5hdXRob3JpdHksdC5wYXRoLHQucXVlcnksdC5mcmFnbWVudCk7cmV0dXJuIGYoZSwhMCksZX0sZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSxBKHRoaXMsdCl9LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxlLnJldml2ZT1mdW5jdGlvbih0KXtpZih0KXtpZih0IGluc3RhbmNlb2YgZSlyZXR1cm4gdDt2YXIgcj1uZXcgdih0KTtyZXR1cm4gci5fZm9ybWF0dGVkPXQuZXh0ZXJuYWwsci5fZnNQYXRoPXQuX3NlcD09PWQ/dC5mc1BhdGg6bnVsbCxyfXJldHVybiB0fSxlfSgpLGQ9dD8xOnZvaWQgMCx2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuX2Zvcm1hdHRlZD1udWxsLGUuX2ZzUGF0aD1udWxsLGV9cmV0dXJuIGEoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJmc1BhdGhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZzUGF0aHx8KHRoaXMuX2ZzUGF0aD1DKHRoaXMsITEpKSx0aGlzLl9mc1BhdGh9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0P0EodGhpcywhMCk6KHRoaXMuX2Zvcm1hdHRlZHx8KHRoaXMuX2Zvcm1hdHRlZD1BKHRoaXMsITEpKSx0aGlzLl9mb3JtYXR0ZWQpfSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXt2YXIgdD17JG1pZDoxfTtyZXR1cm4gdGhpcy5fZnNQYXRoJiYodC5mc1BhdGg9dGhpcy5fZnNQYXRoLHQuX3NlcD1kKSx0aGlzLl9mb3JtYXR0ZWQmJih0LmV4dGVybmFsPXRoaXMuX2Zvcm1hdHRlZCksdGhpcy5wYXRoJiYodC5wYXRoPXRoaXMucGF0aCksdGhpcy5zY2hlbWUmJih0LnNjaGVtZT10aGlzLnNjaGVtZSksdGhpcy5hdXRob3JpdHkmJih0LmF1dGhvcml0eT10aGlzLmF1dGhvcml0eSksdGhpcy5xdWVyeSYmKHQucXVlcnk9dGhpcy5xdWVyeSksdGhpcy5mcmFnbWVudCYmKHQuZnJhZ21lbnQ9dGhpcy5mcmFnbWVudCksdH0sZX0oZykseT0oKGk9e30pWzU4XT1cIiUzQVwiLGlbNDddPVwiJTJGXCIsaVs2M109XCIlM0ZcIixpWzM1XT1cIiUyM1wiLGlbOTFdPVwiJTVCXCIsaVs5M109XCIlNURcIixpWzY0XT1cIiU0MFwiLGlbMzNdPVwiJTIxXCIsaVszNl09XCIlMjRcIixpWzM4XT1cIiUyNlwiLGlbMzldPVwiJTI3XCIsaVs0MF09XCIlMjhcIixpWzQxXT1cIiUyOVwiLGlbNDJdPVwiJTJBXCIsaVs0M109XCIlMkJcIixpWzQ0XT1cIiUyQ1wiLGlbNTldPVwiJTNCXCIsaVs2MV09XCIlM0RcIixpWzMyXT1cIiUyMFwiLGkpO2Z1bmN0aW9uIG0odCxlLHIpe2Zvcih2YXIgbj12b2lkIDAsbz0tMSxpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciBhPXQuY2hhckNvZGVBdChpKTtpZihhPj05NyYmYTw9MTIyfHxhPj02NSYmYTw9OTB8fGE+PTQ4JiZhPD01N3x8NDU9PT1hfHw0Nj09PWF8fDk1PT09YXx8MTI2PT09YXx8ZSYmNDc9PT1hfHxyJiY5MT09PWF8fHImJjkzPT09YXx8ciYmNTg9PT1hKS0xIT09byYmKG4rPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhvLGkpKSxvPS0xKSx2b2lkIDAhPT1uJiYobis9dC5jaGFyQXQoaSkpO2Vsc2V7dm9pZCAwPT09biYmKG49dC5zdWJzdHIoMCxpKSk7dmFyIGg9eVthXTt2b2lkIDAhPT1oPygtMSE9PW8mJihuKz1lbmNvZGVVUklDb21wb25lbnQodC5zdWJzdHJpbmcobyxpKSksbz0tMSksbis9aCk6LTE9PT1vJiYobz1pKX19cmV0dXJuLTEhPT1vJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKG8pKSksdm9pZCAwIT09bj9uOnR9ZnVuY3Rpb24gYih0KXtmb3IodmFyIGU9dm9pZCAwLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dC5jaGFyQ29kZUF0KHIpOzM1PT09bnx8NjM9PT1uPyh2b2lkIDA9PT1lJiYoZT10LnN1YnN0cigwLHIpKSxlKz15W25dKTp2b2lkIDAhPT1lJiYoZSs9dFtyXSl9cmV0dXJuIHZvaWQgMCE9PWU/ZTp0fWZ1bmN0aW9uIEMoZSxyKXt2YXIgbjtyZXR1cm4gbj1lLmF1dGhvcml0eSYmZS5wYXRoLmxlbmd0aD4xJiZcImZpbGVcIj09PWUuc2NoZW1lP1wiLy9cIi5jb25jYXQoZS5hdXRob3JpdHkpLmNvbmNhdChlLnBhdGgpOjQ3PT09ZS5wYXRoLmNoYXJDb2RlQXQoMCkmJihlLnBhdGguY2hhckNvZGVBdCgxKT49NjUmJmUucGF0aC5jaGFyQ29kZUF0KDEpPD05MHx8ZS5wYXRoLmNoYXJDb2RlQXQoMSk+PTk3JiZlLnBhdGguY2hhckNvZGVBdCgxKTw9MTIyKSYmNTg9PT1lLnBhdGguY2hhckNvZGVBdCgyKT9yP2UucGF0aC5zdWJzdHIoMSk6ZS5wYXRoWzFdLnRvTG93ZXJDYXNlKCkrZS5wYXRoLnN1YnN0cigyKTplLnBhdGgsdCYmKG49bi5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcIikpLG59ZnVuY3Rpb24gQSh0LGUpe3ZhciByPWU/YjptLG49XCJcIixvPXQuc2NoZW1lLGk9dC5hdXRob3JpdHksYT10LnBhdGgsaD10LnF1ZXJ5LHM9dC5mcmFnbWVudDtpZihvJiYobis9byxuKz1cIjpcIiksKGl8fFwiZmlsZVwiPT09bykmJihuKz1sLG4rPWwpLGkpe3ZhciBjPWkuaW5kZXhPZihcIkBcIik7aWYoLTEhPT1jKXt2YXIgZj1pLnN1YnN0cigwLGMpO2k9aS5zdWJzdHIoYysxKSwtMT09PShjPWYubGFzdEluZGV4T2YoXCI6XCIpKT9uKz1yKGYsITEsITEpOihuKz1yKGYuc3Vic3RyKDAsYyksITEsITEpLG4rPVwiOlwiLG4rPXIoZi5zdWJzdHIoYysxKSwhMSwhMCkpLG4rPVwiQFwifS0xPT09KGM9KGk9aS50b0xvd2VyQ2FzZSgpKS5sYXN0SW5kZXhPZihcIjpcIikpP24rPXIoaSwhMSwhMCk6KG4rPXIoaS5zdWJzdHIoMCxjKSwhMSwhMCksbis9aS5zdWJzdHIoYykpfWlmKGEpe2lmKGEubGVuZ3RoPj0zJiY0Nz09PWEuY2hhckNvZGVBdCgwKSYmNTg9PT1hLmNoYXJDb2RlQXQoMikpKHU9YS5jaGFyQ29kZUF0KDEpKT49NjUmJnU8PTkwJiYoYT1cIi9cIi5jb25jYXQoU3RyaW5nLmZyb21DaGFyQ29kZSh1KzMyKSxcIjpcIikuY29uY2F0KGEuc3Vic3RyKDMpKSk7ZWxzZSBpZihhLmxlbmd0aD49MiYmNTg9PT1hLmNoYXJDb2RlQXQoMSkpe3ZhciB1Oyh1PWEuY2hhckNvZGVBdCgwKSk+PTY1JiZ1PD05MCYmKGE9XCJcIi5jb25jYXQoU3RyaW5nLmZyb21DaGFyQ29kZSh1KzMyKSxcIjpcIikuY29uY2F0KGEuc3Vic3RyKDIpKSl9bis9cihhLCEwLCExKX1yZXR1cm4gaCYmKG4rPVwiP1wiLG4rPXIoaCwhMSwhMSkpLHMmJihuKz1cIiNcIixuKz1lP3M6bShzLCExLCExKSksbn1mdW5jdGlvbiB3KHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpfWNhdGNoKGUpe3JldHVybiB0Lmxlbmd0aD4zP3Quc3Vic3RyKDAsMykrdyh0LnN1YnN0cigzKSk6dH19dmFyIHg9LyglWzAtOUEtWmEtel1bMC05QS1aYS16XSkrL2c7ZnVuY3Rpb24gXyh0KXtyZXR1cm4gdC5tYXRjaCh4KT90LnJlcGxhY2UoeCwoZnVuY3Rpb24odCl7cmV0dXJuIHcodCl9KSk6dH12YXIgTyxQPXIoNDcwKSxqPWZ1bmN0aW9uKHQsZSxyKXtpZihyfHwyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG4sbz0wLGk9ZS5sZW5ndGg7bzxpO28rKykhbiYmbyBpbiBlfHwobnx8KG49QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSwwLG8pKSxuW29dPWVbb10pO3JldHVybiB0LmNvbmNhdChufHxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSl9LEk9UC5wb3NpeHx8UCxVPVwiL1wiOyFmdW5jdGlvbih0KXt0LmpvaW5QYXRoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO3JldHVybiB0LndpdGgoe3BhdGg6SS5qb2luLmFwcGx5KEksaihbdC5wYXRoXSxlLCExKSl9KX0sdC5yZXNvbHZlUGF0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTt2YXIgbj10LnBhdGgsbz0hMTtuWzBdIT09VSYmKG49VStuLG89ITApO3ZhciBpPUkucmVzb2x2ZS5hcHBseShJLGooW25dLGUsITEpKTtyZXR1cm4gbyYmaVswXT09PVUmJiF0LmF1dGhvcml0eSYmKGk9aS5zdWJzdHJpbmcoMSkpLHQud2l0aCh7cGF0aDppfSl9LHQuZGlybmFtZT1mdW5jdGlvbih0KXtpZigwPT09dC5wYXRoLmxlbmd0aHx8dC5wYXRoPT09VSlyZXR1cm4gdDt2YXIgZT1JLmRpcm5hbWUodC5wYXRoKTtyZXR1cm4gMT09PWUubGVuZ3RoJiY0Nj09PWUuY2hhckNvZGVBdCgwKSYmKGU9XCJcIiksdC53aXRoKHtwYXRoOmV9KX0sdC5iYXNlbmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gSS5iYXNlbmFtZSh0LnBhdGgpfSx0LmV4dG5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIEkuZXh0bmFtZSh0LnBhdGgpfX0oT3x8KE89e30pKX0pKCksTElCPW59KSgpO2NvbnN0e1VSSSxVdGlsc309TElCO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2dsb2IuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDEzLCBOaWNrIEZpdHpnZXJhbGRcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMSUNFTkNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2V4KGdsb2IsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIGdsb2IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0ciA9IFN0cmluZyhnbG9iKTtcbiAgICAvLyBUaGUgcmVnZXhwIHdlIGFyZSBidWlsZGluZywgYXMgYSBzdHJpbmcuXG4gICAgbGV0IHJlU3RyID0gXCJcIjtcbiAgICAvLyBXaGV0aGVyIHdlIGFyZSBtYXRjaGluZyBzbyBjYWxsZWQgXCJleHRlbmRlZFwiIGdsb2JzIChsaWtlIGJhc2gpIGFuZCBzaG91bGRcbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hpbmcsIG1hdGNoaW5nIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLCBncm91cFxuICAgIC8vIG1hdGNoaW5nLCBldGMuXG4gICAgY29uc3QgZXh0ZW5kZWQgPSBvcHRzID8gISFvcHRzLmV4dGVuZGVkIDogZmFsc2U7XG4gICAgLy8gV2hlbiBnbG9ic3RhciBpcyBfZmFsc2VfIChkZWZhdWx0KSwgJy9mb28vKicgaXMgdHJhbnNsYXRlZCBhIHJlZ2V4cCBsaWtlXG4gICAgLy8gJ15cXC9mb29cXC8uKiQnIHdoaWNoIHdpbGwgbWF0Y2ggYW55IHN0cmluZyBiZWdpbm5pbmcgd2l0aCAnL2Zvby8nXG4gICAgLy8gV2hlbiBnbG9ic3RhciBpcyBfdHJ1ZV8sICcvZm9vLyonIGlzIHRyYW5zbGF0ZWQgdG8gcmVnZXhwIGxpa2VcbiAgICAvLyAnXlxcL2Zvb1xcL1teL10qJCcgd2hpY2ggd2lsbCBtYXRjaCBhbnkgc3RyaW5nIGJlZ2lubmluZyB3aXRoICcvZm9vLycgQlVUXG4gICAgLy8gd2hpY2ggZG9lcyBub3QgaGF2ZSBhICcvJyB0byB0aGUgcmlnaHQgb2YgaXQuXG4gICAgLy8gRS5nLiB3aXRoICcvZm9vLyonIHRoZXNlIHdpbGwgbWF0Y2g6ICcvZm9vL2JhcicsICcvZm9vL2Jhci50eHQnIGJ1dFxuICAgIC8vIHRoZXNlIHdpbGwgbm90ICcvZm9vL2Jhci9iYXonLCAnL2Zvby9iYXIvYmF6LnR4dCdcbiAgICAvLyBMYXN0ZWx5LCB3aGVuIGdsb2JzdGFyIGlzIF90cnVlXywgJy9mb28vKionIGlzIGVxdWl2ZWxhbnQgdG8gJy9mb28vKicgd2hlblxuICAgIC8vIGdsb2JzdGFyIGlzIF9mYWxzZV9cbiAgICBjb25zdCBnbG9ic3RhciA9IG9wdHMgPyAhIW9wdHMuZ2xvYnN0YXIgOiBmYWxzZTtcbiAgICAvLyBJZiB3ZSBhcmUgZG9pbmcgZXh0ZW5kZWQgbWF0Y2hpbmcsIHRoaXMgYm9vbGVhbiBpcyB0cnVlIHdoZW4gd2UgYXJlIGluc2lkZVxuICAgIC8vIGEgZ3JvdXAgKGVnIHsqLmh0bWwsKi5qc30pLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgIGxldCBpbkdyb3VwID0gZmFsc2U7XG4gICAgLy8gUmVnRXhwIGZsYWdzIChlZyBcImlcIiApIHRvIHBhc3MgaW4gdG8gUmVnRXhwIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0IGZsYWdzID0gb3B0cyAmJiB0eXBlb2YgKG9wdHMuZmxhZ3MpID09PSBcInN0cmluZ1wiID8gb3B0cy5mbGFncyA6IFwiXCI7XG4gICAgbGV0IGM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjID0gc3RyW2ldO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgICAgICAgICAgcmVTdHIgKz0gXCJcXFxcXCIgKyBjO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIuXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgICAgICAgaWYgKGluR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCJ8XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZVN0ciArPSBcIlxcXFxcIiArIGM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgb3ZlciBhbGwgY29uc2VjdXRpdmUgXCIqXCIncy5cbiAgICAgICAgICAgICAgICAvLyBBbHNvIHN0b3JlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoYXIgPSBzdHJbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGxldCBzdGFyQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJbaSArIDFdID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHN0cltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFnbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBnbG9ic3RhciBpcyBkaXNhYmxlZCwgc28gdHJlYXQgYW55IG51bWJlciBvZiBcIipcIiBhcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIuKlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYnN0YXIgaXMgZW5hYmxlZCwgc28gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBnbG9ic3RhciBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzR2xvYnN0YXIgPSBzdGFyQ291bnQgPiAxIC8vIG11bHRpcGxlIFwiKlwiJ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChwcmV2Q2hhciA9PT0gXCIvXCIgfHwgcHJldkNoYXIgPT09IHVuZGVmaW5lZCB8fCBwcmV2Q2hhciA9PT0gJ3snIHx8IHByZXZDaGFyID09PSAnLCcpIC8vIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAobmV4dENoYXIgPT09IFwiL1wiIHx8IG5leHRDaGFyID09PSB1bmRlZmluZWQgfHwgbmV4dENoYXIgPT09ICcsJyB8fCBuZXh0Q2hhciA9PT0gJ30nKTsgLy8gdG8gdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNHbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKzsgLy8gbW92ZSBvdmVyIHRoZSBcIi9cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldkNoYXIgPT09ICcvJyAmJiByZVN0ci5lbmRzV2l0aCgnXFxcXC8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlU3RyID0gcmVTdHIuc3Vic3RyKDAsIHJlU3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBhIGdsb2JzdGFyLCBzbyBtYXRjaCB6ZXJvIG9yIG1vcmUgcGF0aCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoKD86W14vXSooPzpcXC98JCkpKilcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IGEgZ2xvYnN0YXIsIHNvIG9ubHkgbWF0Y2ggb25lIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoW14vXSopXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlU3RyICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiByZWdleHAgJ2cnIGZsYWcgaXMgc3BlY2lmaWVkIGRvbid0XG4gICAgLy8gY29uc3RyYWluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBeICYgJFxuICAgIGlmICghZmxhZ3MgfHwgIX5mbGFncy5pbmRleE9mKCdnJykpIHtcbiAgICAgICAgcmVTdHIgPSBcIl5cIiArIHJlU3RyICsgXCIkXCI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJlU3RyLCBmbGFncyk7XG59XG47XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvblNjaGVtYVNlcnZpY2UuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cblxuXG5jb25zdCBCQU5HID0gJyEnO1xuY29uc3QgUEFUSF9TRVAgPSAnLyc7XG5jbGFzcyBGaWxlUGF0dGVybkFzc29jaWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBmb2xkZXJVcmksIHVyaXMpIHtcbiAgICAgICAgdGhpcy5mb2xkZXJVcmkgPSBmb2xkZXJVcmk7XG4gICAgICAgIHRoaXMudXJpcyA9IHVyaXM7XG4gICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXR0ZXJuU3RyaW5nIG9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdWRlID0gcGF0dGVyblN0cmluZ1swXSAhPT0gQkFORztcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0cmluZyA9IHBhdHRlcm5TdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVyblN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuU3RyaW5nWzBdID09PSBQQVRIX1NFUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0cmluZyA9IHBhdHRlcm5TdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwOiBjcmVhdGVSZWdleCgnKiovJyArIHBhdHRlcm5TdHJpbmcsIHsgZXh0ZW5kZWQ6IHRydWUsIGdsb2JzdGFyOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZTogaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKGZvbGRlclVyaSkge1xuICAgICAgICAgICAgICAgIGZvbGRlclVyaSA9IG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcoZm9sZGVyVXJpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbGRlclVyaS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRlclVyaSA9IGZvbGRlclVyaSArICcvJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mb2xkZXJVcmkgPSBmb2xkZXJVcmk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnVyaXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaGVzUGF0dGVybihmaWxlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5mb2xkZXJVcmkgJiYgIWZpbGVOYW1lLnN0YXJ0c1dpdGgodGhpcy5mb2xkZXJVcmkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgeyByZWdleHAsIGluY2x1ZGUgfSBvZiB0aGlzLmdsb2JXcmFwcGVycykge1xuICAgICAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gaW5jbHVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIGdldFVSSXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVyaXM7XG4gICAgfVxufVxuY2xhc3MgU2NoZW1hSGFuZGxlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCB1cmksIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMudXJpID0gdXJpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5hbmNob3JzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuc2VydmljZS5wcm9taXNlLnJlc29sdmUobmV3IFVucmVzb2x2ZWRTY2hlbWEodW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRVbnJlc29sdmVkU2NoZW1hKCkge1xuICAgICAgICBpZiAoIXRoaXMudW5yZXNvbHZlZFNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy51bnJlc29sdmVkU2NoZW1hID0gdGhpcy5zZXJ2aWNlLmxvYWRTY2hlbWEodGhpcy51cmkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVucmVzb2x2ZWRTY2hlbWE7XG4gICAgfVxuICAgIGdldFJlc29sdmVkU2NoZW1hKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRTY2hlbWEgPSB0aGlzLmdldFVucmVzb2x2ZWRTY2hlbWEoKS50aGVuKHVucmVzb2x2ZWQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2UucmVzb2x2ZVNjaGVtYUNvbnRlbnQodW5yZXNvbHZlZCwgdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFNjaGVtYTtcbiAgICB9XG4gICAgY2xlYXJTY2hlbWEoKSB7XG4gICAgICAgIGNvbnN0IGhhc0NoYW5nZXMgPSAhIXRoaXMudW5yZXNvbHZlZFNjaGVtYTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51bnJlc29sdmVkU2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmFuY2hvcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBoYXNDaGFuZ2VzO1xuICAgIH1cbn1cbmNsYXNzIFVucmVzb2x2ZWRTY2hlbWEge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgZXJyb3JzID0gW10pIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbn1cbmNsYXNzIFJlc29sdmVkU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGVycm9ycyA9IFtdLCB3YXJuaW5ncyA9IFtdLCBzY2hlbWFEcmFmdCkge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICAgICAgdGhpcy5zY2hlbWFEcmFmdCA9IHNjaGVtYURyYWZ0O1xuICAgIH1cbiAgICBnZXRTZWN0aW9uKHBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hUmVmID0gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaGVtYVJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGFzU2NoZW1hKHNjaGVtYVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEgfHwgdHlwZW9mIHNjaGVtYSA9PT0gJ2Jvb2xlYW4nIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLnByb3BlcnRpZXNbbmV4dF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hLnByb3BlcnRpZXNbbmV4dF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4dGVuZGVkUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleD8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV4dC5tYXRjaCgnWzAtOV0rJykpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KG5leHQsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGluZGV4KSAmJiBzY2hlbWEuaXRlbXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hLml0ZW1zW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEuaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgSlNPTlNjaGVtYVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3RTZXJ2aWNlLCBjb250ZXh0U2VydmljZSwgcHJvbWlzZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFNlcnZpY2UgPSBjb250ZXh0U2VydmljZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2VydmljZSA9IHJlcXVlc3RTZXJ2aWNlO1xuICAgICAgICB0aGlzLnByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgICAgICB0aGlzLmNhbGxPbkRpc3Bvc2UgPSBbXTtcbiAgICAgICAgdGhpcy5jb250cmlidXRpb25TY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuc2NoZW1hc0J5SWQgPSB7fTtcbiAgICAgICAgdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzID0ge307XG4gICAgfVxuICAgIGdldFJlZ2lzdGVyZWRTY2hlbWFJZHMoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzKS5maWx0ZXIoaWQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gVVJJLnBhcnNlKGlkKS5zY2hlbWU7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1lICE9PSAnc2NoZW1hc2VydmljZScgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNjaGVtZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2FsbE9uRGlzcG9zZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxPbkRpc3Bvc2UucG9wKCkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlc291cmNlQ2hhbmdlKHVyaSkge1xuICAgICAgICAvLyBhbHdheXMgY2xlYXIgdGhpcyBsb2NhbCBjYWNoZSB3aGVuIGEgcmVzb3VyY2UgY2hhbmdlc1xuICAgICAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB1cmkgPSBub3JtYWxpemVJZCh1cmkpO1xuICAgICAgICBjb25zdCB0b1dhbGsgPSBbdXJpXTtcbiAgICAgICAgY29uc3QgYWxsID0gT2JqZWN0LmtleXModGhpcy5zY2hlbWFzQnlJZCkubWFwKGtleSA9PiB0aGlzLnNjaGVtYXNCeUlkW2tleV0pO1xuICAgICAgICB3aGlsZSAodG9XYWxrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY3VyciA9IHRvV2Fsay5wb3AoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gYWxsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgKGhhbmRsZS51cmkgPT09IGN1cnIgfHwgaGFuZGxlLmRlcGVuZGVuY2llcy5oYXMoY3VycikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUudXJpICE9PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1dhbGsucHVzaChoYW5kbGUudXJpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlLmNsZWFyU2NoZW1hKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFsbFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc0NoYW5nZXM7XG4gICAgfVxuICAgIHNldFNjaGVtYUNvbnRyaWJ1dGlvbnMoc2NoZW1hQ29udHJpYnV0aW9ucykge1xuICAgICAgICBpZiAoc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFzID0gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hc1tub3JtYWxpemVkSWRdID0gdGhpcy5hZGRTY2hlbWFIYW5kbGUobm9ybWFsaXplZElkLCBzY2hlbWFzW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFBc3NvY2lhdGlvbnMpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWFBc3NvY2lhdGlvbnMgPSBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYUFzc29jaWF0aW9ucztcbiAgICAgICAgICAgIGZvciAobGV0IHNjaGVtYUFzc29jaWF0aW9uIG9mIHNjaGVtYUFzc29jaWF0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVyaXMgPSBzY2hlbWFBc3NvY2lhdGlvbi51cmlzLm1hcChub3JtYWxpemVJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzLmFkZEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24oc2NoZW1hQXNzb2NpYXRpb24ucGF0dGVybiwgc2NoZW1hQXNzb2NpYXRpb24uZm9sZGVyVXJpLCB1cmlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbkFzc29jaWF0aW9ucy5wdXNoKGFzc29jaWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRTY2hlbWFIYW5kbGUoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYUhhbmRsZSA9IG5ldyBTY2hlbWFIYW5kbGUodGhpcywgaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzQnlJZFtpZF0gPSBzY2hlbWFIYW5kbGU7XG4gICAgICAgIHJldHVybiBzY2hlbWFIYW5kbGU7XG4gICAgfVxuICAgIGdldE9yQWRkU2NoZW1hSGFuZGxlKGlkLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWFzQnlJZFtpZF0gfHwgdGhpcy5hZGRTY2hlbWFIYW5kbGUoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KTtcbiAgICB9XG4gICAgYWRkRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihwYXR0ZXJuLCBmb2xkZXJVcmksIHVyaXMpIHtcbiAgICAgICAgY29uc3QgZnBhID0gbmV3IEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24ocGF0dGVybiwgZm9sZGVyVXJpLCB1cmlzKTtcbiAgICAgICAgdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9ucy5wdXNoKGZwYSk7XG4gICAgICAgIHJldHVybiBmcGE7XG4gICAgfVxuICAgIHJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWQoY29uZmlnLnVyaSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNvbmZpZy5maWxlTWF0Y2ggJiYgY29uZmlnLmZpbGVNYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihjb25maWcuZmlsZU1hdGNoLCBjb25maWcuZm9sZGVyVXJpLCBbaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLnNjaGVtYSA/IHRoaXMuYWRkU2NoZW1hSGFuZGxlKGlkLCBjb25maWcuc2NoZW1hKSA6IHRoaXMuZ2V0T3JBZGRTY2hlbWFIYW5kbGUoaWQpO1xuICAgIH1cbiAgICBjbGVhckV4dGVybmFsU2NoZW1hcygpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzQnlJZCA9IHt9O1xuICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNvbnRyaWJ1dGlvblNjaGVtYXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hc0J5SWRbaWRdID0gdGhpcy5jb250cmlidXRpb25TY2hlbWFzW2lkXTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyaWJ1dGlvbkFzc29jaWF0aW9uIG9mIHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zLnB1c2goY29udHJpYnV0aW9uQXNzb2NpYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlc29sdmVkU2NoZW1hKHNjaGVtYUlkKSB7XG4gICAgICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWQoc2NoZW1hSWQpO1xuICAgICAgICBjb25zdCBzY2hlbWFIYW5kbGUgPSB0aGlzLnNjaGVtYXNCeUlkW2lkXTtcbiAgICAgICAgaWYgKHNjaGVtYUhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYUhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBsb2FkU2NoZW1hKHVybCkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdFNlcnZpY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHQoJ1VuYWJsZSB0byBsb2FkIHNjaGVtYSBmcm9tIFxcJ3swfVxcJy4gTm8gc2NoZW1hIHJlcXVlc3Qgc2VydmljZSBhdmFpbGFibGUnLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobmV3IFVucmVzb2x2ZWRTY2hlbWEoe30sIFtlcnJvck1lc3NhZ2VdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFNlcnZpY2UodXJsKS50aGVuKGNvbnRlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gdCgnVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gXFwnezB9XFwnOiBObyBjb250ZW50LicsIHRvRGlzcGxheVN0cmluZyh1cmwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoe30sIFtlcnJvck1lc3NhZ2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gNjUyNzkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0KCdQcm9ibGVtIHJlYWRpbmcgY29udGVudCBmcm9tIFxcJ3swfVxcJzogVVRGLTggd2l0aCBCT00gZGV0ZWN0ZWQsIG9ubHkgVVRGIDggaXMgYWxsb3dlZC4nLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSkpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNjaGVtYUNvbnRlbnQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHNjaGVtYUNvbnRlbnQgPSBtYWluX3BhcnNlKGNvbnRlbnQsIGpzb25FcnJvcnMpO1xuICAgICAgICAgICAgaWYgKGpzb25FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godCgnVW5hYmxlIHRvIHBhcnNlIGNvbnRlbnQgZnJvbSBcXCd7MH1cXCc6IFBhcnNlIGVycm9yIGF0IG9mZnNldCB7MX0uJywgdG9EaXNwbGF5U3RyaW5nKHVybCksIGpzb25FcnJvcnNbMF0ub2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoc2NoZW1hQ29udGVudCwgZXJyb3JzKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yU3BsaXQgPSBlcnJvci50b1N0cmluZygpLnNwbGl0KCdFcnJvcjogJyk7XG4gICAgICAgICAgICBpZiAoZXJyb3JTcGxpdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9yZSBjb25jaXNlIGVycm9yIG1lc3NhZ2UsIFVSTCBhbmQgY29udGV4dCBhcmUgYXR0YWNoZWQgYnkgY2FsbGVyIGFueXdheXNcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvclNwbGl0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZHNXaXRoKGVycm9yTWVzc2FnZSwgJy4nKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZS5zdWJzdHIoMCwgZXJyb3JNZXNzYWdlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnJlc29sdmVkU2NoZW1hKHt9LCBbdCgnVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gXFwnezB9XFwnOiB7MX0uJywgdG9EaXNwbGF5U3RyaW5nKHVybCksIGVycm9yTWVzc2FnZSldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVTY2hlbWFDb250ZW50KHNjaGVtYVRvUmVzb2x2ZSwgaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVFcnJvcnMgPSBzY2hlbWFUb1Jlc29sdmUuZXJyb3JzLnNsaWNlKDApO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFUb1Jlc29sdmUuc2NoZW1hO1xuICAgICAgICBsZXQgc2NoZW1hRHJhZnQgPSBzY2hlbWEuJHNjaGVtYSA/IG5vcm1hbGl6ZUlkKHNjaGVtYS4kc2NoZW1hKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNjaGVtYURyYWZ0ID09PSAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wMy9zY2hlbWEnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobmV3IFJlc29sdmVkU2NoZW1hKHt9LCBbdChcIkRyYWZ0LTAzIHNjaGVtYXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpXSwgW10sIHNjaGVtYURyYWZ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBjb250ZXh0U2VydmljZSA9IHRoaXMuY29udGV4dFNlcnZpY2U7XG4gICAgICAgIGNvbnN0IGZpbmRTZWN0aW9uQnlKU09OUG9pbnRlciA9IChzY2hlbWEsIHBhdGgpID0+IHtcbiAgICAgICAgICAgIHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQocGF0aCk7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHNjaGVtYTtcbiAgICAgICAgICAgIGlmIChwYXRoWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLnNwbGl0KCcvJykuc29tZSgocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaW5kU2NoZW1hQnlJZCA9IChzY2hlbWEsIGhhbmRsZSwgaWQpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlLmFuY2hvcnMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUuYW5jaG9ycyA9IGNvbGxlY3RBbmNob3JzKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlLmFuY2hvcnMuZ2V0KGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVyZ2UgPSAodGFyZ2V0LCBzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09ICdpZCcgJiYga2V5ICE9PSAnJGlkJykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNlY3Rpb25ba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lcmdlUmVmID0gKHRhcmdldCwgc291cmNlUm9vdCwgc291cmNlSGFuZGxlLCByZWZTZWdtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2VjdGlvbjtcbiAgICAgICAgICAgIGlmIChyZWZTZWdtZW50ID09PSB1bmRlZmluZWQgfHwgcmVmU2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gc291cmNlUm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZlNlZ21lbnQuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAvLyBBICRyZWYgdG8gYSBKU09OIFBvaW50ZXIgKGkuZSAjL2RlZmluaXRpb25zL2ZvbylcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZmluZFNlY3Rpb25CeUpTT05Qb2ludGVyKHNvdXJjZVJvb3QsIHJlZlNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQSAkcmVmIHRvIGEgc3ViLXNjaGVtYSB3aXRoIGFuICRpZCAoaS5lICNoZWxsbylcbiAgICAgICAgICAgICAgICBzZWN0aW9uID0gZmluZFNjaGVtYUJ5SWQoc291cmNlUm9vdCwgc291cmNlSGFuZGxlLCByZWZTZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0LCBzZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaCh0KCckcmVmIFxcJ3swfVxcJyBpbiBcXCd7MX1cXCcgY2FuIG5vdCBiZSByZXNvbHZlZC4nLCByZWZTZWdtZW50IHx8ICcnLCBzb3VyY2VIYW5kbGUudXJpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVFeHRlcm5hbExpbmsgPSAobm9kZSwgdXJpLCByZWZTZWdtZW50LCBwYXJlbnRIYW5kbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0U2VydmljZSAmJiAhL15bQS1aYS16XVtBLVphLXowLTkrXFwtLitdKjpcXC9cXC8uKi8udGVzdCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgdXJpID0gY29udGV4dFNlcnZpY2UucmVzb2x2ZVJlbGF0aXZlUGF0aCh1cmksIHBhcmVudEhhbmRsZS51cmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJpID0gbm9ybWFsaXplSWQodXJpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZWRIYW5kbGUgPSB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKHVyaSk7XG4gICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlZEhhbmRsZS5nZXRVbnJlc29sdmVkU2NoZW1hKCkudGhlbih1bnJlc29sdmVkU2NoZW1hID0+IHtcbiAgICAgICAgICAgICAgICBwYXJlbnRIYW5kbGUuZGVwZW5kZW5jaWVzLmFkZCh1cmkpO1xuICAgICAgICAgICAgICAgIGlmICh1bnJlc29sdmVkU2NoZW1hLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jID0gcmVmU2VnbWVudCA/IHVyaSArICcjJyArIHJlZlNlZ21lbnQgOiB1cmk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaCh0KCdQcm9ibGVtcyBsb2FkaW5nIHJlZmVyZW5jZSBcXCd7MH1cXCc6IHsxfScsIGxvYywgdW5yZXNvbHZlZFNjaGVtYS5lcnJvcnNbMF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2VSZWYobm9kZSwgdW5yZXNvbHZlZFNjaGVtYS5zY2hlbWEsIHJlZmVyZW5jZWRIYW5kbGUsIHJlZlNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlUmVmcyhub2RlLCB1bnJlc29sdmVkU2NoZW1hLnNjaGVtYSwgcmVmZXJlbmNlZEhhbmRsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZVJlZnMgPSAobm9kZSwgcGFyZW50U2NoZW1hLCBwYXJlbnRIYW5kbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5Qcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50cmF2ZXJzZU5vZGVzKG5vZGUsIG5leHQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZW5SZWZzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0LiRyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gbmV4dC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IHJlZi5zcGxpdCgnIycsIDIpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbmV4dC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJlZmVyZW5jZSB0byBhbiBleHRlcm5hbCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Qcm9taXNlcy5wdXNoKHJlc29sdmVFeHRlcm5hbExpbmsobmV4dCwgc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdLCBwYXJlbnRIYW5kbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZWZlcmVuY2UgaW5zaWRlIHRoZSBjdXJyZW50IHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuUmVmcy5oYXMocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gc2VnbWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZWYobmV4dCwgcGFyZW50U2NoZW1hLCBwYXJlbnRIYW5kbGUsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuUmVmcy5hZGQocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kcmVjdXJzaXZlUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzLmFkZCgnJHJlY3Vyc2l2ZVJlZicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kZHluYW1pY1JlZikge1xuICAgICAgICAgICAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoJyRkeW5hbWljUmVmJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLmFsbChvcGVuUHJvbWlzZXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb2xsZWN0QW5jaG9ycyA9IChyb290KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnRyYXZlcnNlTm9kZXMocm9vdCwgbmV4dCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBuZXh0LiRpZCB8fCBuZXh0LmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGlzU3RyaW5nKGlkKSAmJiBpZC5jaGFyQXQoMCkgPT09ICcjJyA/IGlkLnN1YnN0cmluZygxKSA6IG5leHQuJGFuY2hvcjtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaGFzKGFuY2hvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaCh0KCdEdXBsaWNhdGUgYW5jaG9yIGRlY2xhcmF0aW9uOiBcXCd7MH1cXCcnLCBhbmNob3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoYW5jaG9yLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kcmVjdXJzaXZlQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXNVbnN1cHBvcnRlZEZlYXR1cmVzLmFkZCgnJHJlY3Vyc2l2ZUFuY2hvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dC4kZHluYW1pY0FuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoJyRkeW5hbWljQW5jaG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZnMoc2NoZW1hLCBzY2hlbWEsIGhhbmRsZSkudGhlbihfID0+IHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlV2FybmluZ3MgPSBbXTtcbiAgICAgICAgICAgIGlmICh1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVdhcm5pbmdzLnB1c2godCgnVGhlIHNjaGVtYSB1c2VzIG1ldGEtc2NoZW1hIGZlYXR1cmVzICh7MH0pIHRoYXQgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IHRoZSB2YWxpZGF0b3IuJywgQXJyYXkuZnJvbSh1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5rZXlzKCkpLmpvaW4oJywgJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTY2hlbWEoc2NoZW1hLCByZXNvbHZlRXJyb3JzLCByZXNvbHZlV2FybmluZ3MsIHNjaGVtYURyYWZ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYXZlcnNlTm9kZXMocm9vdCwgaGFuZGxlKSB7XG4gICAgICAgIGlmICghcm9vdCB8fCB0eXBlb2Ygcm9vdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgY29sbGVjdEVudHJpZXMgPSAoLi4uZW50cmllcykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICB0b1dhbGsucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb2xsZWN0TWFwRW50cmllcyA9ICguLi5tYXBzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIG1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoZW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb2xsZWN0QXJyYXlFbnRyaWVzID0gKC4uLmFycmF5cykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29sbGVjdEVudHJ5T3JBcnJheUVudHJpZXMgPSAoaXRlbXMpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QoaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b1dhbGsgPSBbcm9vdF07XG4gICAgICAgIGxldCBuZXh0ID0gdG9XYWxrLnBvcCgpO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgICAgaWYgKCFzZWVuLmhhcyhuZXh0KSkge1xuICAgICAgICAgICAgICAgIHNlZW4uYWRkKG5leHQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZShuZXh0KTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0RW50cmllcyhuZXh0LmFkZGl0aW9uYWxJdGVtcywgbmV4dC5hZGRpdGlvbmFsUHJvcGVydGllcywgbmV4dC5ub3QsIG5leHQuY29udGFpbnMsIG5leHQucHJvcGVydHlOYW1lcywgbmV4dC5pZiwgbmV4dC50aGVuLCBuZXh0LmVsc2UsIG5leHQudW5ldmFsdWF0ZWRJdGVtcywgbmV4dC51bmV2YWx1YXRlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RNYXBFbnRyaWVzKG5leHQuZGVmaW5pdGlvbnMsIG5leHQuJGRlZnMsIG5leHQucHJvcGVydGllcywgbmV4dC5wYXR0ZXJuUHJvcGVydGllcywgbmV4dC5kZXBlbmRlbmNpZXMsIG5leHQuZGVwZW5kZW50U2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgY29sbGVjdEFycmF5RW50cmllcyhuZXh0LmFueU9mLCBuZXh0LmFsbE9mLCBuZXh0Lm9uZU9mLCBuZXh0LnByZWZpeEl0ZW1zKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0RW50cnlPckFycmF5RW50cmllcyhuZXh0Lml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSB0b1dhbGsucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGdldFNjaGVtYUZyb21Qcm9wZXJ0eShyZXNvdXJjZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJvb3Q/LnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgZG9jdW1lbnQucm9vdC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAua2V5Tm9kZS52YWx1ZSA9PT0gJyRzY2hlbWEnICYmIHAudmFsdWVOb2RlPy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NoZW1hSWQgPSBwLnZhbHVlTm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dFNlcnZpY2UgJiYgIS9eXFx3W1xcd1xcZCsuLV0qOi8udGVzdChzY2hlbWFJZCkpIHsgLy8gaGFzIHNjaGVtZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hSWQgPSB0aGlzLmNvbnRleHRTZXJ2aWNlLnJlc29sdmVSZWxhdGl2ZVBhdGgoc2NoZW1hSWQsIHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1hSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldEFzc29jaWF0ZWRTY2hlbWFzKHJlc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBzY2hlbWFzID0gW107XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRSZXNvdXJjZSA9IG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcocmVzb3VyY2UpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5tYXRjaGVzUGF0dGVybihub3JtYWxpemVkUmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWFJZCBvZiBlbnRyeS5nZXRVUklzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW3NjaGVtYUlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hcy5wdXNoKHNjaGVtYUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5bc2NoZW1hSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hcztcbiAgICB9XG4gICAgZ2V0U2NoZW1hVVJJc0ZvclJlc291cmNlKHJlc291cmNlLCBkb2N1bWVudCkge1xuICAgICAgICBsZXQgc2NoZW1lSWQgPSBkb2N1bWVudCAmJiB0aGlzLmdldFNjaGVtYUZyb21Qcm9wZXJ0eShyZXNvdXJjZSwgZG9jdW1lbnQpO1xuICAgICAgICBpZiAoc2NoZW1lSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbc2NoZW1lSWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFzc29jaWF0ZWRTY2hlbWFzKHJlc291cmNlKTtcbiAgICB9XG4gICAgZ2V0U2NoZW1hRm9yUmVzb3VyY2UocmVzb3VyY2UsIGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdXNlICRzY2hlbWEgaWYgcHJlc2VudFxuICAgICAgICAgICAgbGV0IHNjaGVtZUlkID0gdGhpcy5nZXRTY2hlbWFGcm9tUHJvcGVydHkocmVzb3VyY2UsIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChzY2hlbWVJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWQoc2NoZW1lSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKGlkKS5nZXRSZXNvbHZlZFNjaGVtYSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlICYmIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZS5yZXNvbHZlZFNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2hlbWFzID0gdGhpcy5nZXRBc3NvY2lhdGVkU2NoZW1hcyhyZXNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gc2NoZW1hcy5sZW5ndGggPiAwID8gdGhpcy5jcmVhdGVDb21iaW5lZFNjaGVtYShyZXNvdXJjZSwgc2NoZW1hcykuZ2V0UmVzb2x2ZWRTY2hlbWEoKSA6IHRoaXMucHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgPSB7IHJlc291cmNlLCByZXNvbHZlZFNjaGVtYSB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG4gICAgfVxuICAgIGNyZWF0ZUNvbWJpbmVkU2NoZW1hKHJlc291cmNlLCBzY2hlbWFJZHMpIHtcbiAgICAgICAgaWYgKHNjaGVtYUlkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKHNjaGVtYUlkc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFNjaGVtYUlkID0gJ3NjaGVtYXNlcnZpY2U6Ly9jb21iaW5lZFNjaGVtYS8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkU2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGFsbE9mOiBzY2hlbWFJZHMubWFwKHNjaGVtYUlkID0+ICh7ICRyZWY6IHNjaGVtYUlkIH0pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNjaGVtYUhhbmRsZShjb21iaW5lZFNjaGVtYUlkLCBjb21iaW5lZFNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWF0Y2hpbmdTY2hlbWFzKGRvY3VtZW50LCBqc29uRG9jdW1lbnQsIHNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS5pZCB8fCAoJ3NjaGVtYXNlcnZpY2U6Ly91bnRpdGxlZC9tYXRjaGluZ1NjaGVtYXMvJyArIGpzb25TY2hlbWFTZXJ2aWNlX2lkQ291bnRlcisrKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuYWRkU2NoZW1hSGFuZGxlKGlkLCBzY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpLnRoZW4ocmVzb2x2ZWRTY2hlbWEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uRG9jdW1lbnQuZ2V0TWF0Y2hpbmdTY2hlbWFzKHJlc29sdmVkU2NoZW1hLnNjaGVtYSkuZmlsdGVyKHMgPT4gIXMuaW52ZXJ0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpLnRoZW4oc2NoZW1hID0+IHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbkRvY3VtZW50LmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hKS5maWx0ZXIocyA9PiAhcy5pbnZlcnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmxldCBqc29uU2NoZW1hU2VydmljZV9pZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgJyMnLCBub3JtYWxpemUgZHJpdmUgY2FwaXRhbGl6YXRpb25cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKGlkKS50b1N0cmluZyh0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcocmVzb3VyY2UpIHtcbiAgICAvLyByZW1vdmUgcXVlcmllcyBhbmQgZnJhZ21lbnRzLCBub3JtYWxpemUgZHJpdmUgY2FwaXRhbGl6YXRpb25cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKHJlc291cmNlKS53aXRoKHsgZnJhZ21lbnQ6IG51bGwsIHF1ZXJ5OiBudWxsIH0pLnRvU3RyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9EaXNwbGF5U3RyaW5nKHVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IFVSSS5wYXJzZSh1cmwpO1xuICAgICAgICBpZiAodXJpLnNjaGVtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpLmZzUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uRm9sZGluZy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuZnVuY3Rpb24gZ2V0Rm9sZGluZ1Jhbmdlcyhkb2N1bWVudCwgY29udGV4dCkge1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGNvbnN0IG5lc3RpbmdMZXZlbHMgPSBbXTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGxldCBwcmV2U3RhcnQgPSAtMTtcbiAgICBjb25zdCBzY2FubmVyID0gbWFpbl9jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgZmFsc2UpO1xuICAgIGxldCB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgbmVzdGluZ0xldmVscy5wdXNoKHN0YWNrLmxlbmd0aCk7XG4gICAgfVxuICAgIHdoaWxlICh0b2tlbiAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0TGluZSwgZW5kTGluZTogc3RhcnRMaW5lLCBraW5kOiB0b2tlbiA9PT0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovID8gJ29iamVjdCcgOiAnYXJyYXknIH07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSB0b2tlbiA9PT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLyA/ICdvYmplY3QnIDogJ2FycmF5JztcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5raW5kID09PSBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIGxpbmUgPiByYW5nZS5zdGFydExpbmUgKyAxICYmIHByZXZTdGFydCAhPT0gcmFuZ2Uuc3RhcnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmRMaW5lID0gbGluZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSByYW5nZS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmU7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKS5saW5lO1xuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuRXJyb3IoKSA9PT0gMSAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLyAmJiBzdGFydExpbmUgKyAxIDwgZG9jdW1lbnQubGluZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24oZG9jdW1lbnQub2Zmc2V0QXQobWFpbi5Qb3NpdGlvbi5jcmVhdGUoc3RhcnRMaW5lICsgMSwgMCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydExpbmUgPCBlbmRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZSh7IHN0YXJ0TGluZSwgZW5kTGluZSwga2luZDogbWFpbi5Gb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSBzdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHRleHQubWF0Y2goL15cXC9cXC9cXHMqIyhyZWdpb25cXGIpfChlbmRyZWdpb25cXGIpLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgICAgICBpZiAobVsxXSkgeyAvLyBzdGFydCBwYXR0ZXJuIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgc3RhcnRMaW5lOiBsaW5lLCBlbmRMaW5lOiBsaW5lLCBraW5kOiBtYWluLkZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgc3RhY2tbaV0ua2luZCAhPT0gbWFpbi5Gb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgPiByYW5nZS5zdGFydExpbmUgJiYgcHJldlN0YXJ0ICE9PSByYW5nZS5zdGFydExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kTGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlN0YXJ0ID0gcmFuZ2Uuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgIH1cbiAgICBjb25zdCByYW5nZUxpbWl0ID0gY29udGV4dCAmJiBjb250ZXh0LnJhbmdlTGltaXQ7XG4gICAgaWYgKHR5cGVvZiByYW5nZUxpbWl0ICE9PSAnbnVtYmVyJyB8fCByYW5nZXMubGVuZ3RoIDw9IHJhbmdlTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJhbmdlTGltaXRFeGNlZWRlZCkge1xuICAgICAgICBjb250ZXh0Lm9uUmFuZ2VMaW1pdEV4Y2VlZGVkKGRvY3VtZW50LnVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50cyA9IFtdO1xuICAgIGZvciAobGV0IGxldmVsIG9mIG5lc3RpbmdMZXZlbHMpIHtcbiAgICAgICAgaWYgKGxldmVsIDwgMzApIHtcbiAgICAgICAgICAgIGNvdW50c1tsZXZlbF0gPSAoY291bnRzW2xldmVsXSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSAwO1xuICAgIGxldCBtYXhMZXZlbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbiA9IGNvdW50c1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGlmIChuICsgZW50cmllcyA+IHJhbmdlTGltaXQpIHtcbiAgICAgICAgICAgICAgICBtYXhMZXZlbCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyaWVzICs9IG47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBuZXN0aW5nTGV2ZWxzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgbWF4TGV2ZWwgfHwgKGxldmVsID09PSBtYXhMZXZlbCAmJiBlbnRyaWVzKysgPCByYW5nZUxpbWl0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uU2VsZWN0aW9uUmFuZ2VzLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZXMoZG9jdW1lbnQsIHBvc2l0aW9ucywgZG9jKSB7XG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2UocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHJhbmdlIHdpdGhvdXQgXCIsIFsgb3Ige1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjU3RhcnQgPSBub2RlLm9mZnNldCArIDEsIGNFbmQgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNTdGFydCA8IGNFbmQgJiYgb2Zmc2V0ID49IGNTdGFydCAmJiBvZmZzZXQgPD0gY0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2UoY1N0YXJ0LCBjRW5kKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1JhbmdlKG5vZGUub2Zmc2V0LCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5JyB8fCBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJDb21tYU9mZnNldCA9IGdldE9mZnNldEFmdGVyTmV4dFRva2VuKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgsIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovKTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXJDb21tYU9mZnNldCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIGFmdGVyQ29tbWFPZmZzZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBtYWluLlNlbGVjdGlvblJhbmdlLmNyZWF0ZShyZXN1bHRbaW5kZXhdLCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBtYWluLlNlbGVjdGlvblJhbmdlLmNyZWF0ZShtYWluLlJhbmdlLmNyZWF0ZShwb3NpdGlvbiwgcG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmV3UmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gbWFpbi5SYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChzdGFydCksIGRvY3VtZW50LnBvc2l0aW9uQXQoZW5kKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYW5uZXIgPSBtYWluX2NyZWF0ZVNjYW5uZXIoZG9jdW1lbnQuZ2V0VGV4dCgpLCB0cnVlKTtcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRBZnRlck5leHRUb2tlbihvZmZzZXQsIGV4cGVjdGVkVG9rZW4pIHtcbiAgICAgICAgc2Nhbm5lci5zZXRQb3NpdGlvbihvZmZzZXQpO1xuICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgaWYgKHRva2VuID09PSBleHBlY3RlZFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5tYXAoZ2V0U2VsZWN0aW9uUmFuZ2UpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2Zvcm1hdC5qc1xuXG5cbmZ1bmN0aW9uIHV0aWxzX2Zvcm1hdF9mb3JtYXQoZG9jdW1lbnRUb0Zvcm1hdCwgZm9ybWF0dGluZ09wdGlvbnMsIGZvcm1hdHRpbmdSYW5nZSkge1xuICAgIGxldCByYW5nZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZm9ybWF0dGluZ1JhbmdlKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50VG9Gb3JtYXQub2Zmc2V0QXQoZm9ybWF0dGluZ1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZG9jdW1lbnRUb0Zvcm1hdC5vZmZzZXRBdChmb3JtYXR0aW5nUmFuZ2UuZW5kKSAtIG9mZnNldDtcbiAgICAgICAgcmFuZ2UgPSB7IG9mZnNldCwgbGVuZ3RoIH07XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHRhYlNpemU6IGZvcm1hdHRpbmdPcHRpb25zID8gZm9ybWF0dGluZ09wdGlvbnMudGFiU2l6ZSA6IDQsXG4gICAgICAgIGluc2VydFNwYWNlczogZm9ybWF0dGluZ09wdGlvbnM/Lmluc2VydFNwYWNlcyA9PT0gdHJ1ZSxcbiAgICAgICAgaW5zZXJ0RmluYWxOZXdsaW5lOiBmb3JtYXR0aW5nT3B0aW9ucz8uaW5zZXJ0RmluYWxOZXdsaW5lID09PSB0cnVlLFxuICAgICAgICBlb2w6ICdcXG4nLFxuICAgICAgICBrZWVwTGluZXM6IGZvcm1hdHRpbmdPcHRpb25zPy5rZWVwTGluZXMgPT09IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBtYWluX2Zvcm1hdChkb2N1bWVudFRvRm9ybWF0LmdldFRleHQoKSwgcmFuZ2UsIG9wdGlvbnMpLm1hcChlZGl0ID0+IHtcbiAgICAgICAgcmV0dXJuIG1haW4uVGV4dEVkaXQucmVwbGFjZShtYWluLlJhbmdlLmNyZWF0ZShkb2N1bWVudFRvRm9ybWF0LnBvc2l0aW9uQXQoZWRpdC5vZmZzZXQpLCBkb2N1bWVudFRvRm9ybWF0LnBvc2l0aW9uQXQoZWRpdC5vZmZzZXQgKyBlZGl0Lmxlbmd0aCkpLCBlZGl0LmNvbnRlbnQpO1xuICAgIH0pO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL3Byb3BlcnR5VHJlZS5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgQ29udGFpbmVyO1xuKGZ1bmN0aW9uIChDb250YWluZXIpIHtcbiAgICBDb250YWluZXJbQ29udGFpbmVyW1wiT2JqZWN0XCJdID0gMF0gPSBcIk9iamVjdFwiO1xuICAgIENvbnRhaW5lcltDb250YWluZXJbXCJBcnJheVwiXSA9IDFdID0gXCJBcnJheVwiO1xufSkoQ29udGFpbmVyIHx8IChDb250YWluZXIgPSB7fSkpO1xuY2xhc3MgUHJvcGVydHlUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eU5hbWUsIGJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWUgPz8gJyc7XG4gICAgICAgIHRoaXMuYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMubGFzdFByb3BlcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9LZXlOYW1lID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZENoaWxkUHJvcGVydHkoY2hpbGRQcm9wZXJ0eSkge1xuICAgICAgICBjaGlsZFByb3BlcnR5LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0aW9uSW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGNoaWxkUHJvcGVydHkubm9LZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25JbmRleCA9IGJpbmFyeVNlYXJjaE9uUHJvcGVydHlBcnJheSh0aGlzLmNoaWxkcmVuUHJvcGVydGllcywgY2hpbGRQcm9wZXJ0eSwgY29tcGFyZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc2VydGlvbkluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gKGluc2VydGlvbkluZGV4ICogLTEpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgY2hpbGRQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuUHJvcGVydGllcy5wdXNoKGNoaWxkUHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZFByb3BlcnR5O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVQcm9wZXJ0aWVzKHByb3BlcnR5VHJlZTEsIHByb3BlcnR5VHJlZTIpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUxID0gcHJvcGVydHlUcmVlMS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUyID0gcHJvcGVydHlUcmVlMi5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocHJvcGVydHlOYW1lMSA8IHByb3BlcnR5TmFtZTIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9wZXJ0eU5hbWUxID4gcHJvcGVydHlOYW1lMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2hPblByb3BlcnR5QXJyYXkocHJvcGVydHlUcmVlQXJyYXksIHByb3BlcnR5VHJlZSwgY29tcGFyZV9mbikge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5VHJlZS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUgPSBwcm9wZXJ0eVRyZWVBcnJheVswXS5wcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBsYXN0UHJvcGVydHlJbkFycmF5TmFtZSA9IHByb3BlcnR5VHJlZUFycmF5W3Byb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDFdLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPCBmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eU5hbWUgPiBsYXN0UHJvcGVydHlJbkFycmF5TmFtZSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlUcmVlQXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgbSA9IDA7XG4gICAgbGV0IG4gPSBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChtIDw9IG4pIHtcbiAgICAgICAgbGV0IGsgPSAobiArIG0pID4+IDE7XG4gICAgICAgIGxldCBjbXAgPSBjb21wYXJlX2ZuKHByb3BlcnR5VHJlZSwgcHJvcGVydHlUcmVlQXJyYXlba10pO1xuICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgbSA9IGsgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIG4gPSBrIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtbSAtIDE7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvc29ydC5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBpbXBvcnQgeyBUZXh0RWRpdH0gZnJvbSAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCc7XG5cblxuXG5cbmZ1bmN0aW9uIHNvcnQoZG9jdW1lbnRUb1NvcnQsIGZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZm9ybWF0dGluZ09wdGlvbnMsXG4gICAgICAgIGtlZXBMaW5lczogZmFsc2UsIC8vIGtlZXBMaW5lcyBtdXN0IGJlIGZhbHNlIHNvIHRoYXQgdGhlIHByb3BlcnRpZXMgYXJlIG9uIHNlcGFyYXRlIGxpbmVzIGZvciB0aGUgc29ydGluZ1xuICAgIH07XG4gICAgY29uc3QgZm9ybWF0dGVkSnNvblN0cmluZyA9IGVzbV9tYWluLyogVGV4dERvY3VtZW50ICovLm4uYXBwbHlFZGl0cyhkb2N1bWVudFRvU29ydCwgdXRpbHNfZm9ybWF0X2Zvcm1hdChkb2N1bWVudFRvU29ydCwgb3B0aW9ucywgdW5kZWZpbmVkKSk7XG4gICAgY29uc3QgZm9ybWF0dGVkSnNvbkRvY3VtZW50ID0gZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi5jcmVhdGUoJ3Rlc3Q6Ly90ZXN0Lmpzb24nLCAnanNvbicsIDAsIGZvcm1hdHRlZEpzb25TdHJpbmcpO1xuICAgIGNvbnN0IGpzb25Qcm9wZXJ0eVRyZWUgPSBmaW5kSnNvbmNQcm9wZXJ0eVRyZWUoZm9ybWF0dGVkSnNvbkRvY3VtZW50KTtcbiAgICBjb25zdCBzb3J0ZWRKc29uRG9jdW1lbnQgPSBzb3J0SnNvbmNEb2N1bWVudChmb3JtYXR0ZWRKc29uRG9jdW1lbnQsIGpzb25Qcm9wZXJ0eVRyZWUpO1xuICAgIGNvbnN0IGVkaXRzID0gdXRpbHNfZm9ybWF0X2Zvcm1hdChzb3J0ZWRKc29uRG9jdW1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCk7XG4gICAgY29uc3Qgc29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50ID0gZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi5hcHBseUVkaXRzKHNvcnRlZEpzb25Eb2N1bWVudCwgZWRpdHMpO1xuICAgIHJldHVybiBbbWFpbi5UZXh0RWRpdC5yZXBsYWNlKG1haW4uUmFuZ2UuY3JlYXRlKG1haW4uUG9zaXRpb24uY3JlYXRlKDAsIDApLCBkb2N1bWVudFRvU29ydC5wb3NpdGlvbkF0KGRvY3VtZW50VG9Tb3J0LmdldFRleHQoKS5sZW5ndGgpKSwgc29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50KV07XG59XG5mdW5jdGlvbiBmaW5kSnNvbmNQcm9wZXJ0eVRyZWUoZm9ybWF0dGVkRG9jdW1lbnQpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRTdHJpbmcgPSBmb3JtYXR0ZWREb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgY29uc3Qgc2Nhbm5lciA9IG1haW5fY3JlYXRlU2Nhbm5lcihmb3JtYXR0ZWRTdHJpbmcsIGZhbHNlKTtcbiAgICAvLyBUaGUgdHJlZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICBsZXQgcm9vdFRyZWUgPSBuZXcgUHJvcGVydHlUcmVlKCk7XG4gICAgLy8gVGhlIHRyZWUgd2hlcmUgdGhlIGN1cnJlbnQgcHJvcGVydGllcyBjYW4gYmUgYWRkZWQgYXMgY2hpbGRyZW5cbiAgICBsZXQgY3VycmVudFRyZWUgPSByb290VHJlZTtcbiAgICAvLyBUaGUgdHJlZSByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcHJvcGVydHkgYW5hbHl6ZWRcbiAgICBsZXQgY3VycmVudFByb3BlcnR5ID0gcm9vdFRyZWU7XG4gICAgLy8gVGhlIHRyZWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyBwcm9wZXJ0eSBhbmFseXplZFxuICAgIGxldCBsYXN0UHJvcGVydHkgPSByb290VHJlZTtcbiAgICAvLyBUaGUgY3VycmVudCBzY2FubmVkIHRva2VuXG4gICAgbGV0IHRva2VuID0gdW5kZWZpbmVkO1xuICAgIC8vIExpbmUgbnVtYmVyIG9mIHRoZSBsYXN0IHRva2VuIGZvdW5kXG4gICAgbGV0IGxhc3RUb2tlbkxpbmUgPSAwO1xuICAgIC8vIFRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9uIHRoZSBsaW5lcyBwcmlvciB0byBjdXJyZW50IGxpbmUgXG4gICAgbGV0IG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcyA9IDA7XG4gICAgLy8gVGhlIGxhc3QgdG9rZW4gc2Nhbm5lZCB0aGF0IGlzIG5vdCB0cml2aWFsLCBub3IgYSBjb21tZW50XG4gICAgbGV0IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgLy8gVGhlIHNlY29uZCB0byBsYXN0IHRva2VuIHNjYW5uZWQgdGhhdCBpcyBub3QgdHJpdmlhbCwgbm9yIGEgY29tbWVudFxuICAgIGxldCBzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgLy8gTGluZSBudW1iZXIgb2YgbGFzdCB0b2tlbiB0aGF0IGlzIG5vdCB0cml2aWFsLCBub3IgYSBjb21tZW50XG4gICAgbGV0IGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSAtMTtcbiAgICAvLyBFbmQgaW5kZXggb24gaXRzIGxpbmUgb2YgbGFzdCB0b2tlbiB0aGF0IGlzIG5vdCB0cml2aWFsLCBub3IgYSBjb21tZW50XG4gICAgbGV0IGVuZEluZGV4T2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gLTE7XG4gICAgLy8gTGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSBvZiBjdXJyZW50L25leHQgcHJvcGVydHlcbiAgICBsZXQgYmVnaW5uaW5nTGluZU51bWJlciA9IDA7XG4gICAgLy8gTGluZSBudW1iZXIgb2YgdGhlIGVuZCBvZiB0aGUgcmFuZ2Ugb2YgY3VycmVudC9uZXh0IHByb3BlcnR5XG4gICAgbGV0IGVuZExpbmVOdW1iZXIgPSAwO1xuICAgIC8vIFN0YWNrIGluZGljYXRpbmcgd2hldGhlciB3ZSBhcmUgaW5zaWRlIG9mIGFuIG9iamVjdCBvciBhbiBhcnJheVxuICAgIGxldCBjdXJyZW50Q29udGFpbmVyU3RhY2sgPSBbXTtcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgY3VycmVudCBwcm9wZXJ0eSBlbmQgbGluZSBudW1iZXIgbmVlZHMgdG8gYmUgdXBkYXRlZC4gVXNlZCBvbmx5IHdoZW4gYmxvY2sgY29tbWVudHMgYXJlIGVuY291bnRlcmVkLlxuICAgIGxldCB1cGRhdGVMYXN0UHJvcGVydHlFbmRMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhlIGJlZ2lubmluZyBsaW5lIG51bWJlciBzaG91bGQgYmUgdXBkYXRlZC4gVXNlZCBvbmx5IHdoZW4gYmxvY2sgY29tbWVudHMgYXJlIGVuY291bnRlcmVkLiBcbiAgICBsZXQgdXBkYXRlQmVnaW5uaW5nTGluZU51bWJlciA9IGZhbHNlO1xuICAgIHdoaWxlICgodG9rZW4gPSBzY2FubmVyLnNjYW4oKSkgIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHdoZW4gYSBibG9jayBjb21tZW50IGhhcyBiZWVuIGVuY291bnRlcmVkIHRoYXQgc3RhcnRzIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGNvbW1hIGVuZGluZyBhIHByb3BlcnR5LCB1cGRhdGUgdGhlIGVuZCBsaW5lIG9mIHRoYXRcbiAgICAgICAgLy8gcHJvcGVydHkgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGJsb2NrIGNvbW1lbnQuIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlOiBcbiAgICAgICAgLy8gMS4gXCJrZXlcIiA6IHt9LCAvKiBzb21lIGJsb2NrXG4gICAgICAgIC8vIDIuIGNvbW1lbnQgKi9cbiAgICAgICAgLy8gVGhlbiwgdGhlIGVuZCBsaW5lIG9mIHRoZSBwcm9wZXJ0eSBcImtleVwiIHNob3VsZCBiZSBsaW5lIDIgbm90IGxpbmUgMVxuICAgICAgICBpZiAodXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciA9PT0gdHJ1ZVxuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi9cbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi9cbiAgICAgICAgICAgICYmIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBlbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgbGFzdCBwcm9wZXJ0eSB2aXNpdGVkIGlzIGEgY29udGFpbmVyIChvYmplY3Qgb3IgYXJyYXkpXG4gICAgICAgICAgICBpZiAoc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgfHwgc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgbGFzdCBwcm9wZXJ0eSB2aXNpdGVkIGlzIGEgc2ltcGxlIHByb3BlcnR5IFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gYSBibG9jayBjb21tZW50IGZvbGxvd3MgYW4gb3BlbiBicmFjZSBvciBhbiBvcGVuIGJyYWNrZXQsIHRoYXQgYmxvY2sgY29tbWVudCBzaG91bGQgYmUgYXNzb2NpYXRlZCB0byB0aGF0IGJyYWNlIG9yIGJyYWNrZXQsIG5vdCB0aGUgcHJvcGVydHkgYmVsb3cgaXQuIEZvciBleGFtcGxlLCBmb3I6XG4gICAgICAgIC8vIDEuIHsgLypcbiAgICAgICAgLy8gMi4gLi4uICovXG4gICAgICAgIC8vIDMuIFwia2V5XCIgOiB7fVxuICAgICAgICAvLyA0LiB9XG4gICAgICAgIC8vIEluc3RlYWQgb2YgYXNzb2NpYXRpbmcgdGhlIGJsb2NrIGNvbW1lbnQgdG8gdGhlIHByb3BlcnR5IG9uIGxpbmUgMywgaXQgaXMgYXNzb2NpYXRlIHRvIHRoZSBwcm9wZXJ0eSBvbiBsaW5lIDFcbiAgICAgICAgaWYgKHVwZGF0ZUJlZ2lubmluZ0xpbmVOdW1iZXIgPT09IHRydWVcbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxNCAvKiBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYSAqL1xuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDE1IC8qIFN5bnRheEtpbmQuVHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqL1xuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSB7XG4gICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgdXBkYXRlQmVnaW5uaW5nTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb24gYWxsIHRoZSBwcmV2aW91cyBsaW5lcyBlYWNoIHRpbWUgdGhlIG5ldyB0b2tlbiBpcyBvbiBhIGRpZmZlcmVudCBsaW5lIHRvIHRoZSBwcmV2aW91cyB0b2tlblxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpICE9PSBsYXN0VG9rZW5MaW5lKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGFzdFRva2VuTGluZTsgaSA8IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoT2ZMaW5lID0gZm9ybWF0dGVkRG9jdW1lbnQuZ2V0VGV4dChtYWluLlJhbmdlLmNyZWF0ZShtYWluLlBvc2l0aW9uLmNyZWF0ZShpLCAwKSwgbWFpbi5Qb3NpdGlvbi5jcmVhdGUoaSArIDEsIDApKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcyA9IG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcyArIGxlbmd0aE9mTGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RUb2tlbkxpbmUgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgLy8gV2hlbiBhIHN0cmluZyBpcyBmb3VuZCwgaWYgaXQgZm9sbG93cyBhbiBvcGVuIGJyYWNlIG9yIGEgY29tbWEgdG9rZW4gYW5kIGl0IGlzIHdpdGhpbiBhbiBvYmplY3QsIHRoZW4gaXQgY29ycmVzcG9uZHMgdG8gYSBrZXkgbmFtZSwgbm90IGEgc2ltcGxlIHN0cmluZ1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBTeW50YXhLaW5kLlN0cmluZ0xpdGVyYWwgKi86IHtcbiAgICAgICAgICAgICAgICBpZiAoKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB8fCBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgfHwgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIGNyZWF0ZSB0aGUgY2hpbGQgcHJvcGVydHkgd2hpY2ggc3RhcnRzIGF0IGJlZ2lubmluZ0xpbmVOdW1iZXIsIGFkZCBpdCB0byB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvcGVydHkgPSBuZXcgUHJvcGVydHlUcmVlKHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50VHJlZS5hZGRDaGlsZFByb3BlcnR5KGNoaWxkUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHRva2VuIGlzIGFuIG9wZW4gYnJhY2tldCwgdGhlbiB3ZSBlbnRlciBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBjYXNlIDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJvb3QgdHJlZSBiZWdpbm5pbmcgbGluZSBudW1iZXIgaXMgbm90IGRlZmluZWQsIHRoZW4gdGhpcyBvcGVuIGJyYWNrZXQgaXMgdGhlIGZpcnN0IG9wZW4gYnJhY2tldCBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICBpZiAocm9vdFRyZWUuYmVnaW5uaW5nTGluZU51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN1cHBvc2Ugd2UgYXJlIGluc2lkZSBvZiBhbiBvYmplY3QsIHRoZW4gdGhlIGN1cnJlbnQgYXJyYXkgaXMgYXNzb2NpYXRlZCB0byBhIGtleSwgYW5kIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiB7XCJhXCI6IFwidmFsXCIsIFwiYXJyYXlcIjogWy4uLl0sIFwiYlwiOiBcInZhbFwifVxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSBuYXZpZ2F0ZSBkb3duIHRvIHRoZSBjaGlsZCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3NlIHdlIGFyZSBpbnNpZGUgb2YgYW4gYXJyYXksIHRoZW4gc2luY2UgdGhlIGN1cnJlbnQgYXJyYXkgaXMgbm90IGFzc29jaWF0ZWQgdG8gYSBrZXksIGl0IGhhcyBub3QgYmVlbiBjcmVhdGVkIHlldFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiBbXCJhXCIsIFsuLi5dLCBcImJcIl1cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UgY3JlYXRlIHRoZSBwcm9wZXJ0eSBhbmQgbmF2aWdhdGUgZG93blxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFByb3BlcnR5ID0gbmV3IFByb3BlcnR5VHJlZShzY2FubmVyLmdldFRva2VuVmFsdWUoKSwgYmVnaW5uaW5nTGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcGVydHkubm9LZXlOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50VHJlZS5hZGRDaGlsZFByb3BlcnR5KGNoaWxkUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclN0YWNrLnB1c2goQ29udGFpbmVyLkFycmF5KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkudHlwZSA9IENvbnRhaW5lci5BcnJheTtcbiAgICAgICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHRva2VuIGlzIGFuIG9wZW4gYnJhY2UsIHRoZW4gd2UgZW50ZXIgaW50byBhbiBvYmplY3RcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJvb3QgdHJlZSBiZWdpbm5pbmcgbGluZSBudW1iZXIgaXMgbm90IGRlZmluZWQsIHRoZW4gdGhpcyBvcGVuIGJyYWNlIGlzIHRoZSBmaXJzdCBvcGVuIGJyYWNlIGluIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGlmIChyb290VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFRyZWUuYmVnaW5uaW5nTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMS4gSWYgd2UgYXJlIGluc2lkZSBvZiBhbiBvYmpldCwgdGhlIGN1cnJlbnQgb2JqZWN0IGlzIGFzc29jaWF0ZWQgdG8gYSBrZXkgYW5kIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiB7XCJhXCI6IFwidmFsXCIsIFwib2JqZWN0XCI6IHsuLi59LCBcImJcIjogXCJ2YWxcIn1cbiAgICAgICAgICAgICAgICAvLyAyLiBPdGhlcndpc2UgdGhlIGN1cnJlbnQgb2JqZWN0IHByb3BlcnR5IGlzIGluc2lkZSBvZiBhbiBhcnJheSwgbm90IGFzc29jaWF0ZWQgdG8gYSBrZXkgbmFtZSBhbmQgdGhlIHByb3BlcnR5IGhhcyBub3QgeWV0IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uOiBbXCJhXCIsIHsuLi59LCBcImJcIl1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eVRyZWUoc2Nhbm5lci5nZXRUb2tlblZhbHVlKCksIGJlZ2lubmluZ0xpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BlcnR5Lm5vS2V5TmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFRyZWUuYWRkQ2hpbGRQcm9wZXJ0eShjaGlsZFByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LnR5cGUgPSBDb250YWluZXIuT2JqZWN0O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJTdGFjay5wdXNoKENvbnRhaW5lci5PYmplY3QpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlcisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBub24tdHJpdmlhbCBub24tY29tbWVudCB0b2tlbiBpcyBhIGNsb3NpbmcgYnJhY2Ugb3IgYnJhY2tldCwgdGhlbiB0aGUgY3VycmVudFByb3BlcnR5IGVuZCBsaW5lIG51bWJlciBoYXMgbm90IGJlZW4gc2V0IHlldCBzbyBzZXQgaXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlndXJhdGlvbiBjb25zaWRlcmVkIGlzOiBbLi4uLCB7fV0gb3IgWy4uLiwgW11dXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5Lmxhc3RQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5saW5lV2hlcmVUb0FkZENvbW1hID0gbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmluZGV4V2hlcmVUb0FkZENvbWEgPSBlbmRJbmRleE9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHkgPyBjdXJyZW50UHJvcGVydHkucGFyZW50IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdFRyZWUuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbnNpZGUgb2YgYW4gZW1wdHkgb2JqZWN0IGFuZCBjdXJyZW50IHByb3BlcnR5IGVuZCBsaW5lIG51bWJlciBoYXMgbm90IHlldCBiZWVuIGRlZmluZWQsIGRlZmluZSBpdFxuICAgICAgICAgICAgICAgIGlmIChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuICE9PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgJiYgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBwcm9wZXJ0eSBpcyBhbHNvIHRoZSBsYXN0IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5sYXN0UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBsaW5lIGFuZCBpbmRleCBvZiB3aGVyZSB0byBhZGQgdGhlIGNvbW1hLCBpbiBjYXNlIGFmdGVyIHNvcnRpbmcsIGl0IGlzIG5vIGxvbmdlciB0aGUgbGFzdCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkubGluZVdoZXJlVG9BZGRDb21tYSA9IGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5pbmRleFdoZXJlVG9BZGRDb21hID0gZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5ID8gY3VycmVudFByb3BlcnR5LnBhcmVudCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvb3RUcmVlLmVuZExpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLzoge1xuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY29udGFpbmVyIGlzIGFuIG9iamVjdCBvciB0aGUgY3VycmVudCBjb250YWluZXIgaXMgYW4gYXJyYXkgYW5kIHRoZSBsYXN0IG5vbi10cml2aWEgbm9uLWNvbW1lbnQgdG9rZW4gaXMgYSBjbG9zaW5nIGJyYWNlIG9yIGEgY2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgLy8gVGhlbiB1cGRhdGUgdGhlIGVuZCBsaW5lIG51bWJlciBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICYmIChjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGxpbmUgYW5kIHRoZSBpbmRleCBvZiB0aGUgY29tbWEgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZW1vdmVkIGR1cmluZyB0aGUgc29ydGluZ1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuY29tbWFJbmRleCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSAtIG51bWJlck9mQ2hhcmFjdGVyc09uUHJldmlvdXNMaW5lcztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmNvbW1hTGluZSA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eSA/IGN1cnJlbnRQcm9wZXJ0eS5wYXJlbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlciArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3Qgbm9uIHRyaXZpYSBub24tY29tbWVudCB0b2tlbiBpcyBhIGNvbW1hIGFuZCB0aGUgYmxvY2sgY29tbWVudCBzdGFydHMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgY29tbWEsIHRoZW4gdXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkuIEZvciBleGFtcGxlIGlmOlxuICAgICAgICAgICAgICAgIC8vIDEuIHt9LCAvKiAuLi5cbiAgICAgICAgICAgICAgICAvLyAyLiAuLiovXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRoZSBwcm9wZXJ0eSBvbiBsaW5lIDEgc2hvdWQgZW5kIG9uIGxpbmUgMiwgbm90IGxpbmUgMVxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIHdlIGFyZSBpbiBhbiBhcnJheSB3ZSB1cGRhdGUgdGhlIGVuZCBsaW5lIG51bWJlciBvbmx5IGlmIHRoZSBzZWNvbmQgdG8gbGFzdCBub24tdHJpdmlhIG5vbi1jb21tZW50IHRva2VuIGlzIGEgY2xvc2luZyBicmFjZSBvciBicmFja2V0XG4gICAgICAgICAgICAgICAgaWYgKGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgICYmIGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKVxuICAgICAgICAgICAgICAgICAgICAmJiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5ICYmIChzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8gfHwgc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHx8IGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlTGFzdFByb3BlcnR5RW5kTGluZU51bWJlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgYmxvY2sgY29tbWVudCBmb2xsb3dzIGFuIG9wZW4gYnJhY2Ugb3IgYW4gb3BlbiB0b2tlbiwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIHNjZW5hcmlvOlxuICAgICAgICAgICAgICAgIC8vIHsgLyoqXG4gICAgICAgICAgICAgICAgLy8gLi4vXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBjb21tZW50IHNob3VsZCBiZSBhc3NpZ25lZCB0byB0aGUgb3BlbiBicmFjZSBub3QgdGhlIGZpcnN0IHByb3BlcnR5IGJlbG93IGl0XG4gICAgICAgICAgICAgICAgaWYgKChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi8pXG4gICAgICAgICAgICAgICAgICAgICYmIGxpbmVPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGFuZCBzZWNvbmQgdG8gbGFzdCBub24tdHJpdmlhIG5vbi1jb21tZW50IHRva2Vuc1xuICAgICAgICBpZiAodG9rZW4gIT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi9cbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi8pIHtcbiAgICAgICAgICAgIHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW47XG4gICAgICAgICAgICBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBsaW5lT2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgLSBudW1iZXJPZkNoYXJhY3RlcnNPblByZXZpb3VzTGluZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb3RUcmVlO1xufVxuZnVuY3Rpb24gc29ydEpzb25jRG9jdW1lbnQoanNvbkRvY3VtZW50LCBwcm9wZXJ0eVRyZWUpIHtcbiAgICBpZiAocHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGpzb25Eb2N1bWVudDtcbiAgICB9XG4gICAgY29uc3Qgc29ydGVkSnNvbkRvY3VtZW50ID0gZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi5jcmVhdGUoJ3Rlc3Q6Ly90ZXN0Lmpzb24nLCAnanNvbicsIDAsIGpzb25Eb2N1bWVudC5nZXRUZXh0KCkpO1xuICAgIGNvbnN0IHF1ZXVlVG9Tb3J0ID0gW107XG4gICAgdXBkYXRlU29ydGluZ1F1ZXVlKHF1ZXVlVG9Tb3J0LCBwcm9wZXJ0eVRyZWUsIHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICB3aGlsZSAocXVldWVUb1NvcnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhVG9Tb3J0ID0gcXVldWVUb1NvcnQuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlUcmVlQXJyYXkgPSBkYXRhVG9Tb3J0LnByb3BlcnR5VHJlZUFycmF5O1xuICAgICAgICBsZXQgYmVnaW5uaW5nTGluZU51bWJlciA9IGRhdGFUb1NvcnQuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlUcmVlID0gcHJvcGVydHlUcmVlQXJyYXlbaV07XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG1haW4uUmFuZ2UuY3JlYXRlKG1haW4uUG9zaXRpb24uY3JlYXRlKHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyLCAwKSwgbWFpbi5Qb3NpdGlvbi5jcmVhdGUocHJvcGVydHlUcmVlLmVuZExpbmVOdW1iZXIgKyAxLCAwKSk7XG4gICAgICAgICAgICBjb25zdCBqc29uQ29udGVudFRvUmVwbGFjZSA9IGpzb25Eb2N1bWVudC5nZXRUZXh0KHJhbmdlKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25Eb2N1bWVudFRvUmVwbGFjZSA9IGVzbV9tYWluLyogVGV4dERvY3VtZW50ICovLm4uY3JlYXRlKCd0ZXN0Oi8vdGVzdC5qc29uJywgJ2pzb24nLCAwLCBqc29uQ29udGVudFRvUmVwbGFjZSk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlUcmVlLmxhc3RQcm9wZXJ0eSA9PT0gdHJ1ZSAmJiBpICE9PSBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZVdoZXJlVG9BZGRDb21tYSA9IHByb3BlcnR5VHJlZS5saW5lV2hlcmVUb0FkZENvbW1hIC0gcHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhXaGVyZVRvQWRkQ29tbWEgPSBwcm9wZXJ0eVRyZWUuaW5kZXhXaGVyZVRvQWRkQ29tYTtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogbWFpbi5SYW5nZS5jcmVhdGUobWFpbi5Qb3NpdGlvbi5jcmVhdGUobGluZVdoZXJlVG9BZGRDb21tYSwgaW5kZXhXaGVyZVRvQWRkQ29tbWEpLCBtYWluLlBvc2l0aW9uLmNyZWF0ZShsaW5lV2hlcmVUb0FkZENvbW1hLCBpbmRleFdoZXJlVG9BZGRDb21tYSkpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnLCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGVzbV9tYWluLyogVGV4dERvY3VtZW50ICovLm4udXBkYXRlKGpzb25Eb2N1bWVudFRvUmVwbGFjZSwgW2VkaXRdLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5VHJlZS5sYXN0UHJvcGVydHkgPT09IGZhbHNlICYmIGkgPT09IHByb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYUluZGV4ID0gcHJvcGVydHlUcmVlLmNvbW1hSW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFMaW5lID0gcHJvcGVydHlUcmVlLmNvbW1hTGluZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lV2hlcmVUb1JlbW92ZUNvbW1hID0gY29tbWFMaW5lIC0gcHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG1haW4uUmFuZ2UuY3JlYXRlKG1haW4uUG9zaXRpb24uY3JlYXRlKGxpbmVXaGVyZVRvUmVtb3ZlQ29tbWEsIGNvbW1hSW5kZXgpLCBtYWluLlBvc2l0aW9uLmNyZWF0ZShsaW5lV2hlcmVUb1JlbW92ZUNvbW1hLCBjb21tYUluZGV4ICsgMSkpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXNtX21haW4vKiBUZXh0RG9jdW1lbnQgKi8ubi51cGRhdGUoanNvbkRvY3VtZW50VG9SZXBsYWNlLCBbZWRpdF0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcHJvcGVydHlUcmVlLmVuZExpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlciArIDE7XG4gICAgICAgICAgICBjb25zdCBlZGl0ID0ge1xuICAgICAgICAgICAgICAgIHJhbmdlOiBtYWluLlJhbmdlLmNyZWF0ZShtYWluLlBvc2l0aW9uLmNyZWF0ZShiZWdpbm5pbmdMaW5lTnVtYmVyLCAwKSwgbWFpbi5Qb3NpdGlvbi5jcmVhdGUoYmVnaW5uaW5nTGluZU51bWJlciArIGxlbmd0aCwgMCkpLFxuICAgICAgICAgICAgICAgIHRleHQ6IGpzb25Eb2N1bWVudFRvUmVwbGFjZS5nZXRUZXh0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlc21fbWFpbi8qIFRleHREb2N1bWVudCAqLy5uLnVwZGF0ZShzb3J0ZWRKc29uRG9jdW1lbnQsIFtlZGl0XSwgMSk7XG4gICAgICAgICAgICB1cGRhdGVTb3J0aW5nUXVldWUocXVldWVUb1NvcnQsIHByb3BlcnR5VHJlZSwgYmVnaW5uaW5nTGluZU51bWJlcik7XG4gICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gYmVnaW5uaW5nTGluZU51bWJlciArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc29ydGVkSnNvbkRvY3VtZW50O1xufVxuZnVuY3Rpb24gdXBkYXRlU29ydGluZ1F1ZXVlKHF1ZXVlLCBwcm9wZXJ0eVRyZWUsIGJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICBpZiAocHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlUcmVlLnR5cGUgPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgbGV0IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRQcm9wZXJ0eSBvZiBwcm9wZXJ0eVRyZWUuY2hpbGRyZW5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0eS5iZWdpbm5pbmdMaW5lTnVtYmVyIDwgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IGNoaWxkUHJvcGVydHkuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWZmID0gbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXIgKyBkaWZmO1xuICAgICAgICBxdWV1ZS5wdXNoKG5ldyBTb3J0aW5nUmFuZ2UoYmVnaW5uaW5nTGluZU51bWJlciwgcHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9wZXJ0eVRyZWUudHlwZSA9PT0gQ29udGFpbmVyLkFycmF5KSB7XG4gICAgICAgIHVwZGF0ZVNvcnRpbmdRdWV1ZUZvckFycmF5UHJvcGVydGllcyhxdWV1ZSwgcHJvcGVydHlUcmVlLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVTb3J0aW5nUXVldWVGb3JBcnJheVByb3BlcnRpZXMocXVldWUsIHByb3BlcnR5VHJlZSwgYmVnaW5uaW5nTGluZU51bWJlcikge1xuICAgIGZvciAoY29uc3Qgc3ViT2JqZWN0IG9mIHByb3BlcnR5VHJlZS5jaGlsZHJlblByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoaWxkIHByb3BlcnR5IG9mIHRoZSBhcnJheSBpcyBhbiBvYmplY3QsIHRoZW4geW91IGNhbiBzb3J0IHRoZSBwcm9wZXJ0aWVzIHdpdGhpbiB0aGlzIG9iamVjdFxuICAgICAgICBpZiAoc3ViT2JqZWN0LnR5cGUgPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgICAgIGxldCBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFByb3BlcnR5IG9mIHN1Yk9iamVjdC5jaGlsZHJlblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0eS5iZWdpbm5pbmdMaW5lTnVtYmVyIDwgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIgPSBjaGlsZFByb3BlcnR5LmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyIC0gc3ViT2JqZWN0LmJlZ2lubmluZ0xpbmVOdW1iZXI7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5ldyBTb3J0aW5nUmFuZ2UoYmVnaW5uaW5nTGluZU51bWJlciArIHN1Yk9iamVjdC5iZWdpbm5pbmdMaW5lTnVtYmVyIC0gcHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXIgKyBkaWZmLCBzdWJPYmplY3QuY2hpbGRyZW5Qcm9wZXJ0aWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNoaWxkIHByb3BlcnR5IG9mIHRoZSBhcnJheSBpcyBhbiBhcnJheSwgdGhlbiB5b3UgbmVlZCB0byByZWN1cnNlIG9uIHRoZSBjaGlsZHJlbiBwcm9wZXJ0aWVzLCB1bnRpbCB5b3UgZmluZCBhbiBvYmplY3QgdG8gc29ydFxuICAgICAgICBpZiAoc3ViT2JqZWN0LnR5cGUgPT09IENvbnRhaW5lci5BcnJheSkge1xuICAgICAgICAgICAgdXBkYXRlU29ydGluZ1F1ZXVlRm9yQXJyYXlQcm9wZXJ0aWVzKHF1ZXVlLCBzdWJPYmplY3QsIGJlZ2lubmluZ0xpbmVOdW1iZXIgKyBzdWJPYmplY3QuYmVnaW5uaW5nTGluZU51bWJlciAtIHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNvcnRpbmdSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoYmVnaW5uaW5nTGluZU51bWJlciwgcHJvcGVydHlUcmVlQXJyYXkpIHtcbiAgICAgICAgdGhpcy5iZWdpbm5pbmdMaW5lTnVtYmVyID0gYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eVRyZWVBcnJheSA9IHByb3BlcnR5VHJlZUFycmF5O1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uTGlua3MuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5mdW5jdGlvbiBmaW5kTGlua3MoZG9jdW1lbnQsIGRvYykge1xuICAgIGNvbnN0IGxpbmtzID0gW107XG4gICAgZG9jLnZpc2l0KG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInByb3BlcnR5XCIgJiYgbm9kZS5rZXlOb2RlLnZhbHVlID09PSBcIiRyZWZcIiAmJiBub2RlLnZhbHVlTm9kZT8udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBub2RlLnZhbHVlTm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBmaW5kVGFyZ2V0Tm9kZShkb2MsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQb3MgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHRhcmdldE5vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBgJHtkb2N1bWVudC51cml9IyR7dGFyZ2V0UG9zLmxpbmUgKyAxfSwke3RhcmdldFBvcy5jaGFyYWN0ZXIgKyAxfWAsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjcmVhdGVSYW5nZShkb2N1bWVudCwgbm9kZS52YWx1ZU5vZGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsaW5rcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVSYW5nZShkb2N1bWVudCwgbm9kZSkge1xuICAgIHJldHVybiBtYWluLlJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgMSksIGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCAtIDEpKTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXROb2RlKGRvYywgcGF0aCkge1xuICAgIGNvbnN0IHRva2VucyA9IHBhcnNlSlNPTlBvaW50ZXIocGF0aCk7XG4gICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaW5kTm9kZSh0b2tlbnMsIGRvYy5yb290KTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlKHBvaW50ZXIsIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBwb2ludGVyLnNoaWZ0KCk7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBub2RlLnByb3BlcnRpZXMuZmluZCgocHJvcGVydHlOb2RlKSA9PiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS52YWx1ZSA9PT0gdG9rZW4pO1xuICAgICAgICBpZiAoIXByb3BlcnR5Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmROb2RlKHBvaW50ZXIsIHByb3BlcnR5Tm9kZS52YWx1ZU5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAodG9rZW4ubWF0Y2goL14oMHxbMS05XVswLTldKikkLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KHRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5SXRlbSA9IG5vZGUuaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFhcnJheUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaW5kTm9kZShwb2ludGVyLCBhcnJheUl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VKU09OUG9pbnRlcihwYXRoKSB7XG4gICAgaWYgKHBhdGggPT09IFwiI1wiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHBhdGhbMF0gIT09ICcjJyB8fCBwYXRoWzFdICE9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygyKS5zcGxpdCgvXFwvLykubWFwKGpzb25MaW5rc191bmVzY2FwZSk7XG59XG5mdW5jdGlvbiBqc29uTGlua3NfdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vanNvbkxhbmd1YWdlU2VydmljZS5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldExhbmd1YWdlU2VydmljZShwYXJhbXMpIHtcbiAgICBjb25zdCBwcm9taXNlID0gcGFyYW1zLnByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgIGNvbnN0IGpzb25TY2hlbWFTZXJ2aWNlID0gbmV3IEpTT05TY2hlbWFTZXJ2aWNlKHBhcmFtcy5zY2hlbWFSZXF1ZXN0U2VydmljZSwgcGFyYW1zLndvcmtzcGFjZUNvbnRleHQsIHByb21pc2UpO1xuICAgIGpzb25TY2hlbWFTZXJ2aWNlLnNldFNjaGVtYUNvbnRyaWJ1dGlvbnMoc2NoZW1hQ29udHJpYnV0aW9ucyk7XG4gICAgY29uc3QganNvbkNvbXBsZXRpb24gPSBuZXcgSlNPTkNvbXBsZXRpb24oanNvblNjaGVtYVNlcnZpY2UsIHBhcmFtcy5jb250cmlidXRpb25zLCBwcm9taXNlLCBwYXJhbXMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcbiAgICBjb25zdCBqc29uSG92ZXIgPSBuZXcgSlNPTkhvdmVyKGpzb25TY2hlbWFTZXJ2aWNlLCBwYXJhbXMuY29udHJpYnV0aW9ucywgcHJvbWlzZSk7XG4gICAgY29uc3QganNvbkRvY3VtZW50U3ltYm9scyA9IG5ldyBKU09ORG9jdW1lbnRTeW1ib2xzKGpzb25TY2hlbWFTZXJ2aWNlKTtcbiAgICBjb25zdCBqc29uVmFsaWRhdGlvbiA9IG5ldyBKU09OVmFsaWRhdGlvbihqc29uU2NoZW1hU2VydmljZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlndXJlOiAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgIGpzb25TY2hlbWFTZXJ2aWNlLmNsZWFyRXh0ZXJuYWxTY2hlbWFzKCk7XG4gICAgICAgICAgICBzZXR0aW5ncy5zY2hlbWFzPy5mb3JFYWNoKGpzb25TY2hlbWFTZXJ2aWNlLnJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEuYmluZChqc29uU2NoZW1hU2VydmljZSkpO1xuICAgICAgICAgICAganNvblZhbGlkYXRpb24uY29uZmlndXJlKHNldHRpbmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRTY2hlbWE6ICh1cmkpID0+IGpzb25TY2hlbWFTZXJ2aWNlLm9uUmVzb3VyY2VDaGFuZ2UodXJpKSxcbiAgICAgICAgZG9WYWxpZGF0aW9uOiBqc29uVmFsaWRhdGlvbi5kb1ZhbGlkYXRpb24uYmluZChqc29uVmFsaWRhdGlvbiksXG4gICAgICAgIGdldExhbmd1YWdlU3RhdHVzOiBqc29uVmFsaWRhdGlvbi5nZXRMYW5ndWFnZVN0YXR1cy5iaW5kKGpzb25WYWxpZGF0aW9uKSxcbiAgICAgICAgcGFyc2VKU09ORG9jdW1lbnQ6IChkb2N1bWVudCkgPT4ganNvblBhcnNlcl9wYXJzZShkb2N1bWVudCwgeyBjb2xsZWN0Q29tbWVudHM6IHRydWUgfSksXG4gICAgICAgIG5ld0pTT05Eb2N1bWVudDogKHJvb3QsIGRpYWdub3N0aWNzKSA9PiBuZXdKU09ORG9jdW1lbnQocm9vdCwgZGlhZ25vc3RpY3MpLFxuICAgICAgICBnZXRNYXRjaGluZ1NjaGVtYXM6IGpzb25TY2hlbWFTZXJ2aWNlLmdldE1hdGNoaW5nU2NoZW1hcy5iaW5kKGpzb25TY2hlbWFTZXJ2aWNlKSxcbiAgICAgICAgZG9SZXNvbHZlOiBqc29uQ29tcGxldGlvbi5kb1Jlc29sdmUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGRvQ29tcGxldGU6IGpzb25Db21wbGV0aW9uLmRvQ29tcGxldGUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGZpbmREb2N1bWVudFN5bWJvbHM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50U3ltYm9scy5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRTeW1ib2xzMjoganNvbkRvY3VtZW50U3ltYm9scy5maW5kRG9jdW1lbnRTeW1ib2xzMi5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRDb2xvcnM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50Q29sb3JzLmJpbmQoanNvbkRvY3VtZW50U3ltYm9scyksXG4gICAgICAgIGdldENvbG9yUHJlc2VudGF0aW9uczoganNvbkRvY3VtZW50U3ltYm9scy5nZXRDb2xvclByZXNlbnRhdGlvbnMuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcbiAgICAgICAgZG9Ib3ZlcjoganNvbkhvdmVyLmRvSG92ZXIuYmluZChqc29uSG92ZXIpLFxuICAgICAgICBnZXRGb2xkaW5nUmFuZ2VzOiBnZXRGb2xkaW5nUmFuZ2VzLFxuICAgICAgICBnZXRTZWxlY3Rpb25SYW5nZXM6IGdldFNlbGVjdGlvblJhbmdlcyxcbiAgICAgICAgZmluZERlZmluaXRpb246ICgpID0+IFByb21pc2UucmVzb2x2ZShbXSksXG4gICAgICAgIGZpbmRMaW5rczogZmluZExpbmtzLFxuICAgICAgICBmb3JtYXQ6IChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpID0+IHV0aWxzX2Zvcm1hdF9mb3JtYXQoZG9jdW1lbnQsIG9wdGlvbnMsIHJhbmdlKSxcbiAgICAgICAgc29ydDogKGRvY3VtZW50LCBvcHRpb25zKSA9PiBzb3J0KGRvY3VtZW50LCBvcHRpb25zKVxuICAgIH07XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9saWIvYnJvd3Nlci9tYWluLmpzXG52YXIgYnJvd3Nlcl9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy50c1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mjk3KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hY2UvcmFuZ2Utc2luZ2xldG9uLnRzXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5jbGFzcyBBY2VSYW5nZSB7XG4gICAgc3RhdGljIGdldENvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICBpZiAoIUFjZVJhbmdlLl9pbnN0YW5jZSAmJiBlZGl0b3IpIHtcbiAgICAgICAgICAgIEFjZVJhbmdlLl9pbnN0YW5jZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpLmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBY2VSYW5nZS5faW5zdGFuY2U7XG4gICAgfVxufVxuX2RlZmluZV9wcm9wZXJ0eShBY2VSYW5nZSwgXCJfaW5zdGFuY2VcIiwgdm9pZCAwKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3R5cGUtY29udmVydGVycy9jb21tb24tY29udmVydGVycy50c1xuXG5cblxudmFyIGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlcjtcbihmdW5jdGlvbihDb21tb25Db252ZXJ0ZXIpIHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemVSYW5nZXMoY29tcGxldGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25zICYmIGNvbXBsZXRpb25zLm1hcCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoZWxbXCJyYW5nZVwiXSkge1xuICAgICAgICAgICAgICAgIGVsW1wicmFuZ2VcIl0gPSB0b1JhbmdlKGVsW1wicmFuZ2VcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLm5vcm1hbGl6ZVJhbmdlcyA9IG5vcm1hbGl6ZVJhbmdlcztcbiAgICBmdW5jdGlvbiBjbGVhbkh0bWwoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88YVxccy8sIFwiPGEgdGFyZ2V0PSdfYmxhbmsnIFwiKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLmNsZWFuSHRtbCA9IGNsZWFuSHRtbDtcbiAgICBmdW5jdGlvbiB0b1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2UgfHwgIXJhbmdlLnN0YXJ0IHx8ICFyYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgUmFuZ2UgPSBBY2VSYW5nZS5nZXRDb25zdHJ1Y3RvcigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIudG9SYW5nZSA9IHRvUmFuZ2U7XG4gICAgZnVuY3Rpb24gY29udmVydEtpbmQoa2luZCkge1xuICAgICAgICBzd2l0Y2goa2luZCl7XG4gICAgICAgICAgICBjYXNlIFwicHJpbWl0aXZlVHlwZVwiOlxuICAgICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkO1xuICAgICAgICAgICAgY2FzZSBcInZhcmlhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibG9jYWxWYXJpYWJsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlO1xuICAgICAgICAgICAgY2FzZSBcIm1lbWJlclZhcmlhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyR2V0QWNjZXNzb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtZW1iZXJTZXRBY2Nlc3NvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyRnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RTaWduYXR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsU2lnbmF0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5kZXhTaWduYXR1cmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5GdW5jdGlvbjtcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuRW51bTtcbiAgICAgICAgICAgIGNhc2UgXCJtb2R1bGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5DbGFzcztcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmZhY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2U7XG4gICAgICAgICAgICBjYXNlIFwid2FybmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk7XG4gICAgfVxuICAgIENvbW1vbkNvbnZlcnRlci5jb252ZXJ0S2luZCA9IGNvbnZlcnRLaW5kO1xuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVCeUVycm9yTWVzc2FnZShkaWFnbm9zdGljcywgZXJyb3JNZXNzYWdlc1RvSWdub3JlLCBmaWVsZE5hbWUgPSBcIm1lc3NhZ2VcIikge1xuICAgICAgICBpZiAoIWVycm9yTWVzc2FnZXNUb0lnbm9yZSkgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3MuZmlsdGVyKChlbCk9PiEoMCx1dGlscy8qIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkgKi8uJHApKGVsW2ZpZWxkTmFtZV0sIGVycm9yTWVzc2FnZXNUb0lnbm9yZSkpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIuZXhjbHVkZUJ5RXJyb3JNZXNzYWdlID0gZXhjbHVkZUJ5RXJyb3JNZXNzYWdlO1xufSkoY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyIHx8IChjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXIgPSB7fSkpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdHlwZS1jb252ZXJ0ZXJzL2xzcC1jb252ZXJ0ZXJzLnRzXG5cblxuXG5cbmZ1bmN0aW9uIGZyb21SYW5nZShyYW5nZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBsaW5lOiByYW5nZS5zdGFydC5yb3csXG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHJhbmdlLnN0YXJ0LmNvbHVtblxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIGxpbmU6IHJhbmdlLmVuZC5yb3csXG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHJhbmdlLmVuZC5jb2x1bW5cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiByYW5nZUZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9SYW5nZShyYW5nZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICByb3c6IHJhbmdlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IHJhbmdlLnN0YXJ0LmNoYXJhY3RlclxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIHJvdzogcmFuZ2UuZW5kLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IHJhbmdlLmVuZC5jaGFyYWN0ZXJcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tUG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBwb2ludC5yb3csXG4gICAgICAgIGNoYXJhY3RlcjogcG9pbnQuY29sdW1uXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvUG9pbnQocG9zaXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb3c6IHBvc2l0aW9uLmxpbmUsXG4gICAgICAgIGNvbHVtbjogcG9zaXRpb24uY2hhcmFjdGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvQW5ub3RhdGlvbnMoZGlhZ25vc3RpY3MpIHtcbiAgICByZXR1cm4gZGlhZ25vc3RpY3MubWFwKChlbCk9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogZWwucmFuZ2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZWwucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyLFxuICAgICAgICAgICAgdGV4dDogZWwubWVzc2FnZSxcbiAgICAgICAgICAgIHR5cGU6IGVsLnNldmVyaXR5ID09PSAxID8gXCJlcnJvclwiIDogZWwuc2V2ZXJpdHkgPT09IDIgPyBcIndhcm5pbmdcIiA6IFwiaW5mb1wiXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb24oaXRlbSkge1xuICAgIHZhciBfaXRlbV90ZXh0RWRpdCwgX2l0ZW1fY29tbWFuZDtcbiAgICBsZXQgaXRlbUtpbmQgPSBpdGVtLmtpbmQ7XG4gICAgbGV0IGtpbmQgPSBpdGVtS2luZCA/IE9iamVjdC5rZXlzKENvbXBsZXRpb25JdGVtS2luZClbT2JqZWN0LnZhbHVlcyhDb21wbGV0aW9uSXRlbUtpbmQpLmluZGV4T2YoaXRlbUtpbmQpXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCwgX3JlZjtcbiAgICBsZXQgdGV4dCA9IChfcmVmID0gKF9pdGVtX3RleHRFZGl0X25ld1RleHQgPSAoX2l0ZW1fdGV4dEVkaXQgPSBpdGVtLnRleHRFZGl0KSA9PT0gbnVsbCB8fCBfaXRlbV90ZXh0RWRpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fdGV4dEVkaXQubmV3VGV4dCkgIT09IG51bGwgJiYgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCAhPT0gdm9pZCAwID8gX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCA6IGl0ZW0uaW5zZXJ0VGV4dCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGl0ZW0ubGFiZWw7XG4gICAgbGV0IGNvbW1hbmQgPSAoKF9pdGVtX2NvbW1hbmQgPSBpdGVtLmNvbW1hbmQpID09PSBudWxsIHx8IF9pdGVtX2NvbW1hbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVtX2NvbW1hbmQuY29tbWFuZCkgPT0gXCJlZGl0b3IuYWN0aW9uLnRyaWdnZXJTdWdnZXN0XCIgPyBcInN0YXJ0QXV0b2NvbXBsZXRlXCIgOiB1bmRlZmluZWQ7XG4gICAgbGV0IHJhbmdlID0gaXRlbS50ZXh0RWRpdCA/IGdldFRleHRFZGl0UmFuZ2UoaXRlbS50ZXh0RWRpdCkgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGNvbXBsZXRpb24gPSB7XG4gICAgICAgIG1ldGE6IGtpbmQsXG4gICAgICAgIGNhcHRpb246IGl0ZW0ubGFiZWwsXG4gICAgICAgIHNjb3JlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGNvbXBsZXRpb25bXCJjb21tYW5kXCJdID0gY29tbWFuZDtcbiAgICBjb21wbGV0aW9uW1wicmFuZ2VcIl0gPSByYW5nZTtcbiAgICBjb21wbGV0aW9uW1wiaXRlbVwiXSA9IGl0ZW07XG4gICAgaWYgKGl0ZW0uaW5zZXJ0VGV4dEZvcm1hdCA9PSBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQpIHtcbiAgICAgICAgY29tcGxldGlvbltcInNuaXBwZXRcIl0gPSB0ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRpb25bXCJ2YWx1ZVwiXSA9IHRleHQgIT09IG51bGwgJiYgdGV4dCAhPT0gdm9pZCAwID8gdGV4dCA6IFwiXCI7XG4gICAgfVxuICAgIGNvbXBsZXRpb25bXCJkb2N1bWVudGF0aW9uXCJdID0gaXRlbS5kb2N1bWVudGF0aW9uOyAvL1RPRE86IHRoaXMgaXMgd29ya2Fyb3VuZCBmb3Igc2VydmljZXMgd2l0aCBpbnN0YW50IGNvbXBsZXRpb25cbiAgICBjb21wbGV0aW9uW1wicG9zaXRpb25cIl0gPSBpdGVtW1wicG9zaXRpb25cIl07XG4gICAgY29tcGxldGlvbltcInNlcnZpY2VcIl0gPSBpdGVtW1wic2VydmljZVwiXTsgLy9UT0RPOiBzaW5jZSB3ZSBoYXZlIG11bHRpcGxlIHNlcnZlcnMsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgLy8gc2VydmVyIHRvIHVzZSBmb3IgcmVzb2x2aW5nXG4gICAgcmV0dXJuIGNvbXBsZXRpb247XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb25zKGNvbXBsZXRpb25zKSB7XG4gICAgaWYgKGNvbXBsZXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGNvbWJpbmVkQ29tcGxldGlvbnMgPSBjb21wbGV0aW9ucy5tYXAoKGVsKT0+e1xuICAgICAgICAgICAgaWYgKCFlbC5jb21wbGV0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhbGxDb21wbGV0aW9ucztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsLmNvbXBsZXRpb25zKSkge1xuICAgICAgICAgICAgICAgIGFsbENvbXBsZXRpb25zID0gZWwuY29tcGxldGlvbnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsbENvbXBsZXRpb25zID0gZWwuY29tcGxldGlvbnMuaXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsQ29tcGxldGlvbnMubWFwKChpdGVtKT0+e1xuICAgICAgICAgICAgICAgIGl0ZW1bXCJzZXJ2aWNlXCJdID0gZWwuc2VydmljZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5mbGF0KCk7XG4gICAgICAgIHJldHVybiBjb21iaW5lZENvbXBsZXRpb25zLm1hcCgoaXRlbSk9PnRvQ29tcGxldGlvbihpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIHRvUmVzb2x2ZWRDb21wbGV0aW9uKGNvbXBsZXRpb24sIGl0ZW0pIHtcbiAgICBjb21wbGV0aW9uW1wiZG9jTWFya2Rvd25cIl0gPSBmcm9tTWFya3VwQ29udGVudChpdGVtLmRvY3VtZW50YXRpb24pO1xuICAgIHJldHVybiBjb21wbGV0aW9uO1xufVxuZnVuY3Rpb24gdG9Db21wbGV0aW9uSXRlbShjb21wbGV0aW9uKSB7XG4gICAgbGV0IGNvbW1hbmQ7XG4gICAgaWYgKGNvbXBsZXRpb25bXCJjb21tYW5kXCJdKSB7XG4gICAgICAgIGNvbW1hbmQgPSB7XG4gICAgICAgICAgICB0aXRsZTogXCJ0cmlnZ2VyU3VnZ2VzdFwiLFxuICAgICAgICAgICAgY29tbWFuZDogY29tcGxldGlvbltcImNvbW1hbmRcIl1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9jb21wbGV0aW9uX2NhcHRpb247XG4gICAgbGV0IGNvbXBsZXRpb25JdGVtID0ge1xuICAgICAgICBsYWJlbDogKF9jb21wbGV0aW9uX2NhcHRpb24gPSBjb21wbGV0aW9uLmNhcHRpb24pICE9PSBudWxsICYmIF9jb21wbGV0aW9uX2NhcHRpb24gIT09IHZvaWQgMCA/IF9jb21wbGV0aW9uX2NhcHRpb24gOiBcIlwiLFxuICAgICAgICBraW5kOiBDb21tb25Db252ZXJ0ZXIuY29udmVydEtpbmQoY29tcGxldGlvbi5tZXRhKSxcbiAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogY29tcGxldGlvbltcInNuaXBwZXRcIl0gPyBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQgOiBJbnNlcnRUZXh0Rm9ybWF0LlBsYWluVGV4dCxcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogY29tcGxldGlvbltcImRvY3VtZW50YXRpb25cIl1cbiAgICB9O1xuICAgIGlmIChjb21wbGV0aW9uW1wicmFuZ2VcIl0pIHtcbiAgICAgICAgdmFyIF9jb21wbGV0aW9uX3NuaXBwZXQ7XG4gICAgICAgIGNvbXBsZXRpb25JdGVtLnRleHRFZGl0ID0ge1xuICAgICAgICAgICAgcmFuZ2U6IGZyb21SYW5nZShjb21wbGV0aW9uW1wicmFuZ2VcIl0pLFxuICAgICAgICAgICAgbmV3VGV4dDogKF9jb21wbGV0aW9uX3NuaXBwZXQgPSBjb21wbGV0aW9uW1wic25pcHBldFwiXSkgIT09IG51bGwgJiYgX2NvbXBsZXRpb25fc25pcHBldCAhPT0gdm9pZCAwID8gX2NvbXBsZXRpb25fc25pcHBldCA6IGNvbXBsZXRpb25bXCJ2YWx1ZVwiXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfY29tcGxldGlvbl9zbmlwcGV0MTtcbiAgICAgICAgY29tcGxldGlvbkl0ZW0uaW5zZXJ0VGV4dCA9IChfY29tcGxldGlvbl9zbmlwcGV0MSA9IGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdKSAhPT0gbnVsbCAmJiBfY29tcGxldGlvbl9zbmlwcGV0MSAhPT0gdm9pZCAwID8gX2NvbXBsZXRpb25fc25pcHBldDEgOiBjb21wbGV0aW9uW1widmFsdWVcIl07XG4gICAgfVxuICAgIGNvbXBsZXRpb25JdGVtW1wiZmlsZU5hbWVcIl0gPSBjb21wbGV0aW9uW1wiZmlsZU5hbWVcIl07XG4gICAgY29tcGxldGlvbkl0ZW1bXCJwb3NpdGlvblwiXSA9IGNvbXBsZXRpb25bXCJwb3NpdGlvblwiXTtcbiAgICBjb21wbGV0aW9uSXRlbVtcIml0ZW1cIl0gPSBjb21wbGV0aW9uW1wiaXRlbVwiXTtcbiAgICBjb21wbGV0aW9uSXRlbVtcInNlcnZpY2VcIl0gPSBjb21wbGV0aW9uW1wic2VydmljZVwiXTsgLy9UT0RPOlxuICAgIHJldHVybiBjb21wbGV0aW9uSXRlbTtcbn1cbmZ1bmN0aW9uIGdldFRleHRFZGl0UmFuZ2UodGV4dEVkaXQpIHtcbiAgICBpZiAodGV4dEVkaXQuaGFzT3duUHJvcGVydHkoXCJpbnNlcnRcIikgJiYgdGV4dEVkaXQuaGFzT3duUHJvcGVydHkoXCJyZXBsYWNlXCIpKSB7XG4gICAgICAgIHRleHRFZGl0ID0gdGV4dEVkaXQ7XG4gICAgICAgIGxldCBtZXJnZWRSYW5nZXMgPSBtZXJnZVJhbmdlcyhbXG4gICAgICAgICAgICB0b1JhbmdlKHRleHRFZGl0Lmluc2VydCksXG4gICAgICAgICAgICB0b1JhbmdlKHRleHRFZGl0LnJlcGxhY2UpXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkUmFuZ2VzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRFZGl0ID0gdGV4dEVkaXQ7XG4gICAgICAgIHJldHVybiB0b1JhbmdlKHRleHRFZGl0LnJhbmdlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1Rvb2x0aXAoaG92ZXIpIHtcbiAgICB2YXIgX2hvdmVyX2ZpbmQ7XG4gICAgaWYgKCFob3ZlcikgcmV0dXJuO1xuICAgIGxldCBjb250ZW50ID0gaG92ZXIubWFwKChlbCk9PntcbiAgICAgICAgaWYgKCFlbCB8fCAhZWwuY29udGVudHMpIHJldHVybjtcbiAgICAgICAgaWYgKE1hcmt1cENvbnRlbnQuaXMoZWwuY29udGVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU1hcmt1cENvbnRlbnQoZWwuY29udGVudHMpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hcmtlZFN0cmluZy5pcyhlbC5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwuY29udGVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJgYGBcIiArIGVsLmNvbnRlbnRzLnZhbHVlICsgXCJgYGBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50cyA9IGVsLmNvbnRlbnRzLm1hcCgoZWwpPT57XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcYFxcYFxcYCR7ZWwudmFsdWV9XFxgXFxgXFxgYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudHMuam9pbihcIlxcblxcblwiKTtcbiAgICAgICAgfVxuICAgIH0pLmZpbHRlcihub3RFbXB0eSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgLy9UT0RPOiBpdCBjb3VsZCBiZSBtZXJnZWQgd2l0aGluIGFsbCByYW5nZXMgaW4gZnV0dXJlXG4gICAgbGV0IGxzcFJhbmdlID0gKF9ob3Zlcl9maW5kID0gaG92ZXIuZmluZCgoZWwpPT57XG4gICAgICAgIHZhciBfZWw7XG4gICAgICAgIHJldHVybiAoX2VsID0gZWwpID09PSBudWxsIHx8IF9lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsLnJhbmdlO1xuICAgIH0pKSA9PT0gbnVsbCB8fCBfaG92ZXJfZmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hvdmVyX2ZpbmQucmFuZ2U7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChsc3BSYW5nZSkgcmFuZ2UgPSB0b1JhbmdlKGxzcFJhbmdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgICB0ZXh0OiBjb250ZW50LmpvaW4oXCJcXG5cXG5cIilcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21TaWduYXR1cmVIZWxwKHNpZ25hdHVyZUhlbHApIHtcbiAgICBpZiAoIXNpZ25hdHVyZUhlbHApIHJldHVybjtcbiAgICBsZXQgY29udGVudCA9IHNpZ25hdHVyZUhlbHAubWFwKChlbCk9PntcbiAgICAgICAgdmFyIF9lbCwgX2VsMTtcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc2lnbmF0dXJlSW5kZXggPSAoKF9lbCA9IGVsKSA9PT0gbnVsbCB8fCBfZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbC5hY3RpdmVTaWduYXR1cmUpIHx8IDA7XG4gICAgICAgIGxldCBhY3RpdmVTaWduYXR1cmUgPSBlbC5zaWduYXR1cmVzW3NpZ25hdHVyZUluZGV4XTtcbiAgICAgICAgaWYgKCFhY3RpdmVTaWduYXR1cmUpIHJldHVybjtcbiAgICAgICAgbGV0IGFjdGl2ZVBhcmFtID0gKF9lbDEgPSBlbCkgPT09IG51bGwgfHwgX2VsMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsMS5hY3RpdmVQYXJhbWV0ZXI7XG4gICAgICAgIGxldCBjb250ZW50cyA9IGFjdGl2ZVNpZ25hdHVyZS5sYWJlbDtcbiAgICAgICAgaWYgKGFjdGl2ZVBhcmFtICE9IHVuZGVmaW5lZCAmJiBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVycyAmJiBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVyc1thY3RpdmVQYXJhbV0pIHtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IGFjdGl2ZVNpZ25hdHVyZS5wYXJhbWV0ZXJzW2FjdGl2ZVBhcmFtXS5sYWJlbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMucmVwbGFjZShwYXJhbSwgYCoqJHtwYXJhbX0qKmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbikge1xuICAgICAgICAgICAgaWYgKE1hcmt1cENvbnRlbnQuaXMoYWN0aXZlU2lnbmF0dXJlLmRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzICsgXCJcXG5cXG5cIiArIGZyb21NYXJrdXBDb250ZW50KGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgKz0gXCJcXG5cXG5cIiArIGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICAgICAgfVxuICAgIH0pLmZpbHRlcihub3RFbXB0eSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrZG93blwiLFxuICAgICAgICAgICAgdGV4dDogY29udGVudC5qb2luKFwiXFxuXFxuXCIpXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbU1hcmt1cENvbnRlbnQoY29udGVudCkge1xuICAgIGlmICghY29udGVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudC52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tQWNlRGVsdGEoZGVsdGEsIGVvbCkge1xuICAgIGNvbnN0IHRleHQgPSBkZWx0YS5saW5lcy5sZW5ndGggPiAxID8gZGVsdGEubGluZXMuam9pbihlb2wpIDogZGVsdGEubGluZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2U6IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHJhbmdlRnJvbVBvc2l0aW9ucyhmcm9tUG9pbnQoZGVsdGEuc3RhcnQpLCBmcm9tUG9pbnQoZGVsdGEuc3RhcnQpKSA6IHJhbmdlRnJvbVBvc2l0aW9ucyhmcm9tUG9pbnQoZGVsdGEuc3RhcnQpLCBmcm9tUG9pbnQoZGVsdGEuZW5kKSksXG4gICAgICAgIHRleHQ6IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHRleHQgOiBcIlwiXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckRpYWdub3N0aWNzKGRpYWdub3N0aWNzLCBmaWx0ZXJFcnJvcnMpIHtcbiAgICByZXR1cm4gY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyLmV4Y2x1ZGVCeUVycm9yTWVzc2FnZShkaWFnbm9zdGljcywgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkubWFwKChlbCk9PntcbiAgICAgICAgaWYgKCgwLHV0aWxzLyogY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSAqLy4kcCkoZWwubWVzc2FnZSwgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nKSkge1xuICAgICAgICAgICAgZWwuc2V2ZXJpdHkgPSBicm93c2VyX21haW4uRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoKDAsdXRpbHMvKiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5ICovLiRwKShlbC5tZXNzYWdlLCBmaWx0ZXJFcnJvcnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8pKSB7XG4gICAgICAgICAgICBlbC5zZXZlcml0eSA9IGJyb3dzZXJfbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZnJvbURvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudEhpZ2hsaWdodHMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRIaWdobGlnaHRzLm1hcChmdW5jdGlvbihlbCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gZWwua2luZCA9PSAyID8gXCJsYW5ndWFnZV9oaWdobGlnaHRfcmVhZFwiIDogZWwua2luZCA9PSAzID8gXCJsYW5ndWFnZV9oaWdobGlnaHRfd3JpdGVcIiA6IFwibGFuZ3VhZ2VfaGlnaGxpZ2h0X3RleHRcIjtcbiAgICAgICAgcmV0dXJuIHRvTWFya2VyR3JvdXBJdGVtKENvbW1vbkNvbnZlcnRlci50b1JhbmdlKHRvUmFuZ2UoZWwucmFuZ2UpKSwgY2xhc3NOYW1lKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvTWFya2VyR3JvdXBJdGVtKHJhbmdlLCBjbGFzc05hbWUsIHRvb2x0aXBUZXh0KSB7XG4gICAgbGV0IG1hcmtlckdyb3VwSXRlbSA9IHtcbiAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH07XG4gICAgaWYgKHRvb2x0aXBUZXh0KSB7XG4gICAgICAgIG1hcmtlckdyb3VwSXRlbVtcInRvb2x0aXBUZXh0XCJdID0gdG9vbHRpcFRleHQ7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJHcm91cEl0ZW07XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZXJ2aWNlcy9qc29uL2pzb24tc2VydmljZS50c1xuZnVuY3Rpb24ganNvbl9zZXJ2aWNlX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cblxuY2xhc3MgSnNvblNlcnZpY2UgZXh0ZW5kcyBiYXNlX3NlcnZpY2UuQmFzZVNlcnZpY2Uge1xuICAgICRnZXRKc29uU2NoZW1hVXJpKHNlc3Npb25JRCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oc2Vzc2lvbklELCBcInNjaGVtYVVyaVwiKTtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIuYWRkRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLiRjb25maWd1cmVTZXJ2aWNlKGRvY3VtZW50LnVyaSk7XG4gICAgfVxuICAgICRjb25maWd1cmVTZXJ2aWNlKHNlc3Npb25JRCkge1xuICAgICAgICB2YXIgX3NjaGVtYXM7XG4gICAgICAgIGxldCBzY2hlbWFzID0gdGhpcy5nZXRPcHRpb24oc2Vzc2lvbklEICE9PSBudWxsICYmIHNlc3Npb25JRCAhPT0gdm9pZCAwID8gc2Vzc2lvbklEIDogXCJcIiwgXCJzY2hlbWFzXCIpO1xuICAgICAgICBsZXQgc2Vzc2lvbklEcyA9IHNlc3Npb25JRCA/IFtdIDogT2JqZWN0LmtleXModGhpcy5kb2N1bWVudHMpO1xuICAgICAgICAoX3NjaGVtYXMgPSBzY2hlbWFzKSA9PT0gbnVsbCB8fCBfc2NoZW1hcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjaGVtYXMuZm9yRWFjaCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbklEKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGdldEpzb25TY2hlbWFVcmkoc2Vzc2lvbklEKSA9PSBlbC51cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9maWxlTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIChfZmlsZU1hdGNoID0gKF9lbCA9IGVsKS5maWxlTWF0Y2gpICE9PSBudWxsICYmIF9maWxlTWF0Y2ggIT09IHZvaWQgMCA/IF9maWxlTWF0Y2ggOiBfZWwuZmlsZU1hdGNoID0gW107XG4gICAgICAgICAgICAgICAgICAgIGVsLmZpbGVNYXRjaC5wdXNoKHNlc3Npb25JRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5maWxlTWF0Y2ggPSBzZXNzaW9uSURzLmZpbHRlcigoc2Vzc2lvbklEKT0+dGhpcy4kZ2V0SnNvblNjaGVtYVVyaShzZXNzaW9uSUQpID09IGVsLnVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2VsX3NjaGVtYTtcbiAgICAgICAgICAgIGxldCBzY2hlbWEgPSAoX2VsX3NjaGVtYSA9IGVsLnNjaGVtYSkgIT09IG51bGwgJiYgX2VsX3NjaGVtYSAhPT0gdm9pZCAwID8gX2VsX3NjaGVtYSA6IHRoaXMuc2NoZW1hc1tlbC51cmldO1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkgdGhpcy5zY2hlbWFzW2VsLnVyaV0gPSBzY2hlbWE7XG4gICAgICAgICAgICB0aGlzLiRzZXJ2aWNlLnJlc2V0U2NoZW1hKGVsLnVyaSk7XG4gICAgICAgICAgICBlbC5zY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRzZXJ2aWNlLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBzY2hlbWFzOiBzY2hlbWFzLFxuICAgICAgICAgICAgYWxsb3dDb21tZW50czogdGhpcy5tb2RlID09PSBcImpzb241XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBfc2NoZW1hcztcbiAgICAgICAgc3VwZXIucmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICBsZXQgc2NoZW1hcyA9IHRoaXMuZ2V0T3B0aW9uKGRvY3VtZW50LnVyaSwgXCJzY2hlbWFzXCIpO1xuICAgICAgICAoX3NjaGVtYXMgPSBzY2hlbWFzKSA9PT0gbnVsbCB8fCBfc2NoZW1hcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjaGVtYXMuZm9yRWFjaCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoZWwudXJpID09PSB0aGlzLiRnZXRKc29uU2NoZW1hVXJpKGRvY3VtZW50LnVyaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsX2ZpbGVNYXRjaDtcbiAgICAgICAgICAgICAgICBlbC5maWxlTWF0Y2ggPSAoX2VsX2ZpbGVNYXRjaCA9IGVsLmZpbGVNYXRjaCkgPT09IG51bGwgfHwgX2VsX2ZpbGVNYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsX2ZpbGVNYXRjaC5maWx0ZXIoKHBhdHRlcm4pPT5wYXR0ZXJuICE9IGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRzZXJ2aWNlLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBzY2hlbWFzOiBzY2hlbWFzLFxuICAgICAgICAgICAgYWxsb3dDb21tZW50czogdGhpcy5tb2RlID09PSBcImpzb241XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE9wdGlvbnMoc2Vzc2lvbklELCBvcHRpb25zLCBtZXJnZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyLnNldE9wdGlvbnMoc2Vzc2lvbklELCBvcHRpb25zLCBtZXJnZSk7XG4gICAgICAgIHRoaXMuJGNvbmZpZ3VyZVNlcnZpY2Uoc2Vzc2lvbklEKTtcbiAgICB9XG4gICAgc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLnNldEdsb2JhbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuJGNvbmZpZ3VyZVNlcnZpY2UoKTtcbiAgICB9XG4gICAgZm9ybWF0KGRvY3VtZW50LCByYW5nZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZnVsbERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChkb2N1bWVudC51cmkpO1xuICAgICAgICBpZiAoIWZ1bGxEb2N1bWVudCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy4kc2VydmljZS5mb3JtYXQoZnVsbERvY3VtZW50LCByYW5nZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBhc3luYyBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICBsZXQgZnVsbERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChkb2N1bWVudC51cmkpO1xuICAgICAgICBpZiAoIWZ1bGxEb2N1bWVudCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBqc29uRG9jdW1lbnQgPSB0aGlzLiRzZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGZ1bGxEb2N1bWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZXJ2aWNlLmRvSG92ZXIoZnVsbERvY3VtZW50LCBwb3NpdGlvbiwganNvbkRvY3VtZW50KTtcbiAgICB9XG4gICAgYXN5bmMgZG9WYWxpZGF0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIGxldCBmdWxsRG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGlmICghZnVsbERvY3VtZW50KSByZXR1cm4gW107XG4gICAgICAgIGxldCBqc29uRG9jdW1lbnQgPSB0aGlzLiRzZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGZ1bGxEb2N1bWVudCk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljcyA9IGF3YWl0IHRoaXMuJHNlcnZpY2UuZG9WYWxpZGF0aW9uKGZ1bGxEb2N1bWVudCwganNvbkRvY3VtZW50LCB7XG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1hczogdGhpcy5tb2RlID09PSBcImpzb241XCIgPyBcImlnbm9yZVwiIDogXCJlcnJvclwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyRGlhZ25vc3RpY3MoZGlhZ25vc3RpY3MsIHRoaXMub3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MpO1xuICAgIH1cbiAgICBhc3luYyBkb0NvbXBsZXRlKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICBsZXQgZnVsbERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChkb2N1bWVudC51cmkpO1xuICAgICAgICBpZiAoIWZ1bGxEb2N1bWVudCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBqc29uRG9jdW1lbnQgPSB0aGlzLiRzZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGZ1bGxEb2N1bWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZXJ2aWNlLmRvQ29tcGxldGUoZnVsbERvY3VtZW50LCBwb3NpdGlvbiwganNvbkRvY3VtZW50KTtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNlcnZpY2UuZG9SZXNvbHZlKGl0ZW0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihtb2RlKXtcbiAgICAgICAgc3VwZXIobW9kZSk7XG4gICAgICAgIGpzb25fc2VydmljZV9kZWZpbmVfcHJvcGVydHkodGhpcywgXCIkc2VydmljZVwiLCB2b2lkIDApO1xuICAgICAgICBqc29uX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2NoZW1hc1wiLCB7fSk7XG4gICAgICAgIGpzb25fc2VydmljZV9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHtcbiAgICAgICAgICAgIGNvbXBsZXRpb25Qcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFyYWN0ZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICdcIicsXG4gICAgICAgICAgICAgICAgICAgICc6J1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaWFnbm9zdGljUHJvdmlkZXI6IHtcbiAgICAgICAgICAgICAgICBpbnRlckZpbGVEZXBlbmRlbmNpZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRGlhZ25vc3RpY3M6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJHNlcnZpY2UgPSBnZXRMYW5ndWFnZVNlcnZpY2Uoe1xuICAgICAgICAgICAgc2NoZW1hUmVxdWVzdFNlcnZpY2U6ICh1cmkpPT57XG4gICAgICAgICAgICAgICAgdXJpID0gdXJpLnJlcGxhY2UoXCJmaWxlOi8vL1wiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBsZXQganNvblNjaGVtYSA9IHRoaXMuc2NoZW1hc1t1cmldO1xuICAgICAgICAgICAgICAgIGlmIChqc29uU2NoZW1hKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGpzb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGF0ICR7dXJpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbn0pKCk7XG5cbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJhIiwiaSIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwicHJvY2VzcyIsImNvbnNvbGUiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfcmVxdWlyZSIsIl9yZXF1aXJlJGNvZGVzIiwiY29kZXMiLCJFUlJfQU1CSUdVT1VTX0FSR1VNRU5UIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfSU5WQUxJRF9BUkdfVkFMVUUiLCJFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUiLCJFUlJfTUlTU0lOR19BUkdTIiwiQXNzZXJ0aW9uRXJyb3IiLCJfcmVxdWlyZTIiLCJpbnNwZWN0IiwiX3JlcXVpcmUkdHlwZXMiLCJ0eXBlcyIsImlzUHJvbWlzZSIsImlzUmVnRXhwIiwib2JqZWN0QXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwib2JqZWN0SXMiLCJpcyIsImVycm9yQ2FjaGUiLCJNYXAiLCJpc0RlZXBFcXVhbCIsImlzRGVlcFN0cmljdEVxdWFsIiwicGFyc2VFeHByZXNzaW9uQXQiLCJmaW5kTm9kZUFyb3VuZCIsImRlY29kZXIiLCJsYXp5TG9hZENvbXBhcmlzb24iLCJjb21wYXJpc29uIiwiZXNjYXBlU2VxdWVuY2VzUmVnRXhwIiwibWV0YSIsImVzY2FwZUZuIiwic3RyIiwiY2hhckNvZGVBdCIsIndhcm5lZCIsImFzc2VydCIsIm9rIiwiTk9fRVhDRVBUSU9OX1NFTlRJTkVMIiwiaW5uZXJGYWlsIiwibWVzc2FnZSIsIkVycm9yIiwiZmFpbCIsImFjdHVhbCIsImV4cGVjdGVkIiwib3BlcmF0b3IiLCJzdGFja1N0YXJ0Rm4iLCJhcmdzTGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaW50ZXJuYWxNZXNzYWdlIiwidW5kZWZpbmVkIiwid2FybiIsImVtaXRXYXJuaW5nIiwiYmluZCIsImVyckFyZ3MiLCJlcnIiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiaW5uZXJPayIsImZuIiwiYXJnTGVuIiwidmFsdWUiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImFwcGx5IiwiY29uY2F0IiwiZXF1YWwiLCJub3RFcXVhbCIsImRlZXBFcXVhbCIsIm5vdERlZXBFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsIm5vdERlZXBTdHJpY3RFcXVhbCIsInN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJDb21wYXJpc29uIiwia2V5cyIsIl90aGlzIiwiZm9yRWFjaCIsImtleSIsInRlc3QiLCJjb21wYXJlRXhjZXB0aW9uS2V5IiwiYiIsIm5hbWUiLCJleHBlY3RlZEV4Y2VwdGlvbiIsIm1zZyIsInB1c2giLCJpc1Byb3RvdHlwZU9mIiwiY2FsbCIsImdldEFjdHVhbCIsImUiLCJjaGVja0lzUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsIndhaXRGb3JBY3R1YWwiLCJwcm9taXNlRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdFByb21pc2UiLCJleHBlY3RzRXJyb3IiLCJlcnJvciIsImRldGFpbHMiLCJmblR5cGUiLCJleHBlY3RzTm9FcnJvciIsInRocm93cyIsIl9sZW4yIiwiX2tleTIiLCJyZWplY3RzIiwiX2xlbjMiLCJfa2V5MyIsInJlc3VsdCIsImRvZXNOb3RUaHJvdyIsIl9sZW40IiwiX2tleTQiLCJkb2VzTm90UmVqZWN0IiwiX2xlbjUiLCJfa2V5NSIsImlmRXJyb3IiLCJuZXdFcnIiLCJvcmlnU3RhY2siLCJzdGFjayIsInRtcDIiLCJzcGxpdCIsInNoaWZ0IiwidG1wMSIsInBvcyIsImluZGV4T2YiLCJzbGljZSIsImpvaW4iLCJzdHJpY3QiLCJfbGVuNiIsIl9rZXk2IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsInNvdXJjZSIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX2RlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwiX3dyYXBOYXRpdmVTdXBlciIsIkNsYXNzIiwiX2NhY2hlIiwiX2lzTmF0aXZlRnVuY3Rpb24iLCJoYXMiLCJnZXQiLCJzZXQiLCJXcmFwcGVyIiwiX2NvbnN0cnVjdCIsIl9nZXRQcm90b3R5cGVPZiIsImlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJEYXRlIiwidG9TdHJpbmciLCJQYXJlbnQiLCJGdW5jdGlvbiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJnZXRQcm90b3R5cGVPZiIsImVuZHNXaXRoIiwic2VhcmNoIiwidGhpc19sZW4iLCJzdWJzdHJpbmciLCJyZXBlYXQiLCJjb3VudCIsIk1hdGgiLCJmbG9vciIsIm1heENvdW50IiwibG9nIiwiYmx1ZSIsImdyZWVuIiwicmVkIiwid2hpdGUiLCJrUmVhZGFibGVPcGVyYXRvciIsInN0cmljdEVxdWFsT2JqZWN0Iiwibm90U3RyaWN0RXF1YWxPYmplY3QiLCJub3RJZGVudGljYWwiLCJrTWF4U2hvcnRMZW5ndGgiLCJjb3B5RXJyb3IiLCJpbnNwZWN0VmFsdWUiLCJ2YWwiLCJjb21wYWN0IiwiY3VzdG9tSW5zcGVjdCIsImRlcHRoIiwibWF4QXJyYXlMZW5ndGgiLCJJbmZpbml0eSIsInNob3dIaWRkZW4iLCJicmVha0xlbmd0aCIsInNob3dQcm94eSIsInNvcnRlZCIsImdldHRlcnMiLCJjcmVhdGVFcnJEaWZmIiwib3RoZXIiLCJyZXMiLCJsYXN0UG9zIiwiZW5kIiwic2tpcHBlZCIsImFjdHVhbEluc3BlY3RlZCIsImFjdHVhbExpbmVzIiwiZXhwZWN0ZWRMaW5lcyIsImluZGljYXRvciIsImlucHV0TGVuZ3RoIiwibWF4TGVuZ3RoIiwic3RkZXJyIiwiaXNUVFkiLCJjb2x1bW5zIiwicG9wIiwibWF4TGluZXMiLCJtYXgiLCJfYWN0dWFsTGluZXMiLCJwcmludGVkTGluZXMiLCJza2lwcGVkTXNnIiwiY3VyIiwiZXhwZWN0ZWRMaW5lIiwiYWN0dWFsTGluZSIsImRpdmVyZ2luZ0xpbmVzIiwiX0Vycm9yIiwib3B0aW9ucyIsImxpbWl0Iiwic3RhY2tUcmFjZUxpbWl0IiwiU3RyaW5nIiwiZ2V0Q29sb3JEZXB0aCIsImJhc2UiLCJfcmVzIiwia25vd25PcGVyYXRvcnMiLCJjb2RlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjdXN0b20iLCJyZWN1cnNlVGltZXMiLCJjdHgiLCJ1dGlsIiwiY3JlYXRlRXJyb3JUeXBlIiwiQmFzZSIsImdldE1lc3NhZ2UiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJOb2RlRXJyb3IiLCJfQmFzZSIsIm9uZU9mIiwidGhpbmciLCJpc0FycmF5IiwibGVuIiwibWFwIiwic3RhcnRzV2l0aCIsInN1YnN0ciIsImluY2x1ZGVzIiwic3RhcnQiLCJkZXRlcm1pbmVyIiwicmVwbGFjZSIsInR5cGUiLCJyZWFzb24iLCJpbnNwZWN0ZWQiLCJSYW5nZUVycm9yIiwiaW5wdXQiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9ub25JdGVyYWJsZVJlc3QiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwicmVnZXhGbGFnc1N1cHBvcnRlZCIsImZsYWdzIiwiYXJyYXlGcm9tU2V0IiwiYXJyYXkiLCJhcnJheUZyb21NYXAiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJudW1iZXJJc05hTiIsIk51bWJlciIsImlzTmFOIiwidW5jdXJyeVRoaXMiLCJmIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm9iamVjdFRvU3RyaW5nIiwiaXNBbnlBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiaXNEYXRlIiwiaXNNYXAiLCJpc1NldCIsImlzTmF0aXZlRXJyb3IiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNOb25JbmRleCIsInBvdyIsImdldE93bk5vbkluZGV4UHJvcGVydGllcyIsImNvbXBhcmUiLCJ4IiwieSIsIm1pbiIsIk9OTFlfRU5VTUVSQUJMRSIsImtTdHJpY3QiLCJrTG9vc2UiLCJrTm9JdGVyYXRvciIsImtJc0FycmF5Iiwia0lzU2V0Iiwia0lzTWFwIiwiYXJlU2ltaWxhclJlZ0V4cHMiLCJSZWdFeHAiLCJhcmVTaW1pbGFyRmxvYXRBcnJheXMiLCJieXRlTGVuZ3RoIiwib2Zmc2V0IiwiYXJlU2ltaWxhclR5cGVkQXJyYXlzIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJhcmVFcXVhbEFycmF5QnVmZmVycyIsImJ1ZjEiLCJidWYyIiwiaXNFcXVhbEJveGVkUHJpbWl0aXZlIiwidmFsMSIsInZhbDIiLCJ2YWx1ZU9mIiwiQm9vbGVhbiIsIkJpZ0ludCIsImlubmVyRGVlcEVxdWFsIiwibWVtb3MiLCJ2YWwxVGFnIiwidmFsMlRhZyIsImtleXMxIiwia2V5czIiLCJrZXlDaGVjayIsImdldFRpbWUiLCJfa2V5cyIsIl9rZXlzMiIsInNpemUiLCJnZXRFbnVtZXJhYmxlcyIsImsiLCJpdGVyYXRpb25UeXBlIiwiYUtleXMiLCJiS2V5cyIsInN5bWJvbEtleXNBIiwic3ltYm9sS2V5c0IiLCJfc3ltYm9sS2V5c0IiLCJwb3NpdGlvbiIsInZhbDJNZW1vQSIsInZhbDJNZW1vQiIsImFyZUVxIiwib2JqRXF1aXYiLCJkZWxldGUiLCJzZXRIYXNFcXVhbEVsZW1lbnQiLCJtZW1vIiwic2V0VmFsdWVzIiwiZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzIiwicHJpbSIsInNldE1pZ2h0SGF2ZUxvb3NlUHJpbSIsImFsdFZhbHVlIiwibWFwTWlnaHRIYXZlTG9vc2VQcmltIiwiaXRlbSIsImN1ckIiLCJzZXRFcXVpdiIsImFWYWx1ZXMiLCJTZXQiLCJhZGQiLCJiVmFsdWVzIiwiX3ZhbCIsIm1hcEhhc0VxdWFsRW50cnkiLCJrZXkxIiwiaXRlbTEiLCJrZXkyIiwibWFwRXF1aXYiLCJhRW50cmllcyIsIl9hRW50cmllcyRpIiwiaXRlbTIiLCJiRW50cmllcyIsIl9pMiIsIl9iRW50cmllcyRfaSIsImtleXNBIiwiR2V0SW50cmluc2ljIiwiY2FsbEJpbmQiLCIkaW5kZXhPZiIsImNhbGxCb3VuZEludHJpbnNpYyIsImFsbG93TWlzc2luZyIsImludHJpbnNpYyIsIiRhcHBseSIsIiRjYWxsIiwiJHJlZmxlY3RBcHBseSIsIiRnT1BEIiwiJGRlZmluZVByb3BlcnR5IiwiJG1heCIsIm9yaWdpbmFsRnVuY3Rpb24iLCJmdW5jIiwiZGVzYyIsImFwcGx5QmluZCIsIm5vdyIsInRpbWVzIiwiZyIsIndpbmRvdyIsImZ1bmN0aW9ucyIsImluZm8iLCJ0aW1lIiwidGltZUVuZCIsInRyYWNlIiwiZGlyIiwiY29uc29sZUFzc2VydCIsInR1cGxlIiwibGFiZWwiLCJkdXJhdGlvbiIsImZvcm1hdCIsIm9iamVjdCIsImV4cHJlc3Npb24iLCJoYXNTeW1ib2xzIiwidG9TdHIiLCJvcmlnRGVmaW5lUHJvcGVydHkiLCJpc0Z1bmN0aW9uIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9ycyIsInN1cHBvcnRzRGVzY3JpcHRvcnMiLCJwcmVkaWNhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJlZGljYXRlcyIsImZpcnN0U291cmNlIiwidG8iLCJuZXh0U291cmNlIiwia2V5c0FycmF5IiwibmV4dEluZGV4IiwibmV4dEtleSIsInBvbHlmaWxsIiwiaXNDYWxsYWJsZSIsImZvckVhY2hBcnJheSIsInJlY2VpdmVyIiwiZm9yRWFjaFN0cmluZyIsInN0cmluZyIsImNoYXJBdCIsImZvckVhY2hPYmplY3QiLCJsaXN0IiwidGhpc0FyZyIsIkVSUk9SX01FU1NBR0UiLCJmdW5jVHlwZSIsInRoYXQiLCJib3VuZCIsImJpbmRlciIsImJvdW5kTGVuZ3RoIiwiYm91bmRBcmdzIiwiRW1wdHkiLCJpbXBsZW1lbnRhdGlvbiIsIiRTeW50YXhFcnJvciIsIlN5bnRheEVycm9yIiwiJEZ1bmN0aW9uIiwiJFR5cGVFcnJvciIsImdldEV2YWxsZWRDb25zdHJ1Y3RvciIsImV4cHJlc3Npb25TeW50YXgiLCJ0aHJvd1R5cGVFcnJvciIsIlRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiY2FsbGVlVGhyb3dzIiwiZ09QRHRocm93cyIsImhhc1Byb3RvIiwiZ2V0UHJvdG8iLCJuZWVkc0V2YWwiLCJUeXBlZEFycmF5IiwiSU5UUklOU0lDUyIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJBdG9taWNzIiwiQmlnSW50NjRBcnJheSIsIkJpZ1VpbnQ2NEFycmF5IiwiRGF0YVZpZXciLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJldmFsIiwiRXZhbEVycm9yIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiSlNPTiIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlNoYXJlZEFycmF5QnVmZmVyIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiVVJJRXJyb3IiLCJXZWFrTWFwIiwiV2Vha1JlZiIsIldlYWtTZXQiLCJlcnJvclByb3RvIiwiZG9FdmFsIiwiZ2VuIiwiTEVHQUNZX0FMSUFTRVMiLCJoYXNPd24iLCIkY29uY2F0IiwiJHNwbGljZUFwcGx5Iiwic3BsaWNlIiwiJHJlcGxhY2UiLCIkc3RyU2xpY2UiLCIkZXhlYyIsImV4ZWMiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwic3RyaW5nVG9QYXRoIiwiZmlyc3QiLCJsYXN0IiwibWF0Y2giLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImdldEJhc2VJbnRyaW5zaWMiLCJpbnRyaW5zaWNOYW1lIiwiYWxpYXMiLCJwYXJ0cyIsImludHJpbnNpY0Jhc2VOYW1lIiwiaW50cmluc2ljUmVhbE5hbWUiLCJza2lwRnVydGhlckNhY2hpbmciLCJpc093biIsInBhcnQiLCJoYXNBcnJheUxlbmd0aERlZmluZUJ1ZyIsImZvbyIsIiRPYmplY3QiLCJvcmlnU3ltYm9sIiwiaGFzU3ltYm9sU2hhbSIsImhhc05hdGl2ZVN5bWJvbHMiLCJzeW1PYmoiLCJzeW1WYWwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic3ltcyIsImhhc1RvU3RyaW5nVGFnU2hhbXMiLCJ0b1N0cmluZ1RhZyIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaGFzVG9TdHJpbmdUYWciLCJjYWxsQm91bmQiLCIkdG9TdHJpbmciLCJpc1N0YW5kYXJkQXJndW1lbnRzIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsInN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMiLCJmblRvU3RyIiwicmVmbGVjdEFwcGx5IiwiYmFkQXJyYXlMaWtlIiwiaXNDYWxsYWJsZU1hcmtlciIsIl8iLCJjb25zdHJ1Y3RvclJlZ2V4IiwiaXNFUzZDbGFzc0ZuIiwiaXNFUzZDbGFzc0Z1bmN0aW9uIiwiZm5TdHIiLCJ0cnlGdW5jdGlvbk9iamVjdCIsInRyeUZ1bmN0aW9uVG9TdHIiLCJvYmplY3RDbGFzcyIsImZuQ2xhc3MiLCJnZW5DbGFzcyIsImRkYUNsYXNzIiwiZGRhQ2xhc3MyIiwiZGRhQ2xhc3MzIiwiaXNJRTY4IiwiaXNEREEiLCJpc0RvY3VtZW50RG90QWxsIiwiZG9jdW1lbnQiLCJhbGwiLCJzdHJDbGFzcyIsImlzRm5SZWdleCIsImdldEdlbmVyYXRvckZ1bmMiLCJHZW5lcmF0b3JGdW5jdGlvbiIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5lcmF0b3JGdW5jIiwiZ2V0UG9seWZpbGwiLCJzaGltIiwiTmFOIiwic2hpbU51bWJlcklzTmFOIiwidGVzdElzTmFOIiwid2hpY2hUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwic2hpbU9iamVjdElzIiwidGVzdE9iamVjdElzIiwia2V5c1NoaW0iLCJpc0FyZ3MiLCJpc0VudW1lcmFibGUiLCJoYXNEb250RW51bUJ1ZyIsImhhc1Byb3RvRW51bUJ1ZyIsImRvbnRFbnVtcyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhjbHVkZWRLZXlzIiwiJGFwcGxpY2F0aW9uQ2FjaGUiLCIkY29uc29sZSIsIiRleHRlcm5hbCIsIiRmcmFtZSIsIiRmcmFtZUVsZW1lbnQiLCIkZnJhbWVzIiwiJGlubmVySGVpZ2h0IiwiJGlubmVyV2lkdGgiLCIkb25tb3pmdWxsc2NyZWVuY2hhbmdlIiwiJG9ubW96ZnVsbHNjcmVlbmVycm9yIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkcGFyZW50IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJpc09iamVjdCIsImlzU3RyaW5nIiwidGhlS2V5cyIsInNraXBQcm90byIsImoiLCJza2lwQ29uc3RydWN0b3IiLCJvcmlnS2V5cyIsIm9yaWdpbmFsS2V5cyIsInNoaW1PYmplY3RLZXlzIiwia2V5c1dvcmtzV2l0aEFyZ3VtZW50cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIm5leHRUaWNrIiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJkIiwiQmFzZVNlcnZpY2UiLCJfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIl9kZWZpbmVfcHJvcGVydHkiLCJhZGREb2N1bWVudCIsImRvY3VtZW50cyIsInVyaSIsIm4iLCJsYW5ndWFnZUlkIiwidGV4dCIsImdldERvY3VtZW50IiwicmVtb3ZlRG9jdW1lbnQiLCJnZXREb2N1bWVudFZhbHVlIiwiX3RoaXNfZ2V0RG9jdW1lbnQiLCJnZXRUZXh0Iiwic2V0VmFsdWUiLCJpZGVudGlmaWVyIiwic2V0R2xvYmFsT3B0aW9ucyIsImdsb2JhbE9wdGlvbnMiLCJzZXRPcHRpb25zIiwic2Vzc2lvbklEIiwibWVyZ2UiLCJQTSIsImdldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJhcHBseURlbHRhcyIsImRlbHRhcyIsInVwZGF0ZSIsImRvQ29tcGxldGUiLCJkb0hvdmVyIiwiZG9SZXNvbHZlIiwiZG9WYWxpZGF0aW9uIiwicmFuZ2UiLCJwcm92aWRlU2lnbmF0dXJlSGVscCIsImZpbmREb2N1bWVudEhpZ2hsaWdodHMiLCJvcHRpb25zVG9GaWx0ZXJEaWFnbm9zdGljcyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8iLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JDb2Rlc1RvSWdub3JlIiwiZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsImVycm9yTWVzc2FnZXNUb0lnbm9yZSIsImVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJtb2RlIiwiJHAiLCJjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5IiwibWVyZ2VPYmplY3RzIiwib2JqMSIsIm9iajIiLCJtZXJnZWRPYmplY3RzIiwibm90RW1wdHkiLCJtZXJnZVJhbmdlcyIsInJhbmdlcyIsInNvcnQiLCJjb21wYXJlUG9pbnRzIiwiY21wIiwiaXNFbXB0eSIsInJvdyIsImNvbHVtbiIsInAxIiwicDIiLCJyZWdleHBBcnJheSIsImlzQnVmZmVyIiwiYXJnIiwiY29weSIsImZpbGwiLCJyZWFkVUludDgiLCJpc0FyZ3VtZW50c09iamVjdCIsIkJpZ0ludFN1cHBvcnRlZCIsIlN5bWJvbFN1cHBvcnRlZCIsIk9iamVjdFRvU3RyaW5nIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xlYW5WYWx1ZSIsImJpZ0ludFZhbHVlIiwic3ltYm9sVmFsdWUiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwicHJvdG90eXBlVmFsdWVPZiIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc01hcFRvU3RyaW5nIiwid29ya2luZyIsImlzU2V0VG9TdHJpbmciLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsIlNoYXJlZEFycmF5QnVmZmVyQ29weSIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwibWV0aG9kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZm9ybWF0UmVnRXhwIiwib2JqZWN0cyIsInN0cmluZ2lmeSIsImlzTnVsbCIsImRlcHJlY2F0ZSIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0VudlJlZ2V4IiwiTk9ERV9ERUJVRyIsImRlYnVnRW52IiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsIm9wdHMiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiY29sb3JzIiwiaXNCb29sZWFuIiwiX2V4dGVuZCIsImlzVW5kZWZpbmVkIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwic3R5bGVzIiwic3R5bGVUeXBlIiwic3R5bGUiLCJhcnJheVRvSGFzaCIsImhhc2giLCJpZHgiLCJyZXQiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwib3V0cHV0IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiaXNOdW1iZXIiLCJsIiwibGluZSIsIm51bUxpbmVzRXN0IiwicmVkdWNlIiwicHJldiIsImFyIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwicHJvcCIsImtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCIsInByb21pc2lmeSIsIm9yaWdpbmFsIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlUmVqZWN0IiwicHJvbWlzZSIsInJlamVjdCIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsImNiIiwibmV3UmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwibWF5YmVDYiIsInJlaiIsIl9fY3JlYXRlQmluZGluZyIsIm0iLCJrMiIsIl9fZXNNb2R1bGUiLCJfX2V4cG9ydFN0YXIiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIkJyb3dzZXJNZXNzYWdlV3JpdGVyIiwiQnJvd3Nlck1lc3NhZ2VSZWFkZXIiLCJyaWxfMSIsImRlZmF1bHQiLCJpbnN0YWxsIiwiYXBpXzEiLCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXIiLCJsaXN0ZW4iLCJjYWxsYmFjayIsIl9vbkRhdGEiLCJldmVudCIsInBvcnQiLCJFbWl0dGVyIiwiX21lc3NhZ2VMaXN0ZW5lciIsImZpcmUiLCJkYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVFcnJvciIsIm9ubWVzc2FnZSIsIkFic3RyYWN0TWVzc2FnZVdyaXRlciIsIndyaXRlIiwicG9zdE1lc3NhZ2UiLCJoYW5kbGVFcnJvciIsImVycm9yQ291bnQiLCJyZWFkZXIiLCJ3cml0ZXIiLCJsb2dnZXIiLCJOdWxsTG9nZ2VyIiwiQ29ubmVjdGlvblN0cmF0ZWd5IiwiY29ubmVjdGlvblN0cmF0ZWd5IiwiTWVzc2FnZUJ1ZmZlciIsIkFic3RyYWN0TWVzc2FnZUJ1ZmZlciIsImVtcHR5QnVmZmVyIiwiZnJvbVN0cmluZyIsIl9lbmNvZGluZyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZW5jb2RpbmciLCJhc2NpaURlY29kZXIiLCJkZWNvZGUiLCJUZXh0RGVjb2RlciIsImFzTmF0aXZlIiwiYWxsb2NOYXRpdmUiLCJSZWFkYWJsZVN0cmVhbVdyYXBwZXIiLCJvbkNsb3NlIiwibGlzdGVuZXIiLCJzb2NrZXQiLCJEaXNwb3NhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uRXJyb3IiLCJvbkVuZCIsIm9uRGF0YSIsImJsb2IiLCJhcnJheUJ1ZmZlciIsIlJBTCIsIldyaXRhYmxlU3RyZWFtV3JhcHBlciIsInNlbmQiLCJjbG9zZSIsIl90ZXh0RW5jb2RlciIsIl9yaWwiLCJmcmVlemUiLCJtZXNzYWdlQnVmZmVyIiwiYXBwbGljYXRpb25Kc29uIiwiZW5jb2RlciIsImNoYXJzZXQiLCJwYXJzZSIsInN0cmVhbSIsImFzUmVhZGFibGVTdHJlYW0iLCJhc1dyaXRhYmxlU3RyZWFtIiwidGltZXIiLCJtcyIsImhhbmRsZSIsImRpc3Bvc2UiLCJzZXRJbW1lZGlhdGUiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJSSUwiLCJQcm9ncmVzc1R5cGUiLCJQcm9ncmVzc1Rva2VuIiwiQ29ubmVjdGlvbk9wdGlvbnMiLCJXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyIiwiTWVzc2FnZVdyaXRlciIsIlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciIsIk1lc3NhZ2VSZWFkZXIiLCJTaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kiLCJTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uVG9rZW4iLCJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSIsIkV2ZW50IiwiTFJVQ2FjaGUiLCJUb3VjaCIsIkxpbmtlZE1hcCIsIlBhcmFtZXRlclN0cnVjdHVyZXMiLCJOb3RpZmljYXRpb25UeXBlOSIsIk5vdGlmaWNhdGlvblR5cGU4IiwiTm90aWZpY2F0aW9uVHlwZTciLCJOb3RpZmljYXRpb25UeXBlNiIsIk5vdGlmaWNhdGlvblR5cGU1IiwiTm90aWZpY2F0aW9uVHlwZTQiLCJOb3RpZmljYXRpb25UeXBlMyIsIk5vdGlmaWNhdGlvblR5cGUyIiwiTm90aWZpY2F0aW9uVHlwZTEiLCJOb3RpZmljYXRpb25UeXBlMCIsIk5vdGlmaWNhdGlvblR5cGUiLCJFcnJvckNvZGVzIiwiUmVzcG9uc2VFcnJvciIsIlJlcXVlc3RUeXBlOSIsIlJlcXVlc3RUeXBlOCIsIlJlcXVlc3RUeXBlNyIsIlJlcXVlc3RUeXBlNiIsIlJlcXVlc3RUeXBlNSIsIlJlcXVlc3RUeXBlNCIsIlJlcXVlc3RUeXBlMyIsIlJlcXVlc3RUeXBlMiIsIlJlcXVlc3RUeXBlMSIsIlJlcXVlc3RUeXBlMCIsIlJlcXVlc3RUeXBlIiwiTWVzc2FnZSIsIk1lc3NhZ2VTdHJhdGVneSIsIkNhbmNlbGxhdGlvblN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IiwiQ29ubmVjdGlvbkVycm9yIiwiQ29ubmVjdGlvbkVycm9ycyIsIkxvZ1RyYWNlTm90aWZpY2F0aW9uIiwiU2V0VHJhY2VOb3RpZmljYXRpb24iLCJUcmFjZUZvcm1hdCIsIlRyYWNlVmFsdWVzIiwiVHJhY2UiLCJtZXNzYWdlc18xIiwibGlua2VkTWFwXzEiLCJkaXNwb3NhYmxlXzEiLCJldmVudHNfMSIsImNhbmNlbGxhdGlvbl8xIiwic2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMSIsIm1lc3NhZ2VSZWFkZXJfMSIsIm1lc3NhZ2VXcml0ZXJfMSIsIm1lc3NhZ2VCdWZmZXJfMSIsImNvbm5lY3Rpb25fMSIsInJhbF8xIiwiSXMiLCJOb25lIiwiaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsIkNhbmNlbGxlZCIsImNhbmRpZGF0ZSIsImJvb2xlYW4iLCJzaG9ydGN1dEV2ZW50IiwiY29udGV4dCIsIk11dGFibGVUb2tlbiIsImNhbmNlbCIsIl9pc0NhbmNlbGxlZCIsIl9lbWl0dGVyIiwidG9rZW4iLCJfdG9rZW4iLCJSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSIsIklkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSIsIkNhbmNlbE5vdGlmaWNhdGlvbiIsIlByb2dyZXNzTm90aWZpY2F0aW9uIiwiU3RhclJlcXVlc3RIYW5kbGVyIiwiT2ZmIiwiTWVzc2FnZXMiLCJDb21wYWN0IiwiVmVyYm9zZSIsInRvTG93ZXJDYXNlIiwiVGV4dCIsImNhbmNlbFVuZGlzcGF0Y2hlZCIsImtpbmQiLCJjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSIsInNlbmRDYW5jZWxsYXRpb24iLCJjb25uIiwiaWQiLCJzZW5kTm90aWZpY2F0aW9uIiwiY2xlYW51cCIsInNlbmRlciIsImhhbmRsZU1lc3NhZ2UiLCJjYW5jZWxsYXRpb25TdHJhdGVneSIsIm1lc3NhZ2VTdHJhdGVneSIsIkNvbm5lY3Rpb25TdGF0ZSIsIm1lc3NhZ2VSZWFkZXIiLCJtZXNzYWdlV3JpdGVyIiwiX2xvZ2dlciIsInNlcXVlbmNlTnVtYmVyIiwibm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIiLCJ1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlciIsInN0YXJSZXF1ZXN0SGFuZGxlciIsInJlcXVlc3RIYW5kbGVycyIsInN0YXJOb3RpZmljYXRpb25IYW5kbGVyIiwibm90aWZpY2F0aW9uSGFuZGxlcnMiLCJwcm9ncmVzc0hhbmRsZXJzIiwibWVzc2FnZVF1ZXVlIiwicmVzcG9uc2VQcm9taXNlcyIsImtub3duQ2FuY2VsZWRSZXF1ZXN0cyIsInJlcXVlc3RUb2tlbnMiLCJ0cmFjZUZvcm1hdCIsInRyYWNlciIsInN0YXRlIiwiTmV3IiwiZXJyb3JFbWl0dGVyIiwiY2xvc2VFbWl0dGVyIiwidW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlciIsInVuaGFuZGxlZFByb2dyZXNzRW1pdHRlciIsImRpc3Bvc2VFbWl0dGVyIiwiY3JlYXRlUmVxdWVzdFF1ZXVlS2V5IiwiY3JlYXRlUmVzcG9uc2VRdWV1ZUtleSIsImNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5IiwiYWRkTWVzc2FnZVRvUXVldWUiLCJpc1JlcXVlc3QiLCJpc1Jlc3BvbnNlIiwiX21lc3NhZ2UiLCJpc0xpc3RlbmluZyIsIkxpc3RlbmluZyIsImlzQ2xvc2VkIiwiQ2xvc2VkIiwiaXNEaXNwb3NlZCIsIkRpc3Bvc2VkIiwiY2xvc2VIYW5kbGVyIiwicmVhZEVycm9ySGFuZGxlciIsIndyaXRlRXJyb3JIYW5kbGVyIiwidHJpZ2dlck1lc3NhZ2VRdWV1ZSIsInByb2Nlc3NNZXNzYWdlUXVldWUiLCJoYW5kbGVSZXF1ZXN0IiwiaXNOb3RpZmljYXRpb24iLCJoYW5kbGVOb3RpZmljYXRpb24iLCJoYW5kbGVSZXNwb25zZSIsImhhbmRsZUludmFsaWRNZXNzYWdlIiwiY2FuY2VsSWQiLCJwYXJhbXMiLCJ0b0NhbmNlbCIsInN0cmF0ZWd5IiwicmVzcG9uc2UiLCJ0cmFjZVNlbmRpbmdSZXNwb25zZSIsImNhbmNlbGxhdGlvblRva2VuIiwidHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbiIsInJlcXVlc3RNZXNzYWdlIiwicmVwbHkiLCJyZXN1bHRPckVycm9yIiwic3RhcnRUaW1lIiwianNvbnJwYyIsInRvSnNvbiIsInJlcGx5RXJyb3IiLCJyZXBseVN1Y2Nlc3MiLCJ0cmFjZVJlY2VpdmVkUmVxdWVzdCIsImVsZW1lbnQiLCJyZXF1ZXN0SGFuZGxlciIsImhhbmRsZXIiLCJ0b2tlbktleSIsImNhbmNlbGxhdGlvblNvdXJjZSIsImhhbmRsZXJSZXN1bHQiLCJudW1iZXJPZlBhcmFtcyIsIkludmFsaWRQYXJhbXMiLCJwYXJhbWV0ZXJTdHJ1Y3R1cmVzIiwiYnlOYW1lIiwiYnlQb3NpdGlvbiIsIkludGVybmFsRXJyb3IiLCJNZXRob2ROb3RGb3VuZCIsInJlc3BvbnNlTWVzc2FnZSIsInJlc3BvbnNlUHJvbWlzZSIsInRyYWNlUmVjZWl2ZWRSZXNwb25zZSIsIm5vdGlmaWNhdGlvbkhhbmRsZXIiLCJyZXNwb25zZUhhbmRsZXIiLCJzdHJpbmdpZnlUcmFjZSIsInRyYWNlU2VuZGluZ1JlcXVlc3QiLCJsb2dMU1BNZXNzYWdlIiwidHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uIiwidGltZXJTdGFydCIsImxzcE1lc3NhZ2UiLCJpc0xTUE1lc3NhZ2UiLCJ0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCIsInRocm93SWZMaXN0ZW5pbmciLCJBbHJlYWR5TGlzdGVuaW5nIiwidGhyb3dJZk5vdExpc3RlbmluZyIsInVuZGVmaW5lZFRvTnVsbCIsInBhcmFtIiwibnVsbFRvVW5kZWZpbmVkIiwiaXNOYW1lZFBhcmFtIiwiY29tcHV0ZVNpbmdsZVBhcmFtIiwiYXV0byIsImNvbXB1dGVNZXNzYWdlUGFyYW1zIiwiY29ubmVjdGlvbiIsIm1lc3NhZ2VQYXJhbXMiLCJwYXJhbVN0YXJ0IiwicGFyYW1FbmQiLCJub3RpZmljYXRpb25NZXNzYWdlIiwib25Ob3RpZmljYXRpb24iLCJvblByb2dyZXNzIiwiX3R5cGUiLCJzZW5kUHJvZ3Jlc3MiLCJvblVuaGFuZGxlZFByb2dyZXNzIiwic2VuZFJlcXVlc3QiLCJkaXNwb3NhYmxlIiwiZW5hYmxlQ2FuY2VsbGF0aW9uIiwicmVzb2x2ZVdpdGhDbGVhbnVwIiwiciIsInJlamVjdFdpdGhDbGVhbnVwIiwiTWVzc2FnZVdyaXRlRXJyb3IiLCJvblJlcXVlc3QiLCJoYXNQZW5kaW5nUmVzcG9uc2UiLCJfdmFsdWUiLCJfdHJhY2VyIiwic2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zIiwiX3NlbmROb3RpZmljYXRpb24iLCJfdHJhY2VGb3JtYXQiLCJvblVuaGFuZGxlZE5vdGlmaWNhdGlvbiIsIm9uRGlzcG9zZSIsIlBlbmRpbmdSZXNwb25zZVJlamVjdGVkIiwidmFsdWVzIiwidmVyYm9zZSIsIl9kaXNwb3NhYmxlIiwiQ2FsbGJhY2tMaXN0IiwiYnVja2V0IiwiX2NhbGxiYWNrcyIsIl9jb250ZXh0cyIsInJlbW92ZSIsImZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCIsImludm9rZSIsImNhbGxiYWNrcyIsImNvbnRleHRzIiwiX2V2ZW50IiwidGhpc0FyZ3MiLCJkaXNwb3NhYmxlcyIsIl9vcHRpb25zIiwib25GaXJzdExpc3RlbmVyQWRkIiwiX25vb3AiLCJvbkxhc3RMaXN0ZW5lclJlbW92ZSIsInN0cmluZ0FycmF5IiwiZXZlcnkiLCJlbGVtIiwiX2EiLCJGaXJzdCIsIkFzT2xkIiwiTGFzdCIsIkFzTmV3IiwiY2xlYXIiLCJfbWFwIiwiX2hlYWQiLCJfdGFpbCIsIl9zaXplIiwiX3N0YXRlIiwidG91Y2giLCJwcmV2aW91cyIsImFkZEl0ZW1MYXN0IiwiYWRkSXRlbUZpcnN0IiwicmVtb3ZlSXRlbSIsImNhbGxiYWNrZm4iLCJjdXJyZW50IiwiZW50cmllcyIsInRyaW1PbGQiLCJuZXdTaXplIiwiY3VycmVudFNpemUiLCJ0b0pTT04iLCJmcm9tSlNPTiIsIl9saW1pdCIsImNoZWNrVHJpbSIsInJhdGlvIiwiX3JhdGlvIiwicGVlayIsInJvdW5kIiwiQ1IiLCJMRiIsIkNSTEYiLCJhcHBlbmQiLCJjaHVuayIsInRvQXBwZW5kIiwiX2NodW5rcyIsIl90b3RhbExlbmd0aCIsInRyeVJlYWRIZWFkZXJzIiwibG93ZXJDYXNlS2V5cyIsImNodW5rSW5kZXgiLCJjaHVua0J5dGVzUmVhZCIsIl9yZWFkIiwiaGVhZGVycyIsImhlYWRlciIsImluZGV4IiwidHJpbSIsInRyeVJlYWRCb2R5IiwibnVtYmVyT2ZCeXRlcyIsImJ5dGVDb3VudCIsInJlc3VsdE9mZnNldCIsImNodW5rUGFydCIsInNlbWFwaG9yZV8xIiwib25QYXJ0aWFsTWVzc2FnZSIsImFzRXJyb3IiLCJmaXJlQ2xvc2UiLCJwYXJ0aWFsTWVzc2FnZUVtaXR0ZXIiLCJmaXJlUGFydGlhbE1lc3NhZ2UiLCJSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zIiwiZnJvbU9wdGlvbnMiLCJjb250ZW50RGVjb2RlciIsImNvbnRlbnREZWNvZGVycyIsImNvbnRlbnRUeXBlRGVjb2RlciIsImNvbnRlbnRUeXBlRGVjb2RlcnMiLCJwYXJ0aWFsTWVzc2FnZVRpbWVvdXQiLCJfcGFydGlhbE1lc3NhZ2VUaW1lb3V0IiwibmV4dE1lc3NhZ2VMZW5ndGgiLCJtZXNzYWdlVG9rZW4iLCJwYXJ0aWFsTWVzc2FnZVRpbWVyIiwicmVhZGFibGUiLCJjb250ZW50TGVuZ3RoIiwiYm9keSIsInNldFBhcnRpYWxNZXNzYWdlVGltZXIiLCJjbGVhclBhcnRpYWxNZXNzYWdlVGltZXIiLCJyZWFkU2VtYXBob3JlIiwibG9jayIsImJ5dGVzIiwid2FpdGluZ1RpbWUiLCJTZW1hcGhvcmUiLCJDb250ZW50TGVuZ3RoIiwiUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyIsImNvbnRlbnRUeXBlRW5jb2RlciIsImNvbnRlbnRFbmNvZGVyIiwid3JpdGVTZW1hcGhvcmUiLCJwYXlsb2FkIiwiZG9Xcml0ZSIsIkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSIsIlBhcnNlRXJyb3IiLCJJbnZhbGlkUmVxdWVzdCIsImpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsInNlcnZlckVycm9yU3RhcnQiLCJNZXNzYWdlUmVhZEVycm9yIiwiQ29ubmVjdGlvbkluYWN0aXZlIiwiU2VydmVyTm90SW5pdGlhbGl6ZWQiLCJVbmtub3duRXJyb3JDb2RlIiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCIsInNlcnZlckVycm9yRW5kIiwiX3BhcmFtZXRlclN0cnVjdHVyZXMiLCJfcmFsIiwicmFsIiwidGh1bmsiLCJfd2FpdGluZyIsInJ1bk5leHQiLCJhY3RpdmUiLCJfYWN0aXZlIiwiX2NhcGFjaXR5IiwiZG9SdW5OZXh0IiwiY2FwYWNpdHkiLCJDYW5jZWxsYXRpb25TdGF0ZSIsIkNvbnRpbnVlIiwicmVxdWVzdCIsImJ1ZmZlcnMiLCIkY2FuY2VsbGF0aW9uRGF0YSIsIl9jb25uIiwic3RvcmUiLCJTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIiwibG9hZCIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24iLCJicm93c2VyXzEiLCJMU1BFcnJvckNvZGVzIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQiLCJSZXF1ZXN0RmFpbGVkIiwiU2VydmVyQ2FuY2VsbGVkIiwiQ29udGVudE1vZGlmaWVkIiwiUmVxdWVzdENhbmNlbGxlZCIsImxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCIsInZzY29kZV9qc29ucnBjXzEiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZSIsIlByb3RvY29sUmVxdWVzdFR5cGUwIiwiUmVnaXN0cmF0aW9uVHlwZSIsIk1lc3NhZ2VEaXJlY3Rpb24iLCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJtZXNzYWdlRGlyZWN0aW9uIiwiY2xpZW50VG9TZXJ2ZXIiLCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3QiLCJEb2N1bWVudENvbG9yUmVxdWVzdCIsIkNvbmZpZ3VyYXRpb25SZXF1ZXN0Iiwic2VydmVyVG9DbGllbnQiLCJEZWNsYXJhdGlvblJlcXVlc3QiLCJfX25vRHluYW1pY0ltcG9ydCIsIkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCIsIldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCIsIkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQiLCJEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSIsInJldHJpZ2dlclJlcXVlc3QiLCJGdWxsIiwiVW5jaGFuZ2VkIiwicGFydGlhbFJlc3VsdCIsIldpbGxEZWxldGVGaWxlc1JlcXVlc3QiLCJEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiIsIkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCIsIkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCIsIkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCIsImZpbGUiLCJmb2xkZXIiLCJGb2xkaW5nUmFuZ2VSZXF1ZXN0IiwiSW1wbGVtZW50YXRpb25SZXF1ZXN0IiwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QiLCJJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCIsIklubGF5SGludFJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0IiwiSW5saW5lVmFsdWVSZXF1ZXN0IiwiV29ya3NwYWNlU3ltYm9sUmVxdWVzdCIsIkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCIsIkNvZGVBY3Rpb25SZXF1ZXN0IiwiRG9jdW1lbnRTeW1ib2xSZXF1ZXN0IiwiRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0IiwiUmVmZXJlbmNlc1JlcXVlc3QiLCJEZWZpbml0aW9uUmVxdWVzdCIsIlNpZ25hdHVyZUhlbHBSZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kIiwiSG92ZXJSZXF1ZXN0IiwiQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IiwiQ29tcGxldGlvblJlcXVlc3QiLCJDb21wbGV0aW9uVHJpZ2dlcktpbmQiLCJQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24iLCJXYXRjaEtpbmQiLCJSZWxhdGl2ZVBhdHRlcm4iLCJGaWxlQ2hhbmdlVHlwZSIsIkRpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiIsIldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCIsIldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50U2F2ZVJlYXNvbiIsIkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCIsIkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTeW5jS2luZCIsIlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIiwiTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiIsIlNob3dNZXNzYWdlUmVxdWVzdCIsIlNob3dNZXNzYWdlTm90aWZpY2F0aW9uIiwiTWVzc2FnZVR5cGUiLCJEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uIiwiRXhpdE5vdGlmaWNhdGlvbiIsIlNodXRkb3duUmVxdWVzdCIsIkluaXRpYWxpemVkTm90aWZpY2F0aW9uIiwiSW5pdGlhbGl6ZUVycm9yQ29kZXMiLCJJbml0aWFsaXplUmVxdWVzdCIsIldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIiwiVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyIsIlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMiLCJQb3NpdGlvbkVuY29kaW5nS2luZCIsIkZhaWx1cmVIYW5kbGluZ0tpbmQiLCJSZXNvdXJjZU9wZXJhdGlvbktpbmQiLCJVbnJlZ2lzdHJhdGlvblJlcXVlc3QiLCJSZWdpc3RyYXRpb25SZXF1ZXN0IiwiRG9jdW1lbnRTZWxlY3RvciIsIk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciIsIk5vdGVib29rRG9jdW1lbnRGaWx0ZXIiLCJUZXh0RG9jdW1lbnRGaWx0ZXIiLCJUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0IiwiVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IiwiTW9uaWtlclJlcXVlc3QiLCJNb25pa2VyS2luZCIsIlVuaXF1ZW5lc3NMZXZlbCIsIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QiLCJTaG93RG9jdW1lbnRSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlIiwiU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JlcXVlc3QiLCJUb2tlbkZvcm1hdCIsIldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24iLCJXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCIsIldvcmtEb25lUHJvZ3Jlc3MiLCJTZWxlY3Rpb25SYW5nZVJlcXVlc3QiLCJEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIiwiV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QiLCJUeXBlRGVmaW5pdGlvblJlcXVlc3QiLCJBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0IiwiRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0IiwiUHJlcGFyZVJlbmFtZVJlcXVlc3QiLCJSZW5hbWVSZXF1ZXN0IiwiUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IiLCJEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCIsIkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVxdWVzdCIsIkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QiLCJDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0IiwiQ29kZUxlbnNSZXF1ZXN0IiwiV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QiLCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0NlbGxBcnJheUNoYW5nZSIsIkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlIiwiTm90ZWJvb2tEb2N1bWVudCIsIk5vdGVib29rQ2VsbCIsIkV4ZWN1dGlvblN1bW1hcnkiLCJOb3RlYm9va0NlbGxLaW5kIiwiVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0IiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEiLCJwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xIiwicHJvdG9jb2xfdHlwZURlZmluaXRpb25fMSIsInByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xIiwicHJvdG9jb2xfY29uZmlndXJhdGlvbl8xIiwicHJvdG9jb2xfY29sb3JQcm92aWRlcl8xIiwicHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEiLCJwcm90b2NvbF9kZWNsYXJhdGlvbl8xIiwicHJvdG9jb2xfc2VsZWN0aW9uUmFuZ2VfMSIsInByb3RvY29sX3Byb2dyZXNzXzEiLCJwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEiLCJwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xIiwicHJvdG9jb2xfc2hvd0RvY3VtZW50XzEiLCJwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMSIsInByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEiLCJwcm90b2NvbF9tb25pa2VyXzEiLCJwcm90b2NvbF90eXBlSGllcmFyY2h5XzEiLCJwcm90b2NvbF9pbmxpbmVWYWx1ZV8xIiwicHJvdG9jb2xfaW5sYXlIaW50XzEiLCJwcm90b2NvbF9kaWFnbm9zdGljXzEiLCJwcm90b2NvbF9ub3RlYm9va18xIiwibGFuZ3VhZ2UiLCJzY2hlbWUiLCJwYXR0ZXJuIiwib2JqZWN0TGl0ZXJhbCIsIm5vdGVib29rVHlwZSIsIm5vdGVib29rIiwiQ3JlYXRlIiwiUmVuYW1lIiwiRGVsZXRlIiwiQWJvcnQiLCJUcmFuc2FjdGlvbmFsIiwiVGV4dE9ubHlUcmFuc2FjdGlvbmFsIiwiVW5kbyIsIlVURjgiLCJVVEYxNiIsIlVURjMyIiwiaGFzSWQiLCJkb2N1bWVudFNlbGVjdG9yIiwid29ya0RvbmVQcm9ncmVzcyIsImhhc1dvcmtEb25lUHJvZ3Jlc3MiLCJ1bmtub3duUHJvdG9jb2xWZXJzaW9uIiwiV2FybmluZyIsIkluZm8iLCJMb2ciLCJJbmNyZW1lbnRhbCIsImlzSW5jcmVtZW50YWwiLCJyYW5nZUxlbmd0aCIsImlzRnVsbCIsIk1hbnVhbCIsIkFmdGVyRGVsYXkiLCJGb2N1c091dCIsIkNyZWF0ZWQiLCJDaGFuZ2VkIiwiRGVsZXRlZCIsIlVSSSIsImJhc2VVcmkiLCJXb3Jrc3BhY2VGb2xkZXIiLCJDaGFuZ2UiLCJJbnZva2VkIiwiVHJpZ2dlckNoYXJhY3RlciIsIlRyaWdnZXJGb3JJbmNvbXBsZXRlQ29tcGxldGlvbnMiLCJDb250ZW50Q2hhbmdlIiwiSWRlbnRpZmllciIsInByb2plY3QiLCJncm91cCIsImdsb2JhbCIsIiRpbXBvcnQiLCIkZXhwb3J0IiwibG9jYWwiLCJNYXJrdXAiLCJDb2RlIiwiZXhlY3V0aW9uT3JkZXIiLCJzdWNjZXNzIiwidWludGVnZXIiLCJlcXVhbHMiLCJvbmUiLCJEb2N1bWVudFVyaSIsIm1ldGFkYXRhIiwiZGlmZiIsInR3byIsImV4ZWN1dGlvblN1bW1hcnkiLCJlcXVhbHNNZXRhZGF0YSIsIm9uZUFycmF5Iiwib3RoZXJBcnJheSIsIm9uZUtleXMiLCJvdGhlcktleXMiLCJjZWxscyIsImludGVnZXIiLCJ0eXBlZEFycmF5IiwicmVnaXN0cmF0aW9uTWV0aG9kIiwiZGVsZXRlQ291bnQiLCJSZWxhdGl2ZSIsImNoZWNrIiwiVGV4dERvY3VtZW50IiwiX19zcHJlYWRBcnJheSIsImZyb20iLCJwYWNrIiwiRnVsbFRleHREb2N1bWVudCIsImNvbnRlbnQiLCJfdXJpIiwiX2xhbmd1YWdlSWQiLCJfdmVyc2lvbiIsIl9jb250ZW50IiwiX2xpbmVPZmZzZXRzIiwib2Zmc2V0QXQiLCJjaGFuZ2VzIiwiY2hhbmdlc18xIiwiY2hhbmdlIiwiZ2V0V2VsbGZvcm1lZFJhbmdlIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZU9mZnNldHMiLCJhZGRlZExpbmVPZmZzZXRzIiwiY29tcHV0ZUxpbmVPZmZzZXRzIiwiZ2V0TGluZU9mZnNldHMiLCJwb3NpdGlvbkF0IiwibG93IiwiaGlnaCIsImNoYXJhY3RlciIsIm1pZCIsImxpbmVPZmZzZXQiLCJuZXh0TGluZU9mZnNldCIsImFwcGx5RWRpdHMiLCJlZGl0cyIsInNvcnRlZEVkaXRzIiwibWVyZ2VTb3J0IiwiZ2V0V2VsbGZvcm1lZEVkaXQiLCJsYXN0TW9kaWZpZWRPZmZzZXQiLCJzcGFucyIsInNvcnRlZEVkaXRzXzEiLCJuZXdUZXh0IiwibGVmdCIsInJpZ2h0IiwibGVmdElkeCIsInJpZ2h0SWR4IiwiaXNBdExpbmVTdGFydCIsInRleHRPZmZzZXQiLCJjaCIsInRleHRFZGl0IiwiQW5ub3RhdGVkVGV4dEVkaXQiLCJDaGFuZ2VBbm5vdGF0aW9uIiwiQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIiLCJDb2RlQWN0aW9uIiwiQ29kZUFjdGlvbkNvbnRleHQiLCJDb2RlQWN0aW9uS2luZCIsIkNvZGVBY3Rpb25UcmlnZ2VyS2luZCIsIkNvZGVEZXNjcmlwdGlvbiIsIkNvZGVMZW5zIiwiQ29sb3IiLCJDb2xvckluZm9ybWF0aW9uIiwiQ29sb3JQcmVzZW50YXRpb24iLCJDb21tYW5kIiwiQ29tcGxldGlvbkl0ZW0iLCJDb21wbGV0aW9uSXRlbUtpbmQiLCJDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyIsIkNvbXBsZXRpb25JdGVtVGFnIiwiQ29tcGxldGlvbkxpc3QiLCJDcmVhdGVGaWxlIiwiRGVsZXRlRmlsZSIsIkRpYWdub3N0aWMiLCJEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIiwiRGlhZ25vc3RpY1NldmVyaXR5IiwiRGlhZ25vc3RpY1RhZyIsIkRvY3VtZW50SGlnaGxpZ2h0IiwiRG9jdW1lbnRIaWdobGlnaHRLaW5kIiwiRG9jdW1lbnRMaW5rIiwiRG9jdW1lbnRTeW1ib2wiLCJFT0wiLCJGb2xkaW5nUmFuZ2UiLCJGb2xkaW5nUmFuZ2VLaW5kIiwiRm9ybWF0dGluZ09wdGlvbnMiLCJIb3ZlciIsIklubGF5SGludCIsIklubGF5SGludEtpbmQiLCJJbmxheUhpbnRMYWJlbFBhcnQiLCJJbmxpbmVWYWx1ZUNvbnRleHQiLCJJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiIsIklubGluZVZhbHVlVGV4dCIsIklubGluZVZhbHVlVmFyaWFibGVMb29rdXAiLCJJbnNlcnRSZXBsYWNlRWRpdCIsIkluc2VydFRleHRGb3JtYXQiLCJJbnNlcnRUZXh0TW9kZSIsIkxvY2F0aW9uIiwiTG9jYXRpb25MaW5rIiwiTWFya2VkU3RyaW5nIiwiTWFya3VwQ29udGVudCIsIk1hcmt1cEtpbmQiLCJPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJQYXJhbWV0ZXJJbmZvcm1hdGlvbiIsIlBvc2l0aW9uIiwiUmFuZ2UiLCJSZW5hbWVGaWxlIiwiU2VsZWN0aW9uUmFuZ2UiLCJTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIiwiU2VtYW50aWNUb2tlblR5cGVzIiwiU2VtYW50aWNUb2tlbnMiLCJTaWduYXR1cmVJbmZvcm1hdGlvbiIsIlN5bWJvbEluZm9ybWF0aW9uIiwiU3ltYm9sS2luZCIsIlN5bWJvbFRhZyIsIlRleHREb2N1bWVudEVkaXQiLCJUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiVGV4dERvY3VtZW50SXRlbSIsIlRleHRFZGl0IiwiVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciIsIldvcmtzcGFjZUNoYW5nZSIsIldvcmtzcGFjZUVkaXQiLCJXb3Jrc3BhY2VTeW1ib2wiLCJNSU5fVkFMVUUiLCJNQVhfVkFMVUUiLCJ0aHJlZSIsImZvdXIiLCJ0YXJnZXRVcmkiLCJ0YXJnZXRSYW5nZSIsInRhcmdldFNlbGVjdGlvblJhbmdlIiwib3JpZ2luU2VsZWN0aW9uUmFuZ2UiLCJhbHBoYSIsIm51bWJlclJhbmdlIiwiY29sb3IiLCJhZGRpdGlvbmFsVGV4dEVkaXRzIiwiQ29tbWVudCIsIkltcG9ydHMiLCJSZWdpb24iLCJzdGFydENoYXJhY3RlciIsImVuZENoYXJhY3RlciIsImNvbGxhcHNlZFRleHQiLCJkZWZpbmVkIiwibG9jYXRpb24iLCJJbmZvcm1hdGlvbiIsIkhpbnQiLCJVbm5lY2Vzc2FyeSIsIkRlcHJlY2F0ZWQiLCJocmVmIiwic2V2ZXJpdHkiLCJyZWxhdGVkSW5mb3JtYXRpb24iLCJjb2RlRGVzY3JpcHRpb24iLCJjb21tYW5kIiwiaW5zZXJ0IiwiZGVsIiwibmVlZHNDb25maXJtYXRpb24iLCJkZXNjcmlwdGlvbiIsImFubm90YXRpb24iLCJhbm5vdGF0aW9uSWQiLCJ0ZXh0RG9jdW1lbnQiLCJvdmVyd3JpdGUiLCJpZ25vcmVJZkV4aXN0cyIsIm9sZFVyaSIsIm5ld1VyaSIsInJlY3Vyc2l2ZSIsImlnbm9yZUlmTm90RXhpc3RzIiwiZG9jdW1lbnRDaGFuZ2VzIiwiVGV4dEVkaXRDaGFuZ2VJbXBsIiwiY2hhbmdlQW5ub3RhdGlvbnMiLCJlZGl0IiwiYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnMiLCJtYW5hZ2UiLCJDaGFuZ2VBbm5vdGF0aW9ucyIsImFubm90YXRpb25zIiwiX2Fubm90YXRpb25zIiwiX2NvdW50ZXIiLCJpZE9yQW5ub3RhdGlvbiIsIm5leHRJZCIsIndvcmtzcGFjZUVkaXQiLCJfdGV4dEVkaXRDaGFuZ2VzIiwiX3dvcmtzcGFjZUVkaXQiLCJfY2hhbmdlQW5ub3RhdGlvbnMiLCJ0ZXh0RWRpdENoYW5nZSIsImluaXREb2N1bWVudENoYW5nZXMiLCJnZXRUZXh0RWRpdENoYW5nZSIsInRleHREb2N1bWVudEVkaXQiLCJpbml0Q2hhbmdlcyIsImNyZWF0ZUZpbGUiLCJvcHRpb25zT3JBbm5vdGF0aW9uIiwib3BlcmF0aW9uIiwicmVuYW1lRmlsZSIsImRlbGV0ZUZpbGUiLCJQbGFpblRleHQiLCJNYXJrZG93biIsIk1ldGhvZCIsIkZpZWxkIiwiVmFyaWFibGUiLCJJbnRlcmZhY2UiLCJNb2R1bGUiLCJQcm9wZXJ0eSIsIlVuaXQiLCJWYWx1ZSIsIkVudW0iLCJLZXl3b3JkIiwiU25pcHBldCIsIkZpbGUiLCJSZWZlcmVuY2UiLCJGb2xkZXIiLCJFbnVtTWVtYmVyIiwiQ29uc3RhbnQiLCJTdHJ1Y3QiLCJPcGVyYXRvciIsIlR5cGVQYXJhbWV0ZXIiLCJhc0lzIiwiYWRqdXN0SW5kZW50YXRpb24iLCJkZXRhaWwiLCJpdGVtcyIsImlzSW5jb21wbGV0ZSIsImZyb21QbGFpblRleHQiLCJwbGFpblRleHQiLCJjb250ZW50cyIsImRvY3VtZW50YXRpb24iLCJwYXJhbWV0ZXJzIiwiUmVhZCIsIldyaXRlIiwiTmFtZXNwYWNlIiwiUGFja2FnZSIsIktleSIsIk51bGwiLCJjb250YWluZXJOYW1lIiwic2VsZWN0aW9uUmFuZ2UiLCJjaGlsZHJlbiIsInRhZ3MiLCJRdWlja0ZpeCIsIlJlZmFjdG9yIiwiUmVmYWN0b3JFeHRyYWN0IiwiUmVmYWN0b3JJbmxpbmUiLCJSZWZhY3RvclJld3JpdGUiLCJTb3VyY2UiLCJTb3VyY2VPcmdhbml6ZUltcG9ydHMiLCJTb3VyY2VGaXhBbGwiLCJBdXRvbWF0aWMiLCJkaWFnbm9zdGljcyIsIm9ubHkiLCJ0cmlnZ2VyS2luZCIsImtpbmRPckNvbW1hbmRPckVkaXQiLCJjaGVja0tpbmQiLCJpc1ByZWZlcnJlZCIsInRhYlNpemUiLCJpbnNlcnRTcGFjZXMiLCJwYXJlbnQiLCJyZXN1bHRJZCIsInZhcmlhYmxlTmFtZSIsImNhc2VTZW5zaXRpdmVMb29rdXAiLCJmcmFtZUlkIiwic3RvcHBlZExvY2F0aW9uIiwiVHlwZSIsIlBhcmFtZXRlciIsInRvb2x0aXAiLCJ0ZXh0RWRpdHMiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImxpbmVDb3VudCIsImlzTGluZVN0YXJ0IiwiYXZhaWxhYmxlVHlwZWRBcnJheXMiLCJnT1BEIiwiZ2xvYmFsVGhpcyIsInR5cGVkQXJyYXlzIiwiJHNsaWNlIiwiY2FjaGUiLCJwcm90byIsInN1cGVyUHJvdG8iLCJ0cnlUeXBlZEFycmF5cyIsInRyeUFsbFR5cGVkQXJyYXlzIiwiZm91bmQiLCJnZXR0ZXIiLCJ0cnlTbGljZXMiLCJ0cnlBbGxTbGljZXMiLCJ0YWciLCJwb3NzaWJsZU5hbWVzIiwib3V0IiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJkZWZpbml0aW9uIiwiSnNvblNlcnZpY2UiLCJiYXNlX3NlcnZpY2UiLCJjcmVhdGVTY2FubmVyIiwiaWdub3JlVHJpdmlhIiwidG9rZW5PZmZzZXQiLCJsaW5lTnVtYmVyIiwibGluZVN0YXJ0T2Zmc2V0IiwidG9rZW5MaW5lU3RhcnRPZmZzZXQiLCJwcmV2VG9rZW5MaW5lU3RhcnRPZmZzZXQiLCJzY2FuRXJyb3IiLCJzY2FuSGV4RGlnaXRzIiwiZXhhY3QiLCJkaWdpdHMiLCJzZXRQb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwic2Nhbk51bWJlciIsImlzRGlnaXQiLCJzY2FuU3RyaW5nIiwiY2gyIiwiY2gzIiwiZnJvbUNoYXJDb2RlIiwiaXNMaW5lQnJlYWsiLCJzY2FuTmV4dCIsImlzV2hpdGVTcGFjZSIsInNhZmVMZW5ndGgiLCJjb21tZW50Q2xvc2VkIiwiaXNVbmtub3duQ29udGVudENoYXJhY3RlciIsInNjYW5OZXh0Tm9uVHJpdmlhIiwiZ2V0UG9zaXRpb24iLCJzY2FuIiwiZ2V0VG9rZW4iLCJnZXRUb2tlblZhbHVlIiwiZ2V0VG9rZW5PZmZzZXQiLCJnZXRUb2tlbkxlbmd0aCIsImdldFRva2VuU3RhcnRMaW5lIiwiZ2V0VG9rZW5TdGFydENoYXJhY3RlciIsImdldFRva2VuRXJyb3IiLCJDaGFyYWN0ZXJDb2RlcyIsImZvcm1hdF9mb3JtYXQiLCJkb2N1bWVudFRleHQiLCJpbml0aWFsSW5kZW50TGV2ZWwiLCJmb3JtYXRUZXh0IiwiZm9ybWF0VGV4dFN0YXJ0IiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwiZm9ybWF0X2lzRU9MIiwiY29tcHV0ZUluZGVudExldmVsIiwiZW9sIiwiZ2V0RU9MIiwibnVtYmVyTGluZUJyZWFrcyIsImluZGVudExldmVsIiwiaW5kZW50VmFsdWUiLCJzY2FubmVyIiwiaGFzRXJyb3IiLCJuZXdMaW5lc0FuZEluZGVudCIsImtlZXBMaW5lcyIsImVkaXRPcGVyYXRpb25zIiwiYWRkRWRpdCIsImZpcnN0VG9rZW4iLCJmaXJzdFRva2VuU3RhcnQiLCJpbml0aWFsSW5kZW50IiwiZmlyc3RUb2tlbkVuZCIsInNlY29uZFRva2VuIiwicmVwbGFjZUNvbnRlbnQiLCJuZWVkc0xpbmVCcmVhayIsImNvbW1lbnRUb2tlblN0YXJ0IiwiaW5zZXJ0RmluYWxOZXdsaW5lIiwic2Vjb25kVG9rZW5TdGFydCIsInMiLCJuQ2hhcnMiLCJQYXJzZU9wdGlvbnMiLCJERUZBVUxUIiwiYWxsb3dUcmFpbGluZ0NvbW1hIiwiZ2V0TG9jYXRpb24iLCJzZWdtZW50cyIsImVhcmx5UmV0dXJuRXhjZXB0aW9uIiwicHJldmlvdXNOb2RlIiwicHJldmlvdXNOb2RlSW5zdCIsImlzQXRQcm9wZXJ0eUtleSIsInNldFByZXZpb3VzTm9kZSIsImNvbG9uT2Zmc2V0IiwidmlzaXQiLCJvbk9iamVjdEJlZ2luIiwib25PYmplY3RQcm9wZXJ0eSIsIm9uT2JqZWN0RW5kIiwib25BcnJheUJlZ2luIiwib25BcnJheUVuZCIsIm9uTGl0ZXJhbFZhbHVlIiwiZ2V0Tm9kZVR5cGUiLCJvblNlcGFyYXRvciIsInNlcCIsInBhdGgiLCJtYXRjaGVzIiwiZXJyb3JzIiwiY3VycmVudFByb3BlcnR5IiwiY3VycmVudFBhcmVudCIsInByZXZpb3VzUGFyZW50cyIsIm9uVmFsdWUiLCJ2aXNpdG9yIiwicGFyc2VyX3BhcnNlVHJlZSIsImVuc3VyZVByb3BlcnR5Q29tcGxldGUiLCJ2YWx1ZU5vZGUiLCJwYXJzZXJfZmluZE5vZGVBdExvY2F0aW9uIiwibm9kZSIsInNlZ21lbnQiLCJwcm9wZXJ0eU5vZGUiLCJnZXROb2RlUGF0aCIsImdldE5vZGVWYWx1ZSIsImNvbnRhaW5zIiwiaW5jbHVkZVJpZ2h0Qm91bmQiLCJmaW5kTm9kZUF0T2Zmc2V0IiwiX3NjYW5uZXIiLCJfanNvblBhdGgiLCJ0b05vQXJnVmlzaXQiLCJ2aXNpdEZ1bmN0aW9uIiwidG9Ob0FyZ1Zpc2l0V2l0aFBhdGgiLCJ0b09uZUFyZ1Zpc2l0IiwidG9PbmVBcmdWaXNpdFdpdGhQYXRoIiwib25Db21tZW50IiwiZGlzYWxsb3dDb21tZW50cyIsInNraXBVbnRpbEFmdGVyIiwic2tpcFVudGlsIiwicGFyc2VTdHJpbmciLCJpc1ZhbHVlIiwicGFyc2VMaXRlcmFsIiwidG9rZW5WYWx1ZSIsInBhcnNlUHJvcGVydHkiLCJwYXJzZVZhbHVlIiwicGFyc2VPYmplY3QiLCJuZWVkc0NvbW1hIiwicGFyc2VBcnJheSIsImlzRmlyc3RFbGVtZW50IiwiYWxsb3dFbXB0eUNvbnRlbnQiLCJzdHJpcENvbW1lbnRzIiwicmVwbGFjZUNoIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsIm9yaWdpbmFsUGF0aCIsInBhcnNlVHJlZSIsImxhc3RTZWdtZW50IiwiZmluZE5vZGVBdExvY2F0aW9uIiwid2l0aEZvcm1hdHRpbmciLCJleGlzdGluZyIsInByb3BlcnR5SW5kZXgiLCJyZW1vdmVCZWdpbiIsInJlbW92ZUVuZCIsIm5ld1Byb3BlcnR5IiwiZ2V0SW5zZXJ0aW9uSW5kZXgiLCJpbnNlcnRJbmRleCIsInJlbW92YWxJbmRleCIsInRvUmVtb3ZlIiwicGFyZW50RW5kT2Zmc2V0IiwiaXNBcnJheUluc2VydGlvbiIsInRvTW9kaWZ5IiwiZm9ybWF0dGluZ09wdGlvbnMiLCJhcHBseUVkaXQiLCJiZWdpbiIsImlzRU9MIiwiZWRpdExlbmd0aCIsImlzV1MiLCJtYWluX2NyZWF0ZVNjYW5uZXIiLCJTY2FuRXJyb3IiLCJTeW50YXhLaW5kIiwibWFpbl9nZXRMb2NhdGlvbiIsIm1haW5fcGFyc2UiLCJtYWluX3BhcnNlVHJlZSIsIm1haW5fZmluZE5vZGVBdExvY2F0aW9uIiwibWFpbl9maW5kTm9kZUF0T2Zmc2V0IiwibWFpbl9nZXROb2RlUGF0aCIsIm1haW5fZ2V0Tm9kZVZhbHVlIiwibWFpbl92aXNpdCIsIm1haW5fc3RyaXBDb21tZW50cyIsIlBhcnNlRXJyb3JDb2RlIiwicHJpbnRQYXJzZUVycm9yQ29kZSIsIm1haW5fZm9ybWF0IiwibW9kaWZ5IiwiaXNEZWZpbmVkIiwiaGF5c3RhY2siLCJuZWVkbGUiLCJsYXN0SW5kZXhPZiIsImNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybiIsInN0cmluZ3NfcmVwZWF0IiwiZXh0ZW5kZWRSZWdFeHAiLCJzdHJpbmdMZW5ndGgiLCJtYWluIiwiZXNtX21haW4iLCJFcnJvckNvZGUiLCJTY2hlbWFEcmFmdCIsIkNsaWVudENhcGFiaWxpdGllcyIsIkxBVEVTVCIsImNvbXBsZXRpb24iLCJjb21wbGV0aW9uSXRlbSIsImRvY3VtZW50YXRpb25Gb3JtYXQiLCJjb21taXRDaGFyYWN0ZXJzU3VwcG9ydCIsImxhYmVsRGV0YWlsc1N1cHBvcnQiLCJyZWFkRmlsZUZyb21VcmkiLCJwcm90b2NvbCIsImZldGNoIiwicmVhZEZpbGVGcm9tRnNQYXRoIiwiYnVuZGxlIiwiY29uZmlnIiwiY29uZmlnMiIsImZpbGVDb250ZW50IiwiZnNQYXRoIiwiaXNCdWlsdGluRXh0ZW5zaW9uIiwiVVJMIiwidXJpQ29udGVudCIsInQiLCJmaXJzdEFyZyIsImZvcm1hdEFyZ3MiLCJjb21tZW50IiwiYnJvd3Nlcl9mb3JtYXQiLCJtZXNzYWdlRnJvbUJ1bmRsZSIsIl9mb3JtYXQyUmVnZXhwIiwidGVtcGxhdGUiLCJqc29uIiwiZm9ybWF0cyIsImVycm9yTWVzc2FnZSIsIkFTVE5vZGVJbXBsIiwiTnVsbEFTVE5vZGVJbXBsIiwiQm9vbGVhbkFTVE5vZGVJbXBsIiwiYm9vbFZhbHVlIiwiQXJyYXlBU1ROb2RlSW1wbCIsIk51bWJlckFTVE5vZGVJbXBsIiwiaXNJbnRlZ2VyIiwiU3RyaW5nQVNUTm9kZUltcGwiLCJQcm9wZXJ0eUFTVE5vZGVJbXBsIiwia2V5Tm9kZSIsIk9iamVjdEFTVE5vZGVJbXBsIiwicHJvcGVydGllcyIsImFzU2NoZW1hIiwic2NoZW1hIiwiRW51bU1hdGNoIiwic2NoZW1hRHJhZnRGcm9tSWQiLCJ2MyIsInY0IiwidjYiLCJ2NyIsInYyMDE5XzA5IiwidjIwMjBfMTIiLCJFdmFsdWF0aW9uQ29udGV4dCIsInNjaGVtYURyYWZ0IiwiU2NoZW1hQ29sbGVjdG9yIiwic2NoZW1hcyIsImluY2x1ZGUiLCJmb2N1c09mZnNldCIsImpzb25QYXJzZXJfY29udGFpbnMiLCJleGNsdWRlIiwibmV3U3ViIiwiTm9PcFNjaGVtYUNvbGxlY3RvciIsIl9zY2hlbWEiLCJfb3RoZXIiLCJfbm9kZSIsIlZhbGlkYXRpb25SZXN1bHQiLCJoYXNQcm9ibGVtcyIsInByb2JsZW1zIiwidmFsaWRhdGlvblJlc3VsdCIsInByb3BlcnRpZXNNYXRjaGVzIiwicHJvcGVydGllc1ZhbHVlTWF0Y2hlcyIsIm1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyIsIm1lcmdlRW51bVZhbHVlcyIsImVudW1WYWx1ZU1hdGNoIiwiZW51bVZhbHVlcyIsIkVudW1WYWx1ZU1pc21hdGNoIiwidiIsIm1lcmdlUHJvcGVydHlNYXRjaCIsInByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCIsInByaW1hcnlWYWx1ZU1hdGNoZXMiLCJwcm9jZXNzZWRQcm9wZXJ0aWVzIiwibmV3SlNPTkRvY3VtZW50IiwiSlNPTkRvY3VtZW50IiwianNvblBhcnNlcl9nZXROb2RlVmFsdWUiLCJqc29uUGFyc2VyX2dldE5vZGVQYXRoIiwiZ2V0Tm9kZUZyb21PZmZzZXQiLCJkb1Zpc2l0IiwiY3RuIiwidmFsaWRhdGUiLCJnZXRTY2hlbWFEcmFmdCIsImdldE1hdGNoaW5nU2NoZW1hcyIsIm1hdGNoaW5nU2NoZW1hcyIsInN5bnRheEVycm9ycyIsImNvbW1lbnRzIiwiZmFsbEJhY2siLCJzY2hlbWFJZCIsIiRzY2hlbWEiLCJfdmFsaWRhdGVOb2RlIiwiX3ZhbGlkYXRlT2JqZWN0Tm9kZSIsIl92YWxpZGF0ZUFycmF5Tm9kZSIsIl92YWxpZGF0ZVN0cmluZ05vZGUiLCJfdmFsaWRhdGVOdW1iZXJOb2RlIiwibWF0Y2hlc1R5cGUiLCJzb21lIiwiYWxsT2YiLCJzdWJTY2hlbWFSZWYiLCJzdWJWYWxpZGF0aW9uUmVzdWx0Iiwic3ViTWF0Y2hpbmdTY2hlbWFzIiwibm90U2NoZW1hIiwibm90IiwiaW52ZXJ0ZWQiLCJ0ZXN0QWx0ZXJuYXRpdmVzIiwiYWx0ZXJuYXRpdmVzIiwibWF4T25lTWF0Y2giLCJiZXN0TWF0Y2giLCJzdWJTY2hlbWEiLCJjb21wYXJlUmVzdWx0IiwiYW55T2YiLCJ0ZXN0QnJhbmNoIiwidGVzdENvbmRpdGlvbiIsImlmU2NoZW1hIiwidGhlblNjaGVtYSIsImVsc2VTY2hlbWEiLCJpZiIsImVsc2UiLCJlbnVtIiwiY29uc3QiLCJkZXByZWNhdGlvbk1lc3NhZ2UiLCJub3JtYWxpemVGbG9hdHMiLCJmbG9hdCIsIm11bHRpcGxpZXIiLCJtdWx0aXBsZU9mIiwicmVtYWluZGVyIiwibm9ybU11bHRpcGxlT2YiLCJub3JtVmFsdWUiLCJhYnMiLCJnZXRFeGNsdXNpdmVMaW1pdCIsImV4Y2x1c2l2ZSIsImdldExpbWl0IiwiZXhjbHVzaXZlTWluaW11bSIsIm1pbmltdW0iLCJleGNsdXNpdmVNYXhpbXVtIiwibWF4aW11bSIsIm1pbkxlbmd0aCIsInJlZ2V4IiwicGF0dGVybkVycm9yTWVzc2FnZSIsInByZWZpeEl0ZW1zU2NoZW1hcyIsImFkZGl0aW9uYWxJdGVtU2NoZW1hIiwicHJlZml4SXRlbXMiLCJhZGRpdGlvbmFsSXRlbXMiLCJpdGVtVmFsaWRhdGlvblJlc3VsdCIsImNvbnRhaW5zU2NoZW1hIiwiY29udGFpbnNDb3VudCIsIm1pbkNvbnRhaW5zIiwibWF4Q29udGFpbnMiLCJ1bmV2YWx1YXRlZEl0ZW1zIiwibWluSXRlbXMiLCJtYXhJdGVtcyIsInVuaXF1ZUl0ZW1zIiwiZHVwbGljYXRlcyIsInNlZW5LZXlzIiwidW5wcm9jZXNzZWRQcm9wZXJ0aWVzIiwicmVxdWlyZWQiLCJwcm9wZXJ0eU5hbWUiLCJwcm9wZXJ0eVByb2Nlc3NlZCIsInByb3BlcnR5U2NoZW1hIiwiY2hpbGQiLCJwYXR0ZXJuUHJvcGVydGllcyIsInByb3BlcnR5UGF0dGVybiIsInByb2Nlc3NlZCIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzIiwibWF4UHJvcGVydGllcyIsIm1pblByb3BlcnRpZXMiLCJkZXBlbmRlbnRSZXF1aXJlZCIsInByb3BlcnR5RGVwcyIsIl92YWxpZGF0ZVByb3BlcnR5RGVwZW5kZW5jaWVzIiwiZGVwZW5kZW50U2NoZW1hcyIsImRlcGVuZGVuY2llcyIsInByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eURlcCIsInJlcXVpcmVkUHJvcCIsImpzb25QYXJzZXJfcGFyc2UiLCJsYXN0UHJvYmxlbU9mZnNldCIsImNvbW1lbnRSYW5nZXMiLCJjb2xsZWN0Q29tbWVudHMiLCJfc2Nhbk5leHQiLCJfY2hlY2tTY2FuRXJyb3IiLCJfYWNjZXB0IiwiX2Vycm9yQXRSYW5nZSIsIl9lcnJvciIsIl9maW5hbGl6ZSIsIkludmFsaWRVbmljb2RlIiwiSW52YWxpZEVzY2FwZUNoYXJhY3RlciIsIlVuZXhwZWN0ZWRFbmRPZk51bWJlciIsIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQiLCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmciLCJJbnZhbGlkQ2hhcmFjdGVyIiwiX3BhcnNlQXJyYXkiLCJWYWx1ZUV4cGVjdGVkIiwiY29tbWFPZmZzZXQiLCJUcmFpbGluZ0NvbW1hIiwiQ29tbWFFeHBlY3RlZCIsIl9wYXJzZVZhbHVlIiwiQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWQiLCJrZXlQbGFjZWhvbGRlciIsIl9wYXJzZVByb3BlcnR5Iiwia2V5c1NlZW4iLCJfcGFyc2VTdHJpbmciLCJVbmRlZmluZWQiLCJEdXBsaWNhdGVLZXkiLCJDb2xvbkV4cGVjdGVkIiwiX3BhcnNlT2JqZWN0IiwiUHJvcGVydHlFeHBlY3RlZCIsInByb3BlcnR5IiwiQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZCIsIl9wYXJzZU51bWJlciIsIl9wYXJzZUxpdGVyYWwiLCJfcm9vdCIsInN0cmluZ2lmeU9iamVjdCIsImluZGVudCIsInN0cmluZ2lmeUxpdGVyYWwiLCJuZXdJbmRlbnQiLCJ2YWx1ZUNvbW1pdENoYXJhY3RlcnMiLCJwcm9wZXJ0eUNvbW1pdENoYXJhY3RlcnMiLCJKU09OQ29tcGxldGlvbiIsImNvbnRyaWJ1dGlvbnMiLCJyZXNvbHZlQ29tcGxldGlvbiIsInJlc29sdmVyIiwicHJvbWlzZUNvbnN0cnVjdG9yIiwiZG9jIiwiaXNJbkNvbW1lbnQiLCJjdXJyZW50V29yZCIsImdldEN1cnJlbnRXb3JkIiwib3ZlcndyaXRlUmFuZ2UiLCJvdmVyd3JpdGVTdGFydCIsInN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycyIsInByb3Bvc2VkIiwiY29sbGVjdG9yIiwic3VnZ2VzdGlvbiIsInNob3J0ZW5kZWRMYWJlbCIsImluc2VydFRleHQiLCJjb21taXRDaGFyYWN0ZXJzIiwibGFiZWxEZXRhaWxzIiwic2V0QXNJbmNvbXBsZXRlIiwiZ2V0TnVtYmVyT2ZQcm9wb3NhbHMiLCJzY2hlbWFTZXJ2aWNlIiwiZ2V0U2NoZW1hRm9yUmVzb3VyY2UiLCJjb2xsZWN0aW9uUHJvbWlzZXMiLCJhZGRWYWx1ZSIsImN1cnJlbnRLZXkiLCJzZXBhcmF0b3JBZnRlciIsImV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIiLCJnZXRQcm9wZXJ0eUNvbXBsZXRpb25zIiwiZ2V0U2NoZW1hTGVzc1Byb3BlcnR5Q29tcGxldGlvbnMiLCJjb250cmlidXRpb24iLCJjb2xsZWN0UHJvbWlzZSIsImNvbGxlY3RQcm9wZXJ0eUNvbXBsZXRpb25zIiwiZ2V0TGFiZWxGb3JWYWx1ZSIsImdldEluc2VydFRleHRGb3JQcm9wZXJ0eSIsImluc2VydFRleHRGb3JtYXQiLCJnZXRWYWx1ZUNvbXBsZXRpb25zIiwiZ2V0U2NoZW1hTGVzc1ZhbHVlQ29tcGxldGlvbnMiLCJnZXRDb250cmlidXRlZFZhbHVlQ29tcGxldGlvbnMiLCJvZmZzZXRGb3JTZXBhcmF0b3IiLCJhZGRGaWxsZXJWYWx1ZUNvbXBsZXRpb25zIiwic2NoZW1hUHJvcGVydGllcyIsImRvTm90U3VnZ2VzdCIsInByb3Bvc2FsIiwiZmlsdGVyVGV4dCIsImdldEZpbHRlclRleHRGb3JWYWx1ZSIsImZyb21NYXJrdXAiLCJtYXJrZG93bkRlc2NyaXB0aW9uIiwic3VnZ2VzdFNvcnRUZXh0Iiwic29ydFRleHQiLCJzY2hlbWFQcm9wZXJ0eU5hbWVzIiwicHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0iLCJlbnVtRGVzY3JpcHRpb24iLCJtYXJrZG93bkVudW1EZXNjcmlwdGlvbnMiLCJlbnVtRGVzY3JpcHRpb25zIiwiY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdCIsImdldEluc2VydFRleHRGb3JWYWx1ZSIsInBhcmVudEtleSIsImdldFN1Z2dlc3Rpb25LaW5kIiwiY29sbGVjdFN1Z2dlc3Rpb25zRm9yVmFsdWVzIiwiZ2V0TGFiZWxUZXh0Rm9yTWF0Y2hpbmdOb2RlIiwiZ2V0SW5zZXJ0VGV4dEZvck1hdGNoaW5nTm9kZSIsImFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24iLCJhZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyIsImFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMiLCJjIiwiZXhpc3RpbmdWYWx1ZXMiLCJmaW5kSXRlbUF0T2Zmc2V0IiwicHJvcGVydHlNYXRjaGVkIiwiYWRkTnVsbFZhbHVlQ29tcGxldGlvbiIsImNvbGxlY3REZWZhdWx0Q29tcGxldGlvbnMiLCJjb2xsZWN0VmFsdWVDb21wbGV0aW9ucyIsImFkZEVudW1WYWx1ZUNvbXBsZXRpb25zIiwiYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMiLCJjb2xsZWN0VHlwZXMiLCJhcnJheURlcHRoIiwiaGFzUHJvcG9zYWxzIiwiZG9lc1N1cHBvcnRzTGFiZWxEZXRhaWxzIiwiZXhhbXBsZXMiLCJleGFtcGxlIiwiZGVmYXVsdFNuaXBwZXRzIiwiZ2V0SW5zZXJ0VGV4dEZvclNuaXBwZXRWYWx1ZSIsImdldEZpbHRlclRleHRGb3JTbmlwcGV0VmFsdWUiLCJnZXRMYWJlbEZvclNuaXBwZXRWYWx1ZSIsImJvZHlUZXh0IiwicHJlZml4Iiwic3VmZml4IiwiZW5tIiwiZG9lc1N1cHBvcnRNYXJrZG93biIsImdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUiLCJzY2hlbWFJZHMiLCJnZXRSZWdpc3RlcmVkU2NoZW1hSWRzIiwiZ2V0VmFsdWVGcm9tTGFiZWwiLCJnZXRJbnNlcnRUZXh0Rm9yUGxhaW5UZXh0IiwicmVwbGFjZXIiLCJzbmlwcGV0VmFsdWUiLCJwcm9wZXJ0eVRleHQiLCJyZXN1bHRUZXh0IiwiblZhbHVlUHJvcG9zYWxzIiwibWFya3VwU3RyaW5nIiwic3VwcG9ydHNNYXJrZG93biIsImNsaWVudENhcGFiaWxpdGllcyIsImRvZXNTdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMiLCJKU09OSG92ZXIiLCJob3ZlclJhbmdlTm9kZSIsImhvdmVyUmFuZ2UiLCJjcmVhdGVIb3ZlciIsImdldEluZm9Db250cmlidXRpb24iLCJodG1sQ29udGVudCIsIm1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb24iLCJlbnVtVmFsdWUiLCJ0b01hcmtkb3duIiwidG9NYXJrZG93bkNvZGVCbG9jayIsInBsYWluIiwiSlNPTlZhbGlkYXRpb24iLCJjb25maWd1cmUiLCJyYXciLCJ2YWxpZGF0aW9uRW5hYmxlZCIsImNvbW1lbnRTZXZlcml0eSIsImFsbG93Q29tbWVudHMiLCJqc29uRG9jdW1lbnQiLCJkb2N1bWVudFNldHRpbmdzIiwiYWRkZWQiLCJhZGRQcm9ibGVtIiwicHJvYmxlbSIsInNpZ25hdHVyZSIsImdldERpYWdub3N0aWNzIiwidHJhaWxpbmdDb21tYVNldmVyaXR5IiwidHJhaWxpbmdDb21tYXMiLCJ0b0RpYWdub3N0aWNTZXZlcml0eSIsInNjaGVtYVZhbGlkYXRpb24iLCJzY2hlbWFSZXF1ZXN0IiwiYWRkU2NoZW1hUHJvYmxlbSIsImVycm9yQ29kZSIsImFzdFJvb3QiLCJTY2hlbWFSZXNvbHZlRXJyb3IiLCJ3YXJuaW5nIiwid2FybmluZ3MiLCJTY2hlbWFVbnN1cHBvcnRlZEZlYXR1cmUiLCJzZW1hbnRpY0Vycm9ycyIsInNjaGVtYUFsbG93c0NvbW1lbnRzIiwic2NoZW1hQWxsb3dzVHJhaWxpbmdDb21tYXMiLCJDb21tZW50Tm90UGVybWl0dGVkIiwiaWRDb3VudGVyIiwianNvblNjaGVtYVNlcnZpY2UiLCJyZWdpc3RlckV4dGVybmFsU2NoZW1hIiwiZ2V0UmVzb2x2ZWRTY2hlbWEiLCJyZXNvbHZlZFNjaGVtYSIsImdldExhbmd1YWdlU3RhdHVzIiwiZ2V0U2NoZW1hVVJJc0ZvclJlc291cmNlIiwic2NoZW1hUmVmIiwiYWxsb3ciLCJhbGxvd1RyYWlsaW5nQ29tbWFzIiwiZGVwclNjaGVtYVJlZiIsInNldmVyaXR5TGV2ZWwiLCJEaWdpdDAiLCJEaWdpdDkiLCJBIiwiaGV4RGlnaXQiLCJjaGFyQ29kZSIsImNvbG9yRnJvbUhleCIsImNvbG9yRnJvbTI1NlJHQiIsIkpTT05Eb2N1bWVudFN5bWJvbHMiLCJmaW5kRG9jdW1lbnRTeW1ib2xzIiwicmVzdWx0TGltaXQiLCJyZXNvdXJjZVN0cmluZyIsImdldFJhbmdlIiwiZ2V0TmFtZSIsIm9uUmVzdWx0TGltaXRFeGNlZWRlZCIsInRvVmlzaXQiLCJuZXh0VG9WaXNpdCIsImxpbWl0RXhjZWVkZWQiLCJjb2xsZWN0T3V0bGluZUVudHJpZXMiLCJjaGlsZENvbnRhaW5lck5hbWUiLCJnZXRLZXlMYWJlbCIsImdldFN5bWJvbEtpbmQiLCJmaW5kRG9jdW1lbnRTeW1ib2xzMiIsInN5bWJvbCIsImdldERldGFpbCIsIm5vZGVUeXBlIiwiZmluZERvY3VtZW50Q29sb3JzIiwidmlzaXRlZE5vZGUiLCJub2RlSWQiLCJnZXRDb2xvclByZXNlbnRhdGlvbnMiLCJyZWQyNTYiLCJncmVlbjI1NiIsImJsdWUyNTYiLCJ0b1R3b0RpZ2l0SGV4Iiwic2NoZW1hQ29udHJpYnV0aW9ucyIsInNjaGVtYUFzc29jaWF0aW9ucyIsIiRyZWYiLCJkZXNjcmlwdGlvbnMiLCJkZWZpbml0aW9ucyIsIiRpZCIsIiRjb21tZW50IiwicmVhZE9ubHkiLCJjb250ZW50TWVkaWFUeXBlIiwiY29udGVudEVuY29kaW5nIiwic2NoZW1hTmFtZSIsInByb3BlcnR5T2JqZWN0IiwiTElCIiwiaCIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJyZWxhdGl2ZSIsInUiLCJfbWFrZUxvbmciLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiZXh0IiwiZGVsaW1pdGVyIiwid2luMzIiLCJwb3NpeCIsIlV0aWxzIiwiTyIsInBsYXRmb3JtIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiYXV0aG9yaXR5IiwicXVlcnkiLCJmcmFnbWVudCIsImlzVXJpIiwid2l0aCIsIkMiLCJyZXZpdmUiLCJfZm9ybWF0dGVkIiwiZXh0ZXJuYWwiLCJfZnNQYXRoIiwiX3NlcCIsIiRtaWQiLCJ3IiwiUCIsIkkiLCJVIiwiam9pblBhdGgiLCJyZXNvbHZlUGF0aCIsImNyZWF0ZVJlZ2V4IiwiZ2xvYiIsInJlU3RyIiwiZXh0ZW5kZWQiLCJnbG9ic3RhciIsImluR3JvdXAiLCJwcmV2Q2hhciIsInN0YXJDb3VudCIsIm5leHRDaGFyIiwiaXNHbG9ic3RhciIsIkJBTkciLCJQQVRIX1NFUCIsIkZpbGVQYXR0ZXJuQXNzb2NpYXRpb24iLCJtYXRjaGVzUGF0dGVybiIsImZpbGVOYW1lIiwiZm9sZGVyVXJpIiwicmVnZXhwIiwiZ2xvYldyYXBwZXJzIiwiZ2V0VVJJcyIsInVyaXMiLCJwYXR0ZXJuU3RyaW5nIiwibm9ybWFsaXplUmVzb3VyY2VGb3JNYXRjaGluZyIsIlNjaGVtYUhhbmRsZSIsImdldFVucmVzb2x2ZWRTY2hlbWEiLCJ1bnJlc29sdmVkU2NoZW1hIiwic2VydmljZSIsImxvYWRTY2hlbWEiLCJ1bnJlc29sdmVkIiwicmVzb2x2ZVNjaGVtYUNvbnRlbnQiLCJjbGVhclNjaGVtYSIsImhhc0NoYW5nZXMiLCJhbmNob3JzIiwidW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQiLCJVbnJlc29sdmVkU2NoZW1hIiwiUmVzb2x2ZWRTY2hlbWEiLCJnZXRTZWN0aW9uIiwiZ2V0U2VjdGlvblJlY3Vyc2l2ZSIsIkpTT05TY2hlbWFTZXJ2aWNlIiwicmVnaXN0ZXJlZFNjaGVtYXNJZHMiLCJjYWxsT25EaXNwb3NlIiwib25SZXNvdXJjZUNoYW5nZSIsImNhY2hlZFNjaGVtYUZvclJlc291cmNlIiwibm9ybWFsaXplSWQiLCJ0b1dhbGsiLCJzY2hlbWFzQnlJZCIsImN1cnIiLCJzZXRTY2hlbWFDb250cmlidXRpb25zIiwibm9ybWFsaXplZElkIiwiY29udHJpYnV0aW9uU2NoZW1hcyIsImFkZFNjaGVtYUhhbmRsZSIsInNjaGVtYUFzc29jaWF0aW9uIiwiYXNzb2NpYXRpb24iLCJhZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uIiwiY29udHJpYnV0aW9uQXNzb2NpYXRpb25zIiwic2NoZW1hSGFuZGxlIiwiZ2V0T3JBZGRTY2hlbWFIYW5kbGUiLCJmcGEiLCJmaWxlUGF0dGVybkFzc29jaWF0aW9ucyIsImZpbGVNYXRjaCIsImNsZWFyRXh0ZXJuYWxTY2hlbWFzIiwiY29udHJpYnV0aW9uQXNzb2NpYXRpb24iLCJ1cmwiLCJyZXF1ZXN0U2VydmljZSIsInRvRGlzcGxheVN0cmluZyIsInRyaW1TdGFydCIsInNjaGVtYUNvbnRlbnQiLCJqc29uRXJyb3JzIiwiZXJyb3JTcGxpdCIsInNjaGVtYVRvUmVzb2x2ZSIsInJlc29sdmVFcnJvcnMiLCJ1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcyIsImNvbnRleHRTZXJ2aWNlIiwiZmluZFNlY3Rpb25CeUpTT05Qb2ludGVyIiwiZmluZFNjaGVtYUJ5SWQiLCJjb2xsZWN0QW5jaG9ycyIsInNlY3Rpb24iLCJtZXJnZVJlZiIsInNvdXJjZVJvb3QiLCJzb3VyY2VIYW5kbGUiLCJyZWZTZWdtZW50IiwicmVzb2x2ZUV4dGVybmFsTGluayIsInBhcmVudEhhbmRsZSIsInJlc29sdmVSZWxhdGl2ZVBhdGgiLCJyZWZlcmVuY2VkSGFuZGxlIiwibG9jIiwicmVzb2x2ZVJlZnMiLCJwYXJlbnRTY2hlbWEiLCJvcGVuUHJvbWlzZXMiLCJ0cmF2ZXJzZU5vZGVzIiwic2VlblJlZnMiLCJyZWYiLCIkcmVjdXJzaXZlUmVmIiwiJGR5bmFtaWNSZWYiLCJhbmNob3IiLCIkYW5jaG9yIiwiJHJlY3Vyc2l2ZUFuY2hvciIsIiRkeW5hbWljQW5jaG9yIiwicmVzb2x2ZVdhcm5pbmdzIiwiY29sbGVjdEVudHJpZXMiLCJlbnRyeSIsImNvbGxlY3RNYXBFbnRyaWVzIiwibWFwcyIsImNvbGxlY3RBcnJheUVudHJpZXMiLCJhcnJheXMiLCJjb2xsZWN0RW50cnlPckFycmF5RW50cmllcyIsIiRkZWZzIiwiZ2V0U2NoZW1hRnJvbVByb3BlcnR5IiwicmVzb3VyY2UiLCJnZXRBc3NvY2lhdGVkU2NoZW1hcyIsIm5vcm1hbGl6ZWRSZXNvdXJjZSIsInNjaGVtZUlkIiwiY3JlYXRlQ29tYmluZWRTY2hlbWEiLCJjb21iaW5lZFNjaGVtYUlkIiwiY29tYmluZWRTY2hlbWEiLCJqc29uU2NoZW1hU2VydmljZV9pZENvdW50ZXIiLCJnZXRGb2xkaW5nUmFuZ2VzIiwibmVzdGluZ0xldmVscyIsInByZXZTdGFydCIsImFkZFJhbmdlIiwicmFuZ2VMaW1pdCIsIm9uUmFuZ2VMaW1pdEV4Y2VlZGVkIiwiY291bnRzIiwibGV2ZWwiLCJtYXhMZXZlbCIsImdldFNlbGVjdGlvblJhbmdlcyIsInBvc2l0aW9ucyIsImdldFNlbGVjdGlvblJhbmdlIiwiY1N0YXJ0IiwiY0VuZCIsIm5ld1JhbmdlIiwiYWZ0ZXJDb21tYU9mZnNldCIsImdldE9mZnNldEFmdGVyTmV4dFRva2VuIiwiZXhwZWN0ZWRUb2tlbiIsInV0aWxzX2Zvcm1hdF9mb3JtYXQiLCJkb2N1bWVudFRvRm9ybWF0IiwiZm9ybWF0dGluZ1JhbmdlIiwiQ29udGFpbmVyIiwiUHJvcGVydHlUcmVlIiwiYWRkQ2hpbGRQcm9wZXJ0eSIsImNoaWxkUHJvcGVydHkiLCJjaGlsZHJlblByb3BlcnRpZXMiLCJpbnNlcnRpb25JbmRleCIsIm5vS2V5TmFtZSIsImJpbmFyeVNlYXJjaE9uUHJvcGVydHlBcnJheSIsImNvbXBhcmVQcm9wZXJ0aWVzIiwiYmVnaW5uaW5nTGluZU51bWJlciIsImxhc3RQcm9wZXJ0eSIsInByb3BlcnR5VHJlZTEiLCJwcm9wZXJ0eVRyZWUyIiwicHJvcGVydHlOYW1lMSIsInByb3BlcnR5TmFtZTIiLCJwcm9wZXJ0eVRyZWVBcnJheSIsInByb3BlcnR5VHJlZSIsImNvbXBhcmVfZm4iLCJmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUiLCJsYXN0UHJvcGVydHlJbkFycmF5TmFtZSIsImRvY3VtZW50VG9Tb3J0IiwiZm9ybWF0dGVkSnNvblN0cmluZyIsImZvcm1hdHRlZEpzb25Eb2N1bWVudCIsImpzb25Qcm9wZXJ0eVRyZWUiLCJmaW5kSnNvbmNQcm9wZXJ0eVRyZWUiLCJzb3J0ZWRKc29uRG9jdW1lbnQiLCJzb3J0SnNvbmNEb2N1bWVudCIsInNvcnRlZEFuZEZvcm1hdHRlZEpzb25Eb2N1bWVudCIsImZvcm1hdHRlZERvY3VtZW50IiwiZm9ybWF0dGVkU3RyaW5nIiwicm9vdFRyZWUiLCJjdXJyZW50VHJlZSIsImxhc3RUb2tlbkxpbmUiLCJudW1iZXJPZkNoYXJhY3RlcnNPblByZXZpb3VzTGluZXMiLCJsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuIiwic2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuIiwibGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiIsImVuZEluZGV4T2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuIiwiZW5kTGluZU51bWJlciIsImN1cnJlbnRDb250YWluZXJTdGFjayIsInVwZGF0ZUxhc3RQcm9wZXJ0eUVuZExpbmVOdW1iZXIiLCJ1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyIiwibGVuZ3RoT2ZMaW5lIiwibGluZVdoZXJlVG9BZGRDb21tYSIsImluZGV4V2hlcmVUb0FkZENvbWEiLCJjb21tYUluZGV4IiwiY29tbWFMaW5lIiwicXVldWVUb1NvcnQiLCJ1cGRhdGVTb3J0aW5nUXVldWUiLCJkYXRhVG9Tb3J0IiwianNvbkNvbnRlbnRUb1JlcGxhY2UiLCJqc29uRG9jdW1lbnRUb1JlcGxhY2UiLCJpbmRleFdoZXJlVG9BZGRDb21tYSIsImxpbmVXaGVyZVRvUmVtb3ZlQ29tbWEiLCJtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciIsIlNvcnRpbmdSYW5nZSIsInVwZGF0ZVNvcnRpbmdRdWV1ZUZvckFycmF5UHJvcGVydGllcyIsInN1Yk9iamVjdCIsImZpbmRMaW5rcyIsImxpbmtzIiwidGFyZ2V0Tm9kZSIsImZpbmRUYXJnZXROb2RlIiwidGFyZ2V0UG9zIiwiY3JlYXRlUmFuZ2UiLCJ0b2tlbnMiLCJwYXJzZUpTT05Qb2ludGVyIiwiZmluZE5vZGUiLCJwb2ludGVyIiwiZmluZCIsImFycmF5SXRlbSIsImpzb25MaW5rc191bmVzY2FwZSIsImdldExhbmd1YWdlU2VydmljZSIsInNjaGVtYVJlcXVlc3RTZXJ2aWNlIiwid29ya3NwYWNlQ29udGV4dCIsImpzb25Db21wbGV0aW9uIiwianNvbkhvdmVyIiwianNvbkRvY3VtZW50U3ltYm9scyIsImpzb25WYWxpZGF0aW9uIiwic2V0dGluZ3MiLCJyZXNldFNjaGVtYSIsInBhcnNlSlNPTkRvY3VtZW50IiwiZmluZERlZmluaXRpb24iLCJicm93c2VyX21haW4iLCJ1dGlscyIsIkFjZVJhbmdlIiwiZ2V0Q29uc3RydWN0b3IiLCJlZGl0b3IiLCJfaW5zdGFuY2UiLCJjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXIiLCJDb21tb25Db252ZXJ0ZXIiLCJub3JtYWxpemVSYW5nZXMiLCJjb21wbGV0aW9ucyIsImVsIiwidG9SYW5nZSIsImNsZWFuSHRtbCIsImh0bWwiLCJmcm9tUG9pbnRzIiwiY29udmVydEtpbmQiLCJleGNsdWRlQnlFcnJvck1lc3NhZ2UiLCJmaWVsZE5hbWUiLCJmcm9tUmFuZ2UiLCJyYW5nZUZyb21Qb3NpdGlvbnMiLCJmcm9tUG9pbnQiLCJwb2ludCIsInRvUG9pbnQiLCJ0b0Fubm90YXRpb25zIiwidG9Db21wbGV0aW9uIiwiX2l0ZW1fdGV4dEVkaXQiLCJfaXRlbV9jb21tYW5kIiwiaXRlbUtpbmQiLCJfaXRlbV90ZXh0RWRpdF9uZXdUZXh0IiwiX3JlZiIsImdldFRleHRFZGl0UmFuZ2UiLCJjYXB0aW9uIiwic2NvcmUiLCJ0b0NvbXBsZXRpb25zIiwiY29tYmluZWRDb21wbGV0aW9ucyIsImFsbENvbXBsZXRpb25zIiwiZmxhdCIsInRvUmVzb2x2ZWRDb21wbGV0aW9uIiwiZnJvbU1hcmt1cENvbnRlbnQiLCJ0b0NvbXBsZXRpb25JdGVtIiwiX2NvbXBsZXRpb25fY2FwdGlvbiIsIl9jb21wbGV0aW9uX3NuaXBwZXQiLCJfY29tcGxldGlvbl9zbmlwcGV0MSIsIm1lcmdlZFJhbmdlcyIsInRvVG9vbHRpcCIsImhvdmVyIiwiX2hvdmVyX2ZpbmQiLCJsc3BSYW5nZSIsIl9lbCIsImZyb21TaWduYXR1cmVIZWxwIiwic2lnbmF0dXJlSGVscCIsIl9lbDEiLCJzaWduYXR1cmVJbmRleCIsImFjdGl2ZVNpZ25hdHVyZSIsInNpZ25hdHVyZXMiLCJhY3RpdmVQYXJhbSIsImFjdGl2ZVBhcmFtZXRlciIsImZyb21BY2VEZWx0YSIsImRlbHRhIiwibGluZXMiLCJhY3Rpb24iLCJmaWx0ZXJEaWFnbm9zdGljcyIsImZpbHRlckVycm9ycyIsImZyb21Eb2N1bWVudEhpZ2hsaWdodHMiLCJkb2N1bWVudEhpZ2hsaWdodHMiLCJjbGFzc05hbWUiLCJ0b01hcmtlckdyb3VwSXRlbSIsInRvb2x0aXBUZXh0IiwibWFya2VyR3JvdXBJdGVtIiwianNvbl9zZXJ2aWNlX2RlZmluZV9wcm9wZXJ0eSIsIiRnZXRKc29uU2NoZW1hVXJpIiwiJGNvbmZpZ3VyZVNlcnZpY2UiLCJfc2NoZW1hcyIsInNlc3Npb25JRHMiLCJfZmlsZU1hdGNoIiwiX2VsX3NjaGVtYSIsIiRzZXJ2aWNlIiwiX2VsX2ZpbGVNYXRjaCIsImZ1bGxEb2N1bWVudCIsImNvbXBsZXRpb25Qcm92aWRlciIsInRyaWdnZXJDaGFyYWN0ZXJzIiwiZGlhZ25vc3RpY1Byb3ZpZGVyIiwiaW50ZXJGaWxlRGVwZW5kZW5jaWVzIiwid29ya3NwYWNlRGlhZ25vc3RpY3MiLCJqc29uU2NoZW1hIl0sInNvdXJjZVJvb3QiOiIifQ==