(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[1372],{

/***/ 21372:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 6093: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_511__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_511__(9907);
                /* provided dependency */ var console = __nested_webpack_require_511__(4364);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_511__(1342), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_511__(9801);
                var _require2 = __nested_webpack_require_511__(6827), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_511__(6827).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_511__(3046).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_511__(5968);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_511__(5656);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 9801: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_31729__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_31729__(9907);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_31729__(6827), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_31729__(1342), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 1342: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65318__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65318__(6093);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65318__(6827);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65318__(6093);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 5656: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76379__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76379__(5968);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76379__(7838);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76379__(6827).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 9818: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_107933__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_107933__(528);
                var callBind = __nested_webpack_require_107933__(8498);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 8498: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108660__)=>{
                "use strict";
                var bind = __nested_webpack_require_108660__(9138);
                var GetIntrinsic = __nested_webpack_require_108660__(528);
                var setFunctionLength = __nested_webpack_require_108660__(6108);
                var $TypeError = __nested_webpack_require_108660__(3468);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $defineProperty = __nested_webpack_require_108660__(4940);
                var $max = GetIntrinsic('%Math.max%');
                module1.exports = function callBind(originalFunction) {
                    if (typeof originalFunction !== 'function') {
                        throw new $TypeError('a function is required');
                    }
                    var func = $reflectApply(bind, $call, arguments);
                    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 4364: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110259__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110259__(6827);
                var assert = __nested_webpack_require_110259__(6093);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110259__.g !== "undefined" && __nested_webpack_require_110259__.g.console) {
                    console = __nested_webpack_require_110259__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 686: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_113941__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_113941__(4940);
                var $SyntaxError = __nested_webpack_require_113941__(5731);
                var $TypeError = __nested_webpack_require_113941__(3468);
                var gopd = __nested_webpack_require_113941__(9336);
                /** @type {import('.')} */ module1.exports = function defineDataProperty(obj, property, value) {
                    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
                        throw new $TypeError('`obj` must be an object or a function`');
                    }
                    if (typeof property !== 'string' && typeof property !== 'symbol') {
                        throw new $TypeError('`property` must be a string or a symbol`');
                    }
                    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
                        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
                        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
                        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
                        throw new $TypeError('`loose`, if provided, must be a boolean');
                    }
                    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                    var nonWritable = arguments.length > 4 ? arguments[4] : null;
                    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                    var loose = arguments.length > 6 ? arguments[6] : false;
                    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
                    if ($defineProperty) {
                        $defineProperty(obj, property, {
                            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                            value: value,
                            writable: nonWritable === null && desc ? desc.writable : !nonWritable
                        });
                    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
                        obj[property] = value; // eslint-disable-line no-param-reassign
                    } else {
                        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
                    }
                };
            /***/ },
            /***/ 1857: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_117229__)=>{
                "use strict";
                var keys = __nested_webpack_require_117229__(9228);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var defineDataProperty = __nested_webpack_require_117229__(686);
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var supportsDescriptors = __nested_webpack_require_117229__(7239)();
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        defineDataProperty(object, name, value, true);
                    } else {
                        defineDataProperty(object, name, value);
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4940: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_119306__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_119306__(528);
                /** @type {import('.')} */ var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = false;
                    }
                }
                module1.exports = $defineProperty;
            /***/ },
            /***/ 6729: /***/ (module1)=>{
                "use strict";
                /** @type {import('./eval')} */ module1.exports = EvalError;
            /***/ },
            /***/ 9838: /***/ (module1)=>{
                "use strict";
                /** @type {import('.')} */ module1.exports = Error;
            /***/ },
            /***/ 1155: /***/ (module1)=>{
                "use strict";
                /** @type {import('./range')} */ module1.exports = RangeError;
            /***/ },
            /***/ 4943: /***/ (module1)=>{
                "use strict";
                /** @type {import('./ref')} */ module1.exports = ReferenceError;
            /***/ },
            /***/ 5731: /***/ (module1)=>{
                "use strict";
                /** @type {import('./syntax')} */ module1.exports = SyntaxError;
            /***/ },
            /***/ 3468: /***/ (module1)=>{
                "use strict";
                /** @type {import('./type')} */ module1.exports = TypeError;
            /***/ },
            /***/ 2140: /***/ (module1)=>{
                "use strict";
                /** @type {import('./uri')} */ module1.exports = URIError;
            /***/ },
            /***/ 3046: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 705: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123152__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_123152__(9617);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 8794: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var toStr = Object.prototype.toString;
                var max = Math.max;
                var funcType = '[object Function]';
                var concatty = function concatty(a, b) {
                    var arr = [];
                    for(var i = 0; i < a.length; i += 1){
                        arr[i] = a[i];
                    }
                    for(var j = 0; j < b.length; j += 1){
                        arr[j + a.length] = b[j];
                    }
                    return arr;
                };
                var slicy = function slicy(arrLike, offset) {
                    var arr = [];
                    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
                        arr[j] = arrLike[i];
                    }
                    return arr;
                };
                var joiny = function(arr, joiner) {
                    var str = '';
                    for(var i = 0; i < arr.length; i += 1){
                        str += arr[i];
                        if (i + 1 < arr.length) {
                            str += joiner;
                        }
                    }
                    return str;
                };
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, concatty(args, arguments));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        }
                        return target.apply(that, concatty(args, arguments));
                    };
                    var boundLength = max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs[i] = '$' + i;
                    }
                    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 9138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_128871__)=>{
                "use strict";
                var implementation = __nested_webpack_require_128871__(8794);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 528: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129152__)=>{
                "use strict";
                var undefined1;
                var $Error = __nested_webpack_require_129152__(9838);
                var $EvalError = __nested_webpack_require_129152__(6729);
                var $RangeError = __nested_webpack_require_129152__(1155);
                var $ReferenceError = __nested_webpack_require_129152__(4943);
                var $SyntaxError = __nested_webpack_require_129152__(5731);
                var $TypeError = __nested_webpack_require_129152__(3468);
                var $URIError = __nested_webpack_require_129152__(2140);
                var $Function = Function;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_129152__(3558)();
                var hasProto = __nested_webpack_require_129152__(6869)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    __proto__: null,
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': $Error,
                    '%eval%': eval,
                    '%EvalError%': $EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': $RangeError,
                    '%ReferenceError%': $ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': $URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    __proto__: null,
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_129152__(9138);
                var hasOwn = __nested_webpack_require_129152__(8554);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 9336: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153030__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_153030__(528);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 7239: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153620__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_153620__(4940);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    return !!$defineProperty;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!$defineProperty) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 6869: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 3558: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155182__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_155182__(2908);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 2908: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 1913: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_158941__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_158941__(2908);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 8554: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159293__)=>{
                "use strict";
                var call = Function.prototype.call;
                var $hasOwn = Object.prototype.hasOwnProperty;
                var bind = __nested_webpack_require_159293__(9138);
                /** @type {import('.')} */ module1.exports = bind.call(call, $hasOwn);
            /***/ },
            /***/ 5615: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 5387: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_161080__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_161080__(1913)();
                var callBound = __nested_webpack_require_161080__(9818);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9617: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 2625: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168140__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_168140__(1913)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 8006: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 7838: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170109__)=>{
                "use strict";
                var callBind = __nested_webpack_require_170109__(8498);
                var define1 = __nested_webpack_require_170109__(1857);
                var implementation = __nested_webpack_require_170109__(8006);
                var getPolyfill = __nested_webpack_require_170109__(1591);
                var shim = __nested_webpack_require_170109__(1641);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1591: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170908__)=>{
                "use strict";
                var implementation = __nested_webpack_require_170908__(8006);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 1641: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171384__)=>{
                "use strict";
                var define1 = __nested_webpack_require_171384__(1857);
                var getPolyfill = __nested_webpack_require_171384__(1591);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5943: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_172152__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_172152__(2730);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 98: /***/ function(module1, exports1, __nested_webpack_require_172485__) {
                /* module decorator */ module1 = __nested_webpack_require_172485__.nmd(module1);
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /* global exports:true, module:true, require:true, define:true, global:true */ 
                (function(root, name, factory) {
                    'use strict';
                    // Used to determine if values are of the language type `Object`
                    var objectTypes = {
                        'function': true,
                        'object': true
                    }, freeExports = objectTypes[typeof exports1] && exports1 && !exports1.nodeType && exports1, freeModule = objectTypes["object"] && module1 && !module1.nodeType && module1, freeGlobal = freeExports && freeModule && typeof __nested_webpack_require_172485__.g === 'object' && __nested_webpack_require_172485__.g, moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                    /* istanbul ignore else */ if (freeGlobal && (freeGlobal.global === freeGlobal || /* istanbul ignore next */ freeGlobal.window === freeGlobal || /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {
                        root = freeGlobal;
                    }
                    // Some AMD build optimizers, like r.js, check for specific condition
                    // patterns like the following:
                    /* istanbul ignore if */ if (true) {
                        // defined as an anonymous module.
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                            exports1
                        ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports1, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        // In case the source has been processed and wrapped in a define module use
                        // the supplied `exports` object.
                        if (freeExports && moduleExports) factory(freeModule.exports);
                    } else /* istanbul ignore else */ {}
                })(this, 'luaparse', function(exports1) {
                    'use strict';
                    exports1.version = "0.3.1";
                    var input, options, length, features, encodingMode;
                    // Options can be set either globally on the parser object through
                    // defaultOptions, or during the parse call.
                    var defaultOptions = exports1.defaultOptions = {
                        // Explicitly tell the parser when the input ends.
                        wait: false,
                        comments: true,
                        scope: false,
                        locations: false,
                        ranges: false,
                        onCreateNode: null,
                        onCreateScope: null,
                        onDestroyScope: null,
                        onLocalDeclaration: null,
                        luaVersion: '5.1',
                        encodingMode: 'none'
                    };
                    function encodeUTF8(codepoint, highMask) {
                        highMask = highMask || 0;
                        if (codepoint < 0x80) {
                            return String.fromCharCode(codepoint);
                        } else if (codepoint < 0x800) {
                            return String.fromCharCode(highMask | 0xc0 | codepoint >> 6, highMask | 0x80 | codepoint & 0x3f);
                        } else if (codepoint < 0x10000) {
                            return String.fromCharCode(highMask | 0xe0 | codepoint >> 12, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else /* istanbul ignore else */ if (codepoint < 0x110000) {
                            return String.fromCharCode(highMask | 0xf0 | codepoint >> 18, highMask | 0x80 | codepoint >> 12 & 0x3f, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else {
                            // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993
                            return null;
                        }
                    }
                    function toHex(num, digits) {
                        var result = num.toString(16);
                        while(result.length < digits)result = '0' + result;
                        return result;
                    }
                    function checkChars(rx) {
                        return function(s) {
                            var m = rx.exec(s);
                            if (!m) return s;
                            raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());
                        };
                    }
                    var encodingModes = {
                        // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding
                        // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;
                        // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks
                        'pseudo-latin1': {
                            fixup: checkChars(/[^\x00-\xff]/),
                            encodeByte: function(value) {
                                if (value === null) return '';
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function(codepoint) {
                                return encodeUTF8(codepoint);
                            }
                        },
                        // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding
                        'x-user-defined': {
                            fixup: checkChars(/[^\x00-\x7f\uf780-\uf7ff]/),
                            encodeByte: function(value) {
                                if (value === null) return '';
                                if (value >= 0x80) return String.fromCharCode(value | 0xf700);
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function(codepoint) {
                                return encodeUTF8(codepoint, 0xf700);
                            }
                        },
                        // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is
                        'none': {
                            discardStrings: true,
                            fixup: function(s) {
                                return s;
                            },
                            encodeByte: function(value) {
                                return '';
                            },
                            encodeUTF8: function(codepoint) {
                                return '';
                            }
                        }
                    };
                    // The available tokens expressed as enum flags so they can be checked with
                    // bitwise operations.
                    var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8, NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64, NilLiteral = 128, VarargLiteral = 256;
                    exports1.tokenTypes = {
                        EOF: EOF,
                        StringLiteral: StringLiteral,
                        Keyword: Keyword,
                        Identifier: Identifier,
                        NumericLiteral: NumericLiteral,
                        Punctuator: Punctuator,
                        BooleanLiteral: BooleanLiteral,
                        NilLiteral: NilLiteral,
                        VarargLiteral: VarargLiteral
                    };
                    // As this parser is a bit different from luas own, the error messages
                    // will be different in some situations.
                    var errors = exports1.errors = {
                        unexpected: 'unexpected %1 \'%2\' near \'%3\'',
                        unexpectedEOF: 'unexpected symbol near \'<eof>\'',
                        expected: '\'%1\' expected near \'%2\'',
                        expectedToken: '%1 expected near \'%2\'',
                        unfinishedString: 'unfinished string near \'%1\'',
                        malformedNumber: 'malformed number near \'%1\'',
                        decimalEscapeTooLarge: 'decimal escape too large near \'%1\'',
                        invalidEscape: 'invalid escape sequence near \'%1\'',
                        hexadecimalDigitExpected: 'hexadecimal digit expected near \'%1\'',
                        braceExpected: 'missing \'%1\' near \'%2\'',
                        tooLargeCodepoint: 'UTF-8 value too large near \'%1\'',
                        unfinishedLongString: 'unfinished long string (starting at line %1) near \'%2\'',
                        unfinishedLongComment: 'unfinished long comment (starting at line %1) near \'%2\'',
                        ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \'%1\'',
                        noLoopToBreak: 'no loop to break near \'%1\'',
                        labelAlreadyDefined: 'label \'%1\' already defined on line %2',
                        labelNotVisible: 'no visible label \'%1\' for <goto>',
                        gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \'%2\'',
                        cannotUseVararg: 'cannot use \'...\' outside a vararg function near \'%1\'',
                        invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'
                    };
                    // ### Abstract Syntax Tree
                    //
                    // The default AST structure is inspired by the Mozilla Parser API but can
                    // easily be customized by overriding these functions.
                    var ast = exports1.ast = {
                        labelStatement: function(label) {
                            return {
                                type: 'LabelStatement',
                                label: label
                            };
                        },
                        breakStatement: function() {
                            return {
                                type: 'BreakStatement'
                            };
                        },
                        gotoStatement: function(label) {
                            return {
                                type: 'GotoStatement',
                                label: label
                            };
                        },
                        returnStatement: function(args) {
                            return {
                                type: 'ReturnStatement',
                                'arguments': args
                            };
                        },
                        ifStatement: function(clauses) {
                            return {
                                type: 'IfStatement',
                                clauses: clauses
                            };
                        },
                        ifClause: function(condition, body) {
                            return {
                                type: 'IfClause',
                                condition: condition,
                                body: body
                            };
                        },
                        elseifClause: function(condition, body) {
                            return {
                                type: 'ElseifClause',
                                condition: condition,
                                body: body
                            };
                        },
                        elseClause: function(body) {
                            return {
                                type: 'ElseClause',
                                body: body
                            };
                        },
                        whileStatement: function(condition, body) {
                            return {
                                type: 'WhileStatement',
                                condition: condition,
                                body: body
                            };
                        },
                        doStatement: function(body) {
                            return {
                                type: 'DoStatement',
                                body: body
                            };
                        },
                        repeatStatement: function(condition, body) {
                            return {
                                type: 'RepeatStatement',
                                condition: condition,
                                body: body
                            };
                        },
                        localStatement: function(variables, init) {
                            return {
                                type: 'LocalStatement',
                                variables: variables,
                                init: init
                            };
                        },
                        assignmentStatement: function(variables, init) {
                            return {
                                type: 'AssignmentStatement',
                                variables: variables,
                                init: init
                            };
                        },
                        callStatement: function(expression) {
                            return {
                                type: 'CallStatement',
                                expression: expression
                            };
                        },
                        functionStatement: function(identifier, parameters, isLocal, body) {
                            return {
                                type: 'FunctionDeclaration',
                                identifier: identifier,
                                isLocal: isLocal,
                                parameters: parameters,
                                body: body
                            };
                        },
                        forNumericStatement: function(variable, start, end, step, body) {
                            return {
                                type: 'ForNumericStatement',
                                variable: variable,
                                start: start,
                                end: end,
                                step: step,
                                body: body
                            };
                        },
                        forGenericStatement: function(variables, iterators, body) {
                            return {
                                type: 'ForGenericStatement',
                                variables: variables,
                                iterators: iterators,
                                body: body
                            };
                        },
                        chunk: function(body) {
                            return {
                                type: 'Chunk',
                                body: body
                            };
                        },
                        identifier: function(name) {
                            return {
                                type: 'Identifier',
                                name: name
                            };
                        },
                        literal: function(type, value, raw) {
                            type = type === StringLiteral ? 'StringLiteral' : type === NumericLiteral ? 'NumericLiteral' : type === BooleanLiteral ? 'BooleanLiteral' : type === NilLiteral ? 'NilLiteral' : 'VarargLiteral';
                            return {
                                type: type,
                                value: value,
                                raw: raw
                            };
                        },
                        tableKey: function(key, value) {
                            return {
                                type: 'TableKey',
                                key: key,
                                value: value
                            };
                        },
                        tableKeyString: function(key, value) {
                            return {
                                type: 'TableKeyString',
                                key: key,
                                value: value
                            };
                        },
                        tableValue: function(value) {
                            return {
                                type: 'TableValue',
                                value: value
                            };
                        },
                        tableConstructorExpression: function(fields) {
                            return {
                                type: 'TableConstructorExpression',
                                fields: fields
                            };
                        },
                        binaryExpression: function(operator, left, right) {
                            var type = 'and' === operator || 'or' === operator ? 'LogicalExpression' : 'BinaryExpression';
                            return {
                                type: type,
                                operator: operator,
                                left: left,
                                right: right
                            };
                        },
                        unaryExpression: function(operator, argument) {
                            return {
                                type: 'UnaryExpression',
                                operator: operator,
                                argument: argument
                            };
                        },
                        memberExpression: function(base, indexer, identifier) {
                            return {
                                type: 'MemberExpression',
                                indexer: indexer,
                                identifier: identifier,
                                base: base
                            };
                        },
                        indexExpression: function(base, index) {
                            return {
                                type: 'IndexExpression',
                                base: base,
                                index: index
                            };
                        },
                        callExpression: function(base, args) {
                            return {
                                type: 'CallExpression',
                                base: base,
                                'arguments': args
                            };
                        },
                        tableCallExpression: function(base, args) {
                            return {
                                type: 'TableCallExpression',
                                base: base,
                                'arguments': args
                            };
                        },
                        stringCallExpression: function(base, argument) {
                            return {
                                type: 'StringCallExpression',
                                base: base,
                                argument: argument
                            };
                        },
                        comment: function(value, raw) {
                            return {
                                type: 'Comment',
                                value: value,
                                raw: raw
                            };
                        }
                    };
                    // Wrap up the node object.
                    function finishNode(node) {
                        // Pop a `Marker` off the location-array and attach its location data.
                        if (trackLocations) {
                            var location = locations.pop();
                            location.complete();
                            location.bless(node);
                        }
                        if (options.onCreateNode) options.onCreateNode(node);
                        return node;
                    }
                    // Helpers
                    // -------
                    var slice = Array.prototype.slice, toString = Object.prototype.toString;
                    var indexOf = /* istanbul ignore next */ function(array, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i] === element) return i;
                        }
                        return -1;
                    };
                    /* istanbul ignore else */ if (Array.prototype.indexOf) indexOf = function(array, element) {
                        return array.indexOf(element);
                    };
                    // Iterate through an array of objects and return the index of an object
                    // with a matching property.
                    function indexOfObject(array, property, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i][property] === element) return i;
                        }
                        return -1;
                    }
                    // A sprintf implementation using %index (beginning at 1) to input
                    // arguments in the format string.
                    //
                    // Example:
                    //
                    //     // Unexpected function in token
                    //     sprintf('Unexpected %2 in %1.', 'token', 'function');
                    function sprintf(format) {
                        var args = slice.call(arguments, 1);
                        format = format.replace(/%(\d)/g, function(match, index) {
                            return '' + args[index - 1] || /* istanbul ignore next */ '';
                        });
                        return format;
                    }
                    // Polyfill for `Object.assign`.
                    var assign = /* istanbul ignore next */ function(dest) {
                        var args = slice.call(arguments, 1), src, prop;
                        for(var i = 0, length = args.length; i < length; ++i){
                            src = args[i];
                            for(prop in src)/* istanbul ignore else */ if (Object.prototype.hasOwnProperty.call(src, prop)) {
                                dest[prop] = src[prop];
                            }
                        }
                        return dest;
                    };
                    /* istanbul ignore else */ if (Object.assign) assign = Object.assign;
                    // ### Error functions
                    exports1.SyntaxError = SyntaxError;
                    // XXX: Eliminate this function and change the error type to be different from SyntaxError.
                    // This will unfortunately be a breaking change, because some downstream users depend
                    // on the error thrown being an instance of SyntaxError. For example, the Ace editor:
                    // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>
                    function fixupError(e) {
                        /* istanbul ignore if */ if (!Object.create) return e;
                        return Object.create(e, {
                            'line': {
                                'writable': true,
                                value: e.line
                            },
                            'index': {
                                'writable': true,
                                value: e.index
                            },
                            'column': {
                                'writable': true,
                                value: e.column
                            }
                        });
                    }
                    // #### Raise an exception.
                    //
                    // Raise an exception by passing a token, a string format and its paramters.
                    //
                    // The passed tokens location will automatically be added to the error
                    // message if it exists, if not it will default to the lexers current
                    // position.
                    //
                    // Example:
                    //
                    //     // [1:0] expected [ near (
                    //     raise(token, "expected %1 near %2", '[', token.value);
                    function raise(token) {
                        var message = sprintf.apply(null, slice.call(arguments, 1)), error, col;
                        if (token === null || typeof token.line === 'undefined') {
                            col = index - lineStart + 1;
                            error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));
                            error.index = index;
                            error.line = line;
                            error.column = col;
                        } else {
                            col = token.range[0] - token.lineStart;
                            error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));
                            error.line = token.line;
                            error.index = token.range[0];
                            error.column = col;
                        }
                        throw error;
                    }
                    function tokenValue(token) {
                        var raw = input.slice(token.range[0], token.range[1]);
                        if (raw) return raw;
                        return token.value;
                    }
                    // #### Raise an unexpected token error.
                    //
                    // Example:
                    //
                    //     // expected <name> near '0'
                    //     raiseUnexpectedToken('<name>', token);
                    function raiseUnexpectedToken(type, token) {
                        raise(token, errors.expectedToken, type, tokenValue(token));
                    }
                    // #### Raise a general unexpected error
                    //
                    // Usage should pass either a token object or a symbol string which was
                    // expected. We can also specify a nearby token such as <eof>, this will
                    // default to the currently active token.
                    //
                    // Example:
                    //
                    //     // Unexpected symbol 'end' near '<eof>'
                    //     unexpected(token);
                    //
                    // If there's no token in the buffer it means we have reached <eof>.
                    function unexpected(found) {
                        var near = tokenValue(lookahead);
                        if ('undefined' !== typeof found.type) {
                            var type;
                            switch(found.type){
                                case StringLiteral:
                                    type = 'string';
                                    break;
                                case Keyword:
                                    type = 'keyword';
                                    break;
                                case Identifier:
                                    type = 'identifier';
                                    break;
                                case NumericLiteral:
                                    type = 'number';
                                    break;
                                case Punctuator:
                                    type = 'symbol';
                                    break;
                                case BooleanLiteral:
                                    type = 'boolean';
                                    break;
                                case NilLiteral:
                                    return raise(found, errors.unexpected, 'symbol', 'nil', near);
                                case EOF:
                                    return raise(found, errors.unexpectedEOF);
                            }
                            return raise(found, errors.unexpected, type, tokenValue(found), near);
                        }
                        return raise(found, errors.unexpected, 'symbol', found, near);
                    }
                    // Lexer
                    // -----
                    //
                    // The lexer, or the tokenizer reads the input string character by character
                    // and derives a token left-right. To be as efficient as possible the lexer
                    // prioritizes the common cases such as identifiers. It also works with
                    // character codes instead of characters as string comparisons was the
                    // biggest bottleneck of the parser.
                    //
                    // If `options.comments` is enabled, all comments encountered will be stored
                    // in an array which later will be appended to the chunk object. If disabled,
                    // they will simply be disregarded.
                    //
                    // When the lexer has derived a valid token, it will be returned as an object
                    // containing its value and as well as its position in the input string (this
                    // is always enabled to provide proper debug messages).
                    //
                    // `lex()` starts lexing and returns the following token in the stream.
                    var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;
                    exports1.lex = lex;
                    function lex() {
                        skipWhiteSpace();
                        // Skip comments beginning with --
                        while(45 === input.charCodeAt(index) && 45 === input.charCodeAt(index + 1)){
                            scanComment();
                            skipWhiteSpace();
                        }
                        if (index >= length) return {
                            type: EOF,
                            value: '<eof>',
                            line: line,
                            lineStart: lineStart,
                            range: [
                                index,
                                index
                            ]
                        };
                        var charCode = input.charCodeAt(index), next = input.charCodeAt(index + 1);
                        // Memorize the range index where the token begins.
                        tokenStart = index;
                        if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();
                        switch(charCode){
                            case 39:
                            case 34:
                                return scanStringLiteral();
                            case 48:
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                            case 56:
                            case 57:
                                return scanNumericLiteral();
                            case 46:
                                // If the dot is followed by a digit it's a float.
                                if (isDecDigit(next)) return scanNumericLiteral();
                                if (46 === next) {
                                    if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();
                                    return scanPunctuator('..');
                                }
                                return scanPunctuator('.');
                            case 61:
                                if (61 === next) return scanPunctuator('==');
                                return scanPunctuator('=');
                            case 62:
                                if (features.bitwiseOperators) {
                                    if (62 === next) return scanPunctuator('>>');
                                }
                                if (61 === next) return scanPunctuator('>=');
                                return scanPunctuator('>');
                            case 60:
                                if (features.bitwiseOperators) {
                                    if (60 === next) return scanPunctuator('<<');
                                }
                                if (61 === next) return scanPunctuator('<=');
                                return scanPunctuator('<');
                            case 126:
                                if (61 === next) return scanPunctuator('~=');
                                if (!features.bitwiseOperators) break;
                                return scanPunctuator('~');
                            case 58:
                                if (features.labels) {
                                    if (58 === next) return scanPunctuator('::');
                                }
                                return scanPunctuator(':');
                            case 91:
                                // Check for a multiline string, they begin with [= or [[
                                if (91 === next || 61 === next) return scanLongStringLiteral();
                                return scanPunctuator('[');
                            case 47:
                                // Check for integer division op (//)
                                if (features.integerDivision) {
                                    if (47 === next) return scanPunctuator('//');
                                }
                                return scanPunctuator('/');
                            case 38:
                            case 124:
                                if (!features.bitwiseOperators) break;
                            /* fall through */ case 42:
                            case 94:
                            case 37:
                            case 44:
                            case 123:
                            case 125:
                            case 93:
                            case 40:
                            case 41:
                            case 59:
                            case 35:
                            case 45:
                            case 43:
                                return scanPunctuator(input.charAt(index));
                        }
                        return unexpected(input.charAt(index));
                    }
                    // Whitespace has no semantic meaning in lua so simply skip ahead while
                    // tracking the encounted newlines. Any kind of eol sequence is counted as a
                    // single line.
                    function consumeEOL() {
                        var charCode = input.charCodeAt(index), peekCharCode = input.charCodeAt(index + 1);
                        if (isLineTerminator(charCode)) {
                            // Count \n\r and \r\n as one newline.
                            if (10 === charCode && 13 === peekCharCode) ++index;
                            if (13 === charCode && 10 === peekCharCode) ++index;
                            ++line;
                            lineStart = ++index;
                            return true;
                        }
                        return false;
                    }
                    function skipWhiteSpace() {
                        while(index < length){
                            var charCode = input.charCodeAt(index);
                            if (isWhiteSpace(charCode)) {
                                ++index;
                            } else if (!consumeEOL()) {
                                break;
                            }
                        }
                    }
                    // Identifiers, keywords, booleans and nil all look the same syntax wise. We
                    // simply go through them one by one and defaulting to an identifier if no
                    // previous case matched.
                    function scanIdentifierOrKeyword() {
                        var value, type;
                        // Slicing the input string is prefered before string concatenation in a
                        // loop for performance reasons.
                        while(isIdentifierPart(input.charCodeAt(++index)));
                        value = encodingMode.fixup(input.slice(tokenStart, index));
                        // Decide on the token type and possibly cast the value.
                        if (isKeyword(value)) {
                            type = Keyword;
                        } else if ('true' === value || 'false' === value) {
                            type = BooleanLiteral;
                            value = 'true' === value;
                        } else if ('nil' === value) {
                            type = NilLiteral;
                            value = null;
                        } else {
                            type = Identifier;
                        }
                        return {
                            type: type,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Once a punctuator reaches this function it should already have been
                    // validated so we simply return it as a token.
                    function scanPunctuator(value) {
                        index += value.length;
                        return {
                            type: Punctuator,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // A vararg literal consists of three dots.
                    function scanVarargLiteral() {
                        index += 3;
                        return {
                            type: VarargLiteral,
                            value: '...',
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Find the string literal by matching the delimiter marks used.
                    function scanStringLiteral() {
                        var delimiter = input.charCodeAt(index++), beginLine = line, beginLineStart = lineStart, stringStart = index, string = encodingMode.discardStrings ? null : '', charCode;
                        for(;;){
                            charCode = input.charCodeAt(index++);
                            if (delimiter === charCode) break;
                            // EOF or `\n` terminates a string literal. If we haven't found the
                            // ending delimiter by now, raise an exception.
                            if (index > length || isLineTerminator(charCode)) {
                                string += input.slice(stringStart, index - 1);
                                raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));
                            }
                            if (92 === charCode) {
                                if (!encodingMode.discardStrings) {
                                    var beforeEscape = input.slice(stringStart, index - 1);
                                    string += encodingMode.fixup(beforeEscape);
                                }
                                var escapeValue = readEscapeSequence();
                                if (!encodingMode.discardStrings) string += escapeValue;
                                stringStart = index;
                            }
                        }
                        if (!encodingMode.discardStrings) {
                            string += encodingMode.encodeByte(null);
                            string += encodingMode.fixup(input.slice(stringStart, index - 1));
                        }
                        return {
                            type: StringLiteral,
                            value: string,
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Expect a multiline string literal and return it as a regular string
                    // literal, if it doesn't validate into a valid multiline string, throw an
                    // exception.
                    function scanLongStringLiteral() {
                        var beginLine = line, beginLineStart = lineStart, string = readLongString(false);
                        // Fail if it's not a multiline literal.
                        if (false === string) raise(token, errors.expected, '[', tokenValue(token));
                        return {
                            type: StringLiteral,
                            value: encodingMode.discardStrings ? null : encodingMode.fixup(string),
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Numeric literals will be returned as floating-point numbers instead of
                    // strings. The raw value should be retrieved from slicing the input string
                    // later on in the process.
                    //
                    // If a hexadecimal number is encountered, it will be converted.
                    function scanNumericLiteral() {
                        var character = input.charAt(index), next = input.charAt(index + 1);
                        var literal = '0' === character && 'xX'.indexOf(next || null) >= 0 ? readHexLiteral() : readDecLiteral();
                        var foundImaginaryUnit = readImaginaryUnitSuffix(), foundInt64Suffix = readInt64Suffix();
                        if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {
                            raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        }
                        return {
                            type: NumericLiteral,
                            value: literal.value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    function readImaginaryUnitSuffix() {
                        if (!features.imaginaryNumbers) return;
                        // Imaginary unit number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ('iI'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            return true;
                        } else {
                            return false;
                        }
                    }
                    function readInt64Suffix() {
                        if (!features.integerSuffixes) return;
                        // Int64/uint64 number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ('uU'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                    ++index;
                                    return 'ULL';
                                } else {
                                    // UL but no L
                                    raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                                }
                            } else {
                                // U but no L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                return 'LL';
                            } else {
                                // First L but no second L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        }
                    }
                    // Lua hexadecimals have an optional fraction part and an optional binary
                    // exoponent part. These are not included in JavaScript so we will compute
                    // all three parts separately and then sum them up at the end of the function
                    // with the following algorithm.
                    //
                    //     Digit := toDec(digit)
                    //     Fraction := toDec(fraction) / 16 ^ fractionCount
                    //     BinaryExp := 2 ^ binaryExp
                    //     Number := ( Digit + Fraction ) * BinaryExp
                    function readHexLiteral() {
                        var fraction = 0 // defaults to 0 as it gets summed
                        , binaryExponent = 1 // defaults to 1 as it gets multiplied
                        , binarySign = 1 // positive
                        , digit, fractionStart, exponentStart, digitStart;
                        digitStart = index += 2; // Skip 0x part
                        // A minimum of one hex digit is required.
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        while(isHexDigit(input.charCodeAt(index)))++index;
                        // Convert the hexadecimal digit to base 10.
                        digit = parseInt(input.slice(digitStart, index), 16);
                        // Fraction part is optional.
                        var foundFraction = false;
                        if ('.' === input.charAt(index)) {
                            foundFraction = true;
                            fractionStart = ++index;
                            while(isHexDigit(input.charCodeAt(index)))++index;
                            fraction = input.slice(fractionStart, index);
                            // Empty fraction parts should default to 0, others should be converted
                            // 0.x form so we can use summation at the end.
                            fraction = fractionStart === index ? 0 : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);
                        }
                        // Binary exponents are optional
                        var foundBinaryExponent = false;
                        if ('pP'.indexOf(input.charAt(index) || null) >= 0) {
                            foundBinaryExponent = true;
                            ++index;
                            // Sign part is optional and defaults to 1 (positive).
                            if ('+-'.indexOf(input.charAt(index) || null) >= 0) binarySign = '+' === input.charAt(index++) ? 1 : -1;
                            exponentStart = index;
                            // The binary exponent sign requires a decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                            binaryExponent = input.slice(exponentStart, index);
                            // Calculate the binary exponent of the number.
                            binaryExponent = Math.pow(2, binaryExponent * binarySign);
                        }
                        return {
                            value: (digit + fraction) * binaryExponent,
                            hasFractionPart: foundFraction || foundBinaryExponent
                        };
                    }
                    // Decimal numbers are exactly the same in Lua and in JavaScript, because of
                    // this we check where the token ends and then parse it with native
                    // functions.
                    function readDecLiteral() {
                        while(isDecDigit(input.charCodeAt(index)))++index;
                        // Fraction part is optional
                        var foundFraction = false;
                        if ('.' === input.charAt(index)) {
                            foundFraction = true;
                            ++index;
                            // Fraction part defaults to 0
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        // Exponent part is optional.
                        var foundExponent = false;
                        if ('eE'.indexOf(input.charAt(index) || null) >= 0) {
                            foundExponent = true;
                            ++index;
                            // Sign part is optional.
                            if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;
                            // An exponent is required to contain at least one decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        return {
                            value: parseFloat(input.slice(tokenStart, index)),
                            hasFractionPart: foundFraction || foundExponent
                        };
                    }
                    function readUnicodeEscapeSequence() {
                        var sequenceStart = index++;
                        if (input.charAt(index++) !== '{') raise(null, errors.braceExpected, '{', '\\' + input.slice(sequenceStart, index));
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));
                        while(input.charCodeAt(index) === 0x30)++index;
                        var escStart = index;
                        while(isHexDigit(input.charCodeAt(index))){
                            ++index;
                            if (index - escStart > 6) raise(null, errors.tooLargeCodepoint, '\\' + input.slice(sequenceStart, index));
                        }
                        var b = input.charAt(index++);
                        if (b !== '}') {
                            if (b === '"' || b === "'") raise(null, errors.braceExpected, '}', '\\' + input.slice(sequenceStart, index--));
                            else raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));
                        }
                        var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);
                        var frag = '\\' + input.slice(sequenceStart, index);
                        if (codepoint > 0x10ffff) {
                            raise(null, errors.tooLargeCodepoint, frag);
                        }
                        return encodingMode.encodeUTF8(codepoint, frag);
                    }
                    // Translate escape sequences to the actual characters.
                    function readEscapeSequence() {
                        var sequenceStart = index;
                        switch(input.charAt(index)){
                            // Lua allow the following escape sequences.
                            case 'a':
                                ++index;
                                return '\x07';
                            case 'n':
                                ++index;
                                return '\n';
                            case 'r':
                                ++index;
                                return '\r';
                            case 't':
                                ++index;
                                return '\t';
                            case 'v':
                                ++index;
                                return '\x0b';
                            case 'b':
                                ++index;
                                return '\b';
                            case 'f':
                                ++index;
                                return '\f';
                            // Backslash at the end of the line. We treat all line endings as equivalent,
                            // and as representing the [LF] character (code 10). Lua 5.1 through 5.3
                            // have been verified to behave the same way.
                            case '\r':
                            case '\n':
                                consumeEOL();
                                return '\n';
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                                // \ddd, where ddd is a sequence of up to three decimal digits.
                                while(isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3)++index;
                                var frag = input.slice(sequenceStart, index);
                                var ddd = parseInt(frag, 10);
                                if (ddd > 255) {
                                    raise(null, errors.decimalEscapeTooLarge, '\\' + ddd);
                                }
                                return encodingMode.encodeByte(ddd, '\\' + frag);
                            case 'z':
                                if (features.skipWhitespaceEscape) {
                                    ++index;
                                    skipWhiteSpace();
                                    return '';
                                }
                                break;
                            case 'x':
                                if (features.hexEscapes) {
                                    // \xXX, where XX is a sequence of exactly two hexadecimal digits
                                    if (isHexDigit(input.charCodeAt(index + 1)) && isHexDigit(input.charCodeAt(index + 2))) {
                                        index += 3;
                                        return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\' + input.slice(sequenceStart, index));
                                    }
                                    raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index + 2));
                                }
                                break;
                            case 'u':
                                if (features.unicodeEscapes) return readUnicodeEscapeSequence();
                                break;
                            case '\\':
                            case '"':
                            case "'":
                                return input.charAt(index++);
                        }
                        if (features.strictEscapes) raise(null, errors.invalidEscape, '\\' + input.slice(sequenceStart, index + 1));
                        return input.charAt(index++);
                    }
                    // Comments begin with -- after which it will be decided if they are
                    // multiline comments or not.
                    //
                    // The multiline functionality works the exact same way as with string
                    // literals so we reuse the functionality.
                    function scanComment() {
                        tokenStart = index;
                        index += 2; // --
                        var character = input.charAt(index), content = '', isLong = false, commentStart = index, lineStartComment = lineStart, lineComment = line;
                        if ('[' === character) {
                            content = readLongString(true);
                            // This wasn't a multiline comment after all.
                            if (false === content) content = character;
                            else isLong = true;
                        }
                        // Scan until next line as long as it's not a multiline comment.
                        if (!isLong) {
                            while(index < length){
                                if (isLineTerminator(input.charCodeAt(index))) break;
                                ++index;
                            }
                            if (options.comments) content = input.slice(commentStart, index);
                        }
                        if (options.comments) {
                            var node = ast.comment(content, input.slice(tokenStart, index));
                            // `Marker`s depend on tokens available in the parser and as comments are
                            // intercepted in the lexer all location data is set manually.
                            if (options.locations) {
                                node.loc = {
                                    start: {
                                        line: lineComment,
                                        column: tokenStart - lineStartComment
                                    },
                                    end: {
                                        line: line,
                                        column: index - lineStart
                                    }
                                };
                            }
                            if (options.ranges) {
                                node.range = [
                                    tokenStart,
                                    index
                                ];
                            }
                            if (options.onCreateNode) options.onCreateNode(node);
                            comments.push(node);
                        }
                    }
                    // Read a multiline string by calculating the depth of `=` characters and
                    // then appending until an equal depth is found.
                    function readLongString(isComment) {
                        var level = 0, content = '', terminator = false, character, stringStart, firstLine = line;
                        ++index; // [
                        // Calculate the depth of the comment.
                        while('=' === input.charAt(index + level))++level;
                        // Exit, this is not a long string afterall.
                        if ('[' !== input.charAt(index + level)) return false;
                        index += level + 1;
                        // If the first character is a newline, ignore it and begin on next line.
                        if (isLineTerminator(input.charCodeAt(index))) consumeEOL();
                        stringStart = index;
                        while(index < length){
                            // To keep track of line numbers run the `consumeEOL()` which increments
                            // its counter.
                            while(isLineTerminator(input.charCodeAt(index)))consumeEOL();
                            character = input.charAt(index++);
                            // Once the delimiter is found, iterate through the depth count and see
                            // if it matches.
                            if (']' === character) {
                                terminator = true;
                                for(var i = 0; i < level; ++i){
                                    if ('=' !== input.charAt(index + i)) terminator = false;
                                }
                                if (']' !== input.charAt(index + level)) terminator = false;
                            }
                            // We reached the end of the multiline string. Get out now.
                            if (terminator) {
                                content += input.slice(stringStart, index - 1);
                                index += level + 1;
                                return content;
                            }
                        }
                        raise(null, isComment ? errors.unfinishedLongComment : errors.unfinishedLongString, firstLine, '<eof>');
                    }
                    // ## Lex functions and helpers.
                    // Read the next token.
                    //
                    // This is actually done by setting the current token to the lookahead and
                    // reading in the new lookahead token.
                    function next() {
                        previousToken = token;
                        token = lookahead;
                        lookahead = lex();
                    }
                    // Consume a token if its value matches. Once consumed or not, return the
                    // success of the operation.
                    function consume(value) {
                        if (value === token.value) {
                            next();
                            return true;
                        }
                        return false;
                    }
                    // Expect the next token value to match. If not, throw an exception.
                    function expect(value) {
                        if (value === token.value) next();
                        else raise(token, errors.expected, value, tokenValue(token));
                    }
                    // ### Validation functions
                    function isWhiteSpace(charCode) {
                        return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;
                    }
                    function isLineTerminator(charCode) {
                        return 10 === charCode || 13 === charCode;
                    }
                    function isDecDigit(charCode) {
                        return charCode >= 48 && charCode <= 57;
                    }
                    function isHexDigit(charCode) {
                        return charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70;
                    }
                    // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards
                    // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).
                    // On the other hand, LuaJIT allows arbitrary octets ≥ 128 in identifiers.
                    function isIdentifierStart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    }
                    function isIdentifierPart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode || charCode >= 48 && charCode <= 57) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    }
                    // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)
                    //
                    // `true`, `false` and `nil` will not be considered keywords, but literals.
                    function isKeyword(id) {
                        switch(id.length){
                            case 2:
                                return 'do' === id || 'if' === id || 'in' === id || 'or' === id;
                            case 3:
                                return 'and' === id || 'end' === id || 'for' === id || 'not' === id;
                            case 4:
                                if ('else' === id || 'then' === id) return true;
                                if (features.labels && !features.contextualGoto) return 'goto' === id;
                                return false;
                            case 5:
                                return 'break' === id || 'local' === id || 'until' === id || 'while' === id;
                            case 6:
                                return 'elseif' === id || 'repeat' === id || 'return' === id;
                            case 8:
                                return 'function' === id;
                        }
                        return false;
                    }
                    function isUnary(token) {
                        if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;
                        if (Keyword === token.type) return 'not' === token.value;
                        return false;
                    }
                    // Check if the token syntactically closes a block.
                    function isBlockFollow(token) {
                        if (EOF === token.type) return true;
                        if (Keyword !== token.type) return false;
                        switch(token.value){
                            case 'else':
                            case 'elseif':
                            case 'end':
                            case 'until':
                                return true;
                            default:
                                return false;
                        }
                    }
                    // Scope
                    // -----
                    // Store each block scope as a an array of identifier names. Each scope is
                    // stored in an FILO-array.
                    var scopes, scopeDepth, globals;
                    // Create a new scope inheriting all declarations from the previous scope.
                    function createScope() {
                        var scope = scopes[scopeDepth++].slice();
                        scopes.push(scope);
                        if (options.onCreateScope) options.onCreateScope();
                    }
                    // Exit and remove the current scope.
                    function destroyScope() {
                        var scope = scopes.pop();
                        --scopeDepth;
                        if (options.onDestroyScope) options.onDestroyScope();
                    }
                    // Add identifier name to the current scope if it doesnt already exist.
                    function scopeIdentifierName(name) {
                        if (options.onLocalDeclaration) options.onLocalDeclaration(name);
                        if (-1 !== indexOf(scopes[scopeDepth], name)) return;
                        scopes[scopeDepth].push(name);
                    }
                    // Add identifier to the current scope
                    function scopeIdentifier(node) {
                        scopeIdentifierName(node.name);
                        attachScope(node, true);
                    }
                    // Attach scope information to node. If the node is global, store it in the
                    // globals array so we can return the information to the user.
                    function attachScope(node, isLocal) {
                        if (!isLocal && -1 === indexOfObject(globals, 'name', node.name)) globals.push(node);
                        node.isLocal = isLocal;
                    }
                    // Is the identifier name available in this scope.
                    function scopeHasName(name) {
                        return -1 !== indexOf(scopes[scopeDepth], name);
                    }
                    // Location tracking
                    // -----------------
                    //
                    // Locations are stored in FILO-array as a `Marker` object consisting of both
                    // `loc` and `range` data. Once a `Marker` is popped off the list an end
                    // location is added and the data is attached to a syntax node.
                    var locations = [], trackLocations;
                    function createLocationMarker() {
                        return new Marker(token);
                    }
                    function Marker(token) {
                        if (options.locations) {
                            this.loc = {
                                start: {
                                    line: token.line,
                                    column: token.range[0] - token.lineStart
                                },
                                end: {
                                    line: 0,
                                    column: 0
                                }
                            };
                        }
                        if (options.ranges) this.range = [
                            token.range[0],
                            0
                        ];
                    }
                    // Complete the location data stored in the `Marker` by adding the location
                    // of the *previous token* as an end location.
                    Marker.prototype.complete = function() {
                        if (options.locations) {
                            this.loc.end.line = previousToken.lastLine || previousToken.line;
                            this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);
                        }
                        if (options.ranges) {
                            this.range[1] = previousToken.range[1];
                        }
                    };
                    Marker.prototype.bless = function(node) {
                        if (this.loc) {
                            var loc = this.loc;
                            node.loc = {
                                start: {
                                    line: loc.start.line,
                                    column: loc.start.column
                                },
                                end: {
                                    line: loc.end.line,
                                    column: loc.end.column
                                }
                            };
                        }
                        if (this.range) {
                            node.range = [
                                this.range[0],
                                this.range[1]
                            ];
                        }
                    };
                    // Create a new `Marker` and add it to the FILO-array.
                    function markLocation() {
                        if (trackLocations) locations.push(createLocationMarker());
                    }
                    // Push an arbitrary `Marker` object onto the FILO-array.
                    function pushLocation(marker) {
                        if (trackLocations) locations.push(marker);
                    }
                    // Control flow tracking
                    // ---------------------
                    // A context object that validates loop breaks and `goto`-based control flow.
                    function FullFlowContext() {
                        this.scopes = [];
                        this.pendingGotos = [];
                    }
                    FullFlowContext.prototype.isInLoop = function() {
                        var i = this.scopes.length;
                        while(i-- > 0){
                            if (this.scopes[i].isLoop) return true;
                        }
                        return false;
                    };
                    FullFlowContext.prototype.pushScope = function(isLoop) {
                        var scope = {
                            labels: {},
                            locals: [],
                            deferredGotos: [],
                            isLoop: !!isLoop
                        };
                        this.scopes.push(scope);
                    };
                    FullFlowContext.prototype.popScope = function() {
                        for(var i = 0; i < this.pendingGotos.length; ++i){
                            var theGoto = this.pendingGotos[i];
                            if (theGoto.maxDepth >= this.scopes.length) {
                                if (--theGoto.maxDepth <= 0) raise(theGoto.token, errors.labelNotVisible, theGoto.target);
                            }
                        }
                        this.scopes.pop();
                    };
                    FullFlowContext.prototype.addGoto = function(target, token) {
                        var localCounts = [];
                        for(var i = 0; i < this.scopes.length; ++i){
                            var scope = this.scopes[i];
                            localCounts.push(scope.locals.length);
                            if (Object.prototype.hasOwnProperty.call(scope.labels, target)) return;
                        }
                        this.pendingGotos.push({
                            maxDepth: this.scopes.length,
                            target: target,
                            token: token,
                            localCounts: localCounts
                        });
                    };
                    FullFlowContext.prototype.addLabel = function(name, token) {
                        var scope = this.currentScope();
                        if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {
                            raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);
                        } else {
                            var newGotos = [];
                            for(var i = 0; i < this.pendingGotos.length; ++i){
                                var theGoto = this.pendingGotos[i];
                                if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {
                                    if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {
                                        scope.deferredGotos.push(theGoto);
                                    }
                                    continue;
                                }
                                newGotos.push(theGoto);
                            }
                            this.pendingGotos = newGotos;
                        }
                        scope.labels[name] = {
                            localCount: scope.locals.length,
                            line: token.line
                        };
                    };
                    FullFlowContext.prototype.addLocal = function(name, token) {
                        this.currentScope().locals.push({
                            name: name,
                            token: token
                        });
                    };
                    FullFlowContext.prototype.currentScope = function() {
                        return this.scopes[this.scopes.length - 1];
                    };
                    FullFlowContext.prototype.raiseDeferredErrors = function() {
                        var scope = this.currentScope();
                        var bads = scope.deferredGotos;
                        for(var i = 0; i < bads.length; ++i){
                            var theGoto = bads[i];
                            raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);
                        }
                    // Would be dead code currently, but may be useful later
                    // if (bads.length)
                    //   scope.deferredGotos = [];
                    };
                    // Simplified context that only checks the validity of loop breaks.
                    function LoopFlowContext() {
                        this.level = 0;
                        this.loopLevels = [];
                    }
                    LoopFlowContext.prototype.isInLoop = function() {
                        return !!this.loopLevels.length;
                    };
                    LoopFlowContext.prototype.pushScope = function(isLoop) {
                        ++this.level;
                        if (isLoop) this.loopLevels.push(this.level);
                    };
                    LoopFlowContext.prototype.popScope = function() {
                        var levels = this.loopLevels;
                        var levlen = levels.length;
                        if (levlen) {
                            if (levels[levlen - 1] === this.level) levels.pop();
                        }
                        --this.level;
                    };
                    LoopFlowContext.prototype.addGoto = LoopFlowContext.prototype.addLabel = /* istanbul ignore next */ function() {
                        throw new Error('This should never happen');
                    };
                    LoopFlowContext.prototype.addLocal = LoopFlowContext.prototype.raiseDeferredErrors = function() {};
                    function makeFlowContext() {
                        return features.labels ? new FullFlowContext() : new LoopFlowContext();
                    }
                    // Parse functions
                    // ---------------
                    // Chunk is the main program object. Syntactically it's the same as a block.
                    //
                    //     chunk ::= block
                    function parseChunk() {
                        next();
                        markLocation();
                        if (options.scope) createScope();
                        var flowContext = makeFlowContext();
                        flowContext.allowVararg = true;
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        if (EOF !== token.type) unexpected(token);
                        // If the body is empty no previousToken exists when finishNode runs.
                        if (trackLocations && !body.length) previousToken = token;
                        return finishNode(ast.chunk(body));
                    }
                    // A block contains a list of statements with an optional return statement
                    // as its last statement.
                    //
                    //     block ::= {stat} [retstat]
                    function parseBlock(flowContext) {
                        var block = [], statement;
                        while(!isBlockFollow(token)){
                            // Return has to be the last statement in a block.
                            // Likewise 'break' in Lua older than 5.2
                            if ('return' === token.value || !features.relaxedBreak && 'break' === token.value) {
                                block.push(parseStatement(flowContext));
                                break;
                            }
                            statement = parseStatement(flowContext);
                            consume(';');
                            // Statements are only added if they are returned, this allows us to
                            // ignore some statements, such as EmptyStatement.
                            if (statement) block.push(statement);
                        }
                        // Doesn't really need an ast node
                        return block;
                    }
                    // There are two types of statements, simple and compound.
                    //
                    //     statement ::= break | goto | do | while | repeat | return
                    //          | if | for | function | local | label | assignment
                    //          | functioncall | ';'
                    function parseStatement(flowContext) {
                        markLocation();
                        if (Punctuator === token.type) {
                            if (consume('::')) return parseLabelStatement(flowContext);
                        }
                        // When a `;` is encounted, simply eat it without storing it.
                        if (features.emptyStatement) {
                            if (consume(';')) {
                                if (trackLocations) locations.pop();
                                return;
                            }
                        }
                        flowContext.raiseDeferredErrors();
                        if (Keyword === token.type) {
                            switch(token.value){
                                case 'local':
                                    next();
                                    return parseLocalStatement(flowContext);
                                case 'if':
                                    next();
                                    return parseIfStatement(flowContext);
                                case 'return':
                                    next();
                                    return parseReturnStatement(flowContext);
                                case 'function':
                                    next();
                                    var name = parseFunctionName();
                                    return parseFunctionDeclaration(name);
                                case 'while':
                                    next();
                                    return parseWhileStatement(flowContext);
                                case 'for':
                                    next();
                                    return parseForStatement(flowContext);
                                case 'repeat':
                                    next();
                                    return parseRepeatStatement(flowContext);
                                case 'break':
                                    next();
                                    if (!flowContext.isInLoop()) raise(token, errors.noLoopToBreak, token.value);
                                    return parseBreakStatement();
                                case 'do':
                                    next();
                                    return parseDoStatement(flowContext);
                                case 'goto':
                                    next();
                                    return parseGotoStatement(flowContext);
                            }
                        }
                        if (features.contextualGoto && token.type === Identifier && token.value === 'goto' && lookahead.type === Identifier && lookahead.value !== 'goto') {
                            next();
                            return parseGotoStatement(flowContext);
                        }
                        // Assignments memorizes the location and pushes it manually for wrapper nodes.
                        if (trackLocations) locations.pop();
                        return parseAssignmentOrCallStatement(flowContext);
                    }
                    // ## Statements
                    //     label ::= '::' Name '::'
                    function parseLabelStatement(flowContext) {
                        var nameToken = token, label = parseIdentifier();
                        if (options.scope) {
                            scopeIdentifierName('::' + nameToken.value + '::');
                            attachScope(label, true);
                        }
                        expect('::');
                        flowContext.addLabel(nameToken.value, nameToken);
                        return finishNode(ast.labelStatement(label));
                    }
                    //     break ::= 'break'
                    function parseBreakStatement() {
                        return finishNode(ast.breakStatement());
                    }
                    //     goto ::= 'goto' Name
                    function parseGotoStatement(flowContext) {
                        var name = token.value, gotoToken = previousToken, label = parseIdentifier();
                        flowContext.addGoto(name, gotoToken);
                        return finishNode(ast.gotoStatement(label));
                    }
                    //     do ::= 'do' block 'end'
                    function parseDoStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect('end');
                        return finishNode(ast.doStatement(body));
                    }
                    //     while ::= 'while' exp 'do' block 'end'
                    function parseWhileStatement(flowContext) {
                        var condition = parseExpectedExpression(flowContext);
                        expect('do');
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect('end');
                        return finishNode(ast.whileStatement(condition, body));
                    }
                    //     repeat ::= 'repeat' block 'until' exp
                    function parseRepeatStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        expect('until');
                        flowContext.raiseDeferredErrors();
                        var condition = parseExpectedExpression(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        return finishNode(ast.repeatStatement(condition, body));
                    }
                    //     retstat ::= 'return' [exp {',' exp}] [';']
                    function parseReturnStatement(flowContext) {
                        var expressions = [];
                        if ('end' !== token.value) {
                            var expression = parseExpression(flowContext);
                            if (null != expression) expressions.push(expression);
                            while(consume(',')){
                                expression = parseExpectedExpression(flowContext);
                                expressions.push(expression);
                            }
                            consume(';'); // grammar tells us ; is optional here.
                        }
                        return finishNode(ast.returnStatement(expressions));
                    }
                    //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'
                    //     elif ::= 'elseif' exp 'then' block
                    function parseIfStatement(flowContext) {
                        var clauses = [], condition, body, marker;
                        // IfClauses begin at the same location as the parent IfStatement.
                        // It ends at the start of `end`, `else`, or `elseif`.
                        if (trackLocations) {
                            marker = locations[locations.length - 1];
                            locations.push(marker);
                        }
                        condition = parseExpectedExpression(flowContext);
                        expect('then');
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        clauses.push(finishNode(ast.ifClause(condition, body)));
                        if (trackLocations) marker = createLocationMarker();
                        while(consume('elseif')){
                            pushLocation(marker);
                            condition = parseExpectedExpression(flowContext);
                            expect('then');
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseifClause(condition, body)));
                            if (trackLocations) marker = createLocationMarker();
                        }
                        if (consume('else')) {
                            // Include the `else` in the location of ElseClause.
                            if (trackLocations) {
                                marker = new Marker(previousToken);
                                locations.push(marker);
                            }
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseClause(body)));
                        }
                        expect('end');
                        return finishNode(ast.ifStatement(clauses));
                    }
                    // There are two types of for statements, generic and numeric.
                    //
                    //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'
                    //     for ::= namelist 'in' explist 'do' block 'end'
                    //     namelist ::= Name {',' Name}
                    //     explist ::= exp {',' exp}
                    function parseForStatement(flowContext) {
                        var variable = parseIdentifier(), body;
                        // The start-identifier is local.
                        if (options.scope) {
                            createScope();
                            scopeIdentifier(variable);
                        }
                        // If the first expression is followed by a `=` punctuator, this is a
                        // Numeric For Statement.
                        if (consume('=')) {
                            // Start expression
                            var start = parseExpectedExpression(flowContext);
                            expect(',');
                            // End expression
                            var end = parseExpectedExpression(flowContext);
                            // Optional step expression
                            var step = consume(',') ? parseExpectedExpression(flowContext) : null;
                            expect('do');
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect('end');
                            if (options.scope) destroyScope();
                            return finishNode(ast.forNumericStatement(variable, start, end, step, body));
                        } else {
                            // The namelist can contain one or more identifiers.
                            var variables = [
                                variable
                            ];
                            while(consume(',')){
                                variable = parseIdentifier();
                                // Each variable in the namelist is locally scoped.
                                if (options.scope) scopeIdentifier(variable);
                                variables.push(variable);
                            }
                            expect('in');
                            var iterators = [];
                            // One or more expressions in the explist.
                            do {
                                var expression = parseExpectedExpression(flowContext);
                                iterators.push(expression);
                            }while (consume(','))
                            expect('do');
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect('end');
                            if (options.scope) destroyScope();
                            return finishNode(ast.forGenericStatement(variables, iterators, body));
                        }
                    }
                    // Local statements can either be variable assignments or function
                    // definitions. If a function definition is found, it will be delegated to
                    // `parseFunctionDeclaration()` with the isLocal flag.
                    //
                    // This AST structure might change into a local assignment with a function
                    // child.
                    //
                    //     local ::= 'local' 'function' Name funcdecl
                    //        | 'local' Name {',' Name} ['=' exp {',' exp}]
                    function parseLocalStatement(flowContext) {
                        var name, declToken = previousToken;
                        if (Identifier === token.type) {
                            var variables = [], init = [];
                            do {
                                name = parseIdentifier();
                                variables.push(name);
                                flowContext.addLocal(name.name, declToken);
                            }while (consume(','))
                            if (consume('=')) {
                                do {
                                    var expression = parseExpectedExpression(flowContext);
                                    init.push(expression);
                                }while (consume(','))
                            }
                            // Declarations doesn't exist before the statement has been evaluated.
                            // Therefore assignments can't use their declarator. And the identifiers
                            // shouldn't be added to the scope until the statement is complete.
                            if (options.scope) {
                                for(var i = 0, l = variables.length; i < l; ++i){
                                    scopeIdentifier(variables[i]);
                                }
                            }
                            return finishNode(ast.localStatement(variables, init));
                        }
                        if (consume('function')) {
                            name = parseIdentifier();
                            flowContext.addLocal(name.name, declToken);
                            if (options.scope) {
                                scopeIdentifier(name);
                                createScope();
                            }
                            // MemberExpressions are not allowed in local function statements.
                            return parseFunctionDeclaration(name, true);
                        } else {
                            raiseUnexpectedToken('<name>', token);
                        }
                    }
                    //     assignment ::= varlist '=' explist
                    //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name
                    //     varlist ::= var {',' var}
                    //     explist ::= exp {',' exp}
                    //
                    //     call ::= callexp
                    //     callexp ::= prefixexp args | prefixexp ':' Name args
                    function parseAssignmentOrCallStatement(flowContext) {
                        // Keep a reference to the previous token for better error messages in case
                        // of invalid statement
                        var previous = token, marker, startMarker;
                        var lvalue, base, name;
                        var targets = [];
                        if (trackLocations) startMarker = createLocationMarker();
                        do {
                            if (trackLocations) marker = createLocationMarker();
                            if (Identifier === token.type) {
                                name = token.value;
                                base = parseIdentifier();
                                // Set the parent scope.
                                if (options.scope) attachScope(base, scopeHasName(name));
                                lvalue = true;
                            } else if ('(' === token.value) {
                                next();
                                base = parseExpectedExpression(flowContext);
                                expect(')');
                                lvalue = false;
                            } else {
                                return unexpected(token);
                            }
                            both: for(;;){
                                var newBase;
                                switch(StringLiteral === token.type ? '"' : token.value){
                                    case '.':
                                    case '[':
                                        lvalue = true;
                                        break;
                                    case ':':
                                    case '(':
                                    case '{':
                                    case '"':
                                        lvalue = null;
                                        break;
                                    default:
                                        break both;
                                }
                                base = parsePrefixExpressionPart(base, marker, flowContext);
                            }
                            targets.push(base);
                            if (',' !== token.value) break;
                            if (!lvalue) {
                                return unexpected(token);
                            }
                            next();
                        }while (true)
                        if (targets.length === 1 && lvalue === null) {
                            pushLocation(marker);
                            return finishNode(ast.callStatement(targets[0]));
                        } else if (!lvalue) {
                            return unexpected(token);
                        }
                        expect('=');
                        var values = [];
                        do {
                            values.push(parseExpectedExpression(flowContext));
                        }while (consume(','))
                        pushLocation(startMarker);
                        return finishNode(ast.assignmentStatement(targets, values));
                    }
                    // ### Non-statements
                    //     Identifier ::= Name
                    function parseIdentifier() {
                        markLocation();
                        var identifier = token.value;
                        if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);
                        next();
                        return finishNode(ast.identifier(identifier));
                    }
                    // Parse the functions parameters and body block. The name should already
                    // have been parsed and passed to this declaration function. By separating
                    // this we allow for anonymous functions in expressions.
                    //
                    // For local functions there's a boolean parameter which needs to be set
                    // when parsing the declaration.
                    //
                    //     funcdecl ::= '(' [parlist] ')' block 'end'
                    //     parlist ::= Name {',' Name} | [',' '...'] | '...'
                    function parseFunctionDeclaration(name, isLocal) {
                        var flowContext = makeFlowContext();
                        flowContext.pushScope();
                        var parameters = [];
                        expect('(');
                        // The declaration has arguments
                        if (!consume(')')) {
                            // Arguments are a comma separated list of identifiers, optionally ending
                            // with a vararg.
                            while(true){
                                if (Identifier === token.type) {
                                    var parameter = parseIdentifier();
                                    // Function parameters are local.
                                    if (options.scope) scopeIdentifier(parameter);
                                    parameters.push(parameter);
                                    if (consume(',')) continue;
                                } else if (VarargLiteral === token.type) {
                                    flowContext.allowVararg = true;
                                    parameters.push(parsePrimaryExpression(flowContext));
                                } else {
                                    raiseUnexpectedToken('<name> or \'...\'', token);
                                }
                                expect(')');
                                break;
                            }
                        }
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        expect('end');
                        if (options.scope) destroyScope();
                        isLocal = isLocal || false;
                        return finishNode(ast.functionStatement(name, parameters, isLocal, body));
                    }
                    // Parse the function name as identifiers and member expressions.
                    //
                    //     Name {'.' Name} [':' Name]
                    function parseFunctionName() {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        base = parseIdentifier();
                        if (options.scope) {
                            attachScope(base, scopeHasName(base.name));
                            createScope();
                        }
                        while(consume('.')){
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, '.', name));
                        }
                        if (consume(':')) {
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, ':', name));
                            if (options.scope) scopeIdentifierName('self');
                        }
                        return base;
                    }
                    //     tableconstructor ::= '{' [fieldlist] '}'
                    //     fieldlist ::= field {fieldsep field} fieldsep
                    //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp
                    //
                    //     fieldsep ::= ',' | ';'
                    function parseTableConstructor(flowContext) {
                        var fields = [], key, value;
                        while(true){
                            markLocation();
                            if (Punctuator === token.type && consume('[')) {
                                key = parseExpectedExpression(flowContext);
                                expect(']');
                                expect('=');
                                value = parseExpectedExpression(flowContext);
                                fields.push(finishNode(ast.tableKey(key, value)));
                            } else if (Identifier === token.type) {
                                if ('=' === lookahead.value) {
                                    key = parseIdentifier();
                                    next();
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableKeyString(key, value)));
                                } else {
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableValue(value)));
                                }
                            } else {
                                if (null == (value = parseExpression(flowContext))) {
                                    locations.pop();
                                    break;
                                }
                                fields.push(finishNode(ast.tableValue(value)));
                            }
                            if (',;'.indexOf(token.value) >= 0) {
                                next();
                                continue;
                            }
                            break;
                        }
                        expect('}');
                        return finishNode(ast.tableConstructorExpression(fields));
                    }
                    // Expression parser
                    // -----------------
                    //
                    // Expressions are evaluated and always return a value. If nothing is
                    // matched null will be returned.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    //
                    //     primary ::= nil | false | true | Number | String | '...'
                    //          | functiondef | tableconstructor
                    //
                    //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'
                    //          | '.' Name | ':' Name args | args }
                    //
                    function parseExpression(flowContext) {
                        var expression = parseSubExpression(0, flowContext);
                        return expression;
                    }
                    // Parse an expression expecting it to be valid.
                    function parseExpectedExpression(flowContext) {
                        var expression = parseExpression(flowContext);
                        if (null == expression) raiseUnexpectedToken('<expression>', token);
                        else return expression;
                    }
                    // Return the precedence priority of the operator.
                    //
                    // As unary `-` can't be distinguished from binary `-`, unary precedence
                    // isn't described in this table but in `parseSubExpression()` itself.
                    //
                    // As this function gets hit on every expression it's been optimized due to
                    // the expensive CompareICStub which took ~8% of the parse time.
                    function binaryPrecedence(operator) {
                        var charCode = operator.charCodeAt(0), length = operator.length;
                        if (1 === length) {
                            switch(charCode){
                                case 94:
                                    return 12; // ^
                                case 42:
                                case 47:
                                case 37:
                                    return 10; // * / %
                                case 43:
                                case 45:
                                    return 9; // + -
                                case 38:
                                    return 6; // &
                                case 126:
                                    return 5; // ~
                                case 124:
                                    return 4; // |
                                case 60:
                                case 62:
                                    return 3; // < >
                            }
                        } else if (2 === length) {
                            switch(charCode){
                                case 47:
                                    return 10; // //
                                case 46:
                                    return 8; // ..
                                case 60:
                                case 62:
                                    if ('<<' === operator || '>>' === operator) return 7; // << >>
                                    return 3; // <= >=
                                case 61:
                                case 126:
                                    return 3; // == ~=
                                case 111:
                                    return 1; // or
                            }
                        } else if (97 === charCode && 'and' === operator) return 2;
                        return 0;
                    }
                    // Implement an operator-precedence parser to handle binary operator
                    // precedence.
                    //
                    // We use this algorithm because it's compact, it's fast and Lua core uses
                    // the same so we can be sure our expressions are parsed in the same manner
                    // without excessive amounts of tests.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    function parseSubExpression(minPrecedence, flowContext) {
                        var operator = token.value, expression, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // UnaryExpression
                        if (isUnary(token)) {
                            markLocation();
                            next();
                            var argument = parseSubExpression(10, flowContext);
                            if (argument == null) raiseUnexpectedToken('<expression>', token);
                            expression = finishNode(ast.unaryExpression(operator, argument));
                        }
                        if (null == expression) {
                            // PrimaryExpression
                            expression = parsePrimaryExpression(flowContext);
                            // PrefixExpression
                            if (null == expression) {
                                expression = parsePrefixExpression(flowContext);
                            }
                        }
                        // This is not a valid left hand expression.
                        if (null == expression) return null;
                        var precedence;
                        while(true){
                            operator = token.value;
                            precedence = Punctuator === token.type || Keyword === token.type ? binaryPrecedence(operator) : 0;
                            if (precedence === 0 || precedence <= minPrecedence) break;
                            // Right-hand precedence operators
                            if ('^' === operator || '..' === operator) --precedence;
                            next();
                            var right = parseSubExpression(precedence, flowContext);
                            if (null == right) raiseUnexpectedToken('<expression>', token);
                            // Push in the marker created before the loop to wrap its entirety.
                            if (trackLocations) locations.push(marker);
                            expression = finishNode(ast.binaryExpression(operator, expression, right));
                        }
                        return expression;
                    }
                    //     prefixexp ::= prefix {suffix}
                    //     prefix ::= Name | '(' exp ')'
                    //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args
                    //
                    //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parsePrefixExpressionPart(base, marker, flowContext) {
                        var expression, identifier;
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case '[':
                                    pushLocation(marker);
                                    next();
                                    expression = parseExpectedExpression(flowContext);
                                    expect(']');
                                    return finishNode(ast.indexExpression(base, expression));
                                case '.':
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    return finishNode(ast.memberExpression(base, '.', identifier));
                                case ':':
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    base = finishNode(ast.memberExpression(base, ':', identifier));
                                    // Once a : is found, this has to be a CallExpression, otherwise
                                    // throw an error.
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                                case '(':
                                case '{':
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                            }
                        } else if (StringLiteral === token.type) {
                            pushLocation(marker);
                            return parseCallExpression(base, flowContext);
                        }
                        return null;
                    }
                    function parsePrefixExpression(flowContext) {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // The prefix
                        if (Identifier === token.type) {
                            name = token.value;
                            base = parseIdentifier();
                            // Set the parent scope.
                            if (options.scope) attachScope(base, scopeHasName(name));
                        } else if (consume('(')) {
                            base = parseExpectedExpression(flowContext);
                            expect(')');
                        } else {
                            return null;
                        }
                        // The suffix
                        for(;;){
                            var newBase = parsePrefixExpressionPart(base, marker, flowContext);
                            if (newBase === null) break;
                            base = newBase;
                        }
                        return base;
                    }
                    //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parseCallExpression(base, flowContext) {
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case '(':
                                    if (!features.emptyStatement) {
                                        if (token.line !== previousToken.line) raise(null, errors.ambiguousSyntax, token.value);
                                    }
                                    next();
                                    // List of expressions
                                    var expressions = [];
                                    var expression = parseExpression(flowContext);
                                    if (null != expression) expressions.push(expression);
                                    while(consume(',')){
                                        expression = parseExpectedExpression(flowContext);
                                        expressions.push(expression);
                                    }
                                    expect(')');
                                    return finishNode(ast.callExpression(base, expressions));
                                case '{':
                                    markLocation();
                                    next();
                                    var table = parseTableConstructor(flowContext);
                                    return finishNode(ast.tableCallExpression(base, table));
                            }
                        } else if (StringLiteral === token.type) {
                            return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));
                        }
                        raiseUnexpectedToken('function arguments', token);
                    }
                    //     primary ::= String | Numeric | nil | true | false
                    //          | functiondef | tableconstructor | '...'
                    function parsePrimaryExpression(flowContext) {
                        var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral, value = token.value, type = token.type, marker;
                        if (trackLocations) marker = createLocationMarker();
                        if (type === VarargLiteral && !flowContext.allowVararg) {
                            raise(token, errors.cannotUseVararg, token.value);
                        }
                        if (type & literals) {
                            pushLocation(marker);
                            var raw = input.slice(token.range[0], token.range[1]);
                            next();
                            return finishNode(ast.literal(type, value, raw));
                        } else if (Keyword === type && 'function' === value) {
                            pushLocation(marker);
                            next();
                            if (options.scope) createScope();
                            return parseFunctionDeclaration(null);
                        } else if (consume('{')) {
                            pushLocation(marker);
                            return parseTableConstructor(flowContext);
                        }
                    }
                    // Parser
                    // ------
                    // Export the main parser.
                    //
                    //   - `wait` Hold parsing until end() is called. Defaults to false
                    //   - `comments` Store comments. Defaults to true.
                    //   - `scope` Track identifier scope. Defaults to false.
                    //   - `locations` Store location information. Defaults to false.
                    //   - `ranges` Store the start and end character locations. Defaults to
                    //     false.
                    //   - `onCreateNode` Callback which will be invoked when a syntax node is
                    //     created.
                    //   - `onCreateScope` Callback which will be invoked when a new scope is
                    //     created.
                    //   - `onDestroyScope` Callback which will be invoked when the current scope
                    //     is destroyed.
                    //
                    // Example:
                    //
                    //     var parser = require('luaparser');
                    //     parser.parse('i = 0');
                    exports1.parse = parse;
                    var versionFeatures = {
                        '5.1': {},
                        '5.2': {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            relaxedBreak: true
                        },
                        '5.3': {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            bitwiseOperators: true,
                            integerDivision: true,
                            relaxedBreak: true
                        },
                        'LuaJIT': {
                            // XXX: LuaJIT language features may depend on compilation options; may need to
                            // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT
                            // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?
                            labels: true,
                            contextualGoto: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            imaginaryNumbers: true,
                            integerSuffixes: true
                        }
                    };
                    function parse(_input, _options) {
                        if ('undefined' === typeof _options && 'object' === typeof _input) {
                            _options = _input;
                            _input = undefined;
                        }
                        if (!_options) _options = {};
                        input = _input || '';
                        options = assign({}, defaultOptions, _options);
                        // Rewind the lexer
                        index = 0;
                        line = 1;
                        lineStart = 0;
                        length = input.length;
                        // When tracking identifier scope, initialize with an empty scope.
                        scopes = [
                            []
                        ];
                        scopeDepth = 0;
                        globals = [];
                        locations = [];
                        if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {
                            throw new Error(sprintf("Lua version '%1' not supported", options.luaVersion));
                        }
                        features = assign({}, versionFeatures[options.luaVersion]);
                        if (options.extendedIdentifiers !== void 0) features.extendedIdentifiers = !!options.extendedIdentifiers;
                        if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {
                            throw new Error(sprintf("Encoding mode '%1' not supported", options.encodingMode));
                        }
                        encodingMode = encodingModes[options.encodingMode];
                        if (options.comments) comments = [];
                        if (!options.wait) return end();
                        return exports1;
                    }
                    // Write to the source code buffer without beginning the parse.
                    exports1.write = write;
                    function write(_input) {
                        input += String(_input);
                        length = input.length;
                        return exports1;
                    }
                    // Send an EOF and begin parsing.
                    exports1.end = end;
                    function end(_input) {
                        if ('undefined' !== typeof _input) write(_input);
                        // Ignore shebangs.
                        if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function(line) {
                            return line.replace(/./g, ' ');
                        });
                        length = input.length;
                        trackLocations = options.locations || options.ranges;
                        // Initialize with a lookahead token.
                        lookahead = lex();
                        var chunk = parseChunk();
                        if (options.comments) chunk.comments = comments;
                        if (options.scope) chunk.globals = globals;
                        /* istanbul ignore if */ if (locations.length > 0) throw new Error('Location tracking failed. This is most likely a bug in luaparse');
                        return chunk;
                    }
                });
            /* vim: set sw=2 ts=2 et tw=79 : */ /***/ },
            /***/ 2372: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 5968: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_301858__)=>{
                "use strict";
                var define1 = __nested_webpack_require_301858__(1857);
                var callBind = __nested_webpack_require_301858__(8498);
                var implementation = __nested_webpack_require_301858__(2372);
                var getPolyfill = __nested_webpack_require_301858__(1937);
                var shim = __nested_webpack_require_301858__(5087);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1937: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_302586__)=>{
                "use strict";
                var implementation = __nested_webpack_require_302586__(2372);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 5087: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_302958__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_302958__(1937);
                var define1 = __nested_webpack_require_302958__(1857);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 8160: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_303646__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_303646__(968); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 9228: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_309615__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_309615__(968);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_309615__(8160);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 968: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 9907: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 6108: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_319979__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_319979__(528);
                var define1 = __nested_webpack_require_319979__(686);
                var hasDescriptors = __nested_webpack_require_319979__(7239)();
                var gOPD = __nested_webpack_require_319979__(9336);
                var $TypeError = __nested_webpack_require_319979__(3468);
                var $floor = GetIntrinsic('%Math.floor%');
                /** @type {import('.')} */ module1.exports = function setFunctionLength(fn, length) {
                    if (typeof fn !== 'function') {
                        throw new $TypeError('`fn` is not a function');
                    }
                    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
                        throw new $TypeError('`length` must be a positive 32-bit integer');
                    }
                    var loose = arguments.length > 2 && !!arguments[2];
                    var functionLengthIsConfigurable = true;
                    var functionLengthIsWritable = true;
                    if ('length' in fn && gOPD) {
                        var desc = gOPD(fn, 'length');
                        if (desc && !desc.configurable) {
                            functionLengthIsConfigurable = false;
                        }
                        if (desc && !desc.writable) {
                            functionLengthIsWritable = false;
                        }
                    }
                    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                        if (hasDescriptors) {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length, true, true);
                        } else {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length);
                        }
                    }
                    return fn;
                };
            /***/ },
            /***/ 2125: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_322053__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_322053__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_322053__(5501);
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_322053__.n(vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__);
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_322053__(7770);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_322053__(8041);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, document1.text);
                    }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    renameDocument(document1, newDocumentUri) {
                        const previousDocument = this.getDocument(document1.uri);
                        this.addDocument({
                            uri: newDocumentUri,
                            version: previousDocument.version,
                            languageId: previousDocument.languageId,
                            text: previousDocument.getText()
                        });
                        this.options[newDocumentUri] = this.options[document1.uri];
                        this.removeDocument(document1);
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setWorkspace(workspaceUri) {
                        this.workspaceUri = workspaceUri;
                    }
                    setOptions(documentUri, options, merge = false) {
                        this.options[documentUri] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_2__ /* .mergeObjects */ .rL)(options, this.options[documentUri]) : options;
                    }
                    getOption(documentUri, optionName) {
                        if (this.options[documentUri] && this.options[documentUri][optionName]) {
                            return this.options[documentUri][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doInlineComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    getSemanticTokens(document1, range) {
                        return Promise.resolve(null);
                    }
                    dispose() {
                        return Promise.resolve();
                    }
                    closeConnection() {
                        return Promise.resolve();
                    }
                    getCodeActions(document1, range, context) {
                        return Promise.resolve(null);
                    }
                    executeCommand(command, args) {
                        return Promise.resolve(null);
                    }
                    sendAppliedResult(result, callbackId) {}
                    sendRequest(name, args) {
                        return Promise.resolve(null);
                    }
                    sendResponse(callbackId, args) {
                        return;
                    }
                    constructor(mode, workspaceUri){
                        _define_property(this, "serviceName", void 0);
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        _define_property(this, "workspaceUri", void 0);
                        _define_property(this, "clientCapabilities", {
                            textDocument: {
                                diagnostic: {
                                    dynamicRegistration: true,
                                    relatedDocumentSupport: true
                                },
                                publishDiagnostics: {
                                    relatedInformation: true,
                                    versionSupport: false,
                                    tagSupport: {
                                        valueSet: [
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Unnecessary,
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Deprecated
                                        ]
                                    }
                                },
                                hover: {
                                    dynamicRegistration: true,
                                    contentFormat: [
                                        'markdown',
                                        'plaintext'
                                    ]
                                },
                                synchronization: {
                                    dynamicRegistration: true,
                                    willSave: false,
                                    didSave: false,
                                    willSaveWaitUntil: false
                                },
                                formatting: {
                                    dynamicRegistration: true
                                },
                                completion: {
                                    dynamicRegistration: true,
                                    completionItem: {
                                        snippetSupport: true,
                                        commitCharactersSupport: false,
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        deprecatedSupport: false,
                                        preselectSupport: false
                                    },
                                    contextSupport: false
                                },
                                signatureHelp: {
                                    signatureInformation: {
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        activeParameterSupport: true
                                    }
                                },
                                documentHighlight: {
                                    dynamicRegistration: true
                                },
                                semanticTokens: {
                                    multilineTokenSupport: false,
                                    overlappingTokenSupport: false,
                                    tokenTypes: [],
                                    tokenModifiers: [],
                                    formats: [
                                        "relative"
                                    ],
                                    requests: {
                                        full: {
                                            delta: false
                                        },
                                        range: true
                                    },
                                    augmentsSyntaxTokens: true
                                },
                                codeAction: {
                                    dynamicRegistration: true
                                },
                                inlineCompletion: {
                                    dynamicRegistration: true
                                }
                            },
                            window: {
                                showDocument: {
                                    support: true
                                }
                            },
                            workspace: {
                                didChangeConfiguration: {
                                    dynamicRegistration: true
                                },
                                executeCommand: {
                                    dynamicRegistration: true
                                },
                                applyEdit: true,
                                workspaceEdit: {
                                    failureHandling: "abort",
                                    normalizesLineEndings: false,
                                    documentChanges: false
                                }
                            }
                        });
                        this.mode = mode;
                        this.workspaceUri = workspaceUri;
                        this.serviceName = "BaseService";
                        this.serviceData = {
                            className: "BaseService",
                            modes: "",
                            module: ()=>{}
                        };
                    }
                }
            /***/ },
            /***/ 7770: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_336972__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_336972__.d(__nested_webpack_exports__, {
                    /* harmony export */ Tk: ()=>/* binding */ checkValueAgainstRegexpArray,
                    /* harmony export */ rL: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, isEmptyRange, mergeRanges, convertToUri */ function mergeObjects(obj1, obj2, excludeUndefined = false) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    if (excludeUndefined) {
                        obj1 = excludeUndefinedValues(obj1);
                        obj2 = excludeUndefinedValues(obj2);
                    }
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function excludeUndefinedValues(obj) {
                    const filteredEntries = Object.entries(obj).filter(([_, value])=>value !== undefined);
                    return Object.fromEntries(filteredEntries);
                }
                function notEmpty1(value) {
                    return value !== null && value !== undefined;
                }
                function isEmptyRange(range) {
                    return range.start.row === range.end.row && range.start.column === range.end.column;
                }
                //taken with small changes from ace-code
                function mergeRanges1(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !isEmptyRange(range) && !isEmptyRange(next)) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
                function convertToUri(filePath) {
                    //already URI
                    if (filePath.startsWith("file:///")) {
                        return filePath;
                    }
                    return URI.file(filePath).toString();
                }
            /***/ },
            /***/ 5272: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 1531: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_341552__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_341552__(5387);
                var isGeneratorFunction = __nested_webpack_require_341552__(2625);
                var whichTypedArray = __nested_webpack_require_341552__(2730);
                var isTypedArray = __nested_webpack_require_341552__(5943);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 6827: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_354029__)=>{
                /* provided dependency */ var process = __nested_webpack_require_354029__(9907);
                /* provided dependency */ var console = __nested_webpack_require_354029__(4364);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_354029__(1531);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_354029__(5272);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_354029__(5615);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 9208: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_385627__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_385627__(9110);
            /***/ },
            /***/ 9110: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_386186__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_386186__(3312);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_386186__(7672);
                __exportStar(__nested_webpack_require_386186__(7672), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3312: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_390601__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_390601__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_390601__(7672);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 7672: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_398980__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_398980__(7162);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_398980__(1109);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_398980__(8844);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_398980__(2479);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_398980__(6957);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_398980__(3489);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_398980__(656);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_398980__(9036);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_398980__(9805);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_398980__(4054);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_398980__(5091);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 6957: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_417044__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_417044__(5091);
                const Is = __nested_webpack_require_417044__(6618);
                const events_1 = __nested_webpack_require_417044__(2479);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken || (exports1.CancellationToken = CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 4054: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_421969__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_421969__(5091);
                const Is = __nested_webpack_require_421969__(6618);
                const messages_1 = __nested_webpack_require_421969__(7162);
                const linkedMap_1 = __nested_webpack_require_421969__(1109);
                const events_1 = __nested_webpack_require_421969__(2479);
                const cancellation_1 = __nested_webpack_require_421969__(6957);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken || (exports1.ProgressToken = ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues || (exports1.TraceValues = TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification || (exports1.SetTraceNotification = SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification || (exports1.LogTraceNotification = LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors || (exports1.ConnectionErrors = ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy || (exports1.ConnectionStrategy = ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy || (exports1.CancellationSenderStrategy = CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy || (exports1.CancellationStrategy = CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy || (exports1.MessageStrategy = MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions || (exports1.ConnectionOptions = ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8844: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable || (exports1.Disposable = Disposable = {}));
            /***/ },
            /***/ 2479: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_492899__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_492899__(5091);
                var Event;
                (function(Event) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event.None = function() {
                        return _disposable;
                    };
                })(Event || (exports1.Event = Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 6618: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 1109: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch || (exports1.Touch = Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 9805: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error(`Message header must separate key and value using ':'\n${header}`);
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 656: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_528586__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_528586__(5091);
                const Is = __nested_webpack_require_528586__(6618);
                const events_1 = __nested_webpack_require_528586__(2479);
                const semaphore_1 = __nested_webpack_require_528586__(418);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader || (exports1.MessageReader = MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        try {
                            this.buffer.append(data);
                            while(true){
                                if (this.nextMessageLength === -1) {
                                    const headers = this.buffer.tryReadHeaders(true);
                                    if (!headers) {
                                        return;
                                    }
                                    const contentLength = headers.get('content-length');
                                    if (!contentLength) {
                                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
                                        return;
                                    }
                                    const length = parseInt(contentLength);
                                    if (isNaN(length)) {
                                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                                        return;
                                    }
                                    this.nextMessageLength = length;
                                }
                                const body = this.buffer.tryReadBody(this.nextMessageLength);
                                if (body === undefined) {
                                    /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                    return;
                                }
                                this.clearPartialMessageTimer();
                                this.nextMessageLength = -1;
                                // Make sure that we convert one received message after the
                                // other. Otherwise it could happen that a decoding of a second
                                // smaller message finished before the decoding of a first larger
                                // message and then we would deliver the second message first.
                                this.readSemaphore.lock(async ()=>{
                                    const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                    this.callback(message);
                                }).catch((error)=>{
                                    this.fireError(error);
                                });
                            }
                        } catch (error) {
                            this.fireError(error);
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 9036: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_540208__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_540208__(5091);
                const Is = __nested_webpack_require_540208__(6618);
                const semaphore_1 = __nested_webpack_require_540208__(418);
                const events_1 = __nested_webpack_require_540208__(2479);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter || (exports1.MessageWriter = MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 7162: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_547084__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_547084__(6618);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes || (exports1.ErrorCodes = ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message || (exports1.Message = Message = {}));
            /***/ },
            /***/ 5091: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 418: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_562573__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_562573__(5091);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 3489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_566016__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_566016__(6957);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 5501: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_569921__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_569921__(9208);
                __exportStar(__nested_webpack_require_569921__(9208), exports1);
                __exportStar(__nested_webpack_require_569921__(3147), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 3147: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_572110__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_572110__(9110), exports1);
                __exportStar(__nested_webpack_require_572110__(2852), exports1);
                __exportStar(__nested_webpack_require_572110__(8431), exports1);
                __exportStar(__nested_webpack_require_572110__(1815), exports1);
                var connection_1 = __nested_webpack_require_572110__(291);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes || (exports1.LSPErrorCodes = LSPErrorCodes = {}));
            /***/ },
            /***/ 291: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_576250__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_576250__(9110);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8431: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_577487__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_577487__(9110);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection || (exports1.MessageDirection = MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 7602: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_580204__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_580204__(8431);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 3747: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_583208__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_583208__(8431);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest || (exports1.DocumentColorRequest = DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest || (exports1.ColorPresentationRequest = ColorPresentationRequest = {}));
            /***/ },
            /***/ 7639: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_585493__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_585493__(8431);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest || (exports1.ConfigurationRequest = ConfigurationRequest = {}));
            /***/ },
            /***/ 5581: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_587266__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_587266__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
 * or a Thenable that resolves to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest || (exports1.DeclarationRequest = DeclarationRequest = {}));
            /***/ },
            /***/ 1494: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_588895__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_588895__(9110);
                const Is = __nested_webpack_require_588895__(8633);
                const messages_1 = __nested_webpack_require_588895__(8431);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 4781: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_593094__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_593094__(8431);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind || (exports1.FileOperationPatternKind = FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest || (exports1.WillCreateFilesRequest = WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification || (exports1.DidCreateFilesNotification = DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest || (exports1.WillRenameFilesRequest = WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification || (exports1.DidRenameFilesNotification = DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 1203: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_599036__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRefreshRequest = exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_599036__(8431);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest || (exports1.FoldingRangeRequest = FoldingRangeRequest = {}));
                /**
 * @since 3.18.0
 * @proposed
 */ var FoldingRangeRefreshRequest;
                (function(FoldingRangeRefreshRequest) {
                    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;
                    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);
                })(FoldingRangeRefreshRequest || (exports1.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
            /***/ },
            /***/ 7287: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_601095__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_601095__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest || (exports1.ImplementationRequest = ImplementationRequest = {}));
            /***/ },
            /***/ 9383: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_602708__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_602708__(8431);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest || (exports1.InlayHintRequest = InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest || (exports1.InlayHintResolveRequest = InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 2322: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_605484__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineCompletionRequest = void 0;
                const messages_1 = __nested_webpack_require_605484__(8431);
                /**
 * A request to provide inline completions in a document. The request's parameter is of
 * type {@link InlineCompletionParams}, the response is of type
 * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.
 *
 * @since 3.18.0
 * @proposed
 */ var InlineCompletionRequest;
                (function(InlineCompletionRequest) {
                    InlineCompletionRequest.method = 'textDocument/inlineCompletion';
                    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);
                })(InlineCompletionRequest || (exports1.InlineCompletionRequest = InlineCompletionRequest = {}));
            /***/ },
            /***/ 3491: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_607015__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_607015__(8431);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest || (exports1.InlineValueRequest = InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 1815: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_609063__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRefreshRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangesFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.InlineCompletionRequest = exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_609063__(8431);
                const vscode_languageserver_types_1 = __nested_webpack_require_609063__(2852);
                const Is = __nested_webpack_require_609063__(8633);
                const protocol_implementation_1 = __nested_webpack_require_609063__(7287);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_609063__(9264);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_609063__(6860);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_609063__(7639);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_609063__(3747);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_609063__(1203);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "FoldingRangeRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_609063__(5581);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_609063__(1530);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_609063__(4166);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_609063__(7602);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_609063__(2067);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_609063__(4333);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_609063__(2249);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_609063__(4781);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_609063__(7684);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_609063__(7062);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_609063__(3491);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_609063__(9383);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_609063__(1494);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_609063__(4792);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                const protocol_inlineCompletion_1 = __nested_webpack_require_609063__(2322);
                Object.defineProperty(exports1, "InlineCompletionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineCompletion_1.InlineCompletionRequest;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate) || Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter || (exports1.TextDocumentFilter = TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter || (exports1.NotebookDocumentFilter = NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector || (exports1.DocumentSelector = DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest || (exports1.RegistrationRequest = RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest || (exports1.UnregistrationRequest = UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind || (exports1.ResourceOperationKind = ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind || (exports1.FailureHandlingKind = FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind || (exports1.PositionEncodingKind = PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions || (exports1.StaticRegistrationOptions = StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest || (exports1.InitializeRequest = InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes || (exports1.InitializeErrorCodes = InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification || (exports1.InitializedNotification = InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest || (exports1.ShutdownRequest = ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification || (exports1.ExitNotification = ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                    /**
     * A debug message.
     *
     * @since 3.18.0
     */ MessageType.Debug = 5;
                })(MessageType || (exports1.MessageType = MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification || (exports1.ShowMessageNotification = ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest || (exports1.ShowMessageRequest = ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification || (exports1.LogMessageNotification = LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification || (exports1.TelemetryEventNotification = TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind || (exports1.TextDocumentSyncKind = TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason || (exports1.TextDocumentSaveReason = TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType || (exports1.FileChangeType = FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern || (exports1.RelativePattern = RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind || (exports1.WatchKind = WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind || (exports1.CompletionTriggerKind = CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest || (exports1.CompletionRequest = CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest || (exports1.CompletionResolveRequest = CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest || (exports1.HoverRequest = HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest || (exports1.SignatureHelpRequest = SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPosition}
 * the response is of either type {@link Definition} or a typed array of
 * {@link DefinitionLink} or a Thenable that resolves to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest || (exports1.DefinitionRequest = DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest || (exports1.ReferencesRequest = ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type {@link TextDocumentPosition}
 * the request response is an array of type {@link DocumentHighlight}
 * or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest || (exports1.DocumentHighlightRequest = DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest || (exports1.DocumentSymbolRequest = DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest || (exports1.CodeActionRequest = CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest || (exports1.CodeActionResolveRequest = CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest || (exports1.CodeLensRequest = CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest || (exports1.CodeLensResolveRequest = CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest || (exports1.DocumentLinkRequest = DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
                /**
 * A request to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest || (exports1.DocumentFormattingRequest = DocumentFormattingRequest = {}));
                /**
 * A request to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
                /**
 * A request to format ranges in a document.
 *
 * @since 3.18.0
 * @proposed
 */ var DocumentRangesFormattingRequest;
                (function(DocumentRangesFormattingRequest) {
                    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';
                    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);
                })(DocumentRangesFormattingRequest || (exports1.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest || (exports1.RenameRequest = RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest || (exports1.PrepareRenameRequest = PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest || (exports1.ExecuteCommandRequest = ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 2249: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_679118__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_679118__(8431);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 7684: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_680482__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_680482__(8431);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel || (exports1.UniquenessLevel = UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind || (exports1.MonikerKind = MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest || (exports1.MonikerRequest = MonikerRequest = {}));
            /***/ },
            /***/ 4792: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_683489__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_683489__(2852);
                const Is = __nested_webpack_require_683489__(8633);
                const messages_1 = __nested_webpack_require_683489__(8431);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind || (exports1.NotebookCellKind = NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary || (exports1.ExecutionSummary = ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell || (exports1.NotebookCell = NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument || (exports1.NotebookDocument = NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange || (exports1.NotebookCellArrayChange = NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 4166: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_696976__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_696976__(9110);
                const messages_1 = __nested_webpack_require_696976__(8431);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress || (exports1.WorkDoneProgress = WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 1530: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_699790__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_699790__(8431);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest || (exports1.SelectionRangeRequest = SelectionRangeRequest = {}));
            /***/ },
            /***/ 2067: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_701261__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_701261__(8431);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat || (exports1.TokenFormat = TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest || (exports1.SemanticTokensRequest = SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 4333: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_705518__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_705518__(8431);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest || (exports1.ShowDocumentRequest = ShowDocumentRequest = {}));
            /***/ },
            /***/ 9264: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_706987__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_706987__(8431);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest || (exports1.TypeDefinitionRequest = TypeDefinitionRequest = {}));
            /***/ },
            /***/ 7062: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_708600__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_708600__(8431);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 6860: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_711507__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_711507__(8431);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 8633: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 2730: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_716373__)=>{
                "use strict";
                var forEach = __nested_webpack_require_716373__(705);
                var availableTypedArrays = __nested_webpack_require_716373__(4834);
                var callBind = __nested_webpack_require_716373__(8498);
                var callBound = __nested_webpack_require_716373__(9818);
                var gOPD = __nested_webpack_require_716373__(9336);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_716373__(1913)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_716373__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 4834: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_720620__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_720620__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ },
            /***/ 8041: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_721734__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_721734__.d(__nested_webpack_exports__, {
                    /* harmony export */ V: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            const start = this.offsetAt(range.start);
                            const end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(changes, version) {
                        for (const change of changes){
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                const range = getWellformedRange(change.range);
                                // update content
                                const startOffset = this.offsetAt(range.start);
                                const endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                const startLine = Math.max(range.start.line, 0);
                                const endLine = Math.max(range.end.line, 0);
                                let lineOffsets = this._lineOffsets;
                                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(let i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                const diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        const lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            const mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        const line = low - 1;
                        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
                        return {
                            line,
                            character: offset - lineOffsets[line]
                        };
                    }
                    offsetAt(position) {
                        const lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        const lineOffset = lineOffsets[position.line];
                        if (position.character <= 0) {
                            return lineOffset;
                        }
                        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        const offset = Math.min(lineOffset + position.character, nextLineOffset);
                        return this.ensureBeforeEOL(offset, lineOffset);
                    }
                    ensureBeforeEOL(offset, lineOffset) {
                        while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))){
                            offset--;
                        }
                        return offset;
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    static isIncremental(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    static isFull(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        const text = document1.getText();
                        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b)=>{
                            const diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = 0;
                        const spans = [];
                        for (const e of sortedEdits){
                            const startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    const p = data.length / 2 | 0;
                    const left = data.slice(0, p);
                    const right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    let leftIdx = 0;
                    let rightIdx = 0;
                    let i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        const ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
                    const result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(let i = 0; i < text.length; i++){
                        const ch = text.charCodeAt(i);
                        if (isEOL(ch)) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function isEOL(char) {
                    return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;
                }
                function getWellformedRange(range) {
                    const start = range.start;
                    const end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    const range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range
                        };
                    }
                    return textEdit;
                }
            /***/ },
            /***/ 2852: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_736100__)=>{
                "use strict";
                __nested_webpack_require_736100__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_736100__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind1,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineCompletionContext: ()=>/* binding */ InlineCompletionContext,
                    /* harmony export */ InlineCompletionItem: ()=>/* binding */ InlineCompletionItem,
                    /* harmony export */ InlineCompletionList: ()=>/* binding */ InlineCompletionList,
                    /* harmony export */ InlineCompletionTriggerKind: ()=>/* binding */ InlineCompletionTriggerKind,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat1,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString1,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent1,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectedCompletionInfo: ()=>/* binding */ SelectedCompletionInfo,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ StringValue: ()=>/* binding */ StringValue,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI1,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI1;
                (function(URI1) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI1.is = is;
                })(URI1 || (URI1 = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line,
                            character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri,
                            range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri,
                            targetRange,
                            targetSelectionRange,
                            originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red,
                            green,
                            blue,
                            alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range,
                            color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label,
                            textEdit,
                            additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        const result = {
                            startLine,
                            endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location,
                            message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        let result = {
                            range,
                            message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command, ...args) {
                        let result = {
                            title,
                            command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range,
                            newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        const result = {
                            label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range,
                            newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        const candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument,
                            edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        let result = {
                            kind: 'create',
                            uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        let result = {
                            kind: 'rename',
                            oldUri,
                            newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        let result = {
                            kind: 'delete',
                            uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        let candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every((change)=>{
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                class TextEditChangeImpl {
                    insert(position, newText, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    replace(range, newText, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    delete(range, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    add(edit) {
                        this.edits.push(edit);
                    }
                    all() {
                        return this.edits;
                    }
                    clear() {
                        this.edits.splice(0, this.edits.length);
                    }
                    assertChangeAnnotations(value) {
                        if (value === undefined) {
                            throw new Error(`Text edit change is not configured to manage change annotations.`);
                        }
                    }
                    constructor(edits, changeAnnotations){
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                }
                /**
 * A helper class
 */ class ChangeAnnotations {
                    all() {
                        return this._annotations;
                    }
                    get size() {
                        return this._size;
                    }
                    manage(idOrAnnotation, annotation) {
                        let id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error(`Id ${id} is already in use.`);
                        }
                        if (annotation === undefined) {
                            throw new Error(`No annotation provided for id ${id}`);
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    }
                    nextId() {
                        this._counter++;
                        return this._counter.toString();
                    }
                    constructor(annotations){
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                }
                /**
 * A workspace change helps constructing changes to a workspace.
 */ class WorkspaceChange {
                    /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */ get edit() {
                        this.initDocumentChanges();
                        if (this._changeAnnotations !== undefined) {
                            if (this._changeAnnotations.size === 0) {
                                this._workspaceEdit.changeAnnotations = undefined;
                            } else {
                                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                            }
                        }
                        return this._workspaceEdit;
                    }
                    getTextEditChange(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            const textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            let result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                const edits = [];
                                const textDocumentEdit = {
                                    textDocument,
                                    edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            let result = this._textEditChanges[key];
                            if (!result) {
                                let edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    }
                    initDocumentChanges() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    }
                    initChanges() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    }
                    createFile(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    renameFile(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    deleteFile(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    constructor(workspaceEdit){
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach((change)=>{
                                    if (TextDocumentEdit.is(change)) {
                                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                                        this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach((key)=>{
                                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                }
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri,
                            version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri,
                            version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri,
                            languageId,
                            version,
                            text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        const candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent1;
                (function(MarkupContent1) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent1.is = is;
                })(MarkupContent1 || (MarkupContent1 = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind1;
                (function(CompletionItemKind1) {
                    CompletionItemKind1.Text = 1;
                    CompletionItemKind1.Method = 2;
                    CompletionItemKind1.Function = 3;
                    CompletionItemKind1.Constructor = 4;
                    CompletionItemKind1.Field = 5;
                    CompletionItemKind1.Variable = 6;
                    CompletionItemKind1.Class = 7;
                    CompletionItemKind1.Interface = 8;
                    CompletionItemKind1.Module = 9;
                    CompletionItemKind1.Property = 10;
                    CompletionItemKind1.Unit = 11;
                    CompletionItemKind1.Value = 12;
                    CompletionItemKind1.Enum = 13;
                    CompletionItemKind1.Keyword = 14;
                    CompletionItemKind1.Snippet = 15;
                    CompletionItemKind1.Color = 16;
                    CompletionItemKind1.File = 17;
                    CompletionItemKind1.Reference = 18;
                    CompletionItemKind1.Folder = 19;
                    CompletionItemKind1.EnumMember = 20;
                    CompletionItemKind1.Constant = 21;
                    CompletionItemKind1.Struct = 22;
                    CompletionItemKind1.Event = 23;
                    CompletionItemKind1.Operator = 24;
                    CompletionItemKind1.TypeParameter = 25;
                })(CompletionItemKind1 || (CompletionItemKind1 = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat1;
                (function(InsertTextFormat1) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
                })(InsertTextFormat1 || (InsertTextFormat1 = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText,
                            insert,
                            replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString1;
                (function(MarkedString1) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString1.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        const candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString1.is = is;
                })(MarkedString1 || (MarkedString1 = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        let candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent1.is(candidate.contents) || MarkedString1.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString1.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label,
                            documentation
                        } : {
                            label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation, ...parameters) {
                        let result = {
                            label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        let result = {
                            range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        let result = {
                            name,
                            kind,
                            location: {
                                uri,
                                range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name,
                            kind,
                            location: {
                                uri,
                                range
                            }
                        } : {
                            name,
                            kind,
                            location: {
                                uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        let result = {
                            name,
                            detail,
                            kind,
                            range,
                            selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        let candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        let result = {
                            diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        let result = {
                            title
                        };
                        let checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        let result = {
                            range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize,
                            insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range,
                            target,
                            data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range,
                            parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range,
                            text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range,
                            variableName,
                            caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range,
                            expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId,
                            stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        const result = {
                            position,
                            label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var StringValue;
                (function(StringValue) {
                    function createSnippet(value) {
                        return {
                            kind: 'snippet',
                            value
                        };
                    }
                    StringValue.createSnippet = createSnippet;
                })(StringValue || (StringValue = {}));
                var InlineCompletionItem;
                (function(InlineCompletionItem) {
                    function create(insertText, filterText, range, command) {
                        return {
                            insertText,
                            filterText,
                            range,
                            command
                        };
                    }
                    InlineCompletionItem.create = create;
                })(InlineCompletionItem || (InlineCompletionItem = {}));
                var InlineCompletionList;
                (function(InlineCompletionList) {
                    function create(items) {
                        return {
                            items
                        };
                    }
                    InlineCompletionList.create = create;
                })(InlineCompletionList || (InlineCompletionList = {}));
                /**
 * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
 *
 * @since 3.18.0
 * @proposed
 */ var InlineCompletionTriggerKind;
                (function(InlineCompletionTriggerKind) {
                    /**
     * Completion was triggered explicitly by a user gesture.
     */ InlineCompletionTriggerKind.Invoked = 0;
                    /**
     * Completion was triggered automatically while editing.
     */ InlineCompletionTriggerKind.Automatic = 1;
                })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
                var SelectedCompletionInfo;
                (function(SelectedCompletionInfo) {
                    function create(range, text) {
                        return {
                            range,
                            text
                        };
                    }
                    SelectedCompletionInfo.create = create;
                })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
                var InlineCompletionContext;
                (function(InlineCompletionContext) {
                    function create(triggerKind, selectedCompletionInfo) {
                        return {
                            triggerKind,
                            selectedCompletionInfo
                        };
                    }
                    InlineCompletionContext.create = create;
                })(InlineCompletionContext || (InlineCompletionContext = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && URI1.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                const EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        let text = document1.getText();
                        let sortedEdits = mergeSort(edits, (a, b)=>{
                            let diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = text.length;
                        for(let i = sortedEdits.length - 1; i >= 0; i--){
                            let e = sortedEdits[i];
                            let startOffset = document1.offsetAt(e.range.start);
                            let endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        const p = data.length / 2 | 0;
                        const left = data.slice(0, p);
                        const right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        let leftIdx = 0;
                        let rightIdx = 0;
                        let i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            let ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            let start = this.offsetAt(range.start);
                            let end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            let lineOffsets = [];
                            let text = this._content;
                            let isLineStart = true;
                            for(let i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                let ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        let lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            let mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        let line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    }
                    offsetAt(position) {
                        let lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        let lineOffset = lineOffsets[position.line];
                        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var Is;
                (function(Is) {
                    const toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_847097__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ id: moduleId,
                /******/ loaded: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_847097__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.loaded = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __nested_webpack_require_847097__.n = (module1)=>{
                /******/ var getter = module1 && module1.__esModule ? /******/ ()=>module1['default'] : /******/ ()=>module1;
                /******/ __nested_webpack_require_847097__.d(getter, {
                    a: getter
                });
                /******/ return getter;
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_847097__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_847097__.o(definition, key) && !__nested_webpack_require_847097__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_847097__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_847097__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_847097__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/node module decorator */ /******/ (()=>{
            /******/ __nested_webpack_require_847097__.nmd = (module1)=>{
                /******/ module1.paths = [];
                /******/ if (!module1.children) module1.children = [];
                /******/ return module1;
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_847097__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_847097__.d(__nested_webpack_exports__, {
                LuaService: ()=>/* binding */ LuaService
            });
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_847097__(2125);
            // EXTERNAL MODULE: ../../node_modules/luaparse/luaparse.js
            var luaparse = __nested_webpack_require_847097__(98);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var main = __nested_webpack_require_847097__(5501);
            // EXTERNAL MODULE: ./src/utils.ts
            var utils = __nested_webpack_require_847097__(7770);
            ; // CONCATENATED MODULE: ./src/ace/range-singleton.ts
            function _define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class AceRange {
                static getConstructor(editor) {
                    if (!AceRange._instance && editor) {
                        AceRange._instance = editor.getSelectionRange().constructor;
                    }
                    return AceRange._instance;
                }
            }
            _define_property(AceRange, "_instance", void 0);
            ; // CONCATENATED MODULE: ./src/type-converters/common-converters.ts
            var common_converters_CommonConverter;
            (function(CommonConverter1) {
                function normalizeRanges(completions) {
                    return completions && completions.map((el)=>{
                        if (el["range"]) {
                            el["range"] = toRange(el["range"]);
                        }
                        return el;
                    });
                }
                CommonConverter1.normalizeRanges = normalizeRanges;
                function cleanHtml(html) {
                    return html.replace(/<a\s/, "<a target='_blank' ");
                }
                CommonConverter1.cleanHtml = cleanHtml;
                function toRange(range) {
                    if (!range || !range.start || !range.end) {
                        return;
                    }
                    let Range = AceRange.getConstructor();
                    // @ts-ignore
                    return Range.fromPoints(range.start, range.end);
                }
                CommonConverter1.toRange = toRange;
                function convertKind(kind) {
                    switch(kind){
                        case "primitiveType":
                        case "keyword":
                            return main.CompletionItemKind.Keyword;
                        case "variable":
                        case "localVariable":
                            return main.CompletionItemKind.Variable;
                        case "memberVariable":
                        case "memberGetAccessor":
                        case "memberSetAccessor":
                            return main.CompletionItemKind.Field;
                        case "function":
                        case "memberFunction":
                        case "constructSignature":
                        case "callSignature":
                        case "indexSignature":
                            return main.CompletionItemKind.Function;
                        case "enum":
                            return main.CompletionItemKind.Enum;
                        case "module":
                            return main.CompletionItemKind.Module;
                        case "class":
                            return main.CompletionItemKind.Class;
                        case "interface":
                            return main.CompletionItemKind.Interface;
                        case "warning":
                            return main.CompletionItemKind.File;
                    }
                    return main.CompletionItemKind.Property;
                }
                CommonConverter1.convertKind = convertKind;
                function excludeByErrorMessage(diagnostics, errorMessagesToIgnore, fieldName = "message") {
                    if (!errorMessagesToIgnore) return diagnostics;
                    return diagnostics.filter((el)=>!(0, utils /* checkValueAgainstRegexpArray */ .Tk)(el[fieldName], errorMessagesToIgnore));
                }
                CommonConverter1.excludeByErrorMessage = excludeByErrorMessage;
            })(common_converters_CommonConverter || (common_converters_CommonConverter = {}));
            ; // CONCATENATED MODULE: ./src/type-converters/lsp/lsp-converters.ts
            function fromRange(range) {
                return {
                    start: {
                        line: range.start.row,
                        character: range.start.column
                    },
                    end: {
                        line: range.end.row,
                        character: range.end.column
                    }
                };
            }
            function rangeFromPositions(start, end) {
                return {
                    start: start,
                    end: end
                };
            }
            function toRange(range) {
                return {
                    start: {
                        row: range.start.line,
                        column: range.start.character
                    },
                    end: {
                        row: range.end.line,
                        column: range.end.character
                    }
                };
            }
            function fromPoint(point) {
                return {
                    line: point.row,
                    character: point.column
                };
            }
            function toPoint(position) {
                return {
                    row: position.line,
                    column: position.character
                };
            }
            function toAnnotations(diagnostics) {
                var _diagnostics;
                return (_diagnostics = diagnostics) === null || _diagnostics === void 0 ? void 0 : _diagnostics.map((el)=>{
                    return {
                        row: el.range.start.line,
                        column: el.range.start.character,
                        text: el.message,
                        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info",
                        code: el.code
                    };
                });
            }
            function fromAnnotations(annotations) {
                var _annotations;
                return (_annotations = annotations) === null || _annotations === void 0 ? void 0 : _annotations.map((el)=>{
                    return {
                        range: {
                            start: {
                                line: el.row,
                                character: el.column
                            },
                            end: {
                                line: el.row,
                                character: el.column
                            }
                        },
                        message: el.text,
                        severity: el.type === "error" ? 1 : el.type === "warning" ? 2 : 3,
                        code: el["code"]
                    };
                });
            }
            function toCompletion(item) {
                var _item_textEdit, _item_command;
                let itemKind = item.kind;
                let kind = itemKind ? Object.keys(CompletionItemKind)[Object.values(CompletionItemKind).indexOf(itemKind)] : undefined;
                var _item_textEdit_newText, _ref;
                let text = (_ref = (_item_textEdit_newText = (_item_textEdit = item.textEdit) === null || _item_textEdit === void 0 ? void 0 : _item_textEdit.newText) !== null && _item_textEdit_newText !== void 0 ? _item_textEdit_newText : item.insertText) !== null && _ref !== void 0 ? _ref : item.label;
                let filterText;
                // filtering would happen on ace editor side
                //TODO: if filtering and sorting are on server side, we should disable FilteredList in ace completer
                if (item.filterText) {
                    const firstWordMatch = item.filterText.match(/\w+/);
                    const firstWord = firstWordMatch ? firstWordMatch[0] : null;
                    if (firstWord) {
                        const wordRegex = new RegExp(`\\b${firstWord}\\b`, 'i');
                        if (!wordRegex.test(text)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    } else {
                        if (!text.includes(item.filterText)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    }
                }
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.textEdit ? getTextEditRange(item.textEdit, filterText) : undefined;
                let completion = {
                    meta: kind,
                    caption: item.label,
                    score: undefined
                };
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (item.insertTextFormat == InsertTextFormat.Snippet) {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["documentation"] = item.documentation; //TODO: this is workaround for services with instant completion
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = getCompletionItems(completions);
                    return combinedCompletions.map((item)=>toCompletion(item));
                }
                return [];
            }
            function getCompletionItems(completions) {
                return completions.map((el)=>{
                    if (!el.completions) {
                        return [];
                    }
                    let allCompletions;
                    if (Array.isArray(el.completions)) {
                        allCompletions = el.completions;
                    } else {
                        allCompletions = el.completions.items;
                    }
                    return allCompletions.map((item)=>{
                        item["service"] = el.service;
                        return item;
                    });
                }).flat();
            }
            function toInlineCompletion(item) {
                var _item_command;
                let text = typeof item.insertText === "string" ? item.insertText : item.insertText.value;
                let filterText;
                // filtering would happen on ace editor side
                //TODO: if filtering and sorting are on server side, we should disable FilteredList in ace completer
                if (item.filterText) {
                    const firstWordMatch = item.filterText.match(/\w+/);
                    const firstWord = firstWordMatch ? firstWordMatch[0] : null;
                    if (firstWord) {
                        const wordRegex = new RegExp(`\\b${firstWord}\\b`, 'i');
                        if (!wordRegex.test(text)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    } else {
                        if (!text.includes(item.filterText)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    }
                }
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.range ? getInlineCompletionRange(item.range, filterText) : undefined;
                let completion = {};
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (typeof item.insertText !== "string") {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toInlineCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = getCompletionItems(completions);
                    return combinedCompletions.map((item)=>toInlineCompletion(item));
                }
                return [];
            }
            function toResolvedCompletion(completion, item) {
                completion["docMarkdown"] = fromMarkupContent(item.documentation);
                return completion;
            }
            function toCompletionItem(completion) {
                let command;
                if (completion["command"]) {
                    command = {
                        title: "triggerSuggest",
                        command: completion["command"]
                    };
                }
                var _completion_caption;
                let completionItem = {
                    label: (_completion_caption = completion.caption) !== null && _completion_caption !== void 0 ? _completion_caption : "",
                    kind: CommonConverter.convertKind(completion.meta),
                    command: command,
                    insertTextFormat: completion["snippet"] ? InsertTextFormat.Snippet : InsertTextFormat.PlainText,
                    documentation: completion["documentation"]
                };
                if (completion["range"]) {
                    var _completion_snippet;
                    completionItem.textEdit = {
                        range: fromRange(completion["range"]),
                        newText: (_completion_snippet = completion["snippet"]) !== null && _completion_snippet !== void 0 ? _completion_snippet : completion["value"]
                    };
                } else {
                    var _completion_snippet1;
                    completionItem.insertText = (_completion_snippet1 = completion["snippet"]) !== null && _completion_snippet1 !== void 0 ? _completion_snippet1 : completion["value"];
                }
                completionItem["fileName"] = completion["fileName"];
                completionItem["position"] = completion["position"];
                completionItem["item"] = completion["item"];
                completionItem["service"] = completion["service"]; //TODO:
                return completionItem;
            }
            function getTextEditRange(textEdit, filterText) {
                const filterLength = filterText ? filterText.length : 0;
                if ("insert" in textEdit && "replace" in textEdit) {
                    let mergedRanges = mergeRanges([
                        toRange(textEdit.insert),
                        toRange(textEdit.replace)
                    ]);
                    return mergedRanges[0];
                } else {
                    textEdit.range.start.character -= filterLength;
                    return toRange(textEdit.range);
                }
            }
            function getInlineCompletionRange(range, filterText) {
                const filterLength = filterText ? filterText.length : 0;
                range.start.character -= filterLength;
                return toRange(range);
            }
            function toTooltip(hover) {
                var _hover_find;
                if (!hover) return;
                let content = hover.map((el)=>{
                    if (!el || !el.contents) return;
                    if (MarkupContent.is(el.contents)) {
                        return fromMarkupContent(el.contents);
                    } else if (MarkedString.is(el.contents)) {
                        if (typeof el.contents === "string") {
                            return el.contents;
                        }
                        return "```" + el.contents.value + "```";
                    } else {
                        let contents = el.contents.map((el)=>{
                            if (typeof el !== "string") {
                                return `\`\`\`${el.value}\`\`\``;
                            } else {
                                return el;
                            }
                        });
                        return contents.join("\n\n");
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                //TODO: it could be merged within all ranges in future
                let lspRange = (_hover_find = hover.find((el)=>{
                    var _el;
                    return (_el = el) === null || _el === void 0 ? void 0 : _el.range;
                })) === null || _hover_find === void 0 ? void 0 : _hover_find.range;
                let range;
                if (lspRange) range = toRange(lspRange);
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    },
                    range: range
                };
            }
            function fromSignatureHelp(signatureHelp) {
                if (!signatureHelp) return;
                let content = signatureHelp.map((el)=>{
                    var _el, _el1;
                    if (!el) return;
                    let signatureIndex = ((_el = el) === null || _el === void 0 ? void 0 : _el.activeSignature) || 0;
                    let activeSignature = el.signatures[signatureIndex];
                    if (!activeSignature) return;
                    let activeParam = (_el1 = el) === null || _el1 === void 0 ? void 0 : _el1.activeParameter;
                    let contents = activeSignature.label;
                    if (activeParam != undefined && activeSignature.parameters && activeSignature.parameters[activeParam]) {
                        let param = activeSignature.parameters[activeParam].label;
                        if (typeof param == "string") {
                            contents = contents.replace(param, `**${param}**`);
                        }
                    }
                    if (activeSignature.documentation) {
                        if (MarkupContent.is(activeSignature.documentation)) {
                            return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
                        } else {
                            contents += "\n\n" + activeSignature.documentation;
                            return contents;
                        }
                    } else {
                        return contents;
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            }
            function fromMarkupContent(content) {
                if (!content) return;
                if (typeof content === "string") {
                    return content;
                } else {
                    return content.value;
                }
            }
            function fromAceDelta(delta, eol) {
                const text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
                return {
                    range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
                    text: delta.action === "insert" ? text : ""
                };
            }
            function filterDiagnostics(diagnostics, filterErrors) {
                return common_converters_CommonConverter.excludeByErrorMessage(diagnostics, filterErrors.errorMessagesToIgnore).map((el)=>{
                    if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsWarning)) {
                        el.severity = main.DiagnosticSeverity.Warning;
                    } else if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsInfo)) {
                        el.severity = main.DiagnosticSeverity.Information;
                    }
                    return el;
                });
            }
            function fromDocumentHighlights(documentHighlights) {
                return documentHighlights.map(function(el) {
                    let className = el.kind == 2 ? "language_highlight_read" : el.kind == 3 ? "language_highlight_write" : "language_highlight_text";
                    return toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), className);
                });
            }
            function toMarkerGroupItem(range, className, tooltipText) {
                let markerGroupItem = {
                    range: range,
                    className: className
                };
                if (tooltipText) {
                    markerGroupItem["tooltipText"] = tooltipText;
                }
                return markerGroupItem;
            }
            ; // CONCATENATED MODULE: ./src/services/lua/lua-service.ts
            function lua_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class LuaService extends base_service.BaseService {
                async doValidation(document1) {
                    let value = this.getDocumentValue(document1.uri);
                    if (!value) return [];
                    let errors = [];
                    try {
                        this.$service.parse(value);
                    } catch (e) {
                        if (e instanceof this.$service.SyntaxError) {
                            errors.push({
                                range: {
                                    start: {
                                        line: e.line - 1,
                                        character: e.column
                                    },
                                    end: {
                                        line: e.line - 1,
                                        character: e.column
                                    }
                                },
                                message: e.message,
                                severity: 1
                            });
                        }
                    }
                    return filterDiagnostics(errors, this.optionsToFilterDiagnostics);
                }
                constructor(mode){
                    super(mode);
                    lua_service_define_property(this, "$service", void 0);
                    lua_service_define_property(this, "serviceCapabilities", {
                        diagnosticProvider: {
                            interFileDependencies: true,
                            workspaceDiagnostics: true
                        }
                    });
                    this.$service = luaparse;
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXB0QixTQUFTbUQsRUFBRW5ELE9BQU87Z0NBQ2xCc2pFLFVBQVU7NEJBQ2Q7d0JBQ0o7b0JBQ0o7b0JBQ0EsT0FBT2lNLGtCQUFrQnRvRCxRQUFRLElBQUksQ0FBQzhaLDBCQUEwQjtnQkFDcEU7Z0JBQ0E1akMsWUFBWW9sQyxJQUFJLENBQUM7b0JBQ2IsS0FBSyxDQUFDQTtvQkFDTnV0Qyw0QkFBNEIsSUFBSSxFQUFFLFlBQVksS0FBSztvQkFDbkRBLDRCQUE0QixJQUFJLEVBQUUsdUJBQXVCO3dCQUNyREUsb0JBQW9COzRCQUNoQkMsdUJBQXVCOzRCQUN2QkMsc0JBQXNCO3dCQUMxQjtvQkFDSjtvQkFDQSxJQUFJLENBQUNILFFBQVEsR0FBR2xGO2dCQUNwQjtZQUNKO1FBRUE7UUFFQSxNQUFNLEdBQUksT0FBTzFzQywwQkFBbUJBO0lBQ3BDLE1BQU0sR0FBRztBQUVUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNlLWxpbnRlcnMtcm9vdC8uL3BhY2thZ2VzL2FjZS1saW50ZXJzL2J1aWxkL2x1YS1zZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDYwOTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwNyk7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gICAgRVJSX0FNQklHVU9VU19BUkdVTUVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTO1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MDEpO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpLnR5cGVzKSxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogKF9fd2VicGFja19yZXF1aXJlX18oMzA0NikuYXNzaWduKTtcbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IF9fd2VicGFja19yZXF1aXJlX18oNTk2OCk7XG52YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKTtcbnZhciBpc0RlZXBFcXVhbDtcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcbnZhciBwYXJzZUV4cHJlc3Npb25BdDtcbnZhciBmaW5kTm9kZUFyb3VuZDtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjU2KTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdKSk7XG5cbnZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07XG59O1xuXG52YXIgd2FybmVkID0gZmFsc2U7IC8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcbnZhciBOT19FWENFUFRJT05fU0VOVElORUwgPSB7fTsgLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZTtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGbikge1xuICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbnRlcm5hbE1lc3NhZ2U7XG5cbiAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICB3YXJuKCdhc3NlcnQuZmFpbCgpIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgYXNzZXJ0LnN0cmljdEVxdWFsKCkgaW5zdGVhZCBvciBvbmx5IHBhc3MgYSBtZXNzYWdlLicsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDA5NCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzTGVuID09PSAyKSBvcGVyYXRvciA9ICchPSc7XG4gIH1cblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtZXNzYWdlO1xuICB2YXIgZXJyQXJncyA9IHtcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSB1bmRlZmluZWQgPyAnZmFpbCcgOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsXG4gIH07XG5cbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKGVyckFyZ3MpO1xuXG4gIGlmIChpbnRlcm5hbE1lc3NhZ2UpIHtcbiAgICBlcnIubWVzc2FnZSA9IGludGVybmFsTWVzc2FnZTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmFzc2VydC5mYWlsID0gZmFpbDsgLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogdmFsdWUsXG4gICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhdmFsdWUuXG5cblxuZnVuY3Rpb24gb2soKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0Lm9rID0gb2s7IC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3Rcbi8vIGVxdWFsIHdpdGggIT0uXG5cblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJyE9JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG5cblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuXG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5cbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKG9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKGFjdHVhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAob2JqW2tleV0pICYmIG9ialtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBhY3R1YWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1lc3NhZ2UsIGtleXMsIGZuKSB7XG4gIGlmICghKGtleSBpbiBhY3R1YWwpIHx8ICFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSkpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIGNyZWF0ZSBhIG5pY2Ugb3V0cHV0LlxuICAgICAgdmFyIGEgPSBuZXcgQ29tcGFyaXNvbihhY3R1YWwsIGtleXMpO1xuICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLmFjdHVhbCA9IGFjdHVhbDtcbiAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCwgbXNnLCBmbikge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2V4cGVjdGVkJywgWydGdW5jdGlvbicsICdSZWdFeHAnXSwgZXhwZWN0ZWQpO1xuICAgIH0gLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG5cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZFxuICAgIC8vIGFzIHdlbGwuXG5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlcnJvcicsIGV4cGVjdGVkLCAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKGV4cGVjdGVkW2tleV0pICYmIGV4cGVjdGVkW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbXNnLCBrZXlzLCBmbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gR3VhcmQgaW5zdGFuY2VvZiBhZ2FpbnN0IGFycm93IGZ1bmN0aW9ucyBhcyB0aGV5IGRvbid0IGhhdmUgYSBwcm90b3R5cGUuXG5cblxuICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3R1YWwoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCAnRnVuY3Rpb24nLCBmbik7XG4gIH1cblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xuICAvLyBBY2NlcHQgbmF0aXZlIEVTNiBwcm9taXNlcyBhbmQgcHJvbWlzZXMgdGhhdCBhcmUgaW1wbGVtZW50ZWQgaW4gYSBzaW1pbGFyXG4gIC8vIHdheS4gRG8gbm90IGFjY2VwdCB0aGVuYWJsZXMgdGhhdCB1c2UgYSBmdW5jdGlvbiBhcyBgb2JqYCBhbmQgdGhhdCBoYXZlIG5vXG4gIC8vIGBjYXRjaGAgaGFuZGxlci5cbiAgLy8gVE9ETzogdGhlbmFibGVzIGFyZSBjaGVja2VkIHVwIHVudGlsIHRoZXkgaGF2ZSB0aGUgY29ycmVjdCBtZXRob2RzLFxuICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cbiAgcmV0dXJuIGlzUHJvbWlzZShvYmopIHx8IG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNhdGNoID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdFByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIHByb21pc2VGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm4oKTsgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG5cbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnaW5zdGFuY2Ugb2YgUHJvbWlzZScsICdwcm9taXNlRm4nLCByZXN1bHRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGVycm9yICE9IG51bGwgJiYgX3R5cGVvZihlcnJvcikgIT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgdmFyIGRldGFpbHMgPSAnJztcblxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XG4gICAgICBkZXRhaWxzICs9IFwiIChcIi5jb25jYXQoZXJyb3IubmFtZSwgXCIpXCIpO1xuICAgIH1cblxuICAgIGRldGFpbHMgKz0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAncmVqZWN0cycgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBleHBlY3RlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscyksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcblxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgXCJcXG5cIikgKyBcIkFjdHVhbCBtZXNzYWdlOiBcXFwiXCIuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgXCJcXFwiXCIpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IGFjdHVhbDtcbn1cblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIHRocm93cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFtyZWplY3RzLCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhmbikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xuXG4gICAgaWYgKF90eXBlb2YoZXJyKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmxlbmd0aCA9PT0gMCAmJiBlcnIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBlcnIsXG4gICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yXG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG5cbiAgICB2YXIgb3JpZ1N0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAvLyBjcmVhdGVkIG9uZXMuXG4gICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB0bXAyLnNoaWZ0KCk7IC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cblxuICAgICAgdmFyIHRtcDEgPSBuZXdFcnIuc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XG5cbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld0Vyci5zdGFjayA9IFwiXCIuY29uY2F0KHRtcDEuam9pbignXFxuJyksIFwiXFxuXCIpLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXdFcnI7XG4gIH1cbn07IC8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5cblxuZnVuY3Rpb24gc3RyaWN0KCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgwMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXG5cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDEzNDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuIC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkzKTtcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdChfdHlwZW9mKGFjdHVhbCkpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdpcyBpbnZhbGlkJztcbiAgaWYgKHV0aWwgPT09IHVuZGVmaW5lZCkgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyk7XG4gIHZhciBpbnNwZWN0ZWQgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuXG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgaW5zcGVjdGVkID0gXCJcIi5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksIFwiLi4uXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIi5jb25jYXQobmFtZSwgXCInIFwiKS5jb25jYXQocmVhc29uLCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChpbnNwZWN0ZWQpO1xufSwgVHlwZUVycm9yLCBSYW5nZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZTtcblxuICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHR5cGUgPSBcImluc3RhbmNlIG9mIFwiLmNvbmNhdCh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJ0eXBlIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5Myk7XG4gIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB2YXIgbXNnID0gJ1RoZSAnO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoYSwgXCJcXFwiXCIpO1xuICB9KTtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICBtc2cgKz0gXCIsIGFuZCBcIi5jb25jYXQoYXJnc1tsZW4gLSAxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY1Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcblxudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogX193ZWJwYWNrX3JlcXVpcmVfXyg3ODM4KTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gKF9fd2VicGFja19yZXF1aXJlX18oNjgyNykudHlwZXMpLFxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgaXNEYXRlID0gX3JlcXVpcmUkdHlwZXMuaXNEYXRlLFxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICBpc1NldCA9IF9yZXF1aXJlJHR5cGVzLmlzU2V0LFxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgIGlzTnVtYmVyT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNOdW1iZXJPYmplY3QsXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgaXNCaWdJbnRPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0JpZ0ludE9iamVjdCxcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgaXNGbG9hdDY0QXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cblxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7IC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgcmV0dXJuIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPyBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncyA6IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gIHJldHVybiBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cblxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xuICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdHJpY3QgPyBvYmplY3RJcyh2YWwxLCB2YWwyKSA6IHRydWU7XG4gIH0gLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuXG5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwxKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSk7XG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XG5cbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG5cblxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG5cblxuICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpOyAvLyBUaGUgcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcblxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG5cbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYUtleXMubGVuZ3RoID09PSAwICYmIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fCBpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCB8fCB2YWwxLnNpemUgPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cblxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG5cbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuXG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuXG5mdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gR28gbG9va2luZy5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VxdWFsaXR5X2NvbXBhcmlzb25zX2FuZF9zYW1lbmVzcyNMb29zZV9lcXVhbGl0eV91c2luZ1xuLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuLy8gY2FuIG1hdGNoIGxvdHMgb2YgZGlmZmVyZW50IHN0cmluZyB2YWx1ZXMgKGUuZy4sIDFuID09ICcrMDAwMDEnKS5cblxuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWU7XG4gIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuXG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XG5cbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5cbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gIC8vIHBhaXJ3aXNlLlxuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07IC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuXG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldOyAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtMSwgaXRlbTIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBmYWxzZSwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gIC8vIFNldHMgYW5kIG1hcHMgZG9uJ3QgaGF2ZSB0aGVpciBlbnRyaWVzIGFjY2Vzc2libGUgdmlhIG5vcm1hbCBvYmplY3RcbiAgLy8gcHJvcGVydGllcy5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG5cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2tleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODE4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xuXG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0OTgpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0OTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG52YXIgc2V0RnVuY3Rpb25MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxMDgpO1xuXG52YXIgJFR5cGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2OCk7XG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTQwKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRpZiAodHlwZW9mIG9yaWdpbmFsRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSxcblx0XHR0cnVlXG5cdCk7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzNjQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KVxudmFyIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5MylcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09IFwidW5kZWZpbmVkXCIgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NDApO1xuXG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcblxudmFyIGdvcGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMzYpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVEYXRhUHJvcGVydHkoXG5cdG9iaixcblx0cHJvcGVydHksXG5cdHZhbHVlXG4pIHtcblx0aWYgKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BvYmpgIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25gJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgcHJvcGVydHlgIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBzeW1ib2xgJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHR5cGVvZiBhcmd1bWVudHNbM10gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbM10gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkVudW1lcmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB0eXBlb2YgYXJndW1lbnRzWzRdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzRdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Xcml0YWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIHR5cGVvZiBhcmd1bWVudHNbNV0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNV0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkNvbmZpZ3VyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIHR5cGVvZiBhcmd1bWVudHNbNl0gIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbG9vc2VgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBub25FbnVtZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXHR2YXIgbm9uV3JpdGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cdHZhciBub25Db25maWd1cmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG5cblx0LyogQHR5cGUge2ZhbHNlIHwgVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8dW5rbm93bj59ICovXG5cdHZhciBkZXNjID0gISFnb3BkICYmIGdvcGQob2JqLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IG5vbkNvbmZpZ3VyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5jb25maWd1cmFibGUgOiAhbm9uQ29uZmlndXJhYmxlLFxuXHRcdFx0ZW51bWVyYWJsZTogbm9uRW51bWVyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5lbnVtZXJhYmxlIDogIW5vbkVudW1lcmFibGUsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogbm9uV3JpdGFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2Mud3JpdGFibGUgOiAhbm9uV3JpdGFibGVcblx0XHR9KTtcblx0fSBlbHNlIGlmIChsb29zZSB8fCAoIW5vbkVudW1lcmFibGUgJiYgIW5vbldyaXRhYmxlICYmICFub25Db25maWd1cmFibGUpKSB7XG5cdFx0Ly8gbXVzdCBmYWxsIGJhY2sgdG8gW1tTZXRdXSwgYW5kIHdhcyBub3QgZXhwbGljaXRseSBhc2tlZCB0byBtYWtlIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1jb25maWd1cmFibGVcblx0XHRvYmpbcHJvcGVydHldID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgYSBwcm9wZXJ0eSBhcyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1lbnVtZXJhYmxlLicpO1xuXHR9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIyOCk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgZGVmaW5lRGF0YVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYpO1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMzkpKCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKHByZWRpY2F0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0aWYgKG9iamVjdFtuYW1lXSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuXHRcdGRlZmluZURhdGFQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHZhbHVlLCB0cnVlKTtcblx0fSBlbHNlIHtcblx0XHRkZWZpbmVEYXRhUHJvcGVydHkob2JqZWN0LCBuYW1lLCB2YWx1ZSk7XG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5NDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpIHx8IGZhbHNlO1xuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWZpbmVQcm9wZXJ0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjcyOTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2V2YWwnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXZhbEVycm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODM4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExNTU6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yYW5nZScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSYW5nZUVycm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTQzOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmVmJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmVyZW5jZUVycm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NzMxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc3ludGF4Jyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRheEVycm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDY4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxNDA6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi91cmknKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gVVJJRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMwNDY6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29kZSByZWZhY3RvcmVkIGZyb20gTW96aWxsYSBEZXZlbG9wZXIgTmV0d29yazpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAqL1xuXG5cblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgZmlyc3RTb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGZpcnN0IGFyZ3VtZW50IHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBuZXh0U291cmNlID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICBmb3IgKHZhciBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCsrKSB7XG4gICAgICB2YXIgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICBpZiAoIU9iamVjdC5hc3NpZ24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhc3NpZ25cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXNzaWduOiBhc3NpZ24sXG4gIHBvbHlmaWxsOiBwb2x5ZmlsbFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTYxNyk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm9yRWFjaEFycmF5ID0gZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaFN0cmluZyA9IGZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlcmF0b3Ioc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaE9iamVjdCA9IGZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgb2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjZWl2ZXI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICByZWNlaXZlciA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgaWYgKHRvU3RyLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg3OTQ6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG52YXIgY29uY2F0dHkgPSBmdW5jdGlvbiBjb25jYXR0eShhLCBiKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBhcnJbaiArIGEubGVuZ3RoXSA9IGJbal07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBzbGljeSA9IGZ1bmN0aW9uIHNsaWN5KGFyckxpa2UsIG9mZnNldCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0IHx8IDAsIGogPSAwOyBpIDwgYXJyTGlrZS5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICAgIGFycltqXSA9IGFyckxpa2VbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgam9pbnkgPSBmdW5jdGlvbiAoYXJyLCBqb2luZXIpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGFycltpXTtcbiAgICAgICAgaWYgKGkgKyAxIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyICs9IGpvaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5hcHBseSh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWN5KGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgKTtcblxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJnc1tpXSA9ICckJyArIGk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGpvaW55KGJvdW5kQXJncywgJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MTM4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3OTQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Mjg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MzgpO1xudmFyICRFdmFsRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MjkpO1xudmFyICRSYW5nZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTU1KTtcbnZhciAkUmVmZXJlbmNlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NDMpO1xudmFyICRTeW50YXhFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTczMSk7XG52YXIgJFR5cGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2OCk7XG52YXIgJFVSSUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTQwKTtcblxudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTU4KSgpO1xudmFyIGhhc1Byb3RvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODY5KSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgKFxuXHRoYXNQcm90b1xuXHRcdD8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblx0XHQ6IG51bGxcbik7XG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6ICRFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiAkRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6ICRSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6ICRSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogJFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG5pZiAoZ2V0UHJvdG8pIHtcblx0dHJ5IHtcblx0XHRudWxsLmVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc2hhZG93cmVhbG0vcHVsbC8zODQjaXNzdWVjb21tZW50LTEzNjQyNjQyMjlcblx0XHR2YXIgZXJyb3JQcm90byA9IGdldFByb3RvKGdldFByb3RvKGUpKTtcblx0XHRJTlRSSU5TSUNTWyclRXJyb3IucHJvdG90eXBlJSddID0gZXJyb3JQcm90bztcblx0fVxufVxuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuICYmIGdldFByb3RvKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEzOCk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTU0KTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzMzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5cbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcyMzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NDApO1xuXG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMoKSB7XG5cdHJldHVybiAhISRkZWZpbmVQcm9wZXJ0eTtcbn07XG5cbmhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcblx0Ly8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG5cdGlmICghJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gJGRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJbiBGaXJlZm94IDQtMjIsIGRlZmluaW5nIGxlbmd0aCBvbiBhbiBhcnJheSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4Njk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdGVzdCA9IHtcblx0Zm9vOiB7fVxufTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzUHJvdG8oKSB7XG5cdHJldHVybiB7IF9fcHJvdG9fXzogdGVzdCB9LmZvbyA9PT0gdGVzdC5mb28gJiYgISh7IF9fcHJvdG9fXzogbnVsbCB9IGluc3RhbmNlb2YgJE9iamVjdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNTU4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjkwODpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTkxMzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MDgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NTU0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xudmFyICRoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMzgpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoY2FsbCwgJGhhc093bik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU2MTU6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzODc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMykoKTtcbnZhciBjYWxsQm91bmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MTgpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NjE3OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcmVmbGVjdEFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QgIT09IG51bGwgJiYgUmVmbGVjdC5hcHBseTtcbnZhciBiYWRBcnJheUxpa2U7XG52YXIgaXNDYWxsYWJsZU1hcmtlcjtcbmlmICh0eXBlb2YgcmVmbGVjdEFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcblx0dHJ5IHtcblx0XHRiYWRBcnJheUxpa2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdsZW5ndGgnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgaXNDYWxsYWJsZU1hcmtlcjtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpc0NhbGxhYmxlTWFya2VyID0ge307XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblx0XHRyZWZsZWN0QXBwbHkoZnVuY3Rpb24gKCkgeyB0aHJvdyA0MjsgfSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0fSBjYXRjaCAoXykge1xuXHRcdGlmIChfICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkgPSBudWxsO1xuXHRcdH1cblx0fVxufSBlbHNlIHtcblx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcbn1cblxudmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzc1xcYi87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KGZuU3RyKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm90IGEgZnVuY3Rpb25cblx0fVxufTtcblxudmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25Ub1N0cih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGRkYUNsYXNzID0gJ1tvYmplY3QgSFRNTEFsbENvbGxlY3Rpb25dJzsgLy8gSUUgMTFcbnZhciBkZGFDbGFzczIgPSAnW29iamVjdCBIVE1MIGRvY3VtZW50LmFsbCBjbGFzc10nO1xudmFyIGRkYUNsYXNzMyA9ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc7IC8vIElFIDktMTBcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7IC8vIGJldHRlcjogdXNlIGBoYXMtdG9zdHJpbmd0YWdgXG5cbnZhciBpc0lFNjggPSAhKDAgaW4gWyxdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zcGFyc2UtYXJyYXlzLCBjb21tYS1zcGFjaW5nXG5cbnZhciBpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwoKSB7IHJldHVybiBmYWxzZTsgfTtcbmlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSB7XG5cdC8vIEZpcmVmb3ggMyBjYW5vbmljYWxpemVzIEREQSB0byB1bmRlZmluZWQgd2hlbiBpdCdzIG5vdCBhY2Nlc3NlZCBkaXJlY3RseVxuXHR2YXIgYWxsID0gZG9jdW1lbnQuYWxsO1xuXHRpZiAodG9TdHIuY2FsbChhbGwpID09PSB0b1N0ci5jYWxsKGRvY3VtZW50LmFsbCkpIHtcblx0XHRpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwodmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbHMgZG9jdW1lbnQ6IGZhbHNlICovXG5cdFx0XHQvLyBpbiBJRSA2LTgsIHR5cGVvZiBkb2N1bWVudC5hbGwgaXMgXCJvYmplY3RcIiBhbmQgaXQncyB0cnV0aHlcblx0XHRcdGlmICgoaXNJRTY4IHx8ICF2YWx1ZSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdHN0ciA9PT0gZGRhQ2xhc3Ncblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MyXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMyAvLyBvcGVyYSAxMi4xNlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBvYmplY3RDbGFzcyAvLyBJRSA2LThcblx0XHRcdFx0XHQpICYmIHZhbHVlKCcnKSA9PSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWZsZWN0QXBwbHlcblx0PyBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkodmFsdWUsIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKGUgIT09IGlzQ2FsbGFibGVNYXJrZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiAhaXNFUzZDbGFzc0ZuKHZhbHVlKSAmJiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH1cblx0OiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHN0ckNsYXNzICE9PSBmbkNsYXNzICYmIHN0ckNsYXNzICE9PSBnZW5DbGFzcyAmJiAhKC9eXFxbb2JqZWN0IEhUTUwvKS50ZXN0KHN0ckNsYXNzKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRyZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjI1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MTMpKCk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24qKCkge30nKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn07XG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwMDY6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc4Mzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODU3KTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDA2KTtcbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTU5MSk7XG52YXIgc2hpbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTY0MSk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE51bWJlcik7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU5MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDA2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0aWYgKE51bWJlci5pc05hTiAmJiBOdW1iZXIuaXNOYU4oTmFOKSAmJiAhTnVtYmVyLmlzTmFOKCdhJykpIHtcblx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOO1xuXHR9XG5cdHJldHVybiBpbXBsZW1lbnRhdGlvbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE2NDE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkxKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1OdW1iZXJJc05hTigpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE51bWJlciwgeyBpc05hTjogcG9seWZpbGwgfSwge1xuXHRcdGlzTmFOOiBmdW5jdGlvbiB0ZXN0SXNOYU4oKSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyLmlzTmFOICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTQzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgd2hpY2hUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzMwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0cmV0dXJuICEhd2hpY2hUeXBlZEFycmF5KHZhbHVlKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBtb2R1bGUgZGVjb3JhdG9yICovIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18ubm1kKG1vZHVsZSk7XG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBnbG9iYWwgZXhwb3J0czp0cnVlLCBtb2R1bGU6dHJ1ZSwgcmVxdWlyZTp0cnVlLCBkZWZpbmU6dHJ1ZSwgZ2xvYmFsOnRydWUgKi9cblxuKGZ1bmN0aW9uIChyb290LCBuYW1lLCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogdHJ1ZVxuICAgICAgLCAnb2JqZWN0JzogdHJ1ZVxuICAgIH1cbiAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2BcbiAgICAsIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0c1xuICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG4gICAgLCBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbXCJvYmplY3RcIl0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlXG4gICAgLy8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSwgYW5kXG4gICAgLy8gdXNlIGl0IGFzIGB3aW5kb3dgXG4gICAgLCBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nID09PSAnb2JqZWN0JyAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fLmdcbiAgICAvLyBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2BcbiAgICAsIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG4gICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uXG4gIC8vIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0cnVlKSB7XG4gICAgLy8gZGVmaW5lZCBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxuXHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gICAgLy8gSW4gY2FzZSB0aGUgc291cmNlIGhhcyBiZWVuIHByb2Nlc3NlZCBhbmQgd3JhcHBlZCBpbiBhIGRlZmluZSBtb2R1bGUgdXNlXG4gICAgLy8gdGhlIHN1cHBsaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gICAgaWYgKGZyZWVFeHBvcnRzICYmIG1vZHVsZUV4cG9ydHMpIGZhY3RvcnkoZnJlZU1vZHVsZS5leHBvcnRzKTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhblxuICAvLyBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi8ge31cbn0odGhpcywgJ2x1YXBhcnNlJywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGV4cG9ydHMudmVyc2lvbiA9IFwiMC4zLjFcIjtcblxuICB2YXIgaW5wdXQsIG9wdGlvbnMsIGxlbmd0aCwgZmVhdHVyZXMsIGVuY29kaW5nTW9kZTtcblxuICAvLyBPcHRpb25zIGNhbiBiZSBzZXQgZWl0aGVyIGdsb2JhbGx5IG9uIHRoZSBwYXJzZXIgb2JqZWN0IHRocm91Z2hcbiAgLy8gZGVmYXVsdE9wdGlvbnMsIG9yIGR1cmluZyB0aGUgcGFyc2UgY2FsbC5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBFeHBsaWNpdGx5IHRlbGwgdGhlIHBhcnNlciB3aGVuIHRoZSBpbnB1dCBlbmRzLlxuICAgICAgd2FpdDogZmFsc2VcbiAgICAvLyBTdG9yZSBjb21tZW50cyBhcyBhbiBhcnJheSBpbiB0aGUgY2h1bmsgb2JqZWN0LlxuICAgICwgY29tbWVudHM6IHRydWVcbiAgICAvLyBUcmFjayBpZGVudGlmaWVyIHNjb3BlcyBieSBhZGRpbmcgYW4gaXNMb2NhbCBhdHRyaWJ1dGUgdG8gZWFjaFxuICAgIC8vIGlkZW50aWZpZXItbm9kZS5cbiAgICAsIHNjb3BlOiBmYWxzZVxuICAgIC8vIFN0b3JlIGxvY2F0aW9uIGluZm9ybWF0aW9uIG9uIGVhY2ggc3ludGF4IG5vZGUgYXNcbiAgICAvLyBgbG9jOiB7IHN0YXJ0OiB7IGxpbmUsIGNvbHVtbiB9LCBlbmQ6IHsgbGluZSwgY29sdW1uIH0gfWAuXG4gICAgLCBsb2NhdGlvbnM6IGZhbHNlXG4gICAgLy8gU3RvcmUgdGhlIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVyIGxvY2F0aW9ucyBvbiBlYWNoIHN5bnRheCBub2RlIGFzXG4gICAgLy8gYHJhbmdlOiBbc3RhcnQsIGVuZF1gLlxuICAgICwgcmFuZ2VzOiBmYWxzZVxuICAgIC8vIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBzeW50YXggbm9kZSBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgLy8gVGhlIG5vZGUgd2hpY2ggaGFzIGJlZW4gY3JlYXRlZCB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIuXG4gICAgLCBvbkNyZWF0ZU5vZGU6IG51bGxcbiAgICAvLyBBIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgbmV3IHNjb3BlIGlzIGNyZWF0ZWQuXG4gICAgLCBvbkNyZWF0ZVNjb3BlOiBudWxsXG4gICAgLy8gQSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgY3VycmVudCBzY29wZSBpcyBkZXN0cm95ZWQuXG4gICAgLCBvbkRlc3Ryb3lTY29wZTogbnVsbFxuICAgIC8vIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBsb2NhbCB2YXJpYWJsZSBpcyBkZWNsYXJlZCBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICAvLyBUaGUgdmFyaWFibGUncyBuYW1lIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlclxuICAgICwgb25Mb2NhbERlY2xhcmF0aW9uOiBudWxsXG4gICAgLy8gVGhlIHZlcnNpb24gb2YgTHVhIHRhcmdldGVkIGJ5IHRoZSBwYXJzZXIgKHN0cmluZzsgYWxsb3dlZCB2YWx1ZXMgYXJlXG4gICAgLy8gJzUuMScsICc1LjInLCAnNS4zJykuXG4gICAgLCBsdWFWZXJzaW9uOiAnNS4xJ1xuICAgIC8vIEVuY29kaW5nIG1vZGU6IGhvdyB0byBpbnRlcnByZXQgY29kZSB1bml0cyBoaWdoZXIgdGhhbiBVKzAwN0YgaW4gaW5wdXRcbiAgICAsIGVuY29kaW5nTW9kZTogJ25vbmUnXG4gIH07XG5cbiAgZnVuY3Rpb24gZW5jb2RlVVRGOChjb2RlcG9pbnQsIGhpZ2hNYXNrKSB7XG4gICAgaGlnaE1hc2sgPSBoaWdoTWFzayB8fCAwO1xuXG4gICAgaWYgKGNvZGVwb2ludCA8IDB4ODApIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVwb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlcG9pbnQgPCAweDgwMCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIGhpZ2hNYXNrIHwgMHhjMCB8ICAoY29kZXBvaW50ID4+ICA2KSAgICAgICAgLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoIGNvZGVwb2ludCAgICAgICAgJiAweDNmKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVwb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICBoaWdoTWFzayB8IDB4ZTAgfCAgKGNvZGVwb2ludCA+PiAxMikgICAgICAgICxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKChjb2RlcG9pbnQgPj4gIDYpICYgMHgzZiksXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICggY29kZXBvaW50ICAgICAgICAmIDB4M2YpXG4gICAgICApO1xuICAgIH0gZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAoY29kZXBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICBoaWdoTWFzayB8IDB4ZjAgfCAgKGNvZGVwb2ludCA+PiAxOCkgICAgICAgICxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKChjb2RlcG9pbnQgPj4gMTIpICYgMHgzZiksXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICgoY29kZXBvaW50ID4+ICA2KSAmIDB4M2YpLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoIGNvZGVwb2ludCAgICAgICAgJiAweDNmKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogTHVhIDUuNCBhbGxvd3MgdXAgdG8gc2l4LWJ5dGUgc2VxdWVuY2VzLCBhcyBpbiBVVEYtODoxOTkzXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b0hleChudW0sIGRpZ2l0cykge1xuICAgIHZhciByZXN1bHQgPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgZGlnaXRzKVxuICAgICAgcmVzdWx0ID0gJzAnICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NoYXJzKHJ4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzKSB7XG4gICAgICB2YXIgbSA9IHJ4LmV4ZWMocyk7XG4gICAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmludmFsaWRDb2RlVW5pdCwgdG9IZXgobVswXS5jaGFyQ29kZUF0KDApLCA0KS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGVuY29kaW5nTW9kZXMgPSB7XG4gICAgLy8gYHBzZXVkby1sYXRpbjFgIGVuY29kaW5nIG1vZGU6IGFzc3VtZSB0aGUgaW5wdXQgd2FzIGRlY29kZWQgd2l0aCB0aGUgbGF0aW4xIGVuY29kaW5nXG4gICAgLy8gV0FSTklORzogbGF0aW4xIGRvZXMgKipOT1QqKiBtZWFuIGNwMTI1MiBoZXJlIGxpa2UgaW4gdGhlIGJvbmUtaGVhZGVkIFdIQVRXRyBzdGFuZGFyZDtcbiAgICAvLyBpdCBtZWFucyB0cnVlIElTTy9JRUMgODg1OS0xIGlkZW50aXR5LW1hcHBlZCB0byBCYXNpYyBMYXRpbiBhbmQgTGF0aW4tMSBTdXBwbGVtZW50IGJsb2Nrc1xuICAgICdwc2V1ZG8tbGF0aW4xJzoge1xuICAgICAgZml4dXA6IGNoZWNrQ2hhcnMoL1teXFx4MDAtXFx4ZmZdLyksXG4gICAgICBlbmNvZGVCeXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGVuY29kZVVURjg6IGZ1bmN0aW9uIChjb2RlcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVURjgoY29kZXBvaW50KTtcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIC8vIGB4LXVzZXItZGVmaW5lZGAgZW5jb2RpbmcgbW9kZTogYXNzdW1lIHRoZSBpbnB1dCB3YXMgZGVjb2RlZCB3aXRoIHRoZSBXSEFUV0cgYHgtdXNlci1kZWZpbmVkYCBlbmNvZGluZ1xuICAgICd4LXVzZXItZGVmaW5lZCc6IHtcbiAgICAgIGZpeHVwOiBjaGVja0NoYXJzKC9bXlxceDAwLVxceDdmXFx1Zjc4MC1cXHVmN2ZmXS8pLFxuICAgICAgZW5jb2RlQnl0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweDgwKVxuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlIHwgMHhmNzAwKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGVuY29kZVVURjg6IGZ1bmN0aW9uIChjb2RlcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVURjgoY29kZXBvaW50LCAweGY3MDApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBgbm9uZWAgZW5jb2RpbmcgbW9kZTogZGlzcmVnYXJkIGludHJlcHJldGF0aW9uIG9mIHN0cmluZyBsaXRlcmFscywgbGVhdmUgaWRlbnRpZmllcnMgYXMtaXNcbiAgICAnbm9uZSc6IHtcbiAgICAgIGRpc2NhcmRTdHJpbmdzOiB0cnVlLFxuICAgICAgZml4dXA6IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSxcbiAgICAgIGVuY29kZUJ5dGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9LFxuICAgICAgZW5jb2RlVVRGODogZnVuY3Rpb24gKGNvZGVwb2ludCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBhdmFpbGFibGUgdG9rZW5zIGV4cHJlc3NlZCBhcyBlbnVtIGZsYWdzIHNvIHRoZXkgY2FuIGJlIGNoZWNrZWQgd2l0aFxuICAvLyBiaXR3aXNlIG9wZXJhdGlvbnMuXG5cbiAgdmFyIEVPRiA9IDEsIFN0cmluZ0xpdGVyYWwgPSAyLCBLZXl3b3JkID0gNCwgSWRlbnRpZmllciA9IDhcbiAgICAsIE51bWVyaWNMaXRlcmFsID0gMTYsIFB1bmN0dWF0b3IgPSAzMiwgQm9vbGVhbkxpdGVyYWwgPSA2NFxuICAgICwgTmlsTGl0ZXJhbCA9IDEyOCwgVmFyYXJnTGl0ZXJhbCA9IDI1NjtcblxuICBleHBvcnRzLnRva2VuVHlwZXMgPSB7IEVPRjogRU9GLCBTdHJpbmdMaXRlcmFsOiBTdHJpbmdMaXRlcmFsXG4gICAgLCBLZXl3b3JkOiBLZXl3b3JkLCBJZGVudGlmaWVyOiBJZGVudGlmaWVyLCBOdW1lcmljTGl0ZXJhbDogTnVtZXJpY0xpdGVyYWxcbiAgICAsIFB1bmN0dWF0b3I6IFB1bmN0dWF0b3IsIEJvb2xlYW5MaXRlcmFsOiBCb29sZWFuTGl0ZXJhbFxuICAgICwgTmlsTGl0ZXJhbDogTmlsTGl0ZXJhbCwgVmFyYXJnTGl0ZXJhbDogVmFyYXJnTGl0ZXJhbFxuICB9O1xuXG4gIC8vIEFzIHRoaXMgcGFyc2VyIGlzIGEgYml0IGRpZmZlcmVudCBmcm9tIGx1YXMgb3duLCB0aGUgZXJyb3IgbWVzc2FnZXNcbiAgLy8gd2lsbCBiZSBkaWZmZXJlbnQgaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gIHZhciBlcnJvcnMgPSBleHBvcnRzLmVycm9ycyA9IHtcbiAgICAgIHVuZXhwZWN0ZWQ6ICd1bmV4cGVjdGVkICUxIFxcJyUyXFwnIG5lYXIgXFwnJTNcXCcnXG4gICAgLCB1bmV4cGVjdGVkRU9GOiAndW5leHBlY3RlZCBzeW1ib2wgbmVhciBcXCc8ZW9mPlxcJydcbiAgICAsIGV4cGVjdGVkOiAnXFwnJTFcXCcgZXhwZWN0ZWQgbmVhciBcXCclMlxcJydcbiAgICAsIGV4cGVjdGVkVG9rZW46ICclMSBleHBlY3RlZCBuZWFyIFxcJyUyXFwnJ1xuICAgICwgdW5maW5pc2hlZFN0cmluZzogJ3VuZmluaXNoZWQgc3RyaW5nIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBtYWxmb3JtZWROdW1iZXI6ICdtYWxmb3JtZWQgbnVtYmVyIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBkZWNpbWFsRXNjYXBlVG9vTGFyZ2U6ICdkZWNpbWFsIGVzY2FwZSB0b28gbGFyZ2UgbmVhciBcXCclMVxcJydcbiAgICAsIGludmFsaWRFc2NhcGU6ICdpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBuZWFyIFxcJyUxXFwnJ1xuICAgICwgaGV4YWRlY2ltYWxEaWdpdEV4cGVjdGVkOiAnaGV4YWRlY2ltYWwgZGlnaXQgZXhwZWN0ZWQgbmVhciBcXCclMVxcJydcbiAgICAsIGJyYWNlRXhwZWN0ZWQ6ICdtaXNzaW5nIFxcJyUxXFwnIG5lYXIgXFwnJTJcXCcnXG4gICAgLCB0b29MYXJnZUNvZGVwb2ludDogJ1VURi04IHZhbHVlIHRvbyBsYXJnZSBuZWFyIFxcJyUxXFwnJ1xuICAgICwgdW5maW5pc2hlZExvbmdTdHJpbmc6ICd1bmZpbmlzaGVkIGxvbmcgc3RyaW5nIChzdGFydGluZyBhdCBsaW5lICUxKSBuZWFyIFxcJyUyXFwnJ1xuICAgICwgdW5maW5pc2hlZExvbmdDb21tZW50OiAndW5maW5pc2hlZCBsb25nIGNvbW1lbnQgKHN0YXJ0aW5nIGF0IGxpbmUgJTEpIG5lYXIgXFwnJTJcXCcnXG4gICAgLCBhbWJpZ3VvdXNTeW50YXg6ICdhbWJpZ3VvdXMgc3ludGF4IChmdW5jdGlvbiBjYWxsIHggbmV3IHN0YXRlbWVudCkgbmVhciBcXCclMVxcJydcbiAgICAsIG5vTG9vcFRvQnJlYWs6ICdubyBsb29wIHRvIGJyZWFrIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBsYWJlbEFscmVhZHlEZWZpbmVkOiAnbGFiZWwgXFwnJTFcXCcgYWxyZWFkeSBkZWZpbmVkIG9uIGxpbmUgJTInXG4gICAgLCBsYWJlbE5vdFZpc2libGU6ICdubyB2aXNpYmxlIGxhYmVsIFxcJyUxXFwnIGZvciA8Z290bz4nXG4gICAgLCBnb3RvSnVtcEluTG9jYWxTY29wZTogJzxnb3RvICUxPiBqdW1wcyBpbnRvIHRoZSBzY29wZSBvZiBsb2NhbCBcXCclMlxcJydcbiAgICAsIGNhbm5vdFVzZVZhcmFyZzogJ2Nhbm5vdCB1c2UgXFwnLi4uXFwnIG91dHNpZGUgYSB2YXJhcmcgZnVuY3Rpb24gbmVhciBcXCclMVxcJydcbiAgICAsIGludmFsaWRDb2RlVW5pdDogJ2NvZGUgdW5pdCBVKyUxIGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGVuY29kaW5nIG1vZGUnXG4gIH07XG5cbiAgLy8gIyMjIEFic3RyYWN0IFN5bnRheCBUcmVlXG4gIC8vXG4gIC8vIFRoZSBkZWZhdWx0IEFTVCBzdHJ1Y3R1cmUgaXMgaW5zcGlyZWQgYnkgdGhlIE1vemlsbGEgUGFyc2VyIEFQSSBidXQgY2FuXG4gIC8vIGVhc2lseSBiZSBjdXN0b21pemVkIGJ5IG92ZXJyaWRpbmcgdGhlc2UgZnVuY3Rpb25zLlxuXG4gIHZhciBhc3QgPSBleHBvcnRzLmFzdCA9IHtcbiAgICAgIGxhYmVsU3RhdGVtZW50OiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnTGFiZWxTdGF0ZW1lbnQnXG4gICAgICAgICwgbGFiZWw6IGxhYmVsXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgYnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQnJlYWtTdGF0ZW1lbnQnXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgZ290b1N0YXRlbWVudDogZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0dvdG9TdGF0ZW1lbnQnXG4gICAgICAgICwgbGFiZWw6IGxhYmVsXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgcmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdSZXR1cm5TdGF0ZW1lbnQnXG4gICAgICAgICwgJ2FyZ3VtZW50cyc6IGFyZ3NcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBpZlN0YXRlbWVudDogZnVuY3Rpb24oY2xhdXNlcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnSWZTdGF0ZW1lbnQnXG4gICAgICAgICwgY2xhdXNlczogY2xhdXNlc1xuICAgICAgfTtcbiAgICB9XG4gICAgLCBpZkNsYXVzZTogZnVuY3Rpb24oY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdJZkNsYXVzZSdcbiAgICAgICAgLCBjb25kaXRpb246IGNvbmRpdGlvblxuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuICAgICwgZWxzZWlmQ2xhdXNlOiBmdW5jdGlvbihjb25kaXRpb24sIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0Vsc2VpZkNsYXVzZSdcbiAgICAgICAgLCBjb25kaXRpb246IGNvbmRpdGlvblxuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuICAgICwgZWxzZUNsYXVzZTogZnVuY3Rpb24oYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRWxzZUNsYXVzZSdcbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgd2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnV2hpbGVTdGF0ZW1lbnQnXG4gICAgICAgICwgY29uZGl0aW9uOiBjb25kaXRpb25cbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgZG9TdGF0ZW1lbnQ6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0RvU3RhdGVtZW50J1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCByZXBlYXRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnUmVwZWF0U3RhdGVtZW50J1xuICAgICAgICAsIGNvbmRpdGlvbjogY29uZGl0aW9uXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGxvY2FsU3RhdGVtZW50OiBmdW5jdGlvbih2YXJpYWJsZXMsIGluaXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0xvY2FsU3RhdGVtZW50J1xuICAgICAgICAsIHZhcmlhYmxlczogdmFyaWFibGVzXG4gICAgICAgICwgaW5pdDogaW5pdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGFzc2lnbm1lbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHZhcmlhYmxlcywgaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQXNzaWdubWVudFN0YXRlbWVudCdcbiAgICAgICAgLCB2YXJpYWJsZXM6IHZhcmlhYmxlc1xuICAgICAgICAsIGluaXQ6IGluaXRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBjYWxsU3RhdGVtZW50OiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdDYWxsU3RhdGVtZW50J1xuICAgICAgICAsIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBmdW5jdGlvblN0YXRlbWVudDogZnVuY3Rpb24oaWRlbnRpZmllciwgcGFyYW1ldGVycywgaXNMb2NhbCwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRnVuY3Rpb25EZWNsYXJhdGlvbidcbiAgICAgICAgLCBpZGVudGlmaWVyOiBpZGVudGlmaWVyXG4gICAgICAgICwgaXNMb2NhbDogaXNMb2NhbFxuICAgICAgICAsIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgZm9yTnVtZXJpY1N0YXRlbWVudDogZnVuY3Rpb24odmFyaWFibGUsIHN0YXJ0LCBlbmQsIHN0ZXAsIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0Zvck51bWVyaWNTdGF0ZW1lbnQnXG4gICAgICAgICwgdmFyaWFibGU6IHZhcmlhYmxlXG4gICAgICAgICwgc3RhcnQ6IHN0YXJ0XG4gICAgICAgICwgZW5kOiBlbmRcbiAgICAgICAgLCBzdGVwOiBzdGVwXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGZvckdlbmVyaWNTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHZhcmlhYmxlcywgaXRlcmF0b3JzLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdGb3JHZW5lcmljU3RhdGVtZW50J1xuICAgICAgICAsIHZhcmlhYmxlczogdmFyaWFibGVzXG4gICAgICAgICwgaXRlcmF0b3JzOiBpdGVyYXRvcnNcbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgY2h1bms6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0NodW5rJ1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBpZGVudGlmaWVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJ1xuICAgICAgICAsIG5hbWU6IG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBsaXRlcmFsOiBmdW5jdGlvbih0eXBlLCB2YWx1ZSwgcmF3KSB7XG4gICAgICB0eXBlID0gKHR5cGUgPT09IFN0cmluZ0xpdGVyYWwpID8gJ1N0cmluZ0xpdGVyYWwnXG4gICAgICAgIDogKHR5cGUgPT09IE51bWVyaWNMaXRlcmFsKSA/ICdOdW1lcmljTGl0ZXJhbCdcbiAgICAgICAgOiAodHlwZSA9PT0gQm9vbGVhbkxpdGVyYWwpID8gJ0Jvb2xlYW5MaXRlcmFsJ1xuICAgICAgICA6ICh0eXBlID09PSBOaWxMaXRlcmFsKSA/ICdOaWxMaXRlcmFsJ1xuICAgICAgICA6ICdWYXJhcmdMaXRlcmFsJztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICAgICwgcmF3OiByYXdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCB0YWJsZUtleTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVGFibGVLZXknXG4gICAgICAgICwga2V5OiBrZXlcbiAgICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgICwgdGFibGVLZXlTdHJpbmc6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1RhYmxlS2V5U3RyaW5nJ1xuICAgICAgICAsIGtleToga2V5XG4gICAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICAsIHRhYmxlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdUYWJsZVZhbHVlJ1xuICAgICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG5cblxuICAgICwgdGFibGVDb25zdHJ1Y3RvckV4cHJlc3Npb246IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVGFibGVDb25zdHJ1Y3RvckV4cHJlc3Npb24nXG4gICAgICAgICwgZmllbGRzOiBmaWVsZHNcbiAgICAgIH07XG4gICAgfVxuICAgICwgYmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgdHlwZSA9ICgnYW5kJyA9PT0gb3BlcmF0b3IgfHwgJ29yJyA9PT0gb3BlcmF0b3IpID9cbiAgICAgICAgJ0xvZ2ljYWxFeHByZXNzaW9uJyA6XG4gICAgICAgICdCaW5hcnlFeHByZXNzaW9uJztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgICAgICwgbGVmdDogbGVmdFxuICAgICAgICAsIHJpZ2h0OiByaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgLCB1bmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVW5hcnlFeHByZXNzaW9uJ1xuICAgICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgICAgICAsIGFyZ3VtZW50OiBhcmd1bWVudFxuICAgICAgfTtcbiAgICB9XG4gICAgLCBtZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbihiYXNlLCBpbmRleGVyLCBpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJ1xuICAgICAgICAsIGluZGV4ZXI6IGluZGV4ZXJcbiAgICAgICAgLCBpZGVudGlmaWVyOiBpZGVudGlmaWVyXG4gICAgICAgICwgYmFzZTogYmFzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGluZGV4RXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0luZGV4RXhwcmVzc2lvbidcbiAgICAgICAgLCBiYXNlOiBiYXNlXG4gICAgICAgICwgaW5kZXg6IGluZGV4XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgY2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uKGJhc2UsIGFyZ3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0NhbGxFeHByZXNzaW9uJ1xuICAgICAgICAsIGJhc2U6IGJhc2VcbiAgICAgICAgLCAnYXJndW1lbnRzJzogYXJnc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHRhYmxlQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uKGJhc2UsIGFyZ3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1RhYmxlQ2FsbEV4cHJlc3Npb24nXG4gICAgICAgICwgYmFzZTogYmFzZVxuICAgICAgICAsICdhcmd1bWVudHMnOiBhcmdzXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgc3RyaW5nQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uKGJhc2UsIGFyZ3VtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdTdHJpbmdDYWxsRXhwcmVzc2lvbidcbiAgICAgICAgLCBiYXNlOiBiYXNlXG4gICAgICAgICwgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgY29tbWVudDogZnVuY3Rpb24odmFsdWUsIHJhdykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQ29tbWVudCdcbiAgICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgICAgLCByYXc6IHJhd1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gV3JhcCB1cCB0aGUgbm9kZSBvYmplY3QuXG5cbiAgZnVuY3Rpb24gZmluaXNoTm9kZShub2RlKSB7XG4gICAgLy8gUG9wIGEgYE1hcmtlcmAgb2ZmIHRoZSBsb2NhdGlvbi1hcnJheSBhbmQgYXR0YWNoIGl0cyBsb2NhdGlvbiBkYXRhLlxuICAgIGlmICh0cmFja0xvY2F0aW9ucykge1xuICAgICAgdmFyIGxvY2F0aW9uID0gbG9jYXRpb25zLnBvcCgpO1xuICAgICAgbG9jYXRpb24uY29tcGxldGUoKTtcbiAgICAgIGxvY2F0aW9uLmJsZXNzKG5vZGUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vbkNyZWF0ZU5vZGUpIG9wdGlvbnMub25DcmVhdGVOb2RlKG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cblxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tLS1cblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAsIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgIDtcblxuICB2YXIgaW5kZXhPZiA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChhcnJheSwgZWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGFycmF5W2ldID09PSBlbGVtZW50KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZilcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtZW50KTtcbiAgICB9O1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGFuIG9iamVjdFxuICAvLyB3aXRoIGEgbWF0Y2hpbmcgcHJvcGVydHkuXG5cbiAgZnVuY3Rpb24gaW5kZXhPZk9iamVjdChhcnJheSwgcHJvcGVydHksIGVsZW1lbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChhcnJheVtpXVtwcm9wZXJ0eV0gPT09IGVsZW1lbnQpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBBIHNwcmludGYgaW1wbGVtZW50YXRpb24gdXNpbmcgJWluZGV4IChiZWdpbm5pbmcgYXQgMSkgdG8gaW5wdXRcbiAgLy8gYXJndW1lbnRzIGluIHRoZSBmb3JtYXQgc3RyaW5nLlxuICAvL1xuICAvLyBFeGFtcGxlOlxuICAvL1xuICAvLyAgICAgLy8gVW5leHBlY3RlZCBmdW5jdGlvbiBpbiB0b2tlblxuICAvLyAgICAgc3ByaW50ZignVW5leHBlY3RlZCAlMiBpbiAlMS4nLCAndG9rZW4nLCAnZnVuY3Rpb24nKTtcblxuICBmdW5jdGlvbiBzcHJpbnRmKGZvcm1hdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKG1hdGNoLCBpbmRleCkge1xuICAgICAgcmV0dXJuICcnICsgYXJnc1tpbmRleCAtIDFdIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovICcnO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICAvLyBQb2x5ZmlsbCBmb3IgYE9iamVjdC5hc3NpZ25gLlxuXG4gIHZhciBhc3NpZ24gPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZGVzdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAsIHNyYywgcHJvcDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBzcmMgPSBhcmdzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNyYylcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHByb3ApKSB7XG4gICAgICAgICAgZGVzdFtwcm9wXSA9IHNyY1twcm9wXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0O1xuICB9O1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChPYmplY3QuYXNzaWduKVxuICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbiAgLy8gIyMjIEVycm9yIGZ1bmN0aW9uc1xuXG4gIGV4cG9ydHMuU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcblxuICAvLyBYWFg6IEVsaW1pbmF0ZSB0aGlzIGZ1bmN0aW9uIGFuZCBjaGFuZ2UgdGhlIGVycm9yIHR5cGUgdG8gYmUgZGlmZmVyZW50IGZyb20gU3ludGF4RXJyb3IuXG4gIC8vIFRoaXMgd2lsbCB1bmZvcnR1bmF0ZWx5IGJlIGEgYnJlYWtpbmcgY2hhbmdlLCBiZWNhdXNlIHNvbWUgZG93bnN0cmVhbSB1c2VycyBkZXBlbmRcbiAgLy8gb24gdGhlIGVycm9yIHRocm93biBiZWluZyBhbiBpbnN0YW5jZSBvZiBTeW50YXhFcnJvci4gRm9yIGV4YW1wbGUsIHRoZSBBY2UgZWRpdG9yOlxuICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2FqYXhvcmcvYWNlL2Jsb2IvNGM3ZTVlYjNmNWQ1Y2E5NDM0ODQ3YmU1MTgzNGE0ZTQxNjYxYjg1Mi9saWIvYWNlL21vZGUvbHVhX3dvcmtlci5qcyNMNTU+XG5cbiAgZnVuY3Rpb24gZml4dXBFcnJvcihlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFPYmplY3QuY3JlYXRlKVxuICAgICAgcmV0dXJuIGU7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZSwge1xuICAgICAgJ2xpbmUnOiB7ICd3cml0YWJsZSc6IHRydWUsIHZhbHVlOiBlLmxpbmUgfSxcbiAgICAgICdpbmRleCc6IHsgJ3dyaXRhYmxlJzogdHJ1ZSwgdmFsdWU6IGUuaW5kZXggfSxcbiAgICAgICdjb2x1bW4nOiB7ICd3cml0YWJsZSc6IHRydWUsIHZhbHVlOiBlLmNvbHVtbiB9XG4gICAgfSk7XG4gIH1cblxuICAvLyAjIyMjIFJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgLy9cbiAgLy8gUmFpc2UgYW4gZXhjZXB0aW9uIGJ5IHBhc3NpbmcgYSB0b2tlbiwgYSBzdHJpbmcgZm9ybWF0IGFuZCBpdHMgcGFyYW10ZXJzLlxuICAvL1xuICAvLyBUaGUgcGFzc2VkIHRva2VucyBsb2NhdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgYWRkZWQgdG8gdGhlIGVycm9yXG4gIC8vIG1lc3NhZ2UgaWYgaXQgZXhpc3RzLCBpZiBub3QgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsZXhlcnMgY3VycmVudFxuICAvLyBwb3NpdGlvbi5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgIC8vIFsxOjBdIGV4cGVjdGVkIFsgbmVhciAoXG4gIC8vICAgICByYWlzZSh0b2tlbiwgXCJleHBlY3RlZCAlMSBuZWFyICUyXCIsICdbJywgdG9rZW4udmFsdWUpO1xuXG4gIGZ1bmN0aW9uIHJhaXNlKHRva2VuKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBzcHJpbnRmLmFwcGx5KG51bGwsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSlcbiAgICAgICwgZXJyb3IsIGNvbDtcblxuICAgIGlmICh0b2tlbiA9PT0gbnVsbCB8fCB0eXBlb2YgdG9rZW4ubGluZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbCA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIGVycm9yID0gZml4dXBFcnJvcihuZXcgU3ludGF4RXJyb3Ioc3ByaW50ZignWyUxOiUyXSAlMycsIGxpbmUsIGNvbCwgbWVzc2FnZSkpKTtcbiAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gICAgICBlcnJvci5saW5lID0gbGluZTtcbiAgICAgIGVycm9yLmNvbHVtbiA9IGNvbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sID0gdG9rZW4ucmFuZ2VbMF0gLSB0b2tlbi5saW5lU3RhcnQ7XG4gICAgICBlcnJvciA9IGZpeHVwRXJyb3IobmV3IFN5bnRheEVycm9yKHNwcmludGYoJ1slMTolMl0gJTMnLCB0b2tlbi5saW5lLCBjb2wsIG1lc3NhZ2UpKSk7XG4gICAgICBlcnJvci5saW5lID0gdG9rZW4ubGluZTtcbiAgICAgIGVycm9yLmluZGV4ID0gdG9rZW4ucmFuZ2VbMF07XG4gICAgICBlcnJvci5jb2x1bW4gPSBjb2w7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5WYWx1ZSh0b2tlbikge1xuICAgIHZhciByYXcgPSBpbnB1dC5zbGljZSh0b2tlbi5yYW5nZVswXSwgdG9rZW4ucmFuZ2VbMV0pO1xuICAgIGlmIChyYXcpXG4gICAgICByZXR1cm4gcmF3O1xuICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgfVxuXG4gIC8vICMjIyMgUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgIC8vIGV4cGVjdGVkIDxuYW1lPiBuZWFyICcwJ1xuICAvLyAgICAgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxuYW1lPicsIHRva2VuKTtcblxuICBmdW5jdGlvbiByYWlzZVVuZXhwZWN0ZWRUb2tlbih0eXBlLCB0b2tlbikge1xuICAgIHJhaXNlKHRva2VuLCBlcnJvcnMuZXhwZWN0ZWRUb2tlbiwgdHlwZSwgdG9rZW5WYWx1ZSh0b2tlbikpO1xuICB9XG5cbiAgLy8gIyMjIyBSYWlzZSBhIGdlbmVyYWwgdW5leHBlY3RlZCBlcnJvclxuICAvL1xuICAvLyBVc2FnZSBzaG91bGQgcGFzcyBlaXRoZXIgYSB0b2tlbiBvYmplY3Qgb3IgYSBzeW1ib2wgc3RyaW5nIHdoaWNoIHdhc1xuICAvLyBleHBlY3RlZC4gV2UgY2FuIGFsc28gc3BlY2lmeSBhIG5lYXJieSB0b2tlbiBzdWNoIGFzIDxlb2Y+LCB0aGlzIHdpbGxcbiAgLy8gZGVmYXVsdCB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSB0b2tlbi5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgIC8vIFVuZXhwZWN0ZWQgc3ltYm9sICdlbmQnIG5lYXIgJzxlb2Y+J1xuICAvLyAgICAgdW5leHBlY3RlZCh0b2tlbik7XG4gIC8vXG4gIC8vIElmIHRoZXJlJ3Mgbm8gdG9rZW4gaW4gdGhlIGJ1ZmZlciBpdCBtZWFucyB3ZSBoYXZlIHJlYWNoZWQgPGVvZj4uXG5cbiAgZnVuY3Rpb24gdW5leHBlY3RlZChmb3VuZCkge1xuICAgIHZhciBuZWFyID0gdG9rZW5WYWx1ZShsb29rYWhlYWQpO1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGZvdW5kLnR5cGUpIHtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgc3dpdGNoIChmb3VuZC50eXBlKSB7XG4gICAgICAgIGNhc2UgU3RyaW5nTGl0ZXJhbDogICB0eXBlID0gJ3N0cmluZyc7ICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2V5d29yZDogICAgICAgICB0eXBlID0gJ2tleXdvcmQnOyAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSWRlbnRpZmllcjogICAgICB0eXBlID0gJ2lkZW50aWZpZXInOyAgYnJlYWs7XG4gICAgICAgIGNhc2UgTnVtZXJpY0xpdGVyYWw6ICB0eXBlID0gJ251bWJlcic7ICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUHVuY3R1YXRvcjogICAgICB0eXBlID0gJ3N5bWJvbCc7ICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQm9vbGVhbkxpdGVyYWw6ICB0eXBlID0gJ2Jvb2xlYW4nOyAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTmlsTGl0ZXJhbDpcbiAgICAgICAgICByZXR1cm4gcmFpc2UoZm91bmQsIGVycm9ycy51bmV4cGVjdGVkLCAnc3ltYm9sJywgJ25pbCcsIG5lYXIpO1xuICAgICAgICBjYXNlIEVPRjpcbiAgICAgICAgICByZXR1cm4gcmFpc2UoZm91bmQsIGVycm9ycy51bmV4cGVjdGVkRU9GKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYWlzZShmb3VuZCwgZXJyb3JzLnVuZXhwZWN0ZWQsIHR5cGUsIHRva2VuVmFsdWUoZm91bmQpLCBuZWFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhaXNlKGZvdW5kLCBlcnJvcnMudW5leHBlY3RlZCwgJ3N5bWJvbCcsIGZvdW5kLCBuZWFyKTtcbiAgfVxuXG4gIC8vIExleGVyXG4gIC8vIC0tLS0tXG4gIC8vXG4gIC8vIFRoZSBsZXhlciwgb3IgdGhlIHRva2VuaXplciByZWFkcyB0aGUgaW5wdXQgc3RyaW5nIGNoYXJhY3RlciBieSBjaGFyYWN0ZXJcbiAgLy8gYW5kIGRlcml2ZXMgYSB0b2tlbiBsZWZ0LXJpZ2h0LiBUbyBiZSBhcyBlZmZpY2llbnQgYXMgcG9zc2libGUgdGhlIGxleGVyXG4gIC8vIHByaW9yaXRpemVzIHRoZSBjb21tb24gY2FzZXMgc3VjaCBhcyBpZGVudGlmaWVycy4gSXQgYWxzbyB3b3JrcyB3aXRoXG4gIC8vIGNoYXJhY3RlciBjb2RlcyBpbnN0ZWFkIG9mIGNoYXJhY3RlcnMgYXMgc3RyaW5nIGNvbXBhcmlzb25zIHdhcyB0aGVcbiAgLy8gYmlnZ2VzdCBib3R0bGVuZWNrIG9mIHRoZSBwYXJzZXIuXG4gIC8vXG4gIC8vIElmIGBvcHRpb25zLmNvbW1lbnRzYCBpcyBlbmFibGVkLCBhbGwgY29tbWVudHMgZW5jb3VudGVyZWQgd2lsbCBiZSBzdG9yZWRcbiAgLy8gaW4gYW4gYXJyYXkgd2hpY2ggbGF0ZXIgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgY2h1bmsgb2JqZWN0LiBJZiBkaXNhYmxlZCxcbiAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBkaXNyZWdhcmRlZC5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgbGV4ZXIgaGFzIGRlcml2ZWQgYSB2YWxpZCB0b2tlbiwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBvYmplY3RcbiAgLy8gY29udGFpbmluZyBpdHMgdmFsdWUgYW5kIGFzIHdlbGwgYXMgaXRzIHBvc2l0aW9uIGluIHRoZSBpbnB1dCBzdHJpbmcgKHRoaXNcbiAgLy8gaXMgYWx3YXlzIGVuYWJsZWQgdG8gcHJvdmlkZSBwcm9wZXIgZGVidWcgbWVzc2FnZXMpLlxuICAvL1xuICAvLyBgbGV4KClgIHN0YXJ0cyBsZXhpbmcgYW5kIHJldHVybnMgdGhlIGZvbGxvd2luZyB0b2tlbiBpbiB0aGUgc3RyZWFtLlxuXG4gIHZhciBpbmRleFxuICAgICwgdG9rZW5cbiAgICAsIHByZXZpb3VzVG9rZW5cbiAgICAsIGxvb2thaGVhZFxuICAgICwgY29tbWVudHNcbiAgICAsIHRva2VuU3RhcnRcbiAgICAsIGxpbmVcbiAgICAsIGxpbmVTdGFydDtcblxuICBleHBvcnRzLmxleCA9IGxleDtcblxuICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgc2tpcFdoaXRlU3BhY2UoKTtcblxuICAgIC8vIFNraXAgY29tbWVudHMgYmVnaW5uaW5nIHdpdGggLS1cbiAgICB3aGlsZSAoNDUgPT09IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpICYmXG4gICAgICAgICAgIDQ1ID09PSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMSkpIHtcbiAgICAgIHNjYW5Db21tZW50KCk7XG4gICAgICBza2lwV2hpdGVTcGFjZSgpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICB0eXBlIDogRU9GXG4gICAgICAsIHZhbHVlOiAnPGVvZj4nXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFtpbmRleCwgaW5kZXhdXG4gICAgfTtcblxuICAgIHZhciBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpXG4gICAgICAsIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICAvLyBNZW1vcml6ZSB0aGUgcmFuZ2UgaW5kZXggd2hlcmUgdGhlIHRva2VuIGJlZ2lucy5cbiAgICB0b2tlblN0YXJ0ID0gaW5kZXg7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoYXJDb2RlKSkgcmV0dXJuIHNjYW5JZGVudGlmaWVyT3JLZXl3b3JkKCk7XG5cbiAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICBjYXNlIDM5OiBjYXNlIDM0OiAvLyAnXCJcbiAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG5cbiAgICAgIGNhc2UgNDg6IGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6XG4gICAgICBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAwLTlcbiAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIDQ2OiAvLyAuXG4gICAgICAgIC8vIElmIHRoZSBkb3QgaXMgZm9sbG93ZWQgYnkgYSBkaWdpdCBpdCdzIGEgZmxvYXQuXG4gICAgICAgIGlmIChpc0RlY0RpZ2l0KG5leHQpKSByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgIGlmICg0NiA9PT0gbmV4dCkge1xuICAgICAgICAgIGlmICg0NiA9PT0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDIpKSByZXR1cm4gc2NhblZhcmFyZ0xpdGVyYWwoKTtcbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJy4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCcuJyk7XG5cbiAgICAgIGNhc2UgNjE6IC8vID1cbiAgICAgICAgaWYgKDYxID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJz09Jyk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignPScpO1xuXG4gICAgICBjYXNlIDYyOiAvLyA+XG4gICAgICAgIGlmIChmZWF0dXJlcy5iaXR3aXNlT3BlcmF0b3JzKVxuICAgICAgICAgIGlmICg2MiA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc+PicpO1xuICAgICAgICBpZiAoNjEgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignPj0nKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc+Jyk7XG5cbiAgICAgIGNhc2UgNjA6IC8vIDxcbiAgICAgICAgaWYgKGZlYXR1cmVzLmJpdHdpc2VPcGVyYXRvcnMpXG4gICAgICAgICAgaWYgKDYwID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJzw8Jyk7XG4gICAgICAgIGlmICg2MSA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc8PScpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJzwnKTtcblxuICAgICAgY2FzZSAxMjY6IC8vIH5cbiAgICAgICAgaWYgKDYxID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJ349Jyk7XG4gICAgICAgIGlmICghZmVhdHVyZXMuYml0d2lzZU9wZXJhdG9ycylcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCd+Jyk7XG5cbiAgICAgIGNhc2UgNTg6IC8vIDpcbiAgICAgICAgaWYgKGZlYXR1cmVzLmxhYmVscylcbiAgICAgICAgICBpZiAoNTggPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignOjonKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc6Jyk7XG5cbiAgICAgIGNhc2UgOTE6IC8vIFtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGEgbXVsdGlsaW5lIHN0cmluZywgdGhleSBiZWdpbiB3aXRoIFs9IG9yIFtbXG4gICAgICAgIGlmICg5MSA9PT0gbmV4dCB8fCA2MSA9PT0gbmV4dCkgcmV0dXJuIHNjYW5Mb25nU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJ1snKTtcblxuICAgICAgY2FzZSA0NzogLy8gL1xuICAgICAgICAvLyBDaGVjayBmb3IgaW50ZWdlciBkaXZpc2lvbiBvcCAoLy8pXG4gICAgICAgIGlmIChmZWF0dXJlcy5pbnRlZ2VyRGl2aXNpb24pXG4gICAgICAgICAgaWYgKDQ3ID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJy8vJyk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignLycpO1xuXG4gICAgICBjYXNlIDM4OiBjYXNlIDEyNDogLy8gJiB8XG4gICAgICAgIGlmICghZmVhdHVyZXMuYml0d2lzZU9wZXJhdG9ycylcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgNDI6IGNhc2UgOTQ6IGNhc2UgMzc6IGNhc2UgNDQ6IGNhc2UgMTIzOiBjYXNlIDEyNTpcbiAgICAgIGNhc2UgOTM6IGNhc2UgNDA6IGNhc2UgNDE6IGNhc2UgNTk6IGNhc2UgMzU6IGNhc2UgNDU6XG4gICAgICBjYXNlIDQzOiAvLyAqIF4gJSAsIHsgfSBdICggKSA7ICMgLSArXG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcihpbnB1dC5jaGFyQXQoaW5kZXgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5leHBlY3RlZChpbnB1dC5jaGFyQXQoaW5kZXgpKTtcbiAgfVxuXG4gIC8vIFdoaXRlc3BhY2UgaGFzIG5vIHNlbWFudGljIG1lYW5pbmcgaW4gbHVhIHNvIHNpbXBseSBza2lwIGFoZWFkIHdoaWxlXG4gIC8vIHRyYWNraW5nIHRoZSBlbmNvdW50ZWQgbmV3bGluZXMuIEFueSBraW5kIG9mIGVvbCBzZXF1ZW5jZSBpcyBjb3VudGVkIGFzIGFcbiAgLy8gc2luZ2xlIGxpbmUuXG5cbiAgZnVuY3Rpb24gY29uc3VtZUVPTCgpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KVxuICAgICAgLCBwZWVrQ2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaGFyQ29kZSkpIHtcbiAgICAgIC8vIENvdW50IFxcblxcciBhbmQgXFxyXFxuIGFzIG9uZSBuZXdsaW5lLlxuICAgICAgaWYgKDEwID09PSBjaGFyQ29kZSAmJiAxMyA9PT0gcGVla0NoYXJDb2RlKSArK2luZGV4O1xuICAgICAgaWYgKDEzID09PSBjaGFyQ29kZSAmJiAxMCA9PT0gcGVla0NoYXJDb2RlKSArK2luZGV4O1xuICAgICAgKytsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gKytpbmRleDtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZVNwYWNlKCkge1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoYXJDb2RlKSkge1xuICAgICAgICArK2luZGV4O1xuICAgICAgfSBlbHNlIGlmICghY29uc3VtZUVPTCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElkZW50aWZpZXJzLCBrZXl3b3JkcywgYm9vbGVhbnMgYW5kIG5pbCBhbGwgbG9vayB0aGUgc2FtZSBzeW50YXggd2lzZS4gV2VcbiAgLy8gc2ltcGx5IGdvIHRocm91Z2ggdGhlbSBvbmUgYnkgb25lIGFuZCBkZWZhdWx0aW5nIHRvIGFuIGlkZW50aWZpZXIgaWYgbm9cbiAgLy8gcHJldmlvdXMgY2FzZSBtYXRjaGVkLlxuXG4gIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyT3JLZXl3b3JkKCkge1xuICAgIHZhciB2YWx1ZSwgdHlwZTtcblxuICAgIC8vIFNsaWNpbmcgdGhlIGlucHV0IHN0cmluZyBpcyBwcmVmZXJlZCBiZWZvcmUgc3RyaW5nIGNvbmNhdGVuYXRpb24gaW4gYVxuICAgIC8vIGxvb3AgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQoaW5wdXQuY2hhckNvZGVBdCgrK2luZGV4KSkpO1xuICAgIHZhbHVlID0gZW5jb2RpbmdNb2RlLmZpeHVwKGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG5cbiAgICAvLyBEZWNpZGUgb24gdGhlIHRva2VuIHR5cGUgYW5kIHBvc3NpYmx5IGNhc3QgdGhlIHZhbHVlLlxuICAgIGlmIChpc0tleXdvcmQodmFsdWUpKSB7XG4gICAgICB0eXBlID0gS2V5d29yZDtcbiAgICB9IGVsc2UgaWYgKCd0cnVlJyA9PT0gdmFsdWUgfHwgJ2ZhbHNlJyA9PT0gdmFsdWUpIHtcbiAgICAgIHR5cGUgPSBCb29sZWFuTGl0ZXJhbDtcbiAgICAgIHZhbHVlID0gKCd0cnVlJyA9PT0gdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoJ25pbCcgPT09IHZhbHVlKSB7XG4gICAgICB0eXBlID0gTmlsTGl0ZXJhbDtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IElkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgICwgbGluZTogbGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW3Rva2VuU3RhcnQsIGluZGV4XVxuICAgIH07XG4gIH1cblxuICAvLyBPbmNlIGEgcHVuY3R1YXRvciByZWFjaGVzIHRoaXMgZnVuY3Rpb24gaXQgc2hvdWxkIGFscmVhZHkgaGF2ZSBiZWVuXG4gIC8vIHZhbGlkYXRlZCBzbyB3ZSBzaW1wbHkgcmV0dXJuIGl0IGFzIGEgdG9rZW4uXG5cbiAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IodmFsdWUpIHtcbiAgICBpbmRleCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUHVuY3R1YXRvclxuICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgICwgbGluZTogbGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW3Rva2VuU3RhcnQsIGluZGV4XVxuICAgIH07XG4gIH1cblxuICAvLyBBIHZhcmFyZyBsaXRlcmFsIGNvbnNpc3RzIG9mIHRocmVlIGRvdHMuXG5cbiAgZnVuY3Rpb24gc2NhblZhcmFyZ0xpdGVyYWwoKSB7XG4gICAgaW5kZXggKz0gMztcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBWYXJhcmdMaXRlcmFsXG4gICAgICAsIHZhbHVlOiAnLi4uJ1xuICAgICAgLCBsaW5lOiBsaW5lXG4gICAgICAsIGxpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbdG9rZW5TdGFydCwgaW5kZXhdXG4gICAgfTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHN0cmluZyBsaXRlcmFsIGJ5IG1hdGNoaW5nIHRoZSBkZWxpbWl0ZXIgbWFya3MgdXNlZC5cblxuICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICB2YXIgZGVsaW1pdGVyID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKVxuICAgICAgLCBiZWdpbkxpbmUgPSBsaW5lXG4gICAgICAsIGJlZ2luTGluZVN0YXJ0ID0gbGluZVN0YXJ0XG4gICAgICAsIHN0cmluZ1N0YXJ0ID0gaW5kZXhcbiAgICAgICwgc3RyaW5nID0gZW5jb2RpbmdNb2RlLmRpc2NhcmRTdHJpbmdzID8gbnVsbCA6ICcnXG4gICAgICAsIGNoYXJDb2RlO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspO1xuICAgICAgaWYgKGRlbGltaXRlciA9PT0gY2hhckNvZGUpIGJyZWFrO1xuICAgICAgLy8gRU9GIG9yIGBcXG5gIHRlcm1pbmF0ZXMgYSBzdHJpbmcgbGl0ZXJhbC4gSWYgd2UgaGF2ZW4ndCBmb3VuZCB0aGVcbiAgICAgIC8vIGVuZGluZyBkZWxpbWl0ZXIgYnkgbm93LCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICBpZiAoaW5kZXggPiBsZW5ndGggfHwgaXNMaW5lVGVybWluYXRvcihjaGFyQ29kZSkpIHtcbiAgICAgICAgc3RyaW5nICs9IGlucHV0LnNsaWNlKHN0cmluZ1N0YXJ0LCBpbmRleCAtIDEpO1xuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMudW5maW5pc2hlZFN0cmluZywgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXggLSAxKSk7XG4gICAgICB9XG4gICAgICBpZiAoOTIgPT09IGNoYXJDb2RlKSB7IC8vIGJhY2tzbGFzaFxuICAgICAgICBpZiAoIWVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncykge1xuICAgICAgICAgIHZhciBiZWZvcmVFc2NhcGUgPSBpbnB1dC5zbGljZShzdHJpbmdTdGFydCwgaW5kZXggLSAxKTtcbiAgICAgICAgICBzdHJpbmcgKz0gZW5jb2RpbmdNb2RlLmZpeHVwKGJlZm9yZUVzY2FwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVzY2FwZVZhbHVlID0gcmVhZEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgIGlmICghZW5jb2RpbmdNb2RlLmRpc2NhcmRTdHJpbmdzKVxuICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVWYWx1ZTtcbiAgICAgICAgc3RyaW5nU3RhcnQgPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFlbmNvZGluZ01vZGUuZGlzY2FyZFN0cmluZ3MpIHtcbiAgICAgIHN0cmluZyArPSBlbmNvZGluZ01vZGUuZW5jb2RlQnl0ZShudWxsKTtcbiAgICAgIHN0cmluZyArPSBlbmNvZGluZ01vZGUuZml4dXAoaW5wdXQuc2xpY2Uoc3RyaW5nU3RhcnQsIGluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ0xpdGVyYWxcbiAgICAgICwgdmFsdWU6IHN0cmluZ1xuICAgICAgLCBsaW5lOiBiZWdpbkxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBiZWdpbkxpbmVTdGFydFxuICAgICAgLCBsYXN0TGluZTogbGluZVxuICAgICAgLCBsYXN0TGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwZWN0IGEgbXVsdGlsaW5lIHN0cmluZyBsaXRlcmFsIGFuZCByZXR1cm4gaXQgYXMgYSByZWd1bGFyIHN0cmluZ1xuICAvLyBsaXRlcmFsLCBpZiBpdCBkb2Vzbid0IHZhbGlkYXRlIGludG8gYSB2YWxpZCBtdWx0aWxpbmUgc3RyaW5nLCB0aHJvdyBhblxuICAvLyBleGNlcHRpb24uXG5cbiAgZnVuY3Rpb24gc2NhbkxvbmdTdHJpbmdMaXRlcmFsKCkge1xuICAgIHZhciBiZWdpbkxpbmUgPSBsaW5lXG4gICAgICAsIGJlZ2luTGluZVN0YXJ0ID0gbGluZVN0YXJ0XG4gICAgICAsIHN0cmluZyA9IHJlYWRMb25nU3RyaW5nKGZhbHNlKTtcbiAgICAvLyBGYWlsIGlmIGl0J3Mgbm90IGEgbXVsdGlsaW5lIGxpdGVyYWwuXG4gICAgaWYgKGZhbHNlID09PSBzdHJpbmcpIHJhaXNlKHRva2VuLCBlcnJvcnMuZXhwZWN0ZWQsICdbJywgdG9rZW5WYWx1ZSh0b2tlbikpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogU3RyaW5nTGl0ZXJhbFxuICAgICAgLCB2YWx1ZTogZW5jb2RpbmdNb2RlLmRpc2NhcmRTdHJpbmdzID8gbnVsbCA6IGVuY29kaW5nTW9kZS5maXh1cChzdHJpbmcpXG4gICAgICAsIGxpbmU6IGJlZ2luTGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGJlZ2luTGluZVN0YXJ0XG4gICAgICAsIGxhc3RMaW5lOiBsaW5lXG4gICAgICAsIGxhc3RMaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW3Rva2VuU3RhcnQsIGluZGV4XVxuICAgIH07XG4gIH1cblxuICAvLyBOdW1lcmljIGxpdGVyYWxzIHdpbGwgYmUgcmV0dXJuZWQgYXMgZmxvYXRpbmctcG9pbnQgbnVtYmVycyBpbnN0ZWFkIG9mXG4gIC8vIHN0cmluZ3MuIFRoZSByYXcgdmFsdWUgc2hvdWxkIGJlIHJldHJpZXZlZCBmcm9tIHNsaWNpbmcgdGhlIGlucHV0IHN0cmluZ1xuICAvLyBsYXRlciBvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSWYgYSBoZXhhZGVjaW1hbCBudW1iZXIgaXMgZW5jb3VudGVyZWQsIGl0IHdpbGwgYmUgY29udmVydGVkLlxuXG4gIGZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgICB2YXIgY2hhcmFjdGVyID0gaW5wdXQuY2hhckF0KGluZGV4KVxuICAgICAgLCBuZXh0ID0gaW5wdXQuY2hhckF0KGluZGV4ICsgMSk7XG5cbiAgICB2YXIgbGl0ZXJhbCA9ICgnMCcgPT09IGNoYXJhY3RlciAmJiAneFgnLmluZGV4T2YobmV4dCB8fCBudWxsKSA+PSAwKSA/XG4gICAgICByZWFkSGV4TGl0ZXJhbCgpIDogcmVhZERlY0xpdGVyYWwoKTtcblxuICAgIHZhciBmb3VuZEltYWdpbmFyeVVuaXQgPSByZWFkSW1hZ2luYXJ5VW5pdFN1ZmZpeCgpXG4gICAgICAsIGZvdW5kSW50NjRTdWZmaXggPSByZWFkSW50NjRTdWZmaXgoKTtcblxuICAgIGlmIChmb3VuZEludDY0U3VmZml4ICYmIChmb3VuZEltYWdpbmFyeVVuaXQgfHwgbGl0ZXJhbC5oYXNGcmFjdGlvblBhcnQpKSB7XG4gICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IE51bWVyaWNMaXRlcmFsXG4gICAgICAsIHZhbHVlOiBsaXRlcmFsLnZhbHVlXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEltYWdpbmFyeVVuaXRTdWZmaXgoKSB7XG4gICAgaWYgKCFmZWF0dXJlcy5pbWFnaW5hcnlOdW1iZXJzKSByZXR1cm47XG5cbiAgICAvLyBJbWFnaW5hcnkgdW5pdCBudW1iZXIgc3VmZml4IGlzIG9wdGlvbmFsLlxuICAgIC8vIFNlZSBodHRwOi8vbHVhaml0Lm9yZy9leHRfZmZpX2FwaS5odG1sI2xpdGVyYWxzXG4gICAgaWYgKCdpSScuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgICsraW5kZXg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRJbnQ2NFN1ZmZpeCgpIHtcbiAgICBpZiAoIWZlYXR1cmVzLmludGVnZXJTdWZmaXhlcykgcmV0dXJuO1xuXG4gICAgLy8gSW50NjQvdWludDY0IG51bWJlciBzdWZmaXggaXMgb3B0aW9uYWwuXG4gICAgLy8gU2VlIGh0dHA6Ly9sdWFqaXQub3JnL2V4dF9mZmlfYXBpLmh0bWwjbGl0ZXJhbHNcblxuICAgIGlmICgndVUnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgaWYgKCdsTCcuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgaWYgKCdsTCcuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIHJldHVybiAnVUxMJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVTCBidXQgbm8gTFxuICAgICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFUgYnV0IG5vIExcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCdsTCcuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgaWYgKCdsTCcuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIHJldHVybiAnTEwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpcnN0IEwgYnV0IG5vIHNlY29uZCBMXG4gICAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEx1YSBoZXhhZGVjaW1hbHMgaGF2ZSBhbiBvcHRpb25hbCBmcmFjdGlvbiBwYXJ0IGFuZCBhbiBvcHRpb25hbCBiaW5hcnlcbiAgLy8gZXhvcG9uZW50IHBhcnQuIFRoZXNlIGFyZSBub3QgaW5jbHVkZWQgaW4gSmF2YVNjcmlwdCBzbyB3ZSB3aWxsIGNvbXB1dGVcbiAgLy8gYWxsIHRocmVlIHBhcnRzIHNlcGFyYXRlbHkgYW5kIHRoZW4gc3VtIHRoZW0gdXAgYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb25cbiAgLy8gd2l0aCB0aGUgZm9sbG93aW5nIGFsZ29yaXRobS5cbiAgLy9cbiAgLy8gICAgIERpZ2l0IDo9IHRvRGVjKGRpZ2l0KVxuICAvLyAgICAgRnJhY3Rpb24gOj0gdG9EZWMoZnJhY3Rpb24pIC8gMTYgXiBmcmFjdGlvbkNvdW50XG4gIC8vICAgICBCaW5hcnlFeHAgOj0gMiBeIGJpbmFyeUV4cFxuICAvLyAgICAgTnVtYmVyIDo9ICggRGlnaXQgKyBGcmFjdGlvbiApICogQmluYXJ5RXhwXG5cbiAgZnVuY3Rpb24gcmVhZEhleExpdGVyYWwoKSB7XG4gICAgdmFyIGZyYWN0aW9uID0gMCAvLyBkZWZhdWx0cyB0byAwIGFzIGl0IGdldHMgc3VtbWVkXG4gICAgICAsIGJpbmFyeUV4cG9uZW50ID0gMSAvLyBkZWZhdWx0cyB0byAxIGFzIGl0IGdldHMgbXVsdGlwbGllZFxuICAgICAgLCBiaW5hcnlTaWduID0gMSAvLyBwb3NpdGl2ZVxuICAgICAgLCBkaWdpdCwgZnJhY3Rpb25TdGFydCwgZXhwb25lbnRTdGFydCwgZGlnaXRTdGFydDtcblxuICAgIGRpZ2l0U3RhcnQgPSBpbmRleCArPSAyOyAvLyBTa2lwIDB4IHBhcnRcblxuICAgIC8vIEEgbWluaW11bSBvZiBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgIGlmICghaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpXG4gICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgd2hpbGUgKGlzSGV4RGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgIC8vIENvbnZlcnQgdGhlIGhleGFkZWNpbWFsIGRpZ2l0IHRvIGJhc2UgMTAuXG4gICAgZGlnaXQgPSBwYXJzZUludChpbnB1dC5zbGljZShkaWdpdFN0YXJ0LCBpbmRleCksIDE2KTtcblxuICAgIC8vIEZyYWN0aW9uIHBhcnQgaXMgb3B0aW9uYWwuXG4gICAgdmFyIGZvdW5kRnJhY3Rpb24gPSBmYWxzZTtcbiAgICBpZiAoJy4nID09PSBpbnB1dC5jaGFyQXQoaW5kZXgpKSB7XG4gICAgICBmb3VuZEZyYWN0aW9uID0gdHJ1ZTtcbiAgICAgIGZyYWN0aW9uU3RhcnQgPSArK2luZGV4O1xuXG4gICAgICB3aGlsZSAoaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgICBmcmFjdGlvbiA9IGlucHV0LnNsaWNlKGZyYWN0aW9uU3RhcnQsIGluZGV4KTtcblxuICAgICAgLy8gRW1wdHkgZnJhY3Rpb24gcGFydHMgc2hvdWxkIGRlZmF1bHQgdG8gMCwgb3RoZXJzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICAgIC8vIDAueCBmb3JtIHNvIHdlIGNhbiB1c2Ugc3VtbWF0aW9uIGF0IHRoZSBlbmQuXG4gICAgICBmcmFjdGlvbiA9IChmcmFjdGlvblN0YXJ0ID09PSBpbmRleCkgPyAwXG4gICAgICAgIDogcGFyc2VJbnQoZnJhY3Rpb24sIDE2KSAvIE1hdGgucG93KDE2LCBpbmRleCAtIGZyYWN0aW9uU3RhcnQpO1xuICAgIH1cblxuICAgIC8vIEJpbmFyeSBleHBvbmVudHMgYXJlIG9wdGlvbmFsXG4gICAgdmFyIGZvdW5kQmluYXJ5RXhwb25lbnQgPSBmYWxzZTtcbiAgICBpZiAoJ3BQJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgZm91bmRCaW5hcnlFeHBvbmVudCA9IHRydWU7XG4gICAgICArK2luZGV4O1xuXG4gICAgICAvLyBTaWduIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDEgKHBvc2l0aXZlKS5cbiAgICAgIGlmICgnKy0nLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKVxuICAgICAgICBiaW5hcnlTaWduID0gKCcrJyA9PT0gaW5wdXQuY2hhckF0KGluZGV4KyspKSA/IDEgOiAtMTtcblxuICAgICAgZXhwb25lbnRTdGFydCA9IGluZGV4O1xuXG4gICAgICAvLyBUaGUgYmluYXJ5IGV4cG9uZW50IHNpZ24gcmVxdWlyZXMgYSBkZWNpbWFsIGRpZ2l0LlxuICAgICAgaWYgKCFpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSlcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcblxuICAgICAgd2hpbGUgKGlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgICAgYmluYXJ5RXhwb25lbnQgPSBpbnB1dC5zbGljZShleHBvbmVudFN0YXJ0LCBpbmRleCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmluYXJ5IGV4cG9uZW50IG9mIHRoZSBudW1iZXIuXG4gICAgICBiaW5hcnlFeHBvbmVudCA9IE1hdGgucG93KDIsIGJpbmFyeUV4cG9uZW50ICogYmluYXJ5U2lnbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiAoZGlnaXQgKyBmcmFjdGlvbikgKiBiaW5hcnlFeHBvbmVudCxcbiAgICAgIGhhc0ZyYWN0aW9uUGFydDogZm91bmRGcmFjdGlvbiB8fCBmb3VuZEJpbmFyeUV4cG9uZW50XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlY2ltYWwgbnVtYmVycyBhcmUgZXhhY3RseSB0aGUgc2FtZSBpbiBMdWEgYW5kIGluIEphdmFTY3JpcHQsIGJlY2F1c2Ugb2ZcbiAgLy8gdGhpcyB3ZSBjaGVjayB3aGVyZSB0aGUgdG9rZW4gZW5kcyBhbmQgdGhlbiBwYXJzZSBpdCB3aXRoIG5hdGl2ZVxuICAvLyBmdW5jdGlvbnMuXG5cbiAgZnVuY3Rpb24gcmVhZERlY0xpdGVyYWwoKSB7XG4gICAgd2hpbGUgKGlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgIC8vIEZyYWN0aW9uIHBhcnQgaXMgb3B0aW9uYWxcbiAgICB2YXIgZm91bmRGcmFjdGlvbiA9IGZhbHNlO1xuICAgIGlmICgnLicgPT09IGlucHV0LmNoYXJBdChpbmRleCkpIHtcbiAgICAgIGZvdW5kRnJhY3Rpb24gPSB0cnVlO1xuICAgICAgKytpbmRleDtcbiAgICAgIC8vIEZyYWN0aW9uIHBhcnQgZGVmYXVsdHMgdG8gMFxuICAgICAgd2hpbGUgKGlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgIH1cblxuICAgIC8vIEV4cG9uZW50IHBhcnQgaXMgb3B0aW9uYWwuXG4gICAgdmFyIGZvdW5kRXhwb25lbnQgPSBmYWxzZTtcbiAgICBpZiAoJ2VFJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgZm91bmRFeHBvbmVudCA9IHRydWU7XG4gICAgICArK2luZGV4O1xuICAgICAgLy8gU2lnbiBwYXJ0IGlzIG9wdGlvbmFsLlxuICAgICAgaWYgKCcrLScuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApICsraW5kZXg7XG4gICAgICAvLyBBbiBleHBvbmVudCBpcyByZXF1aXJlZCB0byBjb250YWluIGF0IGxlYXN0IG9uZSBkZWNpbWFsIGRpZ2l0LlxuICAgICAgaWYgKCFpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSlcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcblxuICAgICAgd2hpbGUgKGlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogcGFyc2VGbG9hdChpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpLFxuICAgICAgaGFzRnJhY3Rpb25QYXJ0OiBmb3VuZEZyYWN0aW9uIHx8IGZvdW5kRXhwb25lbnRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICB2YXIgc2VxdWVuY2VTdGFydCA9IGluZGV4Kys7XG5cbiAgICBpZiAoaW5wdXQuY2hhckF0KGluZGV4KyspICE9PSAneycpXG4gICAgICByYWlzZShudWxsLCBlcnJvcnMuYnJhY2VFeHBlY3RlZCwgJ3snLCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCkpO1xuICAgIGlmICghaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpXG4gICAgICByYWlzZShudWxsLCBlcnJvcnMuaGV4YWRlY2ltYWxEaWdpdEV4cGVjdGVkLCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCkpO1xuXG4gICAgd2hpbGUgKGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDMwKSArK2luZGV4O1xuICAgIHZhciBlc2NTdGFydCA9IGluZGV4O1xuXG4gICAgd2hpbGUgKGlzSGV4RGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgaWYgKGluZGV4IC0gZXNjU3RhcnQgPiA2KVxuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMudG9vTGFyZ2VDb2RlcG9pbnQsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KSk7XG4gICAgfVxuXG4gICAgdmFyIGIgPSBpbnB1dC5jaGFyQXQoaW5kZXgrKyk7XG4gICAgaWYgKGIgIT09ICd9Jykge1xuICAgICAgaWYgKChiID09PSAnXCInKSB8fCAoYiA9PT0gXCInXCIpKVxuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMuYnJhY2VFeHBlY3RlZCwgJ30nLCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleC0tKSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5oZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KSk7XG4gICAgfVxuXG4gICAgdmFyIGNvZGVwb2ludCA9IHBhcnNlSW50KGlucHV0LnNsaWNlKGVzY1N0YXJ0LCBpbmRleCAtIDEpIHx8ICcwJywgMTYpO1xuICAgIHZhciBmcmFnID0gJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpO1xuXG4gICAgaWYgKGNvZGVwb2ludCA+IDB4MTBmZmZmKSB7XG4gICAgICByYWlzZShudWxsLCBlcnJvcnMudG9vTGFyZ2VDb2RlcG9pbnQsIGZyYWcpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGluZ01vZGUuZW5jb2RlVVRGOChjb2RlcG9pbnQsIGZyYWcpO1xuICB9XG5cbiAgLy8gVHJhbnNsYXRlIGVzY2FwZSBzZXF1ZW5jZXMgdG8gdGhlIGFjdHVhbCBjaGFyYWN0ZXJzLlxuICBmdW5jdGlvbiByZWFkRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgdmFyIHNlcXVlbmNlU3RhcnQgPSBpbmRleDtcbiAgICBzd2l0Y2ggKGlucHV0LmNoYXJBdChpbmRleCkpIHtcbiAgICAgIC8vIEx1YSBhbGxvdyB0aGUgZm9sbG93aW5nIGVzY2FwZSBzZXF1ZW5jZXMuXG4gICAgICBjYXNlICdhJzogKytpbmRleDsgcmV0dXJuICdcXHgwNyc7XG4gICAgICBjYXNlICduJzogKytpbmRleDsgcmV0dXJuICdcXG4nO1xuICAgICAgY2FzZSAncic6ICsraW5kZXg7IHJldHVybiAnXFxyJztcbiAgICAgIGNhc2UgJ3QnOiArK2luZGV4OyByZXR1cm4gJ1xcdCc7XG4gICAgICBjYXNlICd2JzogKytpbmRleDsgcmV0dXJuICdcXHgwYic7XG4gICAgICBjYXNlICdiJzogKytpbmRleDsgcmV0dXJuICdcXGInO1xuICAgICAgY2FzZSAnZic6ICsraW5kZXg7IHJldHVybiAnXFxmJztcblxuICAgICAgLy8gQmFja3NsYXNoIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuIFdlIHRyZWF0IGFsbCBsaW5lIGVuZGluZ3MgYXMgZXF1aXZhbGVudCxcbiAgICAgIC8vIGFuZCBhcyByZXByZXNlbnRpbmcgdGhlIFtMRl0gY2hhcmFjdGVyIChjb2RlIDEwKS4gTHVhIDUuMSB0aHJvdWdoIDUuM1xuICAgICAgLy8gaGF2ZSBiZWVuIHZlcmlmaWVkIHRvIGJlaGF2ZSB0aGUgc2FtZSB3YXkuXG4gICAgICBjYXNlICdcXHInOlxuICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY29uc3VtZUVPTCgpO1xuICAgICAgICByZXR1cm4gJ1xcbic7XG5cbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgLy8gXFxkZGQsIHdoZXJlIGRkZCBpcyBhIHNlcXVlbmNlIG9mIHVwIHRvIHRocmVlIGRlY2ltYWwgZGlnaXRzLlxuICAgICAgICB3aGlsZSAoaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkgJiYgaW5kZXggLSBzZXF1ZW5jZVN0YXJ0IDwgMykgKytpbmRleDtcblxuICAgICAgICB2YXIgZnJhZyA9IGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KTtcbiAgICAgICAgdmFyIGRkZCA9IHBhcnNlSW50KGZyYWcsIDEwKTtcbiAgICAgICAgaWYgKGRkZCA+IDI1NSkge1xuICAgICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5kZWNpbWFsRXNjYXBlVG9vTGFyZ2UsICdcXFxcJyArIGRkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kaW5nTW9kZS5lbmNvZGVCeXRlKGRkZCwgJ1xcXFwnICsgZnJhZyk7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgICBpZiAoZmVhdHVyZXMuc2tpcFdoaXRlc3BhY2VFc2NhcGUpIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIHNraXBXaGl0ZVNwYWNlKCk7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd4JzpcbiAgICAgICAgaWYgKGZlYXR1cmVzLmhleEVzY2FwZXMpIHtcbiAgICAgICAgICAvLyBcXHhYWCwgd2hlcmUgWFggaXMgYSBzZXF1ZW5jZSBvZiBleGFjdGx5IHR3byBoZXhhZGVjaW1hbCBkaWdpdHNcbiAgICAgICAgICBpZiAoaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMSkpICYmXG4gICAgICAgICAgICAgIGlzSGV4RGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDIpKSkge1xuICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGluZ01vZGUuZW5jb2RlQnl0ZShwYXJzZUludChpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0ICsgMSwgaW5kZXgpLCAxNiksICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5oZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4ICsgMikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd1JzpcbiAgICAgICAgaWYgKGZlYXR1cmVzLnVuaWNvZGVFc2NhcGVzKVxuICAgICAgICAgIHJldHVybiByZWFkVW5pY29kZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdcXFxcJzogY2FzZSAnXCInOiBjYXNlIFwiJ1wiOlxuICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KGluZGV4KyspO1xuICAgIH1cblxuICAgIGlmIChmZWF0dXJlcy5zdHJpY3RFc2NhcGVzKVxuICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmludmFsaWRFc2NhcGUsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4ICsgMSkpO1xuICAgIHJldHVybiBpbnB1dC5jaGFyQXQoaW5kZXgrKyk7XG4gIH1cblxuICAvLyBDb21tZW50cyBiZWdpbiB3aXRoIC0tIGFmdGVyIHdoaWNoIGl0IHdpbGwgYmUgZGVjaWRlZCBpZiB0aGV5IGFyZVxuICAvLyBtdWx0aWxpbmUgY29tbWVudHMgb3Igbm90LlxuICAvL1xuICAvLyBUaGUgbXVsdGlsaW5lIGZ1bmN0aW9uYWxpdHkgd29ya3MgdGhlIGV4YWN0IHNhbWUgd2F5IGFzIHdpdGggc3RyaW5nXG4gIC8vIGxpdGVyYWxzIHNvIHdlIHJldXNlIHRoZSBmdW5jdGlvbmFsaXR5LlxuXG4gIGZ1bmN0aW9uIHNjYW5Db21tZW50KCkge1xuICAgIHRva2VuU3RhcnQgPSBpbmRleDtcbiAgICBpbmRleCArPSAyOyAvLyAtLVxuXG4gICAgdmFyIGNoYXJhY3RlciA9IGlucHV0LmNoYXJBdChpbmRleClcbiAgICAgICwgY29udGVudCA9ICcnXG4gICAgICAsIGlzTG9uZyA9IGZhbHNlXG4gICAgICAsIGNvbW1lbnRTdGFydCA9IGluZGV4XG4gICAgICAsIGxpbmVTdGFydENvbW1lbnQgPSBsaW5lU3RhcnRcbiAgICAgICwgbGluZUNvbW1lbnQgPSBsaW5lO1xuXG4gICAgaWYgKCdbJyA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICBjb250ZW50ID0gcmVhZExvbmdTdHJpbmcodHJ1ZSk7XG4gICAgICAvLyBUaGlzIHdhc24ndCBhIG11bHRpbGluZSBjb21tZW50IGFmdGVyIGFsbC5cbiAgICAgIGlmIChmYWxzZSA9PT0gY29udGVudCkgY29udGVudCA9IGNoYXJhY3RlcjtcbiAgICAgIGVsc2UgaXNMb25nID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gU2NhbiB1bnRpbCBuZXh0IGxpbmUgYXMgbG9uZyBhcyBpdCdzIG5vdCBhIG11bHRpbGluZSBjb21tZW50LlxuICAgIGlmICghaXNMb25nKSB7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSBicmVhaztcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNvbW1lbnRzKSBjb250ZW50ID0gaW5wdXQuc2xpY2UoY29tbWVudFN0YXJ0LCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIHtcbiAgICAgIHZhciBub2RlID0gYXN0LmNvbW1lbnQoY29udGVudCwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcblxuICAgICAgLy8gYE1hcmtlcmBzIGRlcGVuZCBvbiB0b2tlbnMgYXZhaWxhYmxlIGluIHRoZSBwYXJzZXIgYW5kIGFzIGNvbW1lbnRzIGFyZVxuICAgICAgLy8gaW50ZXJjZXB0ZWQgaW4gdGhlIGxleGVyIGFsbCBsb2NhdGlvbiBkYXRhIGlzIHNldCBtYW51YWxseS5cbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICBub2RlLmxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7IGxpbmU6IGxpbmVDb21tZW50LCBjb2x1bW46IHRva2VuU3RhcnQgLSBsaW5lU3RhcnRDb21tZW50IH1cbiAgICAgICAgICAsIGVuZDogeyBsaW5lOiBsaW5lLCBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJhbmdlcykge1xuICAgICAgICBub2RlLnJhbmdlID0gW3Rva2VuU3RhcnQsIGluZGV4XTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9uQ3JlYXRlTm9kZSkgb3B0aW9ucy5vbkNyZWF0ZU5vZGUobm9kZSk7XG4gICAgICBjb21tZW50cy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWQgYSBtdWx0aWxpbmUgc3RyaW5nIGJ5IGNhbGN1bGF0aW5nIHRoZSBkZXB0aCBvZiBgPWAgY2hhcmFjdGVycyBhbmRcbiAgLy8gdGhlbiBhcHBlbmRpbmcgdW50aWwgYW4gZXF1YWwgZGVwdGggaXMgZm91bmQuXG5cbiAgZnVuY3Rpb24gcmVhZExvbmdTdHJpbmcoaXNDb21tZW50KSB7XG4gICAgdmFyIGxldmVsID0gMFxuICAgICAgLCBjb250ZW50ID0gJydcbiAgICAgICwgdGVybWluYXRvciA9IGZhbHNlXG4gICAgICAsIGNoYXJhY3Rlciwgc3RyaW5nU3RhcnQsIGZpcnN0TGluZSA9IGxpbmU7XG5cbiAgICArK2luZGV4OyAvLyBbXG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRlcHRoIG9mIHRoZSBjb21tZW50LlxuICAgIHdoaWxlICgnPScgPT09IGlucHV0LmNoYXJBdChpbmRleCArIGxldmVsKSkgKytsZXZlbDtcbiAgICAvLyBFeGl0LCB0aGlzIGlzIG5vdCBhIGxvbmcgc3RyaW5nIGFmdGVyYWxsLlxuICAgIGlmICgnWycgIT09IGlucHV0LmNoYXJBdChpbmRleCArIGxldmVsKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaW5kZXggKz0gbGV2ZWwgKyAxO1xuXG4gICAgLy8gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhIG5ld2xpbmUsIGlnbm9yZSBpdCBhbmQgYmVnaW4gb24gbmV4dCBsaW5lLlxuICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgY29uc3VtZUVPTCgpO1xuXG4gICAgc3RyaW5nU3RhcnQgPSBpbmRleDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIC8vIFRvIGtlZXAgdHJhY2sgb2YgbGluZSBudW1iZXJzIHJ1biB0aGUgYGNvbnN1bWVFT0woKWAgd2hpY2ggaW5jcmVtZW50c1xuICAgICAgLy8gaXRzIGNvdW50ZXIuXG4gICAgICB3aGlsZSAoaXNMaW5lVGVybWluYXRvcihpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpIGNvbnN1bWVFT0woKTtcblxuICAgICAgY2hhcmFjdGVyID0gaW5wdXQuY2hhckF0KGluZGV4KyspO1xuXG4gICAgICAvLyBPbmNlIHRoZSBkZWxpbWl0ZXIgaXMgZm91bmQsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgZGVwdGggY291bnQgYW5kIHNlZVxuICAgICAgLy8gaWYgaXQgbWF0Y2hlcy5cbiAgICAgIGlmICgnXScgPT09IGNoYXJhY3Rlcikge1xuICAgICAgICB0ZXJtaW5hdG9yID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbDsgKytpKSB7XG4gICAgICAgICAgaWYgKCc9JyAhPT0gaW5wdXQuY2hhckF0KGluZGV4ICsgaSkpIHRlcm1pbmF0b3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ10nICE9PSBpbnB1dC5jaGFyQXQoaW5kZXggKyBsZXZlbCkpIHRlcm1pbmF0b3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBtdWx0aWxpbmUgc3RyaW5nLiBHZXQgb3V0IG5vdy5cbiAgICAgIGlmICh0ZXJtaW5hdG9yKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gaW5wdXQuc2xpY2Uoc3RyaW5nU3RhcnQsIGluZGV4IC0gMSk7XG4gICAgICAgIGluZGV4ICs9IGxldmVsICsgMTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmFpc2UobnVsbCwgaXNDb21tZW50ID9cbiAgICAgICAgICAgICAgICBlcnJvcnMudW5maW5pc2hlZExvbmdDb21tZW50IDpcbiAgICAgICAgICAgICAgICBlcnJvcnMudW5maW5pc2hlZExvbmdTdHJpbmcsXG4gICAgICAgICAgZmlyc3RMaW5lLCAnPGVvZj4nKTtcbiAgfVxuXG4gIC8vICMjIExleCBmdW5jdGlvbnMgYW5kIGhlbHBlcnMuXG5cbiAgLy8gUmVhZCB0aGUgbmV4dCB0b2tlbi5cbiAgLy9cbiAgLy8gVGhpcyBpcyBhY3R1YWxseSBkb25lIGJ5IHNldHRpbmcgdGhlIGN1cnJlbnQgdG9rZW4gdG8gdGhlIGxvb2thaGVhZCBhbmRcbiAgLy8gcmVhZGluZyBpbiB0aGUgbmV3IGxvb2thaGVhZCB0b2tlbi5cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICBsb29rYWhlYWQgPSBsZXgoKTtcbiAgfVxuXG4gIC8vIENvbnN1bWUgYSB0b2tlbiBpZiBpdHMgdmFsdWUgbWF0Y2hlcy4gT25jZSBjb25zdW1lZCBvciBub3QsIHJldHVybiB0aGVcbiAgLy8gc3VjY2VzcyBvZiB0aGUgb3BlcmF0aW9uLlxuXG4gIGZ1bmN0aW9uIGNvbnN1bWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRva2VuLnZhbHVlKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHZhbHVlIHRvIG1hdGNoLiBJZiBub3QsIHRocm93IGFuIGV4Y2VwdGlvbi5cblxuICBmdW5jdGlvbiBleHBlY3QodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRva2VuLnZhbHVlKSBuZXh0KCk7XG4gICAgZWxzZSByYWlzZSh0b2tlbiwgZXJyb3JzLmV4cGVjdGVkLCB2YWx1ZSwgdG9rZW5WYWx1ZSh0b2tlbikpO1xuICB9XG5cbiAgLy8gIyMjIFZhbGlkYXRpb24gZnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIDkgPT09IGNoYXJDb2RlIHx8IDMyID09PSBjaGFyQ29kZSB8fCAweEIgPT09IGNoYXJDb2RlIHx8IDB4QyA9PT0gY2hhckNvZGU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIDEwID09PSBjaGFyQ29kZSB8fCAxMyA9PT0gY2hhckNvZGU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RlY0RpZ2l0KGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaGFyQ29kZSkge1xuICAgIHJldHVybiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHx8IChjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIpIHx8IChjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCk7XG4gIH1cblxuICAvLyBGcm9tIFtMdWEgNS4yXShodHRwOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUuMi9tYW51YWwuaHRtbCM4LjEpIG9ud2FyZHNcbiAgLy8gaWRlbnRpZmllcnMgY2Fubm90IHVzZSAnbG9jYWxlLWRlcGVuZGVudCcgbGV0dGVycyAoaS5lLiBkZXBlbmRlbnQgb24gdGhlIEMgbG9jYWxlKS5cbiAgLy8gT24gdGhlIG90aGVyIGhhbmQsIEx1YUpJVCBhbGxvd3MgYXJiaXRyYXJ5IG9jdGV0cyDiiaUgMTI4IGluIGlkZW50aWZpZXJzLlxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoYXJDb2RlKSB7XG4gICAgaWYgKChjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA5MCkgfHwgKGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEyMikgfHwgOTUgPT09IGNoYXJDb2RlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGZlYXR1cmVzLmV4dGVuZGVkSWRlbnRpZmllcnMgJiYgY2hhckNvZGUgPj0gMTI4KVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaGFyQ29kZSkge1xuICAgIGlmICgoY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gOTApIHx8IChjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMjIpIHx8IDk1ID09PSBjaGFyQ29kZSB8fCAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGZlYXR1cmVzLmV4dGVuZGVkSWRlbnRpZmllcnMgJiYgY2hhckNvZGUgPj0gMTI4KVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gWzMuMSBMZXhpY2FsIENvbnZlbnRpb25zXShodHRwOi8vd3d3Lmx1YS5vcmcvbWFudWFsLzUuMi9tYW51YWwuaHRtbCMzLjEpXG4gIC8vXG4gIC8vIGB0cnVlYCwgYGZhbHNlYCBhbmQgYG5pbGAgd2lsbCBub3QgYmUgY29uc2lkZXJlZCBrZXl3b3JkcywgYnV0IGxpdGVyYWxzLlxuXG4gIGZ1bmN0aW9uIGlzS2V5d29yZChpZCkge1xuICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiAnZG8nID09PSBpZCB8fCAnaWYnID09PSBpZCB8fCAnaW4nID09PSBpZCB8fCAnb3InID09PSBpZDtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuICdhbmQnID09PSBpZCB8fCAnZW5kJyA9PT0gaWQgfHwgJ2ZvcicgPT09IGlkIHx8ICdub3QnID09PSBpZDtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKCdlbHNlJyA9PT0gaWQgfHwgJ3RoZW4nID09PSBpZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGZlYXR1cmVzLmxhYmVscyAmJiAhZmVhdHVyZXMuY29udGV4dHVhbEdvdG8pXG4gICAgICAgICAgcmV0dXJuICgnZ290bycgPT09IGlkKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gJ2JyZWFrJyA9PT0gaWQgfHwgJ2xvY2FsJyA9PT0gaWQgfHwgJ3VudGlsJyA9PT0gaWQgfHwgJ3doaWxlJyA9PT0gaWQ7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiAnZWxzZWlmJyA9PT0gaWQgfHwgJ3JlcGVhdCcgPT09IGlkIHx8ICdyZXR1cm4nID09PSBpZDtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuICdmdW5jdGlvbicgPT09IGlkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1VuYXJ5KHRva2VuKSB7XG4gICAgaWYgKFB1bmN0dWF0b3IgPT09IHRva2VuLnR5cGUpIHJldHVybiAnIy1+Jy5pbmRleE9mKHRva2VuLnZhbHVlKSA+PSAwO1xuICAgIGlmIChLZXl3b3JkID09PSB0b2tlbi50eXBlKSByZXR1cm4gJ25vdCcgPT09IHRva2VuLnZhbHVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSB0b2tlbiBzeW50YWN0aWNhbGx5IGNsb3NlcyBhIGJsb2NrLlxuXG4gIGZ1bmN0aW9uIGlzQmxvY2tGb2xsb3codG9rZW4pIHtcbiAgICBpZiAoRU9GID09PSB0b2tlbi50eXBlKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoS2V5d29yZCAhPT0gdG9rZW4udHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Vsc2UnOiBjYXNlICdlbHNlaWYnOlxuICAgICAgY2FzZSAnZW5kJzogY2FzZSAndW50aWwnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBTY29wZVxuICAvLyAtLS0tLVxuXG4gIC8vIFN0b3JlIGVhY2ggYmxvY2sgc2NvcGUgYXMgYSBhbiBhcnJheSBvZiBpZGVudGlmaWVyIG5hbWVzLiBFYWNoIHNjb3BlIGlzXG4gIC8vIHN0b3JlZCBpbiBhbiBGSUxPLWFycmF5LlxuICB2YXIgc2NvcGVzXG4gICAgLy8gVGhlIGN1cnJlbnQgc2NvcGUgaW5kZXhcbiAgICAsIHNjb3BlRGVwdGhcbiAgICAvLyBBIGxpc3Qgb2YgYWxsIGdsb2JhbCBpZGVudGlmaWVyIG5vZGVzLlxuICAgICwgZ2xvYmFscztcblxuICAvLyBDcmVhdGUgYSBuZXcgc2NvcGUgaW5oZXJpdGluZyBhbGwgZGVjbGFyYXRpb25zIGZyb20gdGhlIHByZXZpb3VzIHNjb3BlLlxuICBmdW5jdGlvbiBjcmVhdGVTY29wZSgpIHtcbiAgICB2YXIgc2NvcGUgPSBzY29wZXNbc2NvcGVEZXB0aCsrXS5zbGljZSgpO1xuICAgIHNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICBpZiAob3B0aW9ucy5vbkNyZWF0ZVNjb3BlKSBvcHRpb25zLm9uQ3JlYXRlU2NvcGUoKTtcbiAgfVxuXG4gIC8vIEV4aXQgYW5kIHJlbW92ZSB0aGUgY3VycmVudCBzY29wZS5cbiAgZnVuY3Rpb24gZGVzdHJveVNjb3BlKCkge1xuICAgIHZhciBzY29wZSA9IHNjb3Blcy5wb3AoKTtcbiAgICAtLXNjb3BlRGVwdGg7XG4gICAgaWYgKG9wdGlvbnMub25EZXN0cm95U2NvcGUpIG9wdGlvbnMub25EZXN0cm95U2NvcGUoKTtcbiAgfVxuXG4gIC8vIEFkZCBpZGVudGlmaWVyIG5hbWUgdG8gdGhlIGN1cnJlbnQgc2NvcGUgaWYgaXQgZG9lc250IGFscmVhZHkgZXhpc3QuXG4gIGZ1bmN0aW9uIHNjb3BlSWRlbnRpZmllck5hbWUobmFtZSkge1xuICAgIGlmIChvcHRpb25zLm9uTG9jYWxEZWNsYXJhdGlvbikgb3B0aW9ucy5vbkxvY2FsRGVjbGFyYXRpb24obmFtZSk7XG4gICAgaWYgKC0xICE9PSBpbmRleE9mKHNjb3Blc1tzY29wZURlcHRoXSwgbmFtZSkpIHJldHVybjtcbiAgICBzY29wZXNbc2NvcGVEZXB0aF0ucHVzaChuYW1lKTtcbiAgfVxuXG4gIC8vIEFkZCBpZGVudGlmaWVyIHRvIHRoZSBjdXJyZW50IHNjb3BlXG4gIGZ1bmN0aW9uIHNjb3BlSWRlbnRpZmllcihub2RlKSB7XG4gICAgc2NvcGVJZGVudGlmaWVyTmFtZShub2RlLm5hbWUpO1xuICAgIGF0dGFjaFNjb3BlKG5vZGUsIHRydWUpO1xuICB9XG5cbiAgLy8gQXR0YWNoIHNjb3BlIGluZm9ybWF0aW9uIHRvIG5vZGUuIElmIHRoZSBub2RlIGlzIGdsb2JhbCwgc3RvcmUgaXQgaW4gdGhlXG4gIC8vIGdsb2JhbHMgYXJyYXkgc28gd2UgY2FuIHJldHVybiB0aGUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXG4gIGZ1bmN0aW9uIGF0dGFjaFNjb3BlKG5vZGUsIGlzTG9jYWwpIHtcbiAgICBpZiAoIWlzTG9jYWwgJiYgLTEgPT09IGluZGV4T2ZPYmplY3QoZ2xvYmFscywgJ25hbWUnLCBub2RlLm5hbWUpKVxuICAgICAgZ2xvYmFscy5wdXNoKG5vZGUpO1xuXG4gICAgbm9kZS5pc0xvY2FsID0gaXNMb2NhbDtcbiAgfVxuXG4gIC8vIElzIHRoZSBpZGVudGlmaWVyIG5hbWUgYXZhaWxhYmxlIGluIHRoaXMgc2NvcGUuXG4gIGZ1bmN0aW9uIHNjb3BlSGFzTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuICgtMSAhPT0gaW5kZXhPZihzY29wZXNbc2NvcGVEZXB0aF0sIG5hbWUpKTtcbiAgfVxuXG4gIC8vIExvY2F0aW9uIHRyYWNraW5nXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIExvY2F0aW9ucyBhcmUgc3RvcmVkIGluIEZJTE8tYXJyYXkgYXMgYSBgTWFya2VyYCBvYmplY3QgY29uc2lzdGluZyBvZiBib3RoXG4gIC8vIGBsb2NgIGFuZCBgcmFuZ2VgIGRhdGEuIE9uY2UgYSBgTWFya2VyYCBpcyBwb3BwZWQgb2ZmIHRoZSBsaXN0IGFuIGVuZFxuICAvLyBsb2NhdGlvbiBpcyBhZGRlZCBhbmQgdGhlIGRhdGEgaXMgYXR0YWNoZWQgdG8gYSBzeW50YXggbm9kZS5cblxuICB2YXIgbG9jYXRpb25zID0gW11cbiAgICAsIHRyYWNrTG9jYXRpb25zO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uTWFya2VyKCkge1xuICAgIHJldHVybiBuZXcgTWFya2VyKHRva2VuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1hcmtlcih0b2tlbikge1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgdGhpcy5sb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGxpbmU6IHRva2VuLmxpbmVcbiAgICAgICAgICAsIGNvbHVtbjogdG9rZW4ucmFuZ2VbMF0gLSB0b2tlbi5saW5lU3RhcnRcbiAgICAgICAgfVxuICAgICAgICAsIGVuZDoge1xuICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICwgY29sdW1uOiAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcykgdGhpcy5yYW5nZSA9IFt0b2tlbi5yYW5nZVswXSwgMF07XG4gIH1cblxuICAvLyBDb21wbGV0ZSB0aGUgbG9jYXRpb24gZGF0YSBzdG9yZWQgaW4gdGhlIGBNYXJrZXJgIGJ5IGFkZGluZyB0aGUgbG9jYXRpb25cbiAgLy8gb2YgdGhlICpwcmV2aW91cyB0b2tlbiogYXMgYW4gZW5kIGxvY2F0aW9uLlxuICBNYXJrZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICB0aGlzLmxvYy5lbmQubGluZSA9IHByZXZpb3VzVG9rZW4ubGFzdExpbmUgfHwgcHJldmlvdXNUb2tlbi5saW5lO1xuICAgICAgdGhpcy5sb2MuZW5kLmNvbHVtbiA9IHByZXZpb3VzVG9rZW4ucmFuZ2VbMV0gLSAocHJldmlvdXNUb2tlbi5sYXN0TGluZVN0YXJ0IHx8IHByZXZpb3VzVG9rZW4ubGluZVN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICB0aGlzLnJhbmdlWzFdID0gcHJldmlvdXNUb2tlbi5yYW5nZVsxXTtcbiAgICB9XG4gIH07XG5cbiAgTWFya2VyLnByb3RvdHlwZS5ibGVzcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKHRoaXMubG9jKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5sb2M7XG4gICAgICBub2RlLmxvYyA9IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBsaW5lOiBsb2Muc3RhcnQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGxvYy5zdGFydC5jb2x1bW5cbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgbGluZTogbG9jLmVuZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogbG9jLmVuZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmFuZ2UpIHtcbiAgICAgIG5vZGUucmFuZ2UgPSBbXG4gICAgICAgIHRoaXMucmFuZ2VbMF0sXG4gICAgICAgIHRoaXMucmFuZ2VbMV1cbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8vIENyZWF0ZSBhIG5ldyBgTWFya2VyYCBhbmQgYWRkIGl0IHRvIHRoZSBGSUxPLWFycmF5LlxuICBmdW5jdGlvbiBtYXJrTG9jYXRpb24oKSB7XG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBsb2NhdGlvbnMucHVzaChjcmVhdGVMb2NhdGlvbk1hcmtlcigpKTtcbiAgfVxuXG4gIC8vIFB1c2ggYW4gYXJiaXRyYXJ5IGBNYXJrZXJgIG9iamVjdCBvbnRvIHRoZSBGSUxPLWFycmF5LlxuICBmdW5jdGlvbiBwdXNoTG9jYXRpb24obWFya2VyKSB7XG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBsb2NhdGlvbnMucHVzaChtYXJrZXIpO1xuICB9XG5cbiAgLy8gQ29udHJvbCBmbG93IHRyYWNraW5nXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBIGNvbnRleHQgb2JqZWN0IHRoYXQgdmFsaWRhdGVzIGxvb3AgYnJlYWtzIGFuZCBgZ290b2AtYmFzZWQgY29udHJvbCBmbG93LlxuXG4gIGZ1bmN0aW9uIEZ1bGxGbG93Q29udGV4dCgpIHtcbiAgICB0aGlzLnNjb3BlcyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0dvdG9zID0gW107XG4gIH1cblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLmlzSW5Mb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gdGhpcy5zY29wZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpIC0tPiAwKSB7XG4gICAgICBpZiAodGhpcy5zY29wZXNbaV0uaXNMb29wKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUucHVzaFNjb3BlID0gZnVuY3Rpb24gKGlzTG9vcCkge1xuICAgIHZhciBzY29wZSA9IHtcbiAgICAgIGxhYmVsczoge30sXG4gICAgICBsb2NhbHM6IFtdLFxuICAgICAgZGVmZXJyZWRHb3RvczogW10sXG4gICAgICBpc0xvb3A6ICEhaXNMb29wXG4gICAgfTtcbiAgICB0aGlzLnNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLnBvcFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nR290b3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0aGVHb3RvID0gdGhpcy5wZW5kaW5nR290b3NbaV07XG4gICAgICBpZiAodGhlR290by5tYXhEZXB0aCA+PSB0aGlzLnNjb3Blcy5sZW5ndGgpXG4gICAgICAgIGlmICgtLXRoZUdvdG8ubWF4RGVwdGggPD0gMClcbiAgICAgICAgICByYWlzZSh0aGVHb3RvLnRva2VuLCBlcnJvcnMubGFiZWxOb3RWaXNpYmxlLCB0aGVHb3RvLnRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY29wZXMucG9wKCk7XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRHb3RvID0gZnVuY3Rpb24gKHRhcmdldCwgdG9rZW4pIHtcbiAgICB2YXIgbG9jYWxDb3VudHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zY29wZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVzW2ldO1xuICAgICAgbG9jYWxDb3VudHMucHVzaChzY29wZS5sb2NhbHMubGVuZ3RoKTtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NvcGUubGFiZWxzLCB0YXJnZXQpKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nR290b3MucHVzaCh7XG4gICAgICBtYXhEZXB0aDogdGhpcy5zY29wZXMubGVuZ3RoLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICB0b2tlbjogdG9rZW4sXG4gICAgICBsb2NhbENvdW50czogbG9jYWxDb3VudHNcbiAgICB9KTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLmFkZExhYmVsID0gZnVuY3Rpb24gKG5hbWUsIHRva2VuKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NvcGUubGFiZWxzLCBuYW1lKSkge1xuICAgICAgcmFpc2UodG9rZW4sIGVycm9ycy5sYWJlbEFscmVhZHlEZWZpbmVkLCBuYW1lLCBzY29wZS5sYWJlbHNbbmFtZV0ubGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdHb3RvcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0dvdG9zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0aGVHb3RvID0gdGhpcy5wZW5kaW5nR290b3NbaV07XG5cbiAgICAgICAgaWYgKHRoZUdvdG8ubWF4RGVwdGggPj0gdGhpcy5zY29wZXMubGVuZ3RoICYmIHRoZUdvdG8udGFyZ2V0ID09PSBuYW1lKSB7XG4gICAgICAgICAgaWYgKHRoZUdvdG8ubG9jYWxDb3VudHNbdGhpcy5zY29wZXMubGVuZ3RoIC0gMV0gPCBzY29wZS5sb2NhbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzY29wZS5kZWZlcnJlZEdvdG9zLnB1c2godGhlR290byk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3R290b3MucHVzaCh0aGVHb3RvKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZW5kaW5nR290b3MgPSBuZXdHb3RvcztcbiAgICB9XG5cbiAgICBzY29wZS5sYWJlbHNbbmFtZV0gPSB7XG4gICAgICBsb2NhbENvdW50OiBzY29wZS5sb2NhbHMubGVuZ3RoLFxuICAgICAgbGluZTogdG9rZW4ubGluZVxuICAgIH07XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lLCB0b2tlbikge1xuICAgIHRoaXMuY3VycmVudFNjb3BlKCkubG9jYWxzLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHRva2VuOiB0b2tlblxuICAgIH0pO1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUuY3VycmVudFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3Blc1t0aGlzLnNjb3Blcy5sZW5ndGggLSAxXTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLnJhaXNlRGVmZXJyZWRFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICB2YXIgYmFkcyA9IHNjb3BlLmRlZmVycmVkR290b3M7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdGhlR290byA9IGJhZHNbaV07XG4gICAgICByYWlzZSh0aGVHb3RvLnRva2VuLCBlcnJvcnMuZ290b0p1bXBJbkxvY2FsU2NvcGUsIHRoZUdvdG8udGFyZ2V0LCBzY29wZS5sb2NhbHNbdGhlR290by5sb2NhbENvdW50c1t0aGlzLnNjb3Blcy5sZW5ndGggLSAxXV0ubmFtZSk7XG4gICAgfVxuICAgIC8vIFdvdWxkIGJlIGRlYWQgY29kZSBjdXJyZW50bHksIGJ1dCBtYXkgYmUgdXNlZnVsIGxhdGVyXG4gICAgLy8gaWYgKGJhZHMubGVuZ3RoKVxuICAgIC8vICAgc2NvcGUuZGVmZXJyZWRHb3RvcyA9IFtdO1xuICB9O1xuXG4gIC8vIFNpbXBsaWZpZWQgY29udGV4dCB0aGF0IG9ubHkgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBsb29wIGJyZWFrcy5cblxuICBmdW5jdGlvbiBMb29wRmxvd0NvbnRleHQoKSB7XG4gICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgdGhpcy5sb29wTGV2ZWxzID0gW107XG4gIH1cblxuICBMb29wRmxvd0NvbnRleHQucHJvdG90eXBlLmlzSW5Mb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMubG9vcExldmVscy5sZW5ndGg7XG4gIH07XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5wdXNoU2NvcGUgPSBmdW5jdGlvbiAoaXNMb29wKSB7XG4gICAgKyt0aGlzLmxldmVsO1xuICAgIGlmIChpc0xvb3ApXG4gICAgICB0aGlzLmxvb3BMZXZlbHMucHVzaCh0aGlzLmxldmVsKTtcbiAgfTtcblxuICBMb29wRmxvd0NvbnRleHQucHJvdG90eXBlLnBvcFNjb3BlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxvb3BMZXZlbHM7XG4gICAgdmFyIGxldmxlbiA9IGxldmVscy5sZW5ndGg7XG4gICAgaWYgKGxldmxlbikge1xuICAgICAgaWYgKGxldmVsc1tsZXZsZW4gLSAxXSA9PT0gdGhpcy5sZXZlbClcbiAgICAgICAgbGV2ZWxzLnBvcCgpO1xuICAgIH1cbiAgICAtLXRoaXMubGV2ZWw7XG4gIH07XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRHb3RvID1cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRMYWJlbCA9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4nKTsgfTtcblxuICBMb29wRmxvd0NvbnRleHQucHJvdG90eXBlLmFkZExvY2FsID1cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5yYWlzZURlZmVycmVkRXJyb3JzID1cbiAgZnVuY3Rpb24gKCkge307XG5cbiAgZnVuY3Rpb24gbWFrZUZsb3dDb250ZXh0KCkge1xuICAgIHJldHVybiBmZWF0dXJlcy5sYWJlbHMgPyBuZXcgRnVsbEZsb3dDb250ZXh0KCkgOiBuZXcgTG9vcEZsb3dDb250ZXh0KCk7XG4gIH1cblxuICAvLyBQYXJzZSBmdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQ2h1bmsgaXMgdGhlIG1haW4gcHJvZ3JhbSBvYmplY3QuIFN5bnRhY3RpY2FsbHkgaXQncyB0aGUgc2FtZSBhcyBhIGJsb2NrLlxuICAvL1xuICAvLyAgICAgY2h1bmsgOjo9IGJsb2NrXG5cbiAgZnVuY3Rpb24gcGFyc2VDaHVuaygpIHtcbiAgICBuZXh0KCk7XG4gICAgbWFya0xvY2F0aW9uKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgdmFyIGZsb3dDb250ZXh0ID0gbWFrZUZsb3dDb250ZXh0KCk7XG4gICAgZmxvd0NvbnRleHQuYWxsb3dWYXJhcmcgPSB0cnVlO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgIHZhciBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgaWYgKEVPRiAhPT0gdG9rZW4udHlwZSkgdW5leHBlY3RlZCh0b2tlbik7XG4gICAgLy8gSWYgdGhlIGJvZHkgaXMgZW1wdHkgbm8gcHJldmlvdXNUb2tlbiBleGlzdHMgd2hlbiBmaW5pc2hOb2RlIHJ1bnMuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zICYmICFib2R5Lmxlbmd0aCkgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5jaHVuayhib2R5KSk7XG4gIH1cblxuICAvLyBBIGJsb2NrIGNvbnRhaW5zIGEgbGlzdCBvZiBzdGF0ZW1lbnRzIHdpdGggYW4gb3B0aW9uYWwgcmV0dXJuIHN0YXRlbWVudFxuICAvLyBhcyBpdHMgbGFzdCBzdGF0ZW1lbnQuXG4gIC8vXG4gIC8vICAgICBibG9jayA6Oj0ge3N0YXR9IFtyZXRzdGF0XVxuXG4gIGZ1bmN0aW9uIHBhcnNlQmxvY2soZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgYmxvY2sgPSBbXVxuICAgICAgLCBzdGF0ZW1lbnQ7XG5cbiAgICB3aGlsZSAoIWlzQmxvY2tGb2xsb3codG9rZW4pKSB7XG4gICAgICAvLyBSZXR1cm4gaGFzIHRvIGJlIHRoZSBsYXN0IHN0YXRlbWVudCBpbiBhIGJsb2NrLlxuICAgICAgLy8gTGlrZXdpc2UgJ2JyZWFrJyBpbiBMdWEgb2xkZXIgdGhhbiA1LjJcbiAgICAgIGlmICgncmV0dXJuJyA9PT0gdG9rZW4udmFsdWUgfHwgKCFmZWF0dXJlcy5yZWxheGVkQnJlYWsgJiYgJ2JyZWFrJyA9PT0gdG9rZW4udmFsdWUpKSB7XG4gICAgICAgIGJsb2NrLnB1c2gocGFyc2VTdGF0ZW1lbnQoZmxvd0NvbnRleHQpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICBjb25zdW1lKCc7Jyk7XG4gICAgICAvLyBTdGF0ZW1lbnRzIGFyZSBvbmx5IGFkZGVkIGlmIHRoZXkgYXJlIHJldHVybmVkLCB0aGlzIGFsbG93cyB1cyB0b1xuICAgICAgLy8gaWdub3JlIHNvbWUgc3RhdGVtZW50cywgc3VjaCBhcyBFbXB0eVN0YXRlbWVudC5cbiAgICAgIGlmIChzdGF0ZW1lbnQpIGJsb2NrLnB1c2goc3RhdGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBEb2Vzbid0IHJlYWxseSBuZWVkIGFuIGFzdCBub2RlXG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgLy8gVGhlcmUgYXJlIHR3byB0eXBlcyBvZiBzdGF0ZW1lbnRzLCBzaW1wbGUgYW5kIGNvbXBvdW5kLlxuICAvL1xuICAvLyAgICAgc3RhdGVtZW50IDo6PSBicmVhayB8IGdvdG8gfCBkbyB8IHdoaWxlIHwgcmVwZWF0IHwgcmV0dXJuXG4gIC8vICAgICAgICAgIHwgaWYgfCBmb3IgfCBmdW5jdGlvbiB8IGxvY2FsIHwgbGFiZWwgfCBhc3NpZ25tZW50XG4gIC8vICAgICAgICAgIHwgZnVuY3Rpb25jYWxsIHwgJzsnXG5cbiAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICBtYXJrTG9jYXRpb24oKTtcblxuICAgIGlmIChQdW5jdHVhdG9yID09PSB0b2tlbi50eXBlKSB7XG4gICAgICBpZiAoY29uc3VtZSgnOjonKSkgcmV0dXJuIHBhcnNlTGFiZWxTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYSBgO2AgaXMgZW5jb3VudGVkLCBzaW1wbHkgZWF0IGl0IHdpdGhvdXQgc3RvcmluZyBpdC5cbiAgICBpZiAoZmVhdHVyZXMuZW1wdHlTdGF0ZW1lbnQpIHtcbiAgICAgIGlmIChjb25zdW1lKCc7JykpIHtcbiAgICAgICAgaWYgKHRyYWNrTG9jYXRpb25zKSBsb2NhdGlvbnMucG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmbG93Q29udGV4dC5yYWlzZURlZmVycmVkRXJyb3JzKCk7XG5cbiAgICBpZiAoS2V5d29yZCA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdsb2NhbCc6ICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlTG9jYWxTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdpZic6ICAgICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlSWZTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdyZXR1cm4nOiAgIG5leHQoKTsgcmV0dXJuIHBhcnNlUmV0dXJuU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOiBuZXh0KCk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwYXJzZUZ1bmN0aW9uTmFtZSgpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obmFtZSk7XG4gICAgICAgIGNhc2UgJ3doaWxlJzogICAgbmV4dCgpOyByZXR1cm4gcGFyc2VXaGlsZVN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2Zvcic6ICAgICAgbmV4dCgpOyByZXR1cm4gcGFyc2VGb3JTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdyZXBlYXQnOiAgIG5leHQoKTsgcmV0dXJuIHBhcnNlUmVwZWF0U3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAnYnJlYWsnOiAgICBuZXh0KCk7XG4gICAgICAgICAgaWYgKCFmbG93Q29udGV4dC5pc0luTG9vcCgpKVxuICAgICAgICAgICAgcmFpc2UodG9rZW4sIGVycm9ycy5ub0xvb3BUb0JyZWFrLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKTtcbiAgICAgICAgY2FzZSAnZG8nOiAgICAgICBuZXh0KCk7IHJldHVybiBwYXJzZURvU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAnZ290byc6ICAgICBuZXh0KCk7IHJldHVybiBwYXJzZUdvdG9TdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmZWF0dXJlcy5jb250ZXh0dWFsR290byAmJlxuICAgICAgICB0b2tlbi50eXBlID09PSBJZGVudGlmaWVyICYmIHRva2VuLnZhbHVlID09PSAnZ290bycgJiZcbiAgICAgICAgbG9va2FoZWFkLnR5cGUgPT09IElkZW50aWZpZXIgJiYgbG9va2FoZWFkLnZhbHVlICE9PSAnZ290bycpIHtcbiAgICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlR290b1N0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gQXNzaWdubWVudHMgbWVtb3JpemVzIHRoZSBsb2NhdGlvbiBhbmQgcHVzaGVzIGl0IG1hbnVhbGx5IGZvciB3cmFwcGVyIG5vZGVzLlxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnBvcCgpO1xuXG4gICAgcmV0dXJuIHBhcnNlQXNzaWdubWVudE9yQ2FsbFN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gIH1cblxuICAvLyAjIyBTdGF0ZW1lbnRzXG5cbiAgLy8gICAgIGxhYmVsIDo6PSAnOjonIE5hbWUgJzo6J1xuXG4gIGZ1bmN0aW9uIHBhcnNlTGFiZWxTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgbmFtZVRva2VuID0gdG9rZW5cbiAgICAgICwgbGFiZWwgPSBwYXJzZUlkZW50aWZpZXIoKTtcblxuICAgIGlmIChvcHRpb25zLnNjb3BlKSB7XG4gICAgICBzY29wZUlkZW50aWZpZXJOYW1lKCc6OicgKyBuYW1lVG9rZW4udmFsdWUgKyAnOjonKTtcbiAgICAgIGF0dGFjaFNjb3BlKGxhYmVsLCB0cnVlKTtcbiAgICB9XG5cbiAgICBleHBlY3QoJzo6Jyk7XG5cbiAgICBmbG93Q29udGV4dC5hZGRMYWJlbChuYW1lVG9rZW4udmFsdWUsIG5hbWVUb2tlbik7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmxhYmVsU3RhdGVtZW50KGxhYmVsKSk7XG4gIH1cblxuICAvLyAgICAgYnJlYWsgOjo9ICdicmVhaydcblxuICBmdW5jdGlvbiBwYXJzZUJyZWFrU3RhdGVtZW50KCkge1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5icmVha1N0YXRlbWVudCgpKTtcbiAgfVxuXG4gIC8vICAgICBnb3RvIDo6PSAnZ290bycgTmFtZVxuXG4gIGZ1bmN0aW9uIHBhcnNlR290b1N0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBuYW1lID0gdG9rZW4udmFsdWVcbiAgICAgICwgZ290b1Rva2VuID0gcHJldmlvdXNUb2tlblxuICAgICAgLCBsYWJlbCA9IHBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgZmxvd0NvbnRleHQuYWRkR290byhuYW1lLCBnb3RvVG9rZW4pO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5nb3RvU3RhdGVtZW50KGxhYmVsKSk7XG4gIH1cblxuICAvLyAgICAgZG8gOjo9ICdkbycgYmxvY2sgJ2VuZCdcblxuICBmdW5jdGlvbiBwYXJzZURvU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKCk7XG4gICAgdmFyIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICBleHBlY3QoJ2VuZCcpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5kb1N0YXRlbWVudChib2R5KSk7XG4gIH1cblxuICAvLyAgICAgd2hpbGUgOjo9ICd3aGlsZScgZXhwICdkbycgYmxvY2sgJ2VuZCdcblxuICBmdW5jdGlvbiBwYXJzZVdoaWxlU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGNvbmRpdGlvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICBleHBlY3QoJ2RvJyk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKHRydWUpO1xuICAgIHZhciBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgZXhwZWN0KCdlbmQnKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3Qud2hpbGVTdGF0ZW1lbnQoY29uZGl0aW9uLCBib2R5KSk7XG4gIH1cblxuICAvLyAgICAgcmVwZWF0IDo6PSAncmVwZWF0JyBibG9jayAndW50aWwnIGV4cFxuXG4gIGZ1bmN0aW9uIHBhcnNlUmVwZWF0U3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKHRydWUpO1xuICAgIHZhciBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgZXhwZWN0KCd1bnRpbCcpO1xuICAgIGZsb3dDb250ZXh0LnJhaXNlRGVmZXJyZWRFcnJvcnMoKTtcbiAgICB2YXIgY29uZGl0aW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5yZXBlYXRTdGF0ZW1lbnQoY29uZGl0aW9uLCBib2R5KSk7XG4gIH1cblxuICAvLyAgICAgcmV0c3RhdCA6Oj0gJ3JldHVybicgW2V4cCB7JywnIGV4cH1dIFsnOyddXG5cbiAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcblxuICAgIGlmICgnZW5kJyAhPT0gdG9rZW4udmFsdWUpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIGlmIChudWxsICE9IGV4cHJlc3Npb24pIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICB3aGlsZSAoY29uc3VtZSgnLCcpKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgICBjb25zdW1lKCc7Jyk7IC8vIGdyYW1tYXIgdGVsbHMgdXMgOyBpcyBvcHRpb25hbCBoZXJlLlxuICAgIH1cbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QucmV0dXJuU3RhdGVtZW50KGV4cHJlc3Npb25zKSk7XG4gIH1cblxuICAvLyAgICAgaWYgOjo9ICdpZicgZXhwICd0aGVuJyBibG9jayB7ZWxpZn0gWydlbHNlJyBibG9ja10gJ2VuZCdcbiAgLy8gICAgIGVsaWYgOjo9ICdlbHNlaWYnIGV4cCAndGhlbicgYmxvY2tcblxuICBmdW5jdGlvbiBwYXJzZUlmU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGNsYXVzZXMgPSBbXVxuICAgICAgLCBjb25kaXRpb25cbiAgICAgICwgYm9keVxuICAgICAgLCBtYXJrZXI7XG5cbiAgICAvLyBJZkNsYXVzZXMgYmVnaW4gYXQgdGhlIHNhbWUgbG9jYXRpb24gYXMgdGhlIHBhcmVudCBJZlN0YXRlbWVudC5cbiAgICAvLyBJdCBlbmRzIGF0IHRoZSBzdGFydCBvZiBgZW5kYCwgYGVsc2VgLCBvciBgZWxzZWlmYC5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIHtcbiAgICAgIG1hcmtlciA9IGxvY2F0aW9uc1tsb2NhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICBsb2NhdGlvbnMucHVzaChtYXJrZXIpO1xuICAgIH1cbiAgICBjb25kaXRpb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgZXhwZWN0KCd0aGVuJyk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKCk7XG4gICAgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgIGNsYXVzZXMucHVzaChmaW5pc2hOb2RlKGFzdC5pZkNsYXVzZShjb25kaXRpb24sIGJvZHkpKSk7XG5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG4gICAgd2hpbGUgKGNvbnN1bWUoJ2Vsc2VpZicpKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIGNvbmRpdGlvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIGV4cGVjdCgndGhlbicpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUoKTtcbiAgICAgIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgICBjbGF1c2VzLnB1c2goZmluaXNoTm9kZShhc3QuZWxzZWlmQ2xhdXNlKGNvbmRpdGlvbiwgYm9keSkpKTtcbiAgICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3VtZSgnZWxzZScpKSB7XG4gICAgICAvLyBJbmNsdWRlIHRoZSBgZWxzZWAgaW4gdGhlIGxvY2F0aW9uIG9mIEVsc2VDbGF1c2UuXG4gICAgICBpZiAodHJhY2tMb2NhdGlvbnMpIHtcbiAgICAgICAgbWFya2VyID0gbmV3IE1hcmtlcihwcmV2aW91c1Rva2VuKTtcbiAgICAgICAgbG9jYXRpb25zLnB1c2gobWFya2VyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKCk7XG4gICAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgICAgY2xhdXNlcy5wdXNoKGZpbmlzaE5vZGUoYXN0LmVsc2VDbGF1c2UoYm9keSkpKTtcbiAgICB9XG5cbiAgICBleHBlY3QoJ2VuZCcpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5pZlN0YXRlbWVudChjbGF1c2VzKSk7XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGZvciBzdGF0ZW1lbnRzLCBnZW5lcmljIGFuZCBudW1lcmljLlxuICAvL1xuICAvLyAgICAgZm9yIDo6PSBOYW1lICc9JyBleHAgJywnIGV4cCBbJywnIGV4cF0gJ2RvJyBibG9jayAnZW5kJ1xuICAvLyAgICAgZm9yIDo6PSBuYW1lbGlzdCAnaW4nIGV4cGxpc3QgJ2RvJyBibG9jayAnZW5kJ1xuICAvLyAgICAgbmFtZWxpc3QgOjo9IE5hbWUgeycsJyBOYW1lfVxuICAvLyAgICAgZXhwbGlzdCA6Oj0gZXhwIHsnLCcgZXhwfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIHZhcmlhYmxlID0gcGFyc2VJZGVudGlmaWVyKClcbiAgICAgICwgYm9keTtcblxuICAgIC8vIFRoZSBzdGFydC1pZGVudGlmaWVyIGlzIGxvY2FsLlxuXG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIHtcbiAgICAgIGNyZWF0ZVNjb3BlKCk7XG4gICAgICBzY29wZUlkZW50aWZpZXIodmFyaWFibGUpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBmaXJzdCBleHByZXNzaW9uIGlzIGZvbGxvd2VkIGJ5IGEgYD1gIHB1bmN0dWF0b3IsIHRoaXMgaXMgYVxuICAgIC8vIE51bWVyaWMgRm9yIFN0YXRlbWVudC5cbiAgICBpZiAoY29uc3VtZSgnPScpKSB7XG4gICAgICAvLyBTdGFydCBleHByZXNzaW9uXG4gICAgICB2YXIgc3RhcnQgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICBleHBlY3QoJywnKTtcbiAgICAgIC8vIEVuZCBleHByZXNzaW9uXG4gICAgICB2YXIgZW5kID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgLy8gT3B0aW9uYWwgc3RlcCBleHByZXNzaW9uXG4gICAgICB2YXIgc3RlcCA9IGNvbnN1bWUoJywnKSA/IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KSA6IG51bGw7XG5cbiAgICAgIGV4cGVjdCgnZG8nKTtcbiAgICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSh0cnVlKTtcbiAgICAgIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgICBleHBlY3QoJ2VuZCcpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZm9yTnVtZXJpY1N0YXRlbWVudCh2YXJpYWJsZSwgc3RhcnQsIGVuZCwgc3RlcCwgYm9keSkpO1xuICAgIH1cbiAgICAvLyBJZiBub3QsIGl0J3MgYSBHZW5lcmljIEZvciBTdGF0ZW1lbnRcbiAgICBlbHNlIHtcbiAgICAgIC8vIFRoZSBuYW1lbGlzdCBjYW4gY29udGFpbiBvbmUgb3IgbW9yZSBpZGVudGlmaWVycy5cbiAgICAgIHZhciB2YXJpYWJsZXMgPSBbdmFyaWFibGVdO1xuICAgICAgd2hpbGUgKGNvbnN1bWUoJywnKSkge1xuICAgICAgICB2YXJpYWJsZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAvLyBFYWNoIHZhcmlhYmxlIGluIHRoZSBuYW1lbGlzdCBpcyBsb2NhbGx5IHNjb3BlZC5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIHNjb3BlSWRlbnRpZmllcih2YXJpYWJsZSk7XG4gICAgICAgIHZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICAgIH1cbiAgICAgIGV4cGVjdCgnaW4nKTtcbiAgICAgIHZhciBpdGVyYXRvcnMgPSBbXTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgZXhwcmVzc2lvbnMgaW4gdGhlIGV4cGxpc3QuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICBpdGVyYXRvcnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgIH0gd2hpbGUgKGNvbnN1bWUoJywnKSk7XG5cbiAgICAgIGV4cGVjdCgnZG8nKTtcbiAgICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSh0cnVlKTtcbiAgICAgIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgICBleHBlY3QoJ2VuZCcpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZm9yR2VuZXJpY1N0YXRlbWVudCh2YXJpYWJsZXMsIGl0ZXJhdG9ycywgYm9keSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIExvY2FsIHN0YXRlbWVudHMgY2FuIGVpdGhlciBiZSB2YXJpYWJsZSBhc3NpZ25tZW50cyBvciBmdW5jdGlvblxuICAvLyBkZWZpbml0aW9ucy4gSWYgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGlzIGZvdW5kLCBpdCB3aWxsIGJlIGRlbGVnYXRlZCB0b1xuICAvLyBgcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKClgIHdpdGggdGhlIGlzTG9jYWwgZmxhZy5cbiAgLy9cbiAgLy8gVGhpcyBBU1Qgc3RydWN0dXJlIG1pZ2h0IGNoYW5nZSBpbnRvIGEgbG9jYWwgYXNzaWdubWVudCB3aXRoIGEgZnVuY3Rpb25cbiAgLy8gY2hpbGQuXG4gIC8vXG4gIC8vICAgICBsb2NhbCA6Oj0gJ2xvY2FsJyAnZnVuY3Rpb24nIE5hbWUgZnVuY2RlY2xcbiAgLy8gICAgICAgIHwgJ2xvY2FsJyBOYW1lIHsnLCcgTmFtZX0gWyc9JyBleHAgeycsJyBleHB9XVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgbmFtZVxuICAgICAgLCBkZWNsVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuXG4gICAgaWYgKElkZW50aWZpZXIgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIHZhciB2YXJpYWJsZXMgPSBbXVxuICAgICAgICAsIGluaXQgPSBbXTtcblxuICAgICAgZG8ge1xuICAgICAgICBuYW1lID0gcGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgdmFyaWFibGVzLnB1c2gobmFtZSk7XG4gICAgICAgIGZsb3dDb250ZXh0LmFkZExvY2FsKG5hbWUubmFtZSwgZGVjbFRva2VuKTtcbiAgICAgIH0gd2hpbGUgKGNvbnN1bWUoJywnKSk7XG5cbiAgICAgIGlmIChjb25zdW1lKCc9JykpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgIGluaXQucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgfSB3aGlsZSAoY29uc3VtZSgnLCcpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVjbGFyYXRpb25zIGRvZXNuJ3QgZXhpc3QgYmVmb3JlIHRoZSBzdGF0ZW1lbnQgaGFzIGJlZW4gZXZhbHVhdGVkLlxuICAgICAgLy8gVGhlcmVmb3JlIGFzc2lnbm1lbnRzIGNhbid0IHVzZSB0aGVpciBkZWNsYXJhdG9yLiBBbmQgdGhlIGlkZW50aWZpZXJzXG4gICAgICAvLyBzaG91bGRuJ3QgYmUgYWRkZWQgdG8gdGhlIHNjb3BlIHVudGlsIHRoZSBzdGF0ZW1lbnQgaXMgY29tcGxldGUuXG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhcmlhYmxlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBzY29wZUlkZW50aWZpZXIodmFyaWFibGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QubG9jYWxTdGF0ZW1lbnQodmFyaWFibGVzLCBpbml0KSk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lKCdmdW5jdGlvbicpKSB7XG4gICAgICBuYW1lID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBmbG93Q29udGV4dC5hZGRMb2NhbChuYW1lLm5hbWUsIGRlY2xUb2tlbik7XG5cbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIHNjb3BlSWRlbnRpZmllcihuYW1lKTtcbiAgICAgICAgY3JlYXRlU2NvcGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVtYmVyRXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGxvY2FsIGZ1bmN0aW9uIHN0YXRlbWVudHMuXG4gICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5hbWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYWlzZVVuZXhwZWN0ZWRUb2tlbignPG5hbWU+JywgdG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vICAgICBhc3NpZ25tZW50IDo6PSB2YXJsaXN0ICc9JyBleHBsaXN0XG4gIC8vICAgICB2YXIgOjo9IE5hbWUgfCBwcmVmaXhleHAgJ1snIGV4cCAnXScgfCBwcmVmaXhleHAgJy4nIE5hbWVcbiAgLy8gICAgIHZhcmxpc3QgOjo9IHZhciB7JywnIHZhcn1cbiAgLy8gICAgIGV4cGxpc3QgOjo9IGV4cCB7JywnIGV4cH1cbiAgLy9cbiAgLy8gICAgIGNhbGwgOjo9IGNhbGxleHBcbiAgLy8gICAgIGNhbGxleHAgOjo9IHByZWZpeGV4cCBhcmdzIHwgcHJlZml4ZXhwICc6JyBOYW1lIGFyZ3NcblxuICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRPckNhbGxTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0b2tlbiBmb3IgYmV0dGVyIGVycm9yIG1lc3NhZ2VzIGluIGNhc2VcbiAgICAvLyBvZiBpbnZhbGlkIHN0YXRlbWVudFxuICAgIHZhciBwcmV2aW91cyA9IHRva2VuXG4gICAgICAsIG1hcmtlciwgc3RhcnRNYXJrZXI7XG4gICAgdmFyIGx2YWx1ZSwgYmFzZSwgbmFtZTtcblxuICAgIHZhciB0YXJnZXRzID0gW107XG5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIHN0YXJ0TWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgIGRvIHtcbiAgICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgICAgaWYgKElkZW50aWZpZXIgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgICAgbmFtZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICBiYXNlID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIC8vIFNldCB0aGUgcGFyZW50IHNjb3BlLlxuICAgICAgICBpZiAob3B0aW9ucy5zY29wZSkgYXR0YWNoU2NvcGUoYmFzZSwgc2NvcGVIYXNOYW1lKG5hbWUpKTtcbiAgICAgICAgbHZhbHVlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoJygnID09PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGJhc2UgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICBsdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgYm90aDogZm9yICg7Oykge1xuICAgICAgICB2YXIgbmV3QmFzZTtcblxuICAgICAgICBzd2l0Y2ggKFN0cmluZ0xpdGVyYWwgPT09IHRva2VuLnR5cGUgPyAnXCInIDogdG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgIGx2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICBsdmFsdWUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrIGJvdGg7XG4gICAgICAgIH1cblxuICAgICAgICBiYXNlID0gcGFyc2VQcmVmaXhFeHByZXNzaW9uUGFydChiYXNlLCBtYXJrZXIsIGZsb3dDb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0cy5wdXNoKGJhc2UpO1xuXG4gICAgICBpZiAoJywnICE9PSB0b2tlbi52YWx1ZSlcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGlmICghbHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB1bmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgbmV4dCgpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAxICYmIGx2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuY2FsbFN0YXRlbWVudCh0YXJnZXRzWzBdKSk7XG4gICAgfSBlbHNlIGlmICghbHZhbHVlKSB7XG4gICAgICByZXR1cm4gdW5leHBlY3RlZCh0b2tlbik7XG4gICAgfVxuXG4gICAgZXhwZWN0KCc9Jyk7XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBkbyB7XG4gICAgICB2YWx1ZXMucHVzaChwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCkpO1xuICAgIH0gd2hpbGUgKGNvbnN1bWUoJywnKSk7XG5cbiAgICBwdXNoTG9jYXRpb24oc3RhcnRNYXJrZXIpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5hc3NpZ25tZW50U3RhdGVtZW50KHRhcmdldHMsIHZhbHVlcykpO1xuICB9XG5cbiAgLy8gIyMjIE5vbi1zdGF0ZW1lbnRzXG5cbiAgLy8gICAgIElkZW50aWZpZXIgOjo9IE5hbWVcblxuICBmdW5jdGlvbiBwYXJzZUlkZW50aWZpZXIoKSB7XG4gICAgbWFya0xvY2F0aW9uKCk7XG4gICAgdmFyIGlkZW50aWZpZXIgPSB0b2tlbi52YWx1ZTtcbiAgICBpZiAoSWRlbnRpZmllciAhPT0gdG9rZW4udHlwZSkgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxuYW1lPicsIHRva2VuKTtcbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmlkZW50aWZpZXIoaWRlbnRpZmllcikpO1xuICB9XG5cbiAgLy8gUGFyc2UgdGhlIGZ1bmN0aW9ucyBwYXJhbWV0ZXJzIGFuZCBib2R5IGJsb2NrLiBUaGUgbmFtZSBzaG91bGQgYWxyZWFkeVxuICAvLyBoYXZlIGJlZW4gcGFyc2VkIGFuZCBwYXNzZWQgdG8gdGhpcyBkZWNsYXJhdGlvbiBmdW5jdGlvbi4gQnkgc2VwYXJhdGluZ1xuICAvLyB0aGlzIHdlIGFsbG93IGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIGluIGV4cHJlc3Npb25zLlxuICAvL1xuICAvLyBGb3IgbG9jYWwgZnVuY3Rpb25zIHRoZXJlJ3MgYSBib29sZWFuIHBhcmFtZXRlciB3aGljaCBuZWVkcyB0byBiZSBzZXRcbiAgLy8gd2hlbiBwYXJzaW5nIHRoZSBkZWNsYXJhdGlvbi5cbiAgLy9cbiAgLy8gICAgIGZ1bmNkZWNsIDo6PSAnKCcgW3Bhcmxpc3RdICcpJyBibG9jayAnZW5kJ1xuICAvLyAgICAgcGFybGlzdCA6Oj0gTmFtZSB7JywnIE5hbWV9IHwgWycsJyAnLi4uJ10gfCAnLi4uJ1xuXG4gIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuYW1lLCBpc0xvY2FsKSB7XG4gICAgdmFyIGZsb3dDb250ZXh0ID0gbWFrZUZsb3dDb250ZXh0KCk7XG4gICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKCk7XG5cbiAgICB2YXIgcGFyYW1ldGVycyA9IFtdO1xuICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgLy8gVGhlIGRlY2xhcmF0aW9uIGhhcyBhcmd1bWVudHNcbiAgICBpZiAoIWNvbnN1bWUoJyknKSkge1xuICAgICAgLy8gQXJndW1lbnRzIGFyZSBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGlkZW50aWZpZXJzLCBvcHRpb25hbGx5IGVuZGluZ1xuICAgICAgLy8gd2l0aCBhIHZhcmFyZy5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChJZGVudGlmaWVyID09PSB0b2tlbi50eXBlKSB7XG4gICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIC8vIEZ1bmN0aW9uIHBhcmFtZXRlcnMgYXJlIGxvY2FsLlxuICAgICAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBzY29wZUlkZW50aWZpZXIocGFyYW1ldGVyKTtcblxuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChwYXJhbWV0ZXIpO1xuXG4gICAgICAgICAgaWYgKGNvbnN1bWUoJywnKSkgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gYXJndW1lbnRzIGFyZSBhbGxvd2VkIGFmdGVyIGEgdmFyYXJnLlxuICAgICAgICBlbHNlIGlmIChWYXJhcmdMaXRlcmFsID09PSB0b2tlbi50eXBlKSB7XG4gICAgICAgICAgZmxvd0NvbnRleHQuYWxsb3dWYXJhcmcgPSB0cnVlO1xuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChwYXJzZVByaW1hcnlFeHByZXNzaW9uKGZsb3dDb250ZXh0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxuYW1lPiBvciBcXCcuLi5cXCcnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICBleHBlY3QoJ2VuZCcpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcblxuICAgIGlzTG9jYWwgPSBpc0xvY2FsIHx8IGZhbHNlO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5mdW5jdGlvblN0YXRlbWVudChuYW1lLCBwYXJhbWV0ZXJzLCBpc0xvY2FsLCBib2R5KSk7XG4gIH1cblxuICAvLyBQYXJzZSB0aGUgZnVuY3Rpb24gbmFtZSBhcyBpZGVudGlmaWVycyBhbmQgbWVtYmVyIGV4cHJlc3Npb25zLlxuICAvL1xuICAvLyAgICAgTmFtZSB7Jy4nIE5hbWV9IFsnOicgTmFtZV1cblxuICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uTmFtZSgpIHtcbiAgICB2YXIgYmFzZSwgbmFtZSwgbWFya2VyO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuICAgIGJhc2UgPSBwYXJzZUlkZW50aWZpZXIoKTtcblxuICAgIGlmIChvcHRpb25zLnNjb3BlKSB7XG4gICAgICBhdHRhY2hTY29wZShiYXNlLCBzY29wZUhhc05hbWUoYmFzZS5uYW1lKSk7XG4gICAgICBjcmVhdGVTY29wZSgpO1xuICAgIH1cblxuICAgIHdoaWxlIChjb25zdW1lKCcuJykpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgbmFtZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgYmFzZSA9IGZpbmlzaE5vZGUoYXN0Lm1lbWJlckV4cHJlc3Npb24oYmFzZSwgJy4nLCBuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnN1bWUoJzonKSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICBuYW1lID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBiYXNlID0gZmluaXNoTm9kZShhc3QubWVtYmVyRXhwcmVzc2lvbihiYXNlLCAnOicsIG5hbWUpKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBzY29wZUlkZW50aWZpZXJOYW1lKCdzZWxmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvLyAgICAgdGFibGVjb25zdHJ1Y3RvciA6Oj0gJ3snIFtmaWVsZGxpc3RdICd9J1xuICAvLyAgICAgZmllbGRsaXN0IDo6PSBmaWVsZCB7ZmllbGRzZXAgZmllbGR9IGZpZWxkc2VwXG4gIC8vICAgICBmaWVsZCA6Oj0gJ1snIGV4cCAnXScgJz0nIGV4cCB8IE5hbWUgPSAnZXhwJyB8IGV4cFxuICAvL1xuICAvLyAgICAgZmllbGRzZXAgOjo9ICcsJyB8ICc7J1xuXG4gIGZ1bmN0aW9uIHBhcnNlVGFibGVDb25zdHJ1Y3RvcihmbG93Q29udGV4dCkge1xuICAgIHZhciBmaWVsZHMgPSBbXVxuICAgICAgLCBrZXksIHZhbHVlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIG1hcmtMb2NhdGlvbigpO1xuICAgICAgaWYgKFB1bmN0dWF0b3IgPT09IHRva2VuLnR5cGUgJiYgY29uc3VtZSgnWycpKSB7XG4gICAgICAgIGtleSA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgZXhwZWN0KCddJyk7XG4gICAgICAgIGV4cGVjdCgnPScpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgZmllbGRzLnB1c2goZmluaXNoTm9kZShhc3QudGFibGVLZXkoa2V5LCB2YWx1ZSkpKTtcbiAgICAgIH0gZWxzZSBpZiAoSWRlbnRpZmllciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgICBpZiAoJz0nID09PSBsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICBrZXkgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgZmllbGRzLnB1c2goZmluaXNoTm9kZShhc3QudGFibGVLZXlTdHJpbmcoa2V5LCB2YWx1ZSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICBmaWVsZHMucHVzaChmaW5pc2hOb2RlKGFzdC50YWJsZVZhbHVlKHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobnVsbCA9PSAodmFsdWUgPSBwYXJzZUV4cHJlc3Npb24oZmxvd0NvbnRleHQpKSkge1xuICAgICAgICAgIGxvY2F0aW9ucy5wb3AoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMucHVzaChmaW5pc2hOb2RlKGFzdC50YWJsZVZhbHVlKHZhbHVlKSkpO1xuICAgICAgfVxuICAgICAgaWYgKCcsOycuaW5kZXhPZih0b2tlbi52YWx1ZSkgPj0gMCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGV4cGVjdCgnfScpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC50YWJsZUNvbnN0cnVjdG9yRXhwcmVzc2lvbihmaWVsZHMpKTtcbiAgfVxuXG4gIC8vIEV4cHJlc3Npb24gcGFyc2VyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEV4cHJlc3Npb25zIGFyZSBldmFsdWF0ZWQgYW5kIGFsd2F5cyByZXR1cm4gYSB2YWx1ZS4gSWYgbm90aGluZyBpc1xuICAvLyBtYXRjaGVkIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgLy9cbiAgLy8gICAgIGV4cCA6Oj0gKHVub3AgZXhwIHwgcHJpbWFyeSB8IHByZWZpeGV4cCApIHsgYmlub3AgZXhwIH1cbiAgLy9cbiAgLy8gICAgIHByaW1hcnkgOjo9IG5pbCB8IGZhbHNlIHwgdHJ1ZSB8IE51bWJlciB8IFN0cmluZyB8ICcuLi4nXG4gIC8vICAgICAgICAgIHwgZnVuY3Rpb25kZWYgfCB0YWJsZWNvbnN0cnVjdG9yXG4gIC8vXG4gIC8vICAgICBwcmVmaXhleHAgOjo9IChOYW1lIHwgJygnIGV4cCAnKScgKSB7ICdbJyBleHAgJ10nXG4gIC8vICAgICAgICAgIHwgJy4nIE5hbWUgfCAnOicgTmFtZSBhcmdzIHwgYXJncyB9XG4gIC8vXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVN1YkV4cHJlc3Npb24oMCwgZmxvd0NvbnRleHQpO1xuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG5cbiAgLy8gUGFyc2UgYW4gZXhwcmVzc2lvbiBleHBlY3RpbmcgaXQgdG8gYmUgdmFsaWQuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgaWYgKG51bGwgPT0gZXhwcmVzc2lvbikgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxleHByZXNzaW9uPicsIHRva2VuKTtcbiAgICBlbHNlIHJldHVybiBleHByZXNzaW9uO1xuICB9XG5cblxuICAvLyBSZXR1cm4gdGhlIHByZWNlZGVuY2UgcHJpb3JpdHkgb2YgdGhlIG9wZXJhdG9yLlxuICAvL1xuICAvLyBBcyB1bmFyeSBgLWAgY2FuJ3QgYmUgZGlzdGluZ3Vpc2hlZCBmcm9tIGJpbmFyeSBgLWAsIHVuYXJ5IHByZWNlZGVuY2VcbiAgLy8gaXNuJ3QgZGVzY3JpYmVkIGluIHRoaXMgdGFibGUgYnV0IGluIGBwYXJzZVN1YkV4cHJlc3Npb24oKWAgaXRzZWxmLlxuICAvL1xuICAvLyBBcyB0aGlzIGZ1bmN0aW9uIGdldHMgaGl0IG9uIGV2ZXJ5IGV4cHJlc3Npb24gaXQncyBiZWVuIG9wdGltaXplZCBkdWUgdG9cbiAgLy8gdGhlIGV4cGVuc2l2ZSBDb21wYXJlSUNTdHViIHdoaWNoIHRvb2sgfjglIG9mIHRoZSBwYXJzZSB0aW1lLlxuXG4gIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2Uob3BlcmF0b3IpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBvcGVyYXRvci5jaGFyQ29kZUF0KDApXG4gICAgICAsIGxlbmd0aCA9IG9wZXJhdG9yLmxlbmd0aDtcblxuICAgIGlmICgxID09PSBsZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgY2FzZSA5NDogcmV0dXJuIDEyOyAvLyBeXG4gICAgICAgIGNhc2UgNDI6IGNhc2UgNDc6IGNhc2UgMzc6IHJldHVybiAxMDsgLy8gKiAvICVcbiAgICAgICAgY2FzZSA0MzogY2FzZSA0NTogcmV0dXJuIDk7IC8vICsgLVxuICAgICAgICBjYXNlIDM4OiByZXR1cm4gNjsgLy8gJlxuICAgICAgICBjYXNlIDEyNjogcmV0dXJuIDU7IC8vIH5cbiAgICAgICAgY2FzZSAxMjQ6IHJldHVybiA0OyAvLyB8XG4gICAgICAgIGNhc2UgNjA6IGNhc2UgNjI6IHJldHVybiAzOyAvLyA8ID5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKDIgPT09IGxlbmd0aCkge1xuICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICBjYXNlIDQ3OiByZXR1cm4gMTA7IC8vIC8vXG4gICAgICAgIGNhc2UgNDY6IHJldHVybiA4OyAvLyAuLlxuICAgICAgICBjYXNlIDYwOiBjYXNlIDYyOlxuICAgICAgICAgICAgaWYoJzw8JyA9PT0gb3BlcmF0b3IgfHwgJz4+JyA9PT0gb3BlcmF0b3IpIHJldHVybiA3OyAvLyA8PCA+PlxuICAgICAgICAgICAgcmV0dXJuIDM7IC8vIDw9ID49XG4gICAgICAgIGNhc2UgNjE6IGNhc2UgMTI2OiByZXR1cm4gMzsgLy8gPT0gfj1cbiAgICAgICAgY2FzZSAxMTE6IHJldHVybiAxOyAvLyBvclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoOTcgPT09IGNoYXJDb2RlICYmICdhbmQnID09PSBvcGVyYXRvcikgcmV0dXJuIDI7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBJbXBsZW1lbnQgYW4gb3BlcmF0b3ItcHJlY2VkZW5jZSBwYXJzZXIgdG8gaGFuZGxlIGJpbmFyeSBvcGVyYXRvclxuICAvLyBwcmVjZWRlbmNlLlxuICAvL1xuICAvLyBXZSB1c2UgdGhpcyBhbGdvcml0aG0gYmVjYXVzZSBpdCdzIGNvbXBhY3QsIGl0J3MgZmFzdCBhbmQgTHVhIGNvcmUgdXNlc1xuICAvLyB0aGUgc2FtZSBzbyB3ZSBjYW4gYmUgc3VyZSBvdXIgZXhwcmVzc2lvbnMgYXJlIHBhcnNlZCBpbiB0aGUgc2FtZSBtYW5uZXJcbiAgLy8gd2l0aG91dCBleGNlc3NpdmUgYW1vdW50cyBvZiB0ZXN0cy5cbiAgLy9cbiAgLy8gICAgIGV4cCA6Oj0gKHVub3AgZXhwIHwgcHJpbWFyeSB8IHByZWZpeGV4cCApIHsgYmlub3AgZXhwIH1cblxuICBmdW5jdGlvbiBwYXJzZVN1YkV4cHJlc3Npb24obWluUHJlY2VkZW5jZSwgZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSB0b2tlbi52YWx1ZVxuICAgIC8vIFRoZSBsZWZ0LWhhbmQgc2lkZSBpbiBiaW5hcnkgb3BlcmF0aW9ucy5cbiAgICAgICwgZXhwcmVzc2lvbiwgbWFya2VyO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuXG4gICAgLy8gVW5hcnlFeHByZXNzaW9uXG4gICAgaWYgKGlzVW5hcnkodG9rZW4pKSB7XG4gICAgICBtYXJrTG9jYXRpb24oKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHZhciBhcmd1bWVudCA9IHBhcnNlU3ViRXhwcmVzc2lvbigxMCwgZmxvd0NvbnRleHQpO1xuICAgICAgaWYgKGFyZ3VtZW50ID09IG51bGwpIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8ZXhwcmVzc2lvbj4nLCB0b2tlbik7XG4gICAgICBleHByZXNzaW9uID0gZmluaXNoTm9kZShhc3QudW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCkpO1xuICAgIH1cbiAgICBpZiAobnVsbCA9PSBleHByZXNzaW9uKSB7XG4gICAgICAvLyBQcmltYXJ5RXhwcmVzc2lvblxuICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuXG4gICAgICAvLyBQcmVmaXhFeHByZXNzaW9uXG4gICAgICBpZiAobnVsbCA9PSBleHByZXNzaW9uKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZVByZWZpeEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIGlzIG5vdCBhIHZhbGlkIGxlZnQgaGFuZCBleHByZXNzaW9uLlxuICAgIGlmIChudWxsID09IGV4cHJlc3Npb24pIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHByZWNlZGVuY2U7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIG9wZXJhdG9yID0gdG9rZW4udmFsdWU7XG5cbiAgICAgIHByZWNlZGVuY2UgPSAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSB8fCBLZXl3b3JkID09PSB0b2tlbi50eXBlKSA/XG4gICAgICAgIGJpbmFyeVByZWNlZGVuY2Uob3BlcmF0b3IpIDogMDtcblxuICAgICAgaWYgKHByZWNlZGVuY2UgPT09IDAgfHwgcHJlY2VkZW5jZSA8PSBtaW5QcmVjZWRlbmNlKSBicmVhaztcbiAgICAgIC8vIFJpZ2h0LWhhbmQgcHJlY2VkZW5jZSBvcGVyYXRvcnNcbiAgICAgIGlmICgnXicgPT09IG9wZXJhdG9yIHx8ICcuLicgPT09IG9wZXJhdG9yKSAtLXByZWNlZGVuY2U7XG4gICAgICBuZXh0KCk7XG4gICAgICB2YXIgcmlnaHQgPSBwYXJzZVN1YkV4cHJlc3Npb24ocHJlY2VkZW5jZSwgZmxvd0NvbnRleHQpO1xuICAgICAgaWYgKG51bGwgPT0gcmlnaHQpIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8ZXhwcmVzc2lvbj4nLCB0b2tlbik7XG4gICAgICAvLyBQdXNoIGluIHRoZSBtYXJrZXIgY3JlYXRlZCBiZWZvcmUgdGhlIGxvb3AgdG8gd3JhcCBpdHMgZW50aXJldHkuXG4gICAgICBpZiAodHJhY2tMb2NhdGlvbnMpIGxvY2F0aW9ucy5wdXNoKG1hcmtlcik7XG4gICAgICBleHByZXNzaW9uID0gZmluaXNoTm9kZShhc3QuYmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgZXhwcmVzc2lvbiwgcmlnaHQpKTtcblxuICAgIH1cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIC8vICAgICBwcmVmaXhleHAgOjo9IHByZWZpeCB7c3VmZml4fVxuICAvLyAgICAgcHJlZml4IDo6PSBOYW1lIHwgJygnIGV4cCAnKSdcbiAgLy8gICAgIHN1ZmZpeCA6Oj0gJ1snIGV4cCAnXScgfCAnLicgTmFtZSB8ICc6JyBOYW1lIGFyZ3MgfCBhcmdzXG4gIC8vXG4gIC8vICAgICBhcmdzIDo6PSAnKCcgW2V4cGxpc3RdICcpJyB8IHRhYmxlY29uc3RydWN0b3IgfCBTdHJpbmdcblxuICBmdW5jdGlvbiBwYXJzZVByZWZpeEV4cHJlc3Npb25QYXJ0KGJhc2UsIG1hcmtlciwgZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiwgaWRlbnRpZmllcjtcblxuICAgIGlmIChQdW5jdHVhdG9yID09PSB0b2tlbi50eXBlKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgIGV4cGVjdCgnXScpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5pbmRleEV4cHJlc3Npb24oYmFzZSwgZXhwcmVzc2lvbikpO1xuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgaWRlbnRpZmllciA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5tZW1iZXJFeHByZXNzaW9uKGJhc2UsICcuJywgaWRlbnRpZmllcikpO1xuICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgaWRlbnRpZmllciA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIGJhc2UgPSBmaW5pc2hOb2RlKGFzdC5tZW1iZXJFeHByZXNzaW9uKGJhc2UsICc6JywgaWRlbnRpZmllcikpO1xuICAgICAgICAgIC8vIE9uY2UgYSA6IGlzIGZvdW5kLCB0aGlzIGhhcyB0byBiZSBhIENhbGxFeHByZXNzaW9uLCBvdGhlcndpc2VcbiAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VDYWxsRXhwcmVzc2lvbihiYXNlLCBmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJygnOiBjYXNlICd7JzogLy8gYXJnc1xuICAgICAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUNhbGxFeHByZXNzaW9uKGJhc2UsIGZsb3dDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFN0cmluZ0xpdGVyYWwgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgcmV0dXJuIHBhcnNlQ2FsbEV4cHJlc3Npb24oYmFzZSwgZmxvd0NvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcmVmaXhFeHByZXNzaW9uKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGJhc2UsIG5hbWUsIG1hcmtlcjtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgIC8vIFRoZSBwcmVmaXhcbiAgICBpZiAoSWRlbnRpZmllciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgbmFtZSA9IHRva2VuLnZhbHVlO1xuICAgICAgYmFzZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgLy8gU2V0IHRoZSBwYXJlbnQgc2NvcGUuXG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgYXR0YWNoU2NvcGUoYmFzZSwgc2NvcGVIYXNOYW1lKG5hbWUpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnN1bWUoJygnKSkge1xuICAgICAgYmFzZSA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIGV4cGVjdCgnKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUaGUgc3VmZml4XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG5ld0Jhc2UgPSBwYXJzZVByZWZpeEV4cHJlc3Npb25QYXJ0KGJhc2UsIG1hcmtlciwgZmxvd0NvbnRleHQpO1xuICAgICAgaWYgKG5ld0Jhc2UgPT09IG51bGwpXG4gICAgICAgIGJyZWFrO1xuICAgICAgYmFzZSA9IG5ld0Jhc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvLyAgICAgYXJncyA6Oj0gJygnIFtleHBsaXN0XSAnKScgfCB0YWJsZWNvbnN0cnVjdG9yIHwgU3RyaW5nXG5cbiAgZnVuY3Rpb24gcGFyc2VDYWxsRXhwcmVzc2lvbihiYXNlLCBmbG93Q29udGV4dCkge1xuICAgIGlmIChQdW5jdHVhdG9yID09PSB0b2tlbi50eXBlKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgIGlmICghZmVhdHVyZXMuZW1wdHlTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5saW5lICE9PSBwcmV2aW91c1Rva2VuLmxpbmUpXG4gICAgICAgICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5hbWJpZ3VvdXNTeW50YXgsIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgICAgLy8gTGlzdCBvZiBleHByZXNzaW9uc1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBleHByZXNzaW9uKSBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHdoaWxlIChjb25zdW1lKCcsJykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5jYWxsRXhwcmVzc2lvbihiYXNlLCBleHByZXNzaW9ucykpO1xuXG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgIG1hcmtMb2NhdGlvbigpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB2YXIgdGFibGUgPSBwYXJzZVRhYmxlQ29uc3RydWN0b3IoZmxvd0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC50YWJsZUNhbGxFeHByZXNzaW9uKGJhc2UsIHRhYmxlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChTdHJpbmdMaXRlcmFsID09PSB0b2tlbi50eXBlKSB7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShhc3Quc3RyaW5nQ2FsbEV4cHJlc3Npb24oYmFzZSwgcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihmbG93Q29udGV4dCkpKTtcbiAgICB9XG5cbiAgICByYWlzZVVuZXhwZWN0ZWRUb2tlbignZnVuY3Rpb24gYXJndW1lbnRzJywgdG9rZW4pO1xuICB9XG5cbiAgLy8gICAgIHByaW1hcnkgOjo9IFN0cmluZyB8IE51bWVyaWMgfCBuaWwgfCB0cnVlIHwgZmFsc2VcbiAgLy8gICAgICAgICAgfCBmdW5jdGlvbmRlZiB8IHRhYmxlY29uc3RydWN0b3IgfCAnLi4uJ1xuXG4gIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgbGl0ZXJhbHMgPSBTdHJpbmdMaXRlcmFsIHwgTnVtZXJpY0xpdGVyYWwgfCBCb29sZWFuTGl0ZXJhbCB8IE5pbExpdGVyYWwgfCBWYXJhcmdMaXRlcmFsXG4gICAgICAsIHZhbHVlID0gdG9rZW4udmFsdWVcbiAgICAgICwgdHlwZSA9IHRva2VuLnR5cGVcbiAgICAgICwgbWFya2VyO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuXG4gICAgaWYgKHR5cGUgPT09IFZhcmFyZ0xpdGVyYWwgJiYgIWZsb3dDb250ZXh0LmFsbG93VmFyYXJnKSB7XG4gICAgICByYWlzZSh0b2tlbiwgZXJyb3JzLmNhbm5vdFVzZVZhcmFyZywgdG9rZW4udmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlICYgbGl0ZXJhbHMpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgdmFyIHJhdyA9IGlucHV0LnNsaWNlKHRva2VuLnJhbmdlWzBdLCB0b2tlbi5yYW5nZVsxXSk7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QubGl0ZXJhbCh0eXBlLCB2YWx1ZSwgcmF3KSk7XG4gICAgfSBlbHNlIGlmIChLZXl3b3JkID09PSB0eXBlICYmICdmdW5jdGlvbicgPT09IHZhbHVlKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihudWxsKTtcbiAgICB9IGVsc2UgaWYgKGNvbnN1bWUoJ3snKSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICByZXR1cm4gcGFyc2VUYWJsZUNvbnN0cnVjdG9yKGZsb3dDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXJcbiAgLy8gLS0tLS0tXG5cbiAgLy8gRXhwb3J0IHRoZSBtYWluIHBhcnNlci5cbiAgLy9cbiAgLy8gICAtIGB3YWl0YCBIb2xkIHBhcnNpbmcgdW50aWwgZW5kKCkgaXMgY2FsbGVkLiBEZWZhdWx0cyB0byBmYWxzZVxuICAvLyAgIC0gYGNvbW1lbnRzYCBTdG9yZSBjb21tZW50cy4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgLy8gICAtIGBzY29wZWAgVHJhY2sgaWRlbnRpZmllciBzY29wZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gIC8vICAgLSBgbG9jYXRpb25zYCBTdG9yZSBsb2NhdGlvbiBpbmZvcm1hdGlvbi4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gIC8vICAgLSBgcmFuZ2VzYCBTdG9yZSB0aGUgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgbG9jYXRpb25zLiBEZWZhdWx0cyB0b1xuICAvLyAgICAgZmFsc2UuXG4gIC8vICAgLSBgb25DcmVhdGVOb2RlYCBDYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIHN5bnRheCBub2RlIGlzXG4gIC8vICAgICBjcmVhdGVkLlxuICAvLyAgIC0gYG9uQ3JlYXRlU2NvcGVgIENhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgbmV3IHNjb3BlIGlzXG4gIC8vICAgICBjcmVhdGVkLlxuICAvLyAgIC0gYG9uRGVzdHJveVNjb3BlYCBDYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgY3VycmVudCBzY29wZVxuICAvLyAgICAgaXMgZGVzdHJveWVkLlxuICAvL1xuICAvLyBFeGFtcGxlOlxuICAvL1xuICAvLyAgICAgdmFyIHBhcnNlciA9IHJlcXVpcmUoJ2x1YXBhcnNlcicpO1xuICAvLyAgICAgcGFyc2VyLnBhcnNlKCdpID0gMCcpO1xuXG4gIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICB2YXIgdmVyc2lvbkZlYXR1cmVzID0ge1xuICAgICc1LjEnOiB7XG4gICAgfSxcbiAgICAnNS4yJzoge1xuICAgICAgbGFiZWxzOiB0cnVlLFxuICAgICAgZW1wdHlTdGF0ZW1lbnQ6IHRydWUsXG4gICAgICBoZXhFc2NhcGVzOiB0cnVlLFxuICAgICAgc2tpcFdoaXRlc3BhY2VFc2NhcGU6IHRydWUsXG4gICAgICBzdHJpY3RFc2NhcGVzOiB0cnVlLFxuICAgICAgcmVsYXhlZEJyZWFrOiB0cnVlXG4gICAgfSxcbiAgICAnNS4zJzoge1xuICAgICAgbGFiZWxzOiB0cnVlLFxuICAgICAgZW1wdHlTdGF0ZW1lbnQ6IHRydWUsXG4gICAgICBoZXhFc2NhcGVzOiB0cnVlLFxuICAgICAgc2tpcFdoaXRlc3BhY2VFc2NhcGU6IHRydWUsXG4gICAgICBzdHJpY3RFc2NhcGVzOiB0cnVlLFxuICAgICAgdW5pY29kZUVzY2FwZXM6IHRydWUsXG4gICAgICBiaXR3aXNlT3BlcmF0b3JzOiB0cnVlLFxuICAgICAgaW50ZWdlckRpdmlzaW9uOiB0cnVlLFxuICAgICAgcmVsYXhlZEJyZWFrOiB0cnVlXG4gICAgfSxcbiAgICAnTHVhSklUJzoge1xuICAgICAgLy8gWFhYOiBMdWFKSVQgbGFuZ3VhZ2UgZmVhdHVyZXMgbWF5IGRlcGVuZCBvbiBjb21waWxhdGlvbiBvcHRpb25zOyBtYXkgbmVlZCB0b1xuICAgICAgLy8gcmV0aGluayBob3cgdG8gaGFuZGxlIHRoaXMuIFNwZWNpZmljYWxseSwgdGhlcmUgaXMgYSBMVUFKSVRfRU5BQkxFX0xVQTUyQ09NUEFUXG4gICAgICAvLyB0aGF0IHJlbW92ZXMgY29udGV4dHVhbCBnb3RvLiBNYXliZSBhZGQgJ0x1YUpJVC01LjJjb21wYXQnIGFzIHdlbGw/XG4gICAgICBsYWJlbHM6IHRydWUsXG4gICAgICBjb250ZXh0dWFsR290bzogdHJ1ZSxcbiAgICAgIGhleEVzY2FwZXM6IHRydWUsXG4gICAgICBza2lwV2hpdGVzcGFjZUVzY2FwZTogdHJ1ZSxcbiAgICAgIHN0cmljdEVzY2FwZXM6IHRydWUsXG4gICAgICB1bmljb2RlRXNjYXBlczogdHJ1ZSxcbiAgICAgIGltYWdpbmFyeU51bWJlcnM6IHRydWUsXG4gICAgICBpbnRlZ2VyU3VmZml4ZXM6IHRydWVcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2UoX2lucHV0LCBfb3B0aW9ucykge1xuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIF9vcHRpb25zICYmICdvYmplY3QnID09PSB0eXBlb2YgX2lucHV0KSB7XG4gICAgICBfb3B0aW9ucyA9IF9pbnB1dDtcbiAgICAgIF9pbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFfb3B0aW9ucykgX29wdGlvbnMgPSB7fTtcblxuICAgIGlucHV0ID0gX2lucHV0IHx8ICcnO1xuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBfb3B0aW9ucyk7XG5cbiAgICAvLyBSZXdpbmQgdGhlIGxleGVyXG4gICAgaW5kZXggPSAwO1xuICAgIGxpbmUgPSAxO1xuICAgIGxpbmVTdGFydCA9IDA7XG4gICAgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIC8vIFdoZW4gdHJhY2tpbmcgaWRlbnRpZmllciBzY29wZSwgaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHNjb3BlLlxuICAgIHNjb3BlcyA9IFtbXV07XG4gICAgc2NvcGVEZXB0aCA9IDA7XG4gICAgZ2xvYmFscyA9IFtdO1xuICAgIGxvY2F0aW9ucyA9IFtdO1xuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbkZlYXR1cmVzLCBvcHRpb25zLmx1YVZlcnNpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZihcIkx1YSB2ZXJzaW9uICclMScgbm90IHN1cHBvcnRlZFwiLCBvcHRpb25zLmx1YVZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBmZWF0dXJlcyA9IGFzc2lnbih7fSwgdmVyc2lvbkZlYXR1cmVzW29wdGlvbnMubHVhVmVyc2lvbl0pO1xuICAgIGlmIChvcHRpb25zLmV4dGVuZGVkSWRlbnRpZmllcnMgIT09IHZvaWQgMClcbiAgICAgIGZlYXR1cmVzLmV4dGVuZGVkSWRlbnRpZmllcnMgPSAhIW9wdGlvbnMuZXh0ZW5kZWRJZGVudGlmaWVycztcblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVuY29kaW5nTW9kZXMsIG9wdGlvbnMuZW5jb2RpbmdNb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHNwcmludGYoXCJFbmNvZGluZyBtb2RlICclMScgbm90IHN1cHBvcnRlZFwiLCBvcHRpb25zLmVuY29kaW5nTW9kZSkpO1xuICAgIH1cblxuICAgIGVuY29kaW5nTW9kZSA9IGVuY29kaW5nTW9kZXNbb3B0aW9ucy5lbmNvZGluZ01vZGVdO1xuXG4gICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIGNvbW1lbnRzID0gW107XG4gICAgaWYgKCFvcHRpb25zLndhaXQpIHJldHVybiBlbmQoKTtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIC8vIFdyaXRlIHRvIHRoZSBzb3VyY2UgY29kZSBidWZmZXIgd2l0aG91dCBiZWdpbm5pbmcgdGhlIHBhcnNlLlxuICBleHBvcnRzLndyaXRlID0gd3JpdGU7XG5cbiAgZnVuY3Rpb24gd3JpdGUoX2lucHV0KSB7XG4gICAgaW5wdXQgKz0gU3RyaW5nKF9pbnB1dCk7XG4gICAgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgLy8gU2VuZCBhbiBFT0YgYW5kIGJlZ2luIHBhcnNpbmcuXG4gIGV4cG9ydHMuZW5kID0gZW5kO1xuXG4gIGZ1bmN0aW9uIGVuZChfaW5wdXQpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBfaW5wdXQpIHdyaXRlKF9pbnB1dCk7XG5cbiAgICAvLyBJZ25vcmUgc2hlYmFuZ3MuXG4gICAgaWYgKGlucHV0ICYmIGlucHV0LnN1YnN0cigwLCAyKSA9PT0gJyMhJykgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eLiovLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUucmVwbGFjZSgvLi9nLCAnICcpO1xuICAgIH0pO1xuXG4gICAgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHRyYWNrTG9jYXRpb25zID0gb3B0aW9ucy5sb2NhdGlvbnMgfHwgb3B0aW9ucy5yYW5nZXM7XG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgbG9va2FoZWFkIHRva2VuLlxuICAgIGxvb2thaGVhZCA9IGxleCgpO1xuXG4gICAgdmFyIGNodW5rID0gcGFyc2VDaHVuaygpO1xuICAgIGlmIChvcHRpb25zLmNvbW1lbnRzKSBjaHVuay5jb21tZW50cyA9IGNvbW1lbnRzO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjaHVuay5nbG9iYWxzID0gZ2xvYmFscztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID4gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYXRpb24gdHJhY2tpbmcgZmFpbGVkLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgYnVnIGluIGx1YXBhcnNlJyk7XG5cbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxufSkpO1xuLyogdmltOiBzZXQgc3c9MiB0cz0yIGV0IHR3PTc5IDogKi9cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjM3Mjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTY4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODU3KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjM3Mik7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MzcpO1xudmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwODcpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTM3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNzIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTA4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTM3KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTYwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTIyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oOTY4KTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNjApO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk5MDc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTA4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjg2KTtcbnZhciBoYXNEZXNjcmlwdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIzOSkoKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICRUeXBlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjgpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldEZ1bmN0aW9uTGVuZ3RoKGZuLCBsZW5ndGgpIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gMHhGRkZGRkZGRiB8fCAkZmxvb3IobGVuZ3RoKSAhPT0gbGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BsZW5ndGhgIG11c3QgYmUgYSBwb3NpdGl2ZSAzMi1iaXQgaW50ZWdlcicpO1xuXHR9XG5cblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgISFhcmd1bWVudHNbMl07XG5cblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSB0cnVlO1xuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gdHJ1ZTtcblx0aWYgKCdsZW5ndGgnIGluIGZuICYmIGdPUEQpIHtcblx0XHR2YXIgZGVzYyA9IGdPUEQoZm4sICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2Mud3JpdGFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlIHx8IGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSB8fCAhbG9vc2UpIHtcblx0XHRpZiAoaGFzRGVzY3JpcHRvcnMpIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxMjU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZVNlcnZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VTZXJ2aWNlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzc3MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDQxKTtcbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5cbmNsYXNzIEJhc2VTZXJ2aWNlIHtcbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCBkb2N1bWVudC50ZXh0KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50c1t1cmldO1xuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuYW1lRG9jdW1lbnQoZG9jdW1lbnQsIG5ld0RvY3VtZW50VXJpKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGRvY3VtZW50LnVyaSk7XG4gICAgICAgIHRoaXMuYWRkRG9jdW1lbnQoe1xuICAgICAgICAgICAgdXJpOiBuZXdEb2N1bWVudFVyaSxcbiAgICAgICAgICAgIHZlcnNpb246IHByZXZpb3VzRG9jdW1lbnQudmVyc2lvbixcbiAgICAgICAgICAgIGxhbmd1YWdlSWQ6IHByZXZpb3VzRG9jdW1lbnQubGFuZ3VhZ2VJZCxcbiAgICAgICAgICAgIHRleHQ6IHByZXZpb3VzRG9jdW1lbnQuZ2V0VGV4dCgpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnNbbmV3RG9jdW1lbnRVcmldID0gdGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV07XG4gICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudFZhbHVlKHVyaSkge1xuICAgICAgICB2YXIgX3RoaXNfZ2V0RG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfZ2V0RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KHVyaSkpID09PSBudWxsIHx8IF90aGlzX2dldERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19nZXREb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgfVxuICAgIHNldFZhbHVlKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50ID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgIH1cbiAgICBzZXRXb3Jrc3BhY2Uod29ya3NwYWNlVXJpKSB7XG4gICAgICAgIHRoaXMud29ya3NwYWNlVXJpID0gd29ya3NwYWNlVXJpO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKGRvY3VtZW50VXJpLCBvcHRpb25zLCBtZXJnZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1tkb2N1bWVudFVyaV0gPSBtZXJnZSA/ICgwLF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLm1lcmdlT2JqZWN0cyAqLyAuckwpKG9wdGlvbnMsIHRoaXMub3B0aW9uc1tkb2N1bWVudFVyaV0pIDogb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0T3B0aW9uKGRvY3VtZW50VXJpLCBvcHRpb25OYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldICYmIHRoaXMub3B0aW9uc1tkb2N1bWVudFVyaV1bb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldW29wdGlvbk5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseURlbHRhcyhpZGVudGlmaWVyLCBkZWx0YXMpIHtcbiAgICAgICAgbGV0IGRvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChpZGVudGlmaWVyLnVyaSk7XG4gICAgICAgIGlmIChkb2N1bWVudCkgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi51cGRhdGUoZG9jdW1lbnQsIGRlbHRhcywgaWRlbnRpZmllci52ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvSW5saW5lQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZmluZERvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MoKSB7XG4gICAgICAgIHZhciBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSwgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvckNvZGVzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvckNvZGVzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb0lnbm9yZTogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNlbWFudGljVG9rZW5zKGRvY3VtZW50LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRDb2RlQWN0aW9ucyhkb2N1bWVudCwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgZXhlY3V0ZUNvbW1hbmQoY29tbWFuZCwgYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBzZW5kQXBwbGllZFJlc3VsdChyZXN1bHQsIGNhbGxiYWNrSWQpIHt9XG4gICAgc2VuZFJlcXVlc3QobmFtZSwgYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBzZW5kUmVzcG9uc2UoY2FsbGJhY2tJZCwgYXJncykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1vZGUsIHdvcmtzcGFjZVVyaSl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlTmFtZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwibW9kZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiZG9jdW1lbnRzXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiZ2xvYmFsT3B0aW9uc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlRGF0YVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZUNhcGFiaWxpdGllc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ3b3Jrc3BhY2VVcmlcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNsaWVudENhcGFiaWxpdGllc1wiLCB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWREb2N1bWVudFN1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHB1Ymxpc2hEaWFnbm9zdGljczoge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGVkSW5mb3JtYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25TdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnU3VwcG9ydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5EaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkRpYWdub3N0aWNUYWcuRGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Rm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWludGV4dCdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3luY2hyb25pemF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbGxTYXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGlkU2F2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdpbGxTYXZlV2FpdFVudGlsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25JdGVtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmlwcGV0U3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdENoYXJhY3RlcnNTdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb25Gb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFpbnRleHQnXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZFN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VsZWN0U3VwcG9ydDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFN1cHBvcnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVIZWxwOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUluZm9ybWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uRm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxhaW50ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVBhcmFtZXRlclN1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRIaWdobGlnaHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VtYW50aWNUb2tlbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lVG9rZW5TdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdUb2tlblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5Nb2RpZmllcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhdWdtZW50c1N5bnRheFRva2VuczogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29kZUFjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVDb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2luZG93OiB7XG4gICAgICAgICAgICAgICAgc2hvd0RvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICAgICAgZGlkQ2hhbmdlQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGVjdXRlQ29tbWFuZDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcHBseUVkaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdDoge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlSGFuZGxpbmc6IFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplc0xpbmVFbmRpbmdzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMud29ya3NwYWNlVXJpID0gd29ya3NwYWNlVXJpO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gXCJCYXNlU2VydmljZVwiO1xuICAgICAgICB0aGlzLnNlcnZpY2VEYXRhID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhc2VTZXJ2aWNlXCIsXG4gICAgICAgICAgICBtb2RlczogXCJcIixcbiAgICAgICAgICAgIG1vZHVsZTogKCk9Pnt9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NzcwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRrOiAoKSA9PiAoLyogYmluZGluZyAqLyBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgckw6ICgpID0+ICgvKiBiaW5kaW5nICovIG1lcmdlT2JqZWN0cylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0cyBub3RFbXB0eSwgaXNFbXB0eVJhbmdlLCBtZXJnZVJhbmdlcywgY29udmVydFRvVXJpICovXG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvYmoxLCBvYmoyLCBleGNsdWRlVW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICBpZiAoIW9iajEpIHJldHVybiBvYmoyO1xuICAgIGlmICghb2JqMikgcmV0dXJuIG9iajE7XG4gICAgaWYgKGV4Y2x1ZGVVbmRlZmluZWQpIHtcbiAgICAgICAgb2JqMSA9IGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqMSk7XG4gICAgICAgIG9iajIgPSBleGNsdWRlVW5kZWZpbmVkVmFsdWVzKG9iajIpO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWRPYmplY3RzID0ge1xuICAgICAgICAuLi5vYmoyLFxuICAgICAgICAuLi5vYmoxXG4gICAgfTsgLy8gR2l2ZSBwcmlvcml0eSB0byBvYmoxIHZhbHVlcyBieSBzcHJlYWRpbmcgb2JqMiBmaXJzdCwgdGhlbiBvYmoxXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWVyZ2VkT2JqZWN0cykpe1xuICAgICAgICBpZiAob2JqMVtrZXldICYmIG9iajJba2V5XSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqMVtrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG9iajFba2V5XS5jb25jYXQob2JqMltrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmoyW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gb2JqMltrZXldLmNvbmNhdChvYmoxW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqMVtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMltrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG1lcmdlT2JqZWN0cyhvYmoxW2tleV0sIG9iajJba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZE9iamVjdHM7XG59XG5mdW5jdGlvbiBleGNsdWRlVW5kZWZpbmVkVmFsdWVzKG9iaikge1xuICAgIGNvbnN0IGZpbHRlcmVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChbXywgdmFsdWVdKT0+dmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhmaWx0ZXJlZEVudHJpZXMpO1xufVxuZnVuY3Rpb24gbm90RW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlSYW5nZShyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5zdGFydC5yb3cgPT09IHJhbmdlLmVuZC5yb3cgJiYgcmFuZ2Uuc3RhcnQuY29sdW1uID09PSByYW5nZS5lbmQuY29sdW1uO1xufVxuLy90YWtlbiB3aXRoIHNtYWxsIGNoYW5nZXMgZnJvbSBhY2UtY29kZVxuZnVuY3Rpb24gbWVyZ2VSYW5nZXMocmFuZ2VzKSB7XG4gICAgdmFyIGxpc3QgPSByYW5nZXM7XG4gICAgbGlzdCA9IGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlUG9pbnRzKGEuc3RhcnQsIGIuc3RhcnQpO1xuICAgIH0pO1xuICAgIHZhciBuZXh0ID0gbGlzdFswXSwgcmFuZ2U7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIG5leHQgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgY21wID0gY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuc3RhcnQpO1xuICAgICAgICBpZiAoY21wIDwgMCkgY29udGludWU7XG4gICAgICAgIGlmIChjbXAgPT0gMCAmJiAhaXNFbXB0eVJhbmdlKHJhbmdlKSAmJiAhaXNFbXB0eVJhbmdlKG5leHQpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LmVuZCkgPCAwKSB7XG4gICAgICAgICAgICByYW5nZS5lbmQucm93ID0gbmV4dC5lbmQucm93O1xuICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IG5leHQuZW5kLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgbmV4dCA9IHJhbmdlO1xuICAgICAgICBpLS07XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gY29tcGFyZVBvaW50cyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEucm93IC0gcDIucm93IHx8IHAxLmNvbHVtbiAtIHAyLmNvbHVtbjtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkodmFsdWUsIHJlZ2V4cEFycmF5KSB7XG4gICAgaWYgKCFyZWdleHBBcnJheSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCByZWdleHBBcnJheS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChyZWdleHBBcnJheVtpXS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29udmVydFRvVXJpKGZpbGVQYXRoKSB7XG4gICAgLy9hbHJlYWR5IFVSSVxuICAgIGlmIChmaWxlUGF0aC5zdGFydHNXaXRoKFwiZmlsZTovLy9cIikpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgIH1cbiAgICByZXR1cm4gVVJJLmZpbGUoZmlsZVBhdGgpLnRvU3RyaW5nKCk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyNzI6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTMxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cblxuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzODcpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MjUpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMjczMCk7XG52YXIgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTQzKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4Mjc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MDcpO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2NCk7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MzEpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjcyKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjE1KTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyMDg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTExMDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBleHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IHJpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzEyKTtcbi8vIEluc3RhbGwgdGhlIGJyb3dzZXIgcnVudGltZSBhYnN0cmFjdC5cbnJpbF8xLmRlZmF1bHQuaW5zdGFsbCgpO1xuY29uc3QgYXBpXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzIpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNzY3MiksIGV4cG9ydHMpO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb25EYXRhID0gbmV3IGFwaV8xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkRhdGEuZmlyZShldmVudC5kYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICAgICAgcG9ydC5vbm1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlTGlzdGVuZXI7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlUmVhZGVyID0gQnJvd3Nlck1lc3NhZ2VSZWFkZXI7XG5jbGFzcyBCcm93c2VyTWVzc2FnZVdyaXRlciBleHRlbmRzIGFwaV8xLkFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IocG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgICAgICBwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB0aGlzLmZpcmVFcnJvcihldmVudCkpO1xuICAgIH1cbiAgICB3cml0ZShtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1zZykge1xuICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VXcml0ZXIgPSBCcm93c2VyTWVzc2FnZVdyaXRlcjtcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyID0gYXBpXzEuTnVsbExvZ2dlcjtcbiAgICB9XG4gICAgaWYgKGFwaV8xLkNvbm5lY3Rpb25TdHJhdGVneS5pcyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBjb25uZWN0aW9uU3RyYXRlZ3k6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBhcGlfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMzMTI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2NCk7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuY29uc3QgYXBpXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzIpO1xuY2xhc3MgTWVzc2FnZUJ1ZmZlciBleHRlbmRzIGFwaV8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZW5jb2RpbmcgPSAndXRmLTgnKSB7XG4gICAgICAgIHN1cGVyKGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5hc2NpaURlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ2FzY2lpJyk7XG4gICAgfVxuICAgIGVtcHR5QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlcjtcbiAgICB9XG4gICAgZnJvbVN0cmluZyh2YWx1ZSwgX2VuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzY2lpRGVjb2Rlci5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzTmF0aXZlKGJ1ZmZlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGxvY05hdGl2ZShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfVxufVxuTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuY2xhc3MgUmVhZGFibGVTdHJlYW1XcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBibG9iLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGFwaV8xLlJBTCkoKS5jb25zb2xlLmVycm9yKGBDb252ZXJ0aW5nIGJsb2IgdG8gYXJyYXkgYnVmZmVyIGZhaWxlZC5gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fbWVzc2FnZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25EYXRhKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkRhdGEuZXZlbnQobGlzdGVuZXIpO1xuICAgIH1cbn1cbmNsYXNzIFdyaXRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIH1cbiAgICBvbkNsb3NlKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVycm9yKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVuZChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICB3cml0ZShkYXRhLCBlbmNvZGluZykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyAhPT0gJ3V0Zi04Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgfVxufVxuY29uc3QgX3RleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBfcmlsID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgbWVzc2FnZUJ1ZmZlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGNyZWF0ZTogKGVuY29kaW5nKSA9PiBuZXcgTWVzc2FnZUJ1ZmZlcihlbmNvZGluZylcbiAgICB9KSxcbiAgICBhcHBsaWNhdGlvbkpzb246IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBlbmNvZGVyOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIG5hbWU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGVuY29kZTogKG1zZywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzZXQgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbiBhIEJyb3dzZXIgZW52aXJvbm1lbnRzIG9ubHkgdXRmLTggdGV4dCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQuIEJ1dCBnb3QgZW5jb2Rpbmc6ICR7b3B0aW9ucy5jaGFyc2V0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobXNnLCB1bmRlZmluZWQsIDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBkZWNvZGVyOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIG5hbWU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGRlY29kZTogKGJ1ZmZlciwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IFVpbnQ4QXJyYXlzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoSlNPTi5wYXJzZShuZXcgVGV4dERlY29kZXIob3B0aW9ucy5jaGFyc2V0KS5kZWNvZGUoYnVmZmVyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pLFxuICAgIHN0cmVhbTogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGFzUmVhZGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBSZWFkYWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KSxcbiAgICAgICAgYXNXcml0YWJsZVN0cmVhbTogKHNvY2tldCkgPT4gbmV3IFdyaXRhYmxlU3RyZWFtV3JhcHBlcihzb2NrZXQpXG4gICAgfSksXG4gICAgY29uc29sZTogY29uc29sZSxcbiAgICB0aW1lcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4geyBkaXNwb3NlOiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDAsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRJbnRlcnZhbChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJJbnRlcnZhbChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgfSlcbn0pO1xuZnVuY3Rpb24gUklMKCkge1xuICAgIHJldHVybiBfcmlsO1xufVxuKGZ1bmN0aW9uIChSSUwpIHtcbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgICBhcGlfMS5SQUwuaW5zdGFsbChfcmlsKTtcbiAgICB9XG4gICAgUklMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUklMIHx8IChSSUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSSUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2NzI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy90aGVuYWJsZS5kLnRzXCIgLz5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBleHBvcnRzLlByb2dyZXNzVG9rZW4gPSBleHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5OdWxsTG9nZ2VyID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSBleHBvcnRzLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IGV4cG9ydHMuRGlzcG9zYWJsZSA9IGV4cG9ydHMuTFJVQ2FjaGUgPSBleHBvcnRzLlRvdWNoID0gZXhwb3J0cy5MaW5rZWRNYXAgPSBleHBvcnRzLlBhcmFtZXRlclN0cnVjdHVyZXMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTcgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTQgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5FcnJvckNvZGVzID0gZXhwb3J0cy5SZXNwb25zZUVycm9yID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBleHBvcnRzLlJlcXVlc3RUeXBlOCA9IGV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBleHBvcnRzLlJlcXVlc3RUeXBlNSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBleHBvcnRzLlJlcXVlc3RUeXBlMiA9IGV4cG9ydHMuUmVxdWVzdFR5cGUxID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBleHBvcnRzLlJlcXVlc3RUeXBlID0gZXhwb3J0cy5NZXNzYWdlID0gZXhwb3J0cy5SQUwgPSB2b2lkIDA7XG5leHBvcnRzLk1lc3NhZ2VTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlVmFsdWVzID0gZXhwb3J0cy5UcmFjZSA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNjIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTWVzc2FnZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTA7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU1XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTY7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU4XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTk7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzcG9uc2VFcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckNvZGVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5FcnJvckNvZGVzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTBcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTZcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTlcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcmFtZXRlclN0cnVjdHVyZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXM7IH0gfSkpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMDkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlua2VkTWFwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTGlua2VkTWFwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxSVUNhY2hlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTFJVQ2FjaGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG91Y2hcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rZWRNYXBfMS5Ub3VjaDsgfSB9KSk7XG5jb25zdCBkaXNwb3NhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4NDQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzcG9zYWJsZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3Bvc2FibGVfMS5EaXNwb3NhYmxlOyB9IH0pKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRXZlbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW1pdHRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkVtaXR0ZXI7IH0gfSkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pKTtcbmNvbnN0IHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0ODkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneTsgfSB9KSk7XG5jb25zdCBtZXNzYWdlUmVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1Nik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLk1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLkFic3RyYWN0TWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VXcml0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzNik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLk1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLkFic3RyYWN0TWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZUJ1ZmZlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODA1KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZUJ1ZmZlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VCdWZmZXJfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXI7IH0gfSkpO1xuY29uc3QgY29ubmVjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDU0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25TdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbk9wdGlvbnNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbk9wdGlvbnM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbExvZ2dlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5OdWxsTG9nZ2VyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVG9rZW5cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuUHJvZ3Jlc3NUb2tlbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc1R5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuUHJvZ3Jlc3NUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlVmFsdWVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlVmFsdWVzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlRm9ybWF0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlRm9ybWF0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNldFRyYWNlTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlNldFRyYWNlTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ1RyYWNlTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkxvZ1RyYWNlTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvcnNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbkVycm9yczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbkVycm9yOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25TdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTWVzc2FnZVN0cmF0ZWd5OyB9IH0pKTtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmV4cG9ydHMuUkFMID0gcmFsXzEuZGVmYXVsdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk1Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbnZhciBDYW5jZWxsYXRpb25Ub2tlbjtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBmYWxzZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IHRydWUsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZVxuICAgICAgICAgICAgfHwgY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWRcbiAgICAgICAgICAgIHx8IChJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkgJiYgISFjYW5kaWRhdGUub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQpKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblRva2VuIHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDU0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNjIpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMDkpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xudmFyIENhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoQ2FuY2VsTm90aWZpY2F0aW9uKSB7XG4gICAgQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2NhbmNlbFJlcXVlc3QnKTtcbn0pKENhbmNlbE5vdGlmaWNhdGlvbiB8fCAoQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBQcm9ncmVzc1Rva2VuO1xuKGZ1bmN0aW9uIChQcm9ncmVzc1Rva2VuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgUHJvZ3Jlc3NUb2tlbi5pcyA9IGlzO1xufSkoUHJvZ3Jlc3NUb2tlbiB8fCAoZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gUHJvZ3Jlc3NUb2tlbiA9IHt9KSk7XG52YXIgUHJvZ3Jlc3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFByb2dyZXNzTm90aWZpY2F0aW9uKSB7XG4gICAgUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvcHJvZ3Jlc3MnKTtcbn0pKFByb2dyZXNzTm90aWZpY2F0aW9uIHx8IChQcm9ncmVzc05vdGlmaWNhdGlvbiA9IHt9KSk7XG5jbGFzcyBQcm9ncmVzc1R5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gUHJvZ3Jlc3NUeXBlO1xudmFyIFN0YXJSZXF1ZXN0SGFuZGxlcjtcbihmdW5jdGlvbiAoU3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElzLmZ1bmModmFsdWUpO1xuICAgIH1cbiAgICBTdGFyUmVxdWVzdEhhbmRsZXIuaXMgPSBpcztcbn0pKFN0YXJSZXF1ZXN0SGFuZGxlciB8fCAoU3RhclJlcXVlc3RIYW5kbGVyID0ge30pKTtcbmV4cG9ydHMuTnVsbExvZ2dlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiAoKSA9PiB7IH0sXG4gICAgd2FybjogKCkgPT4geyB9LFxuICAgIGluZm86ICgpID0+IHsgfSxcbiAgICBsb2c6ICgpID0+IHsgfVxufSk7XG52YXIgVHJhY2U7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgVHJhY2VbVHJhY2VbXCJPZmZcIl0gPSAwXSA9IFwiT2ZmXCI7XG4gICAgVHJhY2VbVHJhY2VbXCJNZXNzYWdlc1wiXSA9IDFdID0gXCJNZXNzYWdlc1wiO1xuICAgIFRyYWNlW1RyYWNlW1wiQ29tcGFjdFwiXSA9IDJdID0gXCJDb21wYWN0XCI7XG4gICAgVHJhY2VbVHJhY2VbXCJWZXJib3NlXCJdID0gM10gPSBcIlZlcmJvc2VcIjtcbn0pKFRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0gVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlVmFsdWVzO1xuKGZ1bmN0aW9uIChUcmFjZVZhbHVlcykge1xuICAgIC8qKlxuICAgICAqIFR1cm4gdHJhY2luZyBvZmYuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuT2ZmID0gJ29mZic7XG4gICAgLyoqXG4gICAgICogVHJhY2UgbWVzc2FnZXMgb25seS5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5NZXNzYWdlcyA9ICdtZXNzYWdlcyc7XG4gICAgLyoqXG4gICAgICogQ29tcGFjdCBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuQ29tcGFjdCA9ICdjb21wYWN0JztcbiAgICAvKipcbiAgICAgKiBWZXJib3NlIG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5WZXJib3NlID0gJ3ZlcmJvc2UnO1xufSkoVHJhY2VWYWx1ZXMgfHwgKGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSBUcmFjZVZhbHVlcyA9IHt9KSk7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk1lc3NhZ2VzO1xuICAgICAgICAgICAgY2FzZSAnY29tcGFjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgICAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuVmVyYm9zZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk9mZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk1lc3NhZ2VzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnY29tcGFjdCc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJib3NlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLnRvU3RyaW5nID0gdG9TdHJpbmc7XG59KShUcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IFRyYWNlID0ge30pKTtcbnZhciBUcmFjZUZvcm1hdDtcbihmdW5jdGlvbiAoVHJhY2VGb3JtYXQpIHtcbiAgICBUcmFjZUZvcm1hdFtcIlRleHRcIl0gPSBcInRleHRcIjtcbiAgICBUcmFjZUZvcm1hdFtcIkpTT05cIl0gPSBcImpzb25cIjtcbn0pKFRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuSlNPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlRm9ybWF0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdCA9IHt9KSk7XG52YXIgU2V0VHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFNldFRyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvc2V0VHJhY2UnKTtcbn0pKFNldFRyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0gU2V0VHJhY2VOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIExvZ1RyYWNlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dUcmFjZU5vdGlmaWNhdGlvbikge1xuICAgIExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2xvZ1RyYWNlJyk7XG59KShMb2dUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IExvZ1RyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBDb25uZWN0aW9uRXJyb3JzO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkNsb3NlZFwiXSA9IDFdID0gXCJDbG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiRGlzcG9zZWRcIl0gPSAyXSA9IFwiRGlzcG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGluIGxpc3RlbmluZyBtb2RlLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkFscmVhZHlMaXN0ZW5pbmdcIl0gPSAzXSA9IFwiQWxyZWFkeUxpc3RlbmluZ1wiO1xufSkoQ29ubmVjdGlvbkVycm9ycyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gQ29ubmVjdGlvbkVycm9ycyA9IHt9KSk7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gQ29ubmVjdGlvbkVycm9yO1xudmFyIENvbm5lY3Rpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2FuY2VsVW5kaXNwYXRjaGVkKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDb25uZWN0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gQ29ubmVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbnZhciBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5raW5kID09PSAnaWQnKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSkgJiYgKGNhbmRpZGF0ZS5kaXNwb3NlID09PSB1bmRlZmluZWQgfHwgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkpO1xuICAgIH1cbiAgICBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVxdWVzdCcgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoXykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSkgfHwgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXModmFsdWUpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHNlbmRDYW5jZWxsYXRpb24oY29ubiwgaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25uLnNlbmROb3RpZmljYXRpb24oQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUsIHsgaWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXAoXykgeyB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuc2VuZENhbmNlbGxhdGlvbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2xlYW51cCk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHJlY2VpdmVyOiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UsXG4gICAgICAgIHNlbmRlcjogQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnJlY2VpdmVyKSAmJiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUuc2VuZGVyKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIE1lc3NhZ2VTdHJhdGVneTtcbihmdW5jdGlvbiAoTWVzc2FnZVN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuaGFuZGxlTWVzc2FnZSk7XG4gICAgfVxuICAgIE1lc3NhZ2VTdHJhdGVneS5pcyA9IGlzO1xufSkoTWVzc2FnZVN0cmF0ZWd5IHx8IChleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSA9IE1lc3NhZ2VTdHJhdGVneSA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jYW5jZWxsYXRpb25TdHJhdGVneSkgfHwgQ29ubmVjdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jb25uZWN0aW9uU3RyYXRlZ3kpIHx8IE1lc3NhZ2VTdHJhdGVneS5pcyhjYW5kaWRhdGUubWVzc2FnZVN0cmF0ZWd5KSk7XG4gICAgfVxuICAgIENvbm5lY3Rpb25PcHRpb25zLmlzID0gaXM7XG59KShDb25uZWN0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IENvbm5lY3Rpb25PcHRpb25zID0ge30pKTtcbnZhciBDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJOZXdcIl0gPSAxXSA9IFwiTmV3XCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkxpc3RlbmluZ1wiXSA9IDJdID0gXCJMaXN0ZW5pbmdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiQ2xvc2VkXCJdID0gM10gPSBcIkNsb3NlZFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJEaXNwb3NlZFwiXSA9IDRdID0gXCJEaXNwb3NlZFwiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24obWVzc2FnZVJlYWRlciwgbWVzc2FnZVdyaXRlciwgX2xvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIgIT09IHVuZGVmaW5lZCA/IF9sb2dnZXIgOiBleHBvcnRzLk51bGxMb2dnZXI7XG4gICAgbGV0IHNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCB1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgY29uc3QgdmVyc2lvbiA9ICcyLjAnO1xuICAgIGxldCBzdGFyUmVxdWVzdEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub3RpZmljYXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9ncmVzc0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB0aW1lcjtcbiAgICBsZXQgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgIGxldCByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIGxldCBrbm93bkNhbmNlbGVkUmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHJlcXVlc3RUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRyYWNlID0gVHJhY2UuT2ZmO1xuICAgIGxldCB0cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgbGV0IHRyYWNlcjtcbiAgICBsZXQgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTmV3O1xuICAgIGNvbnN0IGVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGRpc3Bvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25TdHJhdGVneSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpID8gb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSA6IENhbmNlbGxhdGlvblN0cmF0ZWd5Lk1lc3NhZ2U7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzZW5kIHJlcXVlc3RzIHdpdGggaWQgbnVsbCBzaW5jZSB0aGUgcmVzcG9uc2UgY2FuJ3QgYmUgY29ycmVsYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3JlcS0nICsgaWQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLXVua25vd24tJyArICgrK3Vua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbm90LScgKyAoKytub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTWVzc2FnZVRvUXVldWUocXVldWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXF1ZXN0UXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsVW5kaXNwYXRjaGVkKF9tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTGlzdGVuaW5nKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc3Bvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUhhbmRsZXIoKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLk5ldyB8fCBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZykge1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgICAgICAgICAgY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpcyBkaXNwb3NlZCBkb24ndCBzZW50IGNsb3NlIGV2ZW50cy5cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShbZXJyb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRXJyb3JIYW5kbGVyKGRhdGEpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoZGF0YSk7XG4gICAgfVxuICAgIG1lc3NhZ2VSZWFkZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VSZWFkZXIub25FcnJvcihyZWFkRXJyb3JIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uRXJyb3Iod3JpdGVFcnJvckhhbmRsZXIpO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmICh0aW1lciB8fCBtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdHJhdGVneSA9IG9wdGlvbnM/Lm1lc3NhZ2VTdHJhdGVneTtcbiAgICAgICAgICAgIGlmIChNZXNzYWdlU3RyYXRlZ3kuaXMobWVzc2FnZVN0cmF0ZWd5KSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdHJhdGVneS5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgY2FuY2VsbGF0aW9uIG1lc3NhZ2UuIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIHN0aWxsIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgLy8gYW5kIGNhbmNlbCBpdCBpZiBhbGxvd2VkIHRvIGRvIHNvLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSAmJiBtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ2FuY2VsID0gbWVzc2FnZVF1ZXVlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KHRvQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IG9wdGlvbnM/LmNvbm5lY3Rpb25TdHJhdGVneTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoc3RyYXRlZ3kgJiYgc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKSA/IHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCwgY2FuY2VsVW5kaXNwYXRjaGVkKSA6IGNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2UuZXJyb3IgIT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gdG9DYW5jZWwuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShyZXNwb25zZSwgbWVzc2FnZS5tZXRob2QsIERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShyZXNwb25zZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZvciBjYW5jZWxlZCBtZXNzYWdlIGZhaWxlZC5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1ZXN0VG9rZW5zLmdldChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBydW5uaW5nLiBDYW5jZWwgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjYW5jZWwgYnV0IHN0aWxsIHF1ZXVlIHRoZSBtZXNzYWdlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIHN0YXRlIGluIHByb2Nlc3MgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmFkZChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkTWVzc2FnZVRvUXVldWUobWVzc2FnZVF1ZXVlLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBzaWxlbnRseSBzaW5jZSB3ZSBmaXJlZCBhbiBldmVudCB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHkocmVzdWx0T3JFcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0T3JFcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSByZXN1bHRPckVycm9yLnRvSnNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHRPckVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0T3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlFcnJvcihlcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnRvSnNvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseVN1Y2Nlc3MocmVzdWx0LCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIEpTT04gUlBDIGRlZmluZXMgdGhhdCBhIHJlc3BvbnNlIG11c3QgZWl0aGVyIGhhdmUgYSByZXN1bHQgb3IgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIHZhbGlkIHJlc3BvbnNlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZVJlY2VpdmVkUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3RNZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgcmVxdWVzdEhhbmRsZXI7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyIHx8IHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSByZXF1ZXN0TWVzc2FnZS5pZCA/PyBTdHJpbmcoRGF0ZS5ub3coKSk7IC8vXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Tb3VyY2UgPSBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIpXG4gICAgICAgICAgICAgICAgPyBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSh0b2tlbktleSlcbiAgICAgICAgICAgICAgICA6IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCAmJiBrbm93bkNhbmNlbGVkUmVxdWVzdHMuaGFzKHJlcXVlc3RNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblNvdXJjZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuc2V0KHRva2VuS2V5LCBjYW5jZWxsYXRpb25Tb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0TWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoLi4ucmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSBzdGFyUmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UubWV0aG9kLCByZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5U3VjY2VzcyhoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdE9yRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5KHJlc3VsdE9yRXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseShoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXBseShlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCwgYFVuaGFuZGxlZCBtZXRob2QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZDogRXJyb3IgaXM6IFxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2VNZXNzYWdlLmVycm9yLCB1bmRlZmluZWQsIDQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQuIE5vIGZ1cnRoZXIgZXJyb3IgaW5mb3JtYXRpb24gcHJvdmlkZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZFJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXNwb25zZU1lc3NhZ2UuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBub3RpZmljYXRpb25IYW5kbGVyO1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5kZWxldGUoY2FuY2VsSWQpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub3RpZmljYXRpb25IYW5kbGVycy5nZXQobWVzc2FnZS5tZXRob2QpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIgfHwgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyAhPT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIEpTT04tUlBDIGxpYnJhcmllcyB0aGF0IHNlbmQgcHJvZ3Jlc3MgbWVzc2FnZSBhcyBwb3NpdGlvbmFsIHBhcmFtcyBhbHRob3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGFzIG5hbWVkLiBTbyBjb252ZXJ0IHRoZW0gaWYgdGhpcyBpcyB0aGUgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCAmJiBwYXJhbXMubGVuZ3RoID09PSAyICYmIFByb2dyZXNzVG9rZW4uaXMocGFyYW1zWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoeyB0b2tlbjogcGFyYW1zWzBdLCB2YWx1ZTogcGFyYW1zWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSBtZXNzYWdlLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkICR7cGFyYW1zLmxlbmd0aH0gYXJndW1lbnRzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIuZmlyZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdSZWNlaXZlZCBlbXB0eSBtZXNzYWdlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSB3aGljaCBpcyBuZWl0aGVyIGEgcmVzcG9uc2Ugbm9yIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2U6XFxuJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCA0KX1gKTtcbiAgICAgICAgLy8gVGVzdCB3aGV0aGVyIHdlIGZpbmQgYW4gaWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChJcy5zdHJpbmcocmVzcG9uc2VNZXNzYWdlLmlkKSB8fCBJcy5udW1iZXIocmVzcG9uc2VNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIucmVqZWN0KG5ldyBFcnJvcignVGhlIHJlY2VpdmVkIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciBwcm9wZXJ0eS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5VHJhY2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cmFjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5WZXJib3NlOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDQpO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXNwb25zZSAnJHttZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy4gUHJvY2Vzc2luZyByZXF1ZXN0IHRvb2sgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlciB8fCBtZXNzYWdlLm1ldGhvZCA9PT0gTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShtZXNzYWdlLCByZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWVzc2FnZS5lcnJvciA/IGAgUmVxdWVzdCBmYWlsZWQ6ICR7bWVzc2FnZS5lcnJvci5tZXNzYWdlfSAoJHttZXNzYWdlLmVycm9yLmNvZGV9KS5gIDogJyc7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknIGluICR7RGF0ZS5ub3coKSAtIHJlc3BvbnNlUHJvbWlzZS50aW1lclN0YXJ0fW1zLiR7ZXJyb3J9YCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAke21lc3NhZ2UuaWR9IHdpdGhvdXQgYWN0aXZlIHJlc3BvbnNlIHByb21pc2UuYCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nTFNQTWVzc2FnZSh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdHJhY2VyIHx8IHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsc3BNZXNzYWdlID0ge1xuICAgICAgICAgICAgaXNMU1BNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgdHJhY2VyLmxvZyhsc3BNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKSB7XG4gICAgICAgIGlmIChpc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQ2xvc2VkLCAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkRpc3Bvc2VkLCAnQ29ubmVjdGlvbiBpcyBkaXNwb3NlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkFscmVhZHlMaXN0ZW5pbmcsICdDb25uZWN0aW9uIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZk5vdExpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKCFpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGwgbGlzdGVuKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5kZWZpbmVkVG9OdWxsKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBudWxsVG9VbmRlZmluZWQocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWRQYXJhbShwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gIT09IHVuZGVmaW5lZCAmJiBwYXJhbSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbSkgJiYgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtKSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW1ldGVyU3RydWN0dXJlcykge1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bzpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lOlxuICAgICAgICAgICAgICAgIGlmICghaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcGFyYW0gaXMgbm90IGFuIG9iamVjdCBsaXRlcmFsLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBzdHJ1Y3R1cmUgJHtwYXJhbWV0ZXJTdHJ1Y3R1cmVzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wdXRlU2luZ2xlUGFyYW0odHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGggJiYgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkVG9OdWxsKHBhcmFtc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8IG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgbm90aWZpY2F0aW9uIHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZVdyaXRlci53cml0ZShub3RpZmljYXRpb25NZXNzYWdlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgbm90aWZpY2F0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk5vdGlmaWNhdGlvbjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgaWYgKElzLmZ1bmModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZSwgeyB0eXBlOiB1bmRlZmluZWQsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0hhbmRsZXJzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyZXNzIGhhbmRsZXIgZm9yIHRva2VuICR7dG9rZW59IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5zZXQodG9rZW4sIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuZGVsZXRlKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYXdhaXQgYnV0IHNpbXBsZSByZXR1cm4gdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyXG4gICAgICAgICAgICAvLyBhc3luYyBzY2hlZHVsaW5nLiBPdGhlcndpc2Ugb25lIHNlbmQgY291bGQgb3ZlcnRha2UgYW5vdGhlciBzZW5kLlxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCB7IHRva2VuLCB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VbmhhbmRsZWRQcm9ncmVzczogdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmV2ZW50LFxuICAgICAgICBzZW5kUmVxdWVzdDogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICB0aHJvd0lmTm90TGlzdGVuaW5nKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1FbmQgPSBwYXJhbUVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgcmVxdWVzdCBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW251bWJlck9mUGFyYW1zXSkgPyBwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2FibGU7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLnNlbmRDYW5jZWxsYXRpb24oY29ubmVjdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZWNlaXZlZCBubyBwcm9taXNlIGZyb20gY2FuY2VsbGF0aW9uIHN0cmF0ZWd5IHdoZW4gY2FuY2VsbGluZyBpZCAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgY2FuY2VsbGF0aW9uIG1lc3NhZ2VzIGZvciBpZCAke2lkfSBmYWlsZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmVuYWJsZUNhbmNlbGxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24ocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlV2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdFdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHsgbWV0aG9kOiBtZXRob2QsIHRpbWVyU3RhcnQ6IERhdGUubm93KCksIHJlc29sdmU6IHJlc29sdmVXaXRoQ2xlYW51cCwgcmVqZWN0OiByZWplY3RXaXRoQ2xlYW51cCB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lc3NhZ2VXcml0ZXIud3JpdGUocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLnNldChpZCwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXF1ZXN0IGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGluZyB0aGUgbWVzc2FnZSBmYWlsZWQuIFNvIHdlIG5lZWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yLCBlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIHJlYXNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChTdGFyUmVxdWVzdEhhbmRsZXIuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUsIHsgaGFuZGxlcjogaGFuZGxlciwgdHlwZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUGVuZGluZ1Jlc3BvbnNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcy5zaXplID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2U6IGFzeW5jIChfdmFsdWUsIF90cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgbGV0IF9zZW5kTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgIGlmIChzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChJcy5ib29sZWFuKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdHJhY2VGb3JtYXQgPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMudHJhY2VGb3JtYXQgfHwgVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0ID0gX3RyYWNlRm9ybWF0O1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSBfdHJhY2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSwgeyB2YWx1ZTogVHJhY2UudG9TdHJpbmcoX3ZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZXJyb3JFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkNsb3NlOiBjbG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkRpc3Bvc2U6IGRpc3Bvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQsICdQZW5kaW5nIHJlc3BvbnNlIHJlamVjdGVkIHNpbmNlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgcmVzcG9uc2VQcm9taXNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZkxpc3RlbmluZygpO1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5saXN0ZW4oY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5sb2coJ2luc3BlY3QnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlID0gdHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHZlcmJvc2UgPyBwYXJhbXMudmVyYm9zZSA6IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9ncmVzc0hhbmRsZXJzLmdldChwYXJhbXMudG9rZW4pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmZpcmUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODQ0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZvaWQgMDtcbnZhciBEaXNwb3NhYmxlO1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlIHx8IChleHBvcnRzLkRpc3Bvc2FibGUgPSBEaXNwb3NhYmxlID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjQ3OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0gRXZlbnQgPSB7fSkpO1xuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcbiAgICBhZGQoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Y2tldCkpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzW2ldID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrICYgY29udGV4dCBtYXRjaCA9PiByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gYWRkaW5nIGEgbGlzdGVuZXIgd2l0aCBhIGNvbnRleHQsIHlvdSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggdGhlIHNhbWUgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gW10sIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5zbGljZSgwKSwgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cy5zbGljZSgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dHNbaV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgKi9cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBhZnRlciBlbWl0dGVyIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5yZW1vdmUobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cbiAgICAgKiBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmludm9rZS5jYWxsKHRoaXMuX2NhbGxiYWNrcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuRW1pdHRlci5fbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjYxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTEwOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5MaW5rZWRNYXAgPSBleHBvcnRzLlRvdWNoID0gdm9pZCAwO1xudmFyIFRvdWNoO1xuKGZ1bmN0aW9uIChUb3VjaCkge1xuICAgIFRvdWNoLk5vbmUgPSAwO1xuICAgIFRvdWNoLkZpcnN0ID0gMTtcbiAgICBUb3VjaC5Bc09sZCA9IFRvdWNoLkZpcnN0O1xuICAgIFRvdWNoLkxhc3QgPSAyO1xuICAgIFRvdWNoLkFzTmV3ID0gVG91Y2guTGFzdDtcbn0pKFRvdWNoIHx8IChleHBvcnRzLlRvdWNoID0gVG91Y2ggPSB7fSkpO1xuY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9hID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IFRvdWNoLkZpcnN0ICYmIHRvdWNoICE9PSBUb3VjaC5MYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gVG91Y2guRmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlIGF0IGhlYWRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkxhc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rZWRNYXAgPSBMaW5rZWRNYXA7XG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0IHJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgfVxuICAgIHNldCByYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guQXNOZXcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIFRvdWNoLk5vbmUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgVG91Y2guTGFzdCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODA1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRvQXBwZW5kID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IHRoaXMuZnJvbVN0cmluZyhjaHVuaywgdGhpcy5fZW5jb2RpbmcpIDogY2h1bms7XG4gICAgICAgIHRoaXMuX2NodW5rcy5wdXNoKHRvQXBwZW5kKTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggKz0gdG9BcHBlbmQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ5UmVhZEhlYWRlcnMobG93ZXJDYXNlS2V5cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHJvdzogd2hpbGUgKGNodW5rSW5kZXggPCB0aGlzLl9jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb2x1bW46IHdoaWxlIChvZmZzZXQgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rW29mZnNldF07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rQnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjaHVua0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWZmZXIgY29udGFpbnMgdGhlIHR3byBDUkxGIGF0IHRoZSBlbmQuIFNvIHdlIHdpbGxcbiAgICAgICAgLy8gaGF2ZSB0d28gZW1wdHkgbGluZXMgYWZ0ZXIgdGhlIHNwbGl0IGF0IHRoZSBlbmQgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZChjaHVua0J5dGVzUmVhZCArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMudG9TdHJpbmcoYnVmZmVyLCAnYXNjaWknKS5zcGxpdChDUkxGKTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBoZWFkZXIgbXVzdCBzZXBhcmF0ZSBrZXkgYW5kIHZhbHVlIHVzaW5nICc6J1xcbiR7aGVhZGVyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnN1YnN0cigwLCBpbmRleCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGxvd2VyQ2FzZUtleXMgPyBrZXkudG9Mb3dlckNhc2UoKSA6IGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyeVJlYWRCb2R5KGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fdG90YWxMZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQobGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IG51bWJlck9mQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbExlbmd0aDtcbiAgICB9XG4gICAgX3JlYWQoYnl0ZUNvdW50KSB7XG4gICAgICAgIGlmIChieXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVDb3VudCA+IHRoaXMuX3RvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWFkIHNvIG1hbnkgYnl0ZXMhYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID09PSBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIHN1cGVyIGZhc3QgcGF0aCwgcHJlY2lzZWx5IGZpcnN0IGNodW5rIG11c3QgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc05hdGl2ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBmYXN0IHBhdGgsIHRoZSByZWFkaW5nIGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgZmlyc3QgY2h1bmtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc05hdGl2ZShjaHVuaywgYnl0ZUNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rc1swXSA9IGNodW5rLnNsaWNlKGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb2NOYXRpdmUoYnl0ZUNvdW50KTtcbiAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPiBieXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNodW5rIHdpbGwgc3Vydml2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFydCA9IGNodW5rLnNsaWNlKDAsIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVua1BhcnQsIHJlc3VsdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ICs9IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIGJlIGVudGlyZWx5IHJlYWRcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rLCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IEFic3RyYWN0TWVzc2FnZUJ1ZmZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3Qgc2VtYXBob3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxOCk7XG52YXIgTWVzc2FnZVJlYWRlcjtcbihmdW5jdGlvbiAoTWVzc2FnZVJlYWRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5saXN0ZW4pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpICYmXG4gICAgICAgICAgICBJcy5mdW5jKGNhbmRpZGF0ZS5vbkVycm9yKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vblBhcnRpYWxNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVJlYWRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVJlYWRlciB8fCAoZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gTWVzc2FnZVJlYWRlciA9IHt9KSk7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUodGhpcy5hc0Vycm9yKGVycm9yKSk7XG4gICAgfVxuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBnZXQgb25QYXJ0aWFsTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlUGFydGlhbE1lc3NhZ2UoaW5mbykge1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5maXJlKGluZm8pO1xuICAgIH1cbiAgICBhc0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBSZWFkZXIgcmVjZWl2ZWQgZXJyb3IuIFJlYXNvbjogJHtJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBBYnN0cmFjdE1lc3NhZ2VSZWFkZXI7XG52YXIgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucztcbihmdW5jdGlvbiAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNoYXJzZXQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGxldCBjb250ZW50RGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudERlY29kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgY29udGVudFR5cGVEZWNvZGVyO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZURlY29kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hhcnNldCA9IG9wdGlvbnMgPz8gJ3V0Zi04JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQgPz8gJ3V0Zi04JztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnREZWNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlciA9IG9wdGlvbnMuY29udGVudERlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChjb250ZW50RGVjb2Rlci5uYW1lLCBjb250ZW50RGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlciBvZiBvcHRpb25zLmNvbnRlbnREZWNvZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXIgPSBvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlciBvZiBvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoZGVjb2Rlci5uYW1lLCBkZWNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZGVjb2RlcjtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGNvbnRlbnRUeXBlRGVjb2Rlci5uYW1lLCBjb250ZW50VHlwZURlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYXJzZXQsIGNvbnRlbnREZWNvZGVyLCBjb250ZW50RGVjb2RlcnMsIGNvbnRlbnRUeXBlRGVjb2RlciwgY29udGVudFR5cGVEZWNvZGVycyB9O1xuICAgIH1cbiAgICBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zLmZyb21PcHRpb25zID0gZnJvbU9wdGlvbnM7XG59KShSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zIHx8IChSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zID0ge30pKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocmVhZGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHJlYWRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLm1lc3NhZ2VCdWZmZXIuY3JlYXRlKHRoaXMub3B0aW9ucy5jaGFyc2V0KTtcbiAgICAgICAgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0ID0gMTAwMDA7XG4gICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgdGhpcy5tZXNzYWdlVG9rZW4gPSAwO1xuICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUgPSBuZXcgc2VtYXBob3JlXzEuU2VtYXBob3JlKDEpO1xuICAgIH1cbiAgICBzZXQgcGFydGlhbE1lc3NhZ2VUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgZ2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dDtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgdGhpcy5tZXNzYWdlVG9rZW4gPSAwO1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWFkYWJsZS5vbkRhdGEoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuYnVmZmVyLnRyeVJlYWRIZWFkZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKGBIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuXFxuJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycykpfWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcihgQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4gR290ICR7Y29udGVudExlbmd0aH1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuYnVmZmVyLnRyeVJlYWRCb2R5KHRoaXMubmV4dE1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIFdlIGhhdmVuJ3QgcmVjZWl2ZWQgdGhlIGZ1bGwgbWVzc2FnZSB5ZXQuICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgb25lIHJlY2VpdmVkIG1lc3NhZ2UgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIuIE90aGVyd2lzZSBpdCBjb3VsZCBoYXBwZW4gdGhhdCBhIGRlY29kaW5nIG9mIGEgc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gc21hbGxlciBtZXNzYWdlIGZpbmlzaGVkIGJlZm9yZSB0aGUgZGVjb2Rpbmcgb2YgYSBmaXJzdCBsYXJnZXJcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGFuZCB0aGVuIHdlIHdvdWxkIGRlbGl2ZXIgdGhlIHNlY29uZCBtZXNzYWdlIGZpcnN0LlxuICAgICAgICAgICAgICAgIHRoaXMucmVhZFNlbWFwaG9yZS5sb2NrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIuZGVjb2RlKGJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyLmRlY29kZShieXRlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRUaW1lb3V0KCh0b2tlbiwgdGltZW91dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSB0aGlzLm1lc3NhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBhcnRpYWxNZXNzYWdlKHsgbWVzc2FnZVRva2VuOiB0b2tlbiwgd2FpdGluZ1RpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCwgdGhpcy5tZXNzYWdlVG9rZW4sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwMzY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuY29uc3Qgc2VtYXBob3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gTWVzc2FnZVdyaXRlciA9IHt9KSk7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvciwgbWVzc2FnZSwgY291bnQpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZmlyZShbdGhpcy5hc0Vycm9yKGVycm9yKSwgbWVzc2FnZSwgY291bnRdKTtcbiAgICB9XG4gICAgZ2V0IG9uQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGFzRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFdyaXRlciByZWNlaXZlZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZVdyaXRlciA9IEFic3RyYWN0TWVzc2FnZVdyaXRlcjtcbnZhciBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zO1xuKGZ1bmN0aW9uIChSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcnNldDogb3B0aW9ucyA/PyAndXRmLTgnLCBjb250ZW50VHlwZUVuY29kZXI6ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5lbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zLmNoYXJzZXQgPz8gJ3V0Zi04JywgY29udGVudEVuY29kZXI6IG9wdGlvbnMuY29udGVudEVuY29kZXIsIGNvbnRlbnRUeXBlRW5jb2Rlcjogb3B0aW9ucy5jb250ZW50VHlwZUVuY29kZXIgPz8gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zID0gZnJvbU9wdGlvbnM7XG59KShSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zIHx8IChSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zID0ge30pKTtcbmNsYXNzIFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyaXRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB3cml0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgdGhpcy53cml0ZVNlbWFwaG9yZSA9IG5ldyBzZW1hcGhvcmVfMS5TZW1hcGhvcmUoMSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICB9XG4gICAgYXN5bmMgd3JpdGUobXNnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlU2VtYXBob3JlLmxvY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMub3B0aW9ucy5jb250ZW50VHlwZUVuY29kZXIuZW5jb2RlKG1zZywgdGhpcy5vcHRpb25zKS50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb250ZW50RW5jb2Rlci5lbmNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gW107XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENvbnRlbnRMZW5ndGgsIGJ1ZmZlci5ieXRlTGVuZ3RoLnRvU3RyaW5nKCksIENSTEYpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChDUkxGKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb1dyaXRlKG1zZywgaGVhZGVycywgYnVmZmVyKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZG9Xcml0ZShtc2csIGhlYWRlcnMsIGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGFibGUud3JpdGUoaGVhZGVycy5qb2luKCcnKSwgJ2FzY2lpJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0YWJsZS53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZS5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MTYyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTcgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTQgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBleHBvcnRzLlJlcXVlc3RUeXBlOCA9IGV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBleHBvcnRzLlJlcXVlc3RUeXBlNSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBleHBvcnRzLlJlcXVlc3RUeXBlMiA9IGV4cG9ydHMuUmVxdWVzdFR5cGUxID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBleHBvcnRzLlBhcmFtZXRlclN0cnVjdHVyZXMgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkVycm9yQ29kZXMgPSB2b2lkIDA7XG5jb25zdCBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG4vKipcbiAqIFByZWRlZmluZWQgZXJyb3IgY29kZXMuXG4gKi9cbnZhciBFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChFcnJvckNvZGVzKSB7XG4gICAgLy8gRGVmaW5lZCBieSBKU09OIFJQQ1xuICAgIEVycm9yQ29kZXMuUGFyc2VFcnJvciA9IC0zMjcwMDtcbiAgICBFcnJvckNvZGVzLkludmFsaWRSZXF1ZXN0ID0gLTMyNjAwO1xuICAgIEVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQgPSAtMzI2MDE7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zID0gLTMyNjAyO1xuICAgIEVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciA9IC0zMjYwMztcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS4gTm8gYXBwbGljYXRpb24gZXJyb3IgY29kZXMgc2hvdWxkXG4gICAgICogYmUgZGVmaW5lZCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHJhbmdlLiBGb3IgYmFja3dhcmRzXG4gICAgICogY29tcGF0aWJpbGl0eSB0aGUgYFNlcnZlck5vdEluaXRpYWxpemVkYCBhbmQgdGhlIGBVbmtub3duRXJyb3JDb2RlYFxuICAgICAqIGFyZSBsZWZ0IGluIHRoZSByYW5nZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JTdGFydCA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHdyaXRlIGEgbWVzc2FnZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVdyaXRlRXJyb3IgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nIGEgbWVzc2FnZSBmcm9tIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlUmVhZEVycm9yID0gLTMyMDk4O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCBvciBsb3N0IGFuZCBhbGwgcGVuZGluZyByZXNwb25zZXMgZ290XG4gICAgICogcmVqZWN0ZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5QZW5kaW5nUmVzcG9uc2VSZWplY3RlZCA9IC0zMjA5NztcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBpbmFjdGl2ZSBhbmQgYSB1c2Ugb2YgaXQgZmFpbGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuQ29ubmVjdGlvbkluYWN0aXZlID0gLTMyMDk2O1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IGEgc2VydmVyIHJlY2VpdmVkIGEgbm90aWZpY2F0aW9uIG9yXG4gICAgICogcmVxdWVzdCBiZWZvcmUgdGhlIHNlcnZlciBoYXMgcmVjZWl2ZWQgdGhlIGBpbml0aWFsaXplYCByZXF1ZXN0LlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuU2VydmVyTm90SW5pdGlhbGl6ZWQgPSAtMzIwMDI7XG4gICAgRXJyb3JDb2Rlcy5Vbmtub3duRXJyb3JDb2RlID0gLTMyMDAxO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjAwMDtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvckVuZCA9IC0zMjAwMDtcbn0pKEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuRXJyb3JDb2RlcyA9IEVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBBbiBlcnJvciBvYmplY3QgcmV0dXJuIGluIGEgcmVzcG9uc2UgaW4gY2FzZSBhIHJlcXVlc3RcbiAqIGhhcyBmYWlsZWQuXG4gKi9cbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gaXMubnVtYmVyKGNvZGUpID8gY29kZSA6IEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJlc3BvbnNlRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IFJlc3BvbnNlRXJyb3I7XG5jbGFzcyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byB8fCB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUgfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQ7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcztcbi8qKlxuICogVGhlIHBhcmFtZXRlciBzdHJ1Y3R1cmUgaXMgYXV0b21hdGljYWxseSBpbmZlcnJlZCBvbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnNcbiAqIGFuZCB0aGUgcGFyYW1ldGVyIHR5cGUgaW4gY2FzZSBvZiBhIHNpbmdsZSBwYXJhbS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2F1dG8nKTtcbi8qKlxuICogRm9yY2VzIGBieVBvc2l0aW9uYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgaGF2ZSBhIHNpbmdsZVxuICogcGFyYW1ldGVyIHdoaWNoIGhhcyBhIGxpdGVyYWwgdHlwZS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5UG9zaXRpb24nKTtcbi8qKlxuICogRm9yY2VzIGBieU5hbWVgIHBhcmFtZXRlciBzdHJ1Y3R1cmUuIFRoaXMgaXMgb25seSB1c2VmdWwgd2hlbiBoYXZpbmcgYSBzaW5nbGVcbiAqIHBhcmFtZXRlci4gVGhlIGxpYnJhcnkgd2lsbCByZXBvcnQgZXJyb3JzIGlmIHVzZWQgd2l0aCBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5TmFtZScpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIE1lc3NhZ2VUeXBlLlxuICovXG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbXMgPSBudW1iZXJPZlBhcmFtcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmU7XG4vKipcbiAqIENsYXNzZXMgdG8gdHlwZSByZXF1ZXN0IHJlc3BvbnNlIHBhaXJzXG4gKi9cbmNsYXNzIFJlcXVlc3RUeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBSZXF1ZXN0VHlwZTA7XG5jbGFzcyBSZXF1ZXN0VHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlID0gUmVxdWVzdFR5cGU7XG5jbGFzcyBSZXF1ZXN0VHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBSZXF1ZXN0VHlwZTE7XG5jbGFzcyBSZXF1ZXN0VHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gUmVxdWVzdFR5cGUyO1xuY2xhc3MgUmVxdWVzdFR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMyA9IFJlcXVlc3RUeXBlMztcbmNsYXNzIFJlcXVlc3RUeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBSZXF1ZXN0VHlwZTQ7XG5jbGFzcyBSZXF1ZXN0VHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gUmVxdWVzdFR5cGU1O1xuY2xhc3MgUmVxdWVzdFR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNiA9IFJlcXVlc3RUeXBlNjtcbmNsYXNzIFJlcXVlc3RUeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBSZXF1ZXN0VHlwZTc7XG5jbGFzcyBSZXF1ZXN0VHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gUmVxdWVzdFR5cGU4O1xuY2xhc3MgUmVxdWVzdFR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOSA9IFJlcXVlc3RUeXBlOTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gTm90aWZpY2F0aW9uVHlwZTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gTm90aWZpY2F0aW9uVHlwZTE7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IE5vdGlmaWNhdGlvblR5cGUyO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBOb3RpZmljYXRpb25UeXBlMztcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU0IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gTm90aWZpY2F0aW9uVHlwZTQ7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IE5vdGlmaWNhdGlvblR5cGU1O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDYpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBOb3RpZmljYXRpb25UeXBlNjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU3IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gTm90aWZpY2F0aW9uVHlwZTc7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IE5vdGlmaWNhdGlvblR5cGU4O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBOb3RpZmljYXRpb25UeXBlOTtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXF1ZXN0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkpO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzUmVxdWVzdCA9IGlzUmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiBtZXNzYWdlLmlkID09PSB2b2lkIDA7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNOb3RpZmljYXRpb24gPSBpc05vdGlmaWNhdGlvbjtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLnJlc3VsdCAhPT0gdm9pZCAwIHx8ICEhY2FuZGlkYXRlLmVycm9yKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkgfHwgY2FuZGlkYXRlLmlkID09PSBudWxsKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1Jlc3BvbnNlID0gaXNSZXNwb25zZTtcbn0pKE1lc3NhZ2UgfHwgKGV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2UgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5sZXQgX3JhbDtcbmZ1bmN0aW9uIFJBTCgpIHtcbiAgICBpZiAoX3JhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBpbnN0YWxsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yYWw7XG59XG4oZnVuY3Rpb24gKFJBTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwocmFsKSB7XG4gICAgICAgIGlmIChyYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgX3JhbCA9IHJhbDtcbiAgICB9XG4gICAgUkFMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUkFMIHx8IChSQUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSQUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hcGhvcmUgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5ID0gMSkge1xuICAgICAgICBpZiAoY2FwYWNpdHkgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5fd2FpdGluZyA9IFtdO1xuICAgIH1cbiAgICBsb2NrKHRodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nLnB1c2goeyB0aHVuaywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBydW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmRvUnVuTmV4dCgpKTtcbiAgICB9XG4gICAgZG9SdW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl93YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSsrO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlID4gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG8gbWFueSB0aHVua3MgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQudGh1bmsoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgIG5leHQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZW1hcGhvcmUgPSBTZW1hcGhvcmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0ODk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gdm9pZCAwO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xudmFyIENhbmNlbGxhdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TdGF0ZSkge1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNvbnRpbnVlID0gMDtcbiAgICBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQgPSAxO1xufSkoQ2FuY2VsbGF0aW9uU3RhdGUgfHwgKENhbmNlbGxhdGlvblN0YXRlID0ge30pKTtcbmNsYXNzIFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGVuYWJsZUNhbmNlbGxhdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKDQpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgZGF0YVswXSA9IENhbmNlbGxhdGlvblN0YXRlLkNvbnRpbnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuc2V0KHJlcXVlc3QuaWQsIGJ1ZmZlcik7XG4gICAgICAgIHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGEgPSBidWZmZXI7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRDYW5jZWxsYXRpb24oX2Nvbm4sIGlkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVycy5nZXQoaWQpO1xuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgQXRvbWljcy5zdG9yZShkYXRhLCAwLCBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQpO1xuICAgIH1cbiAgICBjbGVhbnVwKGlkKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuY2xlYXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5O1xuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbiB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLmRhdGEsIDApID09PSBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQ7XG4gICAgfVxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5jZWxsYXRpb24gb3ZlciBTaGFyZWRBcnJheUJ1ZmZlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsbGF0aW9uIGV2ZW50c2ApO1xuICAgIH1cbn1cbmNsYXNzIFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLnRva2VuID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4oYnVmZmVyKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgIH1cbn1cbmNsYXNzIFNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdyZXF1ZXN0JztcbiAgICB9XG4gICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSByZXF1ZXN0LiRjYW5jZWxsYXRpb25EYXRhO1xuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTUwMTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjA4KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMDgpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNDcpLCBleHBvcnRzKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCBicm93c2VyXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxNDc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxTUEVycm9yQ29kZXMgPSBleHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NTIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MTUpLCBleHBvcnRzKTtcbnZhciBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uOyB9IH0pKTtcbnZhciBMU1BFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChMU1BFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyODk5O1xuICAgIC8qKlxuICAgICAqIEEgcmVxdWVzdCBmYWlsZWQgYnV0IGl0IHdhcyBzeW50YWN0aWNhbGx5IGNvcnJlY3QsIGUuZyB0aGVcbiAgICAgKiBtZXRob2QgbmFtZSB3YXMga25vd24gYW5kIHRoZSBwYXJhbWV0ZXJzIHdlcmUgdmFsaWQuIFRoZSBlcnJvclxuICAgICAqIG1lc3NhZ2Ugc2hvdWxkIGNvbnRhaW4gaHVtYW4gcmVhZGFibGUgaW5mb3JtYXRpb24gYWJvdXQgd2h5XG4gICAgICogdGhlIHJlcXVlc3QgZmFpbGVkLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdEZhaWxlZCA9IC0zMjgwMztcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGNhbmNlbGxlZCB0aGUgcmVxdWVzdC4gVGhpcyBlcnJvciBjb2RlIHNob3VsZFxuICAgICAqIG9ubHkgYmUgdXNlZCBmb3IgcmVxdWVzdHMgdGhhdCBleHBsaWNpdGx5IHN1cHBvcnQgYmVpbmdcbiAgICAgKiBzZXJ2ZXIgY2FuY2VsbGFibGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5TZXJ2ZXJDYW5jZWxsZWQgPSAtMzI4MDI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBkZXRlY3RlZCB0aGF0IHRoZSBjb250ZW50IG9mIGEgZG9jdW1lbnQgZ290XG4gICAgICogbW9kaWZpZWQgb3V0c2lkZSBub3JtYWwgY29uZGl0aW9ucy4gQSBzZXJ2ZXIgc2hvdWxkXG4gICAgICogTk9UIHNlbmQgdGhpcyBlcnJvciBjb2RlIGlmIGl0IGRldGVjdHMgYSBjb250ZW50IGNoYW5nZVxuICAgICAqIGluIGl0IHVucHJvY2Vzc2VkIG1lc3NhZ2VzLiBUaGUgcmVzdWx0IGV2ZW4gY29tcHV0ZWRcbiAgICAgKiBvbiBhbiBvbGRlciBzdGF0ZSBtaWdodCBzdGlsbCBiZSB1c2VmdWwgZm9yIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIGNsaWVudCBkZWNpZGVzIHRoYXQgYSByZXN1bHQgaXMgbm90IG9mIGFueSB1c2UgYW55bW9yZVxuICAgICAqIHRoZSBjbGllbnQgc2hvdWxkIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLkNvbnRlbnRNb2RpZmllZCA9IC0zMjgwMTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IGhhcyBjYW5jZWxlZCBhIHJlcXVlc3QgYW5kIGEgc2VydmVyIGFzIGRldGVjdGVkXG4gICAgICogdGhlIGNhbmNlbC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlJlcXVlc3RDYW5jZWxsZWQgPSAtMzI4MDA7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgTFNQIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgKlxuICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5sc3BSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzI4MDA7XG59KShMU1BFcnJvckNvZGVzIHx8IChleHBvcnRzLkxTUEVycm9yQ29kZXMgPSBMU1BFcnJvckNvZGVzID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKGlucHV0LCBvdXRwdXQsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmICh2c2NvZGVfanNvbnJwY18xLkNvbm5lY3Rpb25TdHJhdGVneS5pcyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBjb25uZWN0aW9uU3RyYXRlZ3k6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCB2c2NvZGVfanNvbnJwY18xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKShpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0MzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xudmFyIE1lc3NhZ2VEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VEaXJlY3Rpb24pIHtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wiY2xpZW50VG9TZXJ2ZXJcIl0gPSBcImNsaWVudFRvU2VydmVyXCI7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcInNlcnZlclRvQ2xpZW50XCJdID0gXCJzZXJ2ZXJUb0NsaWVudFwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJib3RoXCJdID0gXCJib3RoXCI7XG59KShNZXNzYWdlRGlyZWN0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gPSBNZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbmNsYXNzIFJlZ2lzdHJhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBSZWdpc3RyYXRpb25UeXBlO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZTAgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IFByb3RvY29sUmVxdWVzdFR5cGUwO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IFByb3RvY29sUmVxdWVzdFR5cGU7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMDtcbmNsYXNzIFByb3RvY29sTm90aWZpY2F0aW9uVHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgdnNjb2RlX2pzb25ycGNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2MDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXN1bHQgYSBgQ2FsbEhpZXJhcmNoeUl0ZW1gIGluIGEgZG9jdW1lbnQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAqIENhbiBiZSB1c2VkIGFzIGFuIGlucHV0IHRvIGFuIGluY29taW5nIG9yIG91dGdvaW5nIGNhbGwgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZUNhbGxIaWVyYXJjaHknO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW5jb21pbmcgY2FsbHMgZm9yIGEgZ2l2ZW4gYENhbGxIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXRob2QgPSAnY2FsbEhpZXJhcmNoeS9pbmNvbWluZ0NhbGxzJztcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgfHwgKGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0gQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIG91dGdvaW5nIGNhbGxzIGZvciBhIGdpdmVuIGBDYWxsSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QpIHtcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWV0aG9kID0gJ2NhbGxIaWVyYXJjaHkvb3V0Z29pbmdDYWxscyc7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXRob2QpO1xufSkoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3NDc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgY29sb3Igc3ltYm9scyBmb3VuZCBpbiBhIGdpdmVuIHRleHQgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudENvbG9yUGFyYW1zfSB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb24gQ29sb3JJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudENvbG9yUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRDb2xvclJlcXVlc3QpIHtcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50Q29sb3InO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50Q29sb3JSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Q29sb3JSZXF1ZXN0ID0gRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgcHJlc2VudGF0aW9uIGZvciBhIGNvbG9yLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb25QYXJhbXN9IHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbiBDb2xvckluZm9ybWF0aW9uW119IG9yIGEgVGhlbmFibGVcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29sb3JQcmVzZW50YXRpb24nO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjM5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vLy0tLS0gR2V0IENvbmZpZ3VyYXRpb24gcmVxdWVzdCAtLS0tXG4vKipcbiAqIFRoZSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCBhIGNlcnRhaW5cbiAqIGNvbmZpZ3VyYXRpb24gc2V0dGluZy5cbiAqXG4gKiBUaGlzIHB1bGwgbW9kZWwgcmVwbGFjZXMgdGhlIG9sZCBwdXNoIG1vZGVsIHdlcmUgdGhlIGNsaWVudCBzaWduYWxlZCBjb25maWd1cmF0aW9uIGNoYW5nZSB2aWEgYW5cbiAqIGV2ZW50LiBJZiB0aGUgc2VydmVyIHN0aWxsIG5lZWRzIHRvIHJlYWN0IHRvIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyAoc2luY2UgdGhlIHNlcnZlciBjYWNoZXMgdGhlXG4gKiByZXN1bHQgb2YgYHdvcmtzcGFjZS9jb25maWd1cmF0aW9uYCByZXF1ZXN0cykgdGhlIHNlcnZlciBzaG91bGQgcmVnaXN0ZXIgZm9yIGFuIGVtcHR5IGNvbmZpZ3VyYXRpb25cbiAqIGNoYW5nZSBldmVudCBhbmQgZW1wdHkgdGhlIGNhY2hlIGlmIHN1Y2ggYW4gZXZlbnQgaXMgcmVjZWl2ZWQuXG4gKi9cbnZhciBDb25maWd1cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29uZmlndXJhdGlvblJlcXVlc3QpIHtcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nO1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29uZmlndXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbmZpZ3VyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gQ29uZmlndXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlY2xhcmF0aW9ufSBvciBhIHR5cGVkIGFycmF5IG9mIHtAbGluayBEZWNsYXJhdGlvbkxpbmt9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERlY2xhcmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoRGVjbGFyYXRpb25SZXF1ZXN0KSB7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVjbGFyYXRpb24nO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWNsYXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKERlY2xhcmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSBEZWNsYXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDk0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTExMCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUucmV0cmlnZ2VyUmVxdWVzdCk7XG4gICAgfVxuICAgIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhLmlzID0gaXM7XG59KShEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSB8fCAoZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVwb3J0IGtpbmRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIGRpYWdub3N0aWMgcmVwb3J0IHdpdGggYSBmdWxsXG4gICAgICogc2V0IG9mIHByb2JsZW1zLlxuICAgICAqL1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQuRnVsbCA9ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBBIHJlcG9ydCBpbmRpY2F0aW5nIHRoYXQgdGhlIGxhc3RcbiAgICAgKiByZXR1cm5lZCByZXBvcnQgaXMgc3RpbGwgYWNjdXJhdGUuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5VbmNoYW5nZWQgPSAndW5jaGFuZ2VkJztcbn0pKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgfHwgKGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgZGlhZ25vc3RpYyByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCkge1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWFnbm9zdGljJztcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIHdvcmtzcGFjZSBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2RpYWdub3N0aWMnO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgcmVmcmVzaCByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9kaWFnbm9zdGljL3JlZnJlc2hgO1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc4MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSBwYXR0ZXJuIGtpbmQgZGVzY3JpYmluZyBpZiBhIGdsb2IgcGF0dGVybiBtYXRjaGVzIGEgZmlsZSBhIGZvbGRlciBvclxuICogYm90aC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7XG4oZnVuY3Rpb24gKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIG1hdGNoZXMgYSBmaWxlIG9ubHkuXG4gICAgICovXG4gICAgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kLmZpbGUgPSAnZmlsZSc7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdHRlcm4gbWF0Y2hlcyBhIGZvbGRlciBvbmx5LlxuICAgICAqL1xuICAgIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZC5mb2xkZXIgPSAnZm9sZGVyJztcbn0pKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCB8fCAoZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBjcmVhdGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGNyZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY3JlYXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIHJldHVybiBhIGBXb3Jrc3BhY2VFZGl0YCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gd29ya3NwYWNlIGJlZm9yZSB0aGVcbiAqIGZpbGVzIGFyZSBjcmVhdGVkLiBIZW5jZSB0aGUgYFdvcmtzcGFjZUVkaXRgIGNhbiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGUgZmlsZVxuICogdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxDcmVhdGVGaWxlcyc7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgY3JlYXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgY3JlYXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbikge1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ3JlYXRlRmlsZXMnO1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIHJlbmFtZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogcmVuYW1lZCBhcyBsb25nIGFzIHRoZSByZW5hbWUgaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsUmVuYW1lRmlsZXMnO1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIHJlbmFtZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIHJlbmFtZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZFJlbmFtZUZpbGVzJztcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBkZWxldGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGRlbGV0ZWQgYXMgbG9uZyBhcyB0aGUgZGVsZXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWREZWxldGVGaWxlcyc7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCBkZWxldGUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSBkZWxldGVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsRGVsZXRlRmlsZXMnO1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IFdpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgZm9sZGluZyByYW5nZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEZvbGRpbmdSYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlTGlzdH0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRm9sZGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb2xkaW5nUmFuZ2UnO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBGb2xkaW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKEZvbGRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IEZvbGRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xOC4wXG4gKiBAcHJvcG9zZWRcbiAqL1xudmFyIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvZm9sZGluZ1JhbmdlL3JlZnJlc2hgO1xuICAgIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShGb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCA9IEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW1wbGVtZW50YXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW1wbGVtZW50YXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbXBsZW1lbnRhdGlvblJlcXVlc3QpIHtcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbXBsZW1lbnRhdGlvbic7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoSW1wbGVtZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IEltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5sYXkgaGludHMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGF5SGludHNQYXJhbXN9LCB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIElubGF5SGludCBJbmxheUhpbnRbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVxdWVzdCkge1xuICAgIElubGF5SGludFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxheUhpbnQnO1xuICAgIElubGF5SGludFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxheUhpbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IElubGF5SGludFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIGFuIGlubGF5IGhpbnQuXG4gKiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBJbmxheUhpbnR9LCB0aGUgcmVzcG9uc2UgaXNcbiAqIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2lubGF5SGludC9yZXNvbHZlJztcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IElubGF5SGludFJlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlZnJlc2hSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxheUhpbnQvcmVmcmVzaGA7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzIyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lQ29tcGxldGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5saW5lIGNvbXBsZXRpb25zIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBJbmxpbmVDb21wbGV0aW9uUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVDb21wbGV0aW9uIElubGluZUNvbXBsZXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTguMFxuICogQHByb3Bvc2VkXG4gKi9cbnZhciBJbmxpbmVDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBJbmxpbmVDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZUNvbXBsZXRpb24nO1xuICAgIElubGluZUNvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5saW5lQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKElubGluZUNvbXBsZXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLklubGluZUNvbXBsZXRpb25SZXF1ZXN0ID0gSW5saW5lQ29tcGxldGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGluZSB2YWx1ZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGluZVZhbHVlUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVWYWx1ZSBJbmxpbmVWYWx1ZVtdfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZVZhbHVlJztcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lVmFsdWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gSW5saW5lVmFsdWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxpbmVWYWx1ZS9yZWZyZXNoYDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE4MTU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgPSBleHBvcnRzLlJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSBleHBvcnRzLlNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCA9IGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2F0Y2hLaW5kID0gZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5NZXNzYWdlVHlwZSA9IGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRXhpdE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IGV4cG9ydHMuVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciA9IHZvaWQgMDtcbmV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJLaW5kID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgPSBleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gdm9pZCAwO1xuZXhwb3J0cy5JbmxpbmVDb21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSBleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuY29uc3QgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NTIpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2MzMpO1xuY29uc3QgcHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzI4Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBsZW1lbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xLkltcGxlbWVudGF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjY0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVEZWZpbml0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEuVHlwZURlZmluaXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjM5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbmZpZ3VyYXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xLkNvbmZpZ3VyYXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzc0Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb2N1bWVudENvbG9yUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Eb2N1bWVudENvbG9yUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjAzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMS5Gb2xkaW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZGVjbGFyYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTU4MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kZWNsYXJhdGlvbl8xLkRlY2xhcmF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbGVjdGlvblJhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Byb2dyZXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNjYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MDIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbkZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuVG9rZW5Gb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Nob3dEb2N1bWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzMzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNob3dEb2N1bWVudFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zaG93RG9jdW1lbnRfMS5TaG93RG9jdW1lbnRSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQ5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3ODEpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Njg0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzgzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9pbmxpbmVDb21wbGV0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMjIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5saW5lQ29tcGxldGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVDb21wbGV0aW9uXzEuSW5saW5lQ29tcGxldGlvblJlcXVlc3Q7IH0gfSkpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuc2NoZW1lKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnBhdHRlcm4pKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50RmlsdGVyID0gVGV4dERvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tEb2N1bWVudEZpbHRlcn0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tEb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLm5vdGVib29rVHlwZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5zY2hlbWUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUucGF0dGVybikpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50RmlsdGVyIHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBOb3RlYm9va0RvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLm5vdGVib29rKSB8fCBOb3RlYm9va0RvY3VtZW50RmlsdGVyLmlzKGNhbmRpZGF0ZS5ub3RlYm9vaykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmxhbmd1YWdlID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0gRG9jdW1lbnRTZWxlY3RvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBgY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHJlZ2lzdGVyIGEgbmV3IGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgUmVnaXN0cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVnaXN0cmF0aW9uUmVxdWVzdCkge1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC9yZWdpc3RlckNhcGFiaWxpdHknO1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBSZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKFJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCA9IFJlZ2lzdHJhdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYGNsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHVucmVnaXN0ZXIgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBVbnJlZ2lzdHJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKFVucmVnaXN0cmF0aW9uUmVxdWVzdCkge1xuICAgIFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3VucmVnaXN0ZXJDYXBhYmlsaXR5JztcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShVbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCB8fCAoZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBSZXNvdXJjZU9wZXJhdGlvbktpbmQgPSB7fSkpO1xudmFyIEZhaWx1cmVIYW5kbGluZ0tpbmQ7XG4oZnVuY3Rpb24gKEZhaWx1cmVIYW5kbGluZ0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyB0aGUgd29ya3NwYWNlIGNoYW5nZSBpcyBzaW1wbHkgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGNoYW5nZXMgcHJvdmlkZWRcbiAgICAgKiBmYWlscy4gQWxsIG9wZXJhdGlvbnMgZXhlY3V0ZWQgYmVmb3JlIHRoZSBmYWlsaW5nIG9wZXJhdGlvbiBzdGF5IGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuQWJvcnQgPSAnYWJvcnQnO1xuICAgIC8qKlxuICAgICAqIEFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLiBUaGF0IG1lYW5zIHRoZXkgZWl0aGVyIGFsbFxuICAgICAqIHN1Y2NlZWQgb3Igbm8gY2hhbmdlcyBhdCBhbGwgYXJlIGFwcGxpZWQgdG8gdGhlIHdvcmtzcGFjZS5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlRyYW5zYWN0aW9uYWwgPSAndHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHdvcmtzcGFjZSBlZGl0IGNvbnRhaW5zIG9ubHkgdGV4dHVhbCBmaWxlIGNoYW5nZXMgdGhleSBhcmUgZXhlY3V0ZWQgdHJhbnNhY3Rpb25hbC5cbiAgICAgKiBJZiByZXNvdXJjZSBjaGFuZ2VzIChjcmVhdGUsIHJlbmFtZSBvciBkZWxldGUgZmlsZSkgYXJlIHBhcnQgb2YgdGhlIGNoYW5nZSB0aGUgZmFpbHVyZVxuICAgICAqIGhhbmRsaW5nIHN0cmF0ZWd5IGlzIGFib3J0LlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVGV4dE9ubHlUcmFuc2FjdGlvbmFsID0gJ3RleHRPbmx5VHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0cmllcyB0byB1bmRvIHRoZSBvcGVyYXRpb25zIGFscmVhZHkgZXhlY3V0ZWQuIEJ1dCB0aGVyZSBpcyBub1xuICAgICAqIGd1YXJhbnRlZSB0aGF0IHRoaXMgaXMgc3VjY2VlZGluZy5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlVuZG8gPSAndW5kbyc7XG59KShGYWlsdXJlSGFuZGxpbmdLaW5kIHx8IChleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSBGYWlsdXJlSGFuZGxpbmdLaW5kID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBwb3NpdGlvbiBlbmNvZGluZyBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBQb3NpdGlvbkVuY29kaW5nS2luZDtcbihmdW5jdGlvbiAoUG9zaXRpb25FbmNvZGluZ0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtOCBjb2RlIHVuaXRzIChlLmcuIGJ5dGVzKS5cbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEY4ID0gJ3V0Zi04JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMTYgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgYW5kIG11c3QgYWx3YXlzIGJlIHN1cHBvcnRlZFxuICAgICAqIGJ5IHNlcnZlcnNcbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEYxNiA9ICd1dGYtMTYnO1xuICAgIC8qKlxuICAgICAqIENoYXJhY3RlciBvZmZzZXRzIGNvdW50IFVURi0zMiBjb2RlIHVuaXRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50YXRpb24gbm90ZTogdGhlc2UgYXJlIHRoZSBzYW1lIGFzIFVuaWNvZGUgY29kZXBvaW50cyxcbiAgICAgKiBzbyB0aGlzIGBQb3NpdGlvbkVuY29kaW5nS2luZGAgbWF5IGFsc28gYmUgdXNlZCBmb3IgYW5cbiAgICAgKiBlbmNvZGluZy1hZ25vc3RpYyByZXByZXNlbnRhdGlvbiBvZiBjaGFyYWN0ZXIgb2Zmc2V0cy5cbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEYzMiA9ICd1dGYtMzInO1xufSkoUG9zaXRpb25FbmNvZGluZ0tpbmQgfHwgKGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSBQb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5kb2N1bWVudFNlbGVjdG9yID09PSBudWxsIHx8IERvY3VtZW50U2VsZWN0b3IuaXMoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBXb3JrRG9uZVByb2dyZXNzT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLndvcmtEb25lUHJvZ3Jlc3MgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzKSk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmlzID0gaXM7XG4gICAgZnVuY3Rpb24gaGFzV29ya0RvbmVQcm9ncmVzcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzKTtcbiAgICB9XG4gICAgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMuaGFzV29ya0RvbmVQcm9ncmVzcyA9IGhhc1dvcmtEb25lUHJvZ3Jlc3M7XG59KShXb3JrRG9uZVByb2dyZXNzT3B0aW9ucyB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0IHx8IChleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0ID0gSW5pdGlhbGl6ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBLbm93biBlcnJvciBjb2RlcyBmb3IgYW4gYEluaXRpYWxpemVFcnJvckNvZGVzYDtcbiAqL1xudmFyIEluaXRpYWxpemVFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplRXJyb3JDb2Rlcykge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcm90b2NvbCB2ZXJzaW9uIHByb3ZpZGVkIGJ5IHRoZSBjbGllbnQgY2FuJ3QgYmUgaGFuZGxlZCBieSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBpbml0aWFsaXplIGVycm9yIGdvdCByZXBsYWNlZCBieSBjbGllbnQgY2FwYWJpbGl0aWVzLiBUaGVyZSBpc1xuICAgICAqIG5vIHZlcnNpb24gaGFuZHNoYWtlIGluIHZlcnNpb24gMy4weFxuICAgICAqL1xuICAgIEluaXRpYWxpemVFcnJvckNvZGVzLnVua25vd25Qcm90b2NvbFZlcnNpb24gPSAxO1xufSkoSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBJbml0aWFsaXplRXJyb3JDb2RlcyA9IHt9KSk7XG4vKipcbiAqIFRoZSBpbml0aWFsaXplZCBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlXG4gKiBzZXJ2ZXIgYWZ0ZXIgdGhlIGNsaWVudCBpcyBmdWxseSBpbml0aWFsaXplZCBhbmQgdGhlIHNlcnZlclxuICogaXMgYWxsb3dlZCB0byBzZW5kIHJlcXVlc3RzIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LlxuICovXG52YXIgSW5pdGlhbGl6ZWROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEluaXRpYWxpemVkTm90aWZpY2F0aW9uKSB7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWV0aG9kID0gJ2luaXRpYWxpemVkJztcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKEluaXRpYWxpemVkTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uID0gSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgfHwgKGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0gU2h1dGRvd25SZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBFeGl0IE5vdGlmaWNhdGlvbiAtLS0tXG4vKipcbiAqIFRoZSBleGl0IGV2ZW50IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG9cbiAqIGFzayB0aGUgc2VydmVyIHRvIGV4aXQgaXRzIHByb2Nlc3MuXG4gKi9cbnZhciBFeGl0Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChFeGl0Tm90aWZpY2F0aW9uKSB7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnZXhpdCc7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEV4aXROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAoRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRXhpdE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uID0gRXhpdE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlclxuICogd2hlbiB0aGUgY2xpZW50J3MgY29uZmlndXJhdGlvbiBoYXMgY2hhbmdlZC4gVGhlIG5vdGlmaWNhdGlvbiBjb250YWluc1xuICogdGhlIGNoYW5nZWQgY29uZmlndXJhdGlvbiBhcyBkZWZpbmVkIGJ5IHRoZSBsYW5ndWFnZSBjbGllbnQuXG4gKi9cbnZhciBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZENoYW5nZUNvbmZpZ3VyYXRpb24nO1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uID0gRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xuICAgIC8qKlxuICAgICAqIEEgZGVidWcgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE4LjBcbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5EZWJ1ZyA9IDU7XG59KShNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlVHlwZSA9IE1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBTaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBzaG93IG1lc3NhZ2UgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNob3cgYSBtZXNzYWdlXG4gKiBhbmQgYSBzZXQgb2Ygb3B0aW9ucyBhY3Rpb25zIHRvIHRoZSB1c2VyLlxuICovXG52YXIgU2hvd01lc3NhZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZVJlcXVlc3QpIHtcbiAgICBTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93TWVzc2FnZVJlcXVlc3QnO1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dNZXNzYWdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgPSBTaG93TWVzc2FnZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbG9nIG1lc3NhZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyBhIHBhcnRpY3VsYXIgbWVzc2FnZS5cbiAqL1xudmFyIExvZ01lc3NhZ2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKExvZ01lc3NhZ2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvbG9nTWVzc2FnZSc7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShMb2dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShMb2dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24gPSBMb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgaG93IHRoZSBob3N0IChlZGl0b3IpIHNob3VsZCBzeW5jXG4gKiBkb2N1bWVudCBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTeW5jS2luZDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U3luY0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgc2hvdWxkIG5vdCBiZSBzeW5jZWQgYXQgYWxsLlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFN5bmNLaW5kLk5vbmUgPSAwO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBhcmUgc3luY2VkIGJ5IGFsd2F5cyBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnRcbiAgICAgKiBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbCA9IDE7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgc2VuZGluZyB0aGUgZnVsbCBjb250ZW50IG9uIG9wZW4uXG4gICAgICogQWZ0ZXIgdGhhdCBvbmx5IGluY3JlbWVudGFsIHVwZGF0ZXMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgICAqIHNlbmQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgPSAyO1xufSkoVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSBUZXh0RG9jdW1lbnRTeW5jS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBvcGVuIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIHNpZ25hbFxuICogbmV3bHkgb3BlbmVkIHRleHQgZG9jdW1lbnRzLiBUaGUgZG9jdW1lbnQncyB0cnV0aCBpcyBub3cgbWFuYWdlZCBieSB0aGUgY2xpZW50XG4gKiBhbmQgdGhlIHNlcnZlciBtdXN0IG5vdCB0cnkgdG8gcmVhZCB0aGUgZG9jdW1lbnQncyB0cnV0aCB1c2luZyB0aGUgZG9jdW1lbnQnc1xuICogdXJpLiBPcGVuIGluIHRoaXMgc2Vuc2UgbWVhbnMgaXQgaXMgbWFuYWdlZCBieSB0aGUgY2xpZW50LiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5XG4gKiBtZWFuIHRoYXQgaXRzIGNvbnRlbnQgaXMgcHJlc2VudGVkIGluIGFuIGVkaXRvci4gQW4gb3BlbiBub3RpZmljYXRpb24gbXVzdCBub3RcbiAqIGJlIHNlbnQgbW9yZSB0aGFuIG9uY2Ugd2l0aG91dCBhIGNvcnJlc3BvbmRpbmcgY2xvc2Ugbm90aWZpY2F0aW9uIHNlbmQgYmVmb3JlLlxuICogVGhpcyBtZWFucyBvcGVuIGFuZCBjbG9zZSBub3RpZmljYXRpb24gbXVzdCBiZSBiYWxhbmNlZCBhbmQgdGhlIG1heCBvcGVuIGNvdW50XG4gKiBpcyBvbmUuXG4gKi9cbnZhciBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZE9wZW4nO1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IHx8IChleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gc2lnbmFsXG4gKiBjaGFuZ2VzIHRvIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlkQ2hhbmdlJztcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgY2xvc2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogdGhlIGRvY3VtZW50IGdvdCBjbG9zZWQgaW4gdGhlIGNsaWVudC4gVGhlIGRvY3VtZW50J3MgdHJ1dGggbm93IGV4aXN0cyB3aGVyZVxuICogdGhlIGRvY3VtZW50J3MgdXJpIHBvaW50cyB0byAoZS5nLiBpZiB0aGUgZG9jdW1lbnQncyB1cmkgaXMgYSBmaWxlIHVyaSB0aGVcbiAqIHRydXRoIG5vdyBleGlzdHMgb24gZGlzaykuIEFzIHdpdGggdGhlIG9wZW4gbm90aWZpY2F0aW9uIHRoZSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGlzIGFib3V0IG1hbmFnaW5nIHRoZSBkb2N1bWVudCdzIGNvbnRlbnQuIFJlY2VpdmluZyBhIGNsb3NlIG5vdGlmaWNhdGlvblxuICogZG9lc24ndCBtZWFuIHRoYXQgdGhlIGRvY3VtZW50IHdhcyBvcGVuIGluIGFuIGVkaXRvciBiZWZvcmUuIEEgY2xvc2VcbiAqIG5vdGlmaWNhdGlvbiByZXF1aXJlcyBhIHByZXZpb3VzIG9wZW4gbm90aWZpY2F0aW9uIHRvIGJlIHNlbnQuXG4gKi9cbnZhciBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZENsb3NlJztcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgcmVhc29ucyB3aHkgYSB0ZXh0IGRvY3VtZW50IGlzIHNhdmVkLlxuICovXG52YXIgVGV4dERvY3VtZW50U2F2ZVJlYXNvbjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U2F2ZVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHRyaWdnZXJlZCwgZS5nLiBieSB0aGUgdXNlciBwcmVzc2luZyBzYXZlLCBieSBzdGFydGluZyBkZWJ1Z2dpbmcsXG4gICAgICogb3IgYnkgYW4gQVBJIGNhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWwgPSAxO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBhZnRlciBhIGRlbGF5LlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFNhdmVSZWFzb24uQWZ0ZXJEZWxheSA9IDI7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgZWRpdG9yIGxvc3QgZm9jdXMuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5Gb2N1c091dCA9IDM7XG59KShUZXh0RG9jdW1lbnRTYXZlUmVhc29uIHx8IChleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSBUZXh0RG9jdW1lbnRTYXZlUmVhc29uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCB3aWxsIHNhdmUgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuXG4gKi9cbnZhciBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3dpbGxTYXZlJztcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2F0Y2hlZCBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgY2xpZW50IGRldGVjdHMgY2hhbmdlcyB0byBmaWxlIHdhdGNoZWQgYnkgdGhlIGxhbmd1YWdlIGNsaWVudC5cbiAqL1xudmFyIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzJztcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZmlsZSBldmVudCB0eXBlXG4gKi9cbnZhciBGaWxlQ2hhbmdlVHlwZTtcbihmdW5jdGlvbiAoRmlsZUNoYW5nZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5DcmVhdGVkID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5DaGFuZ2VkID0gMjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5EZWxldGVkID0gMztcbn0pKEZpbGVDaGFuZ2VUeXBlIHx8IChleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0gRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gfHwgKGV4cG9ydHMuUmVsYXRpdmVQYXR0ZXJuID0gUmVsYXRpdmVQYXR0ZXJuID0ge30pKTtcbnZhciBXYXRjaEtpbmQ7XG4oZnVuY3Rpb24gKFdhdGNoS2luZCkge1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY3JlYXRlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ3JlYXRlID0gMTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGNoYW5nZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ2hhbmdlID0gMjtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGRlbGV0ZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuRGVsZXRlID0gNDtcbn0pKFdhdGNoS2luZCB8fCAoZXhwb3J0cy5XYXRjaEtpbmQgPSBXYXRjaEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEaWFnbm9zdGljcyBub3RpZmljYXRpb24gYXJlIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2lnbmFsXG4gKiByZXN1bHRzIG9mIHZhbGlkYXRpb24gcnVucy5cbiAqL1xudmFyIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uKSB7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHVibGlzaERpYWdub3N0aWNzJztcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kID0gQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXF1ZXN0IGNvbXBsZXRpb24gYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50UG9zaXRpb259IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0gQ29tcGxldGlvbkl0ZW1bXX0gb3Ige0BsaW5rIENvbXBsZXRpb25MaXN0fVxuICogb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIGRlbGF5IHRoZSBjb21wdXRhdGlvbiBvZiB0aGUge0BsaW5rIENvbXBsZXRpb25JdGVtLmRldGFpbCBgZGV0YWlsYH1cbiAqIGFuZCB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZG9jdW1lbnRhdGlvbiBgZG9jdW1lbnRhdGlvbmB9IHByb3BlcnRpZXMgdG8gdGhlIGBjb21wbGV0aW9uSXRlbS9yZXNvbHZlYFxuICogcmVxdWVzdC4gSG93ZXZlciwgcHJvcGVydGllcyB0aGF0IGFyZSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsIHNvcnRpbmcgYW5kIGZpbHRlcmluZywgbGlrZSBgc29ydFRleHRgLFxuICogYGZpbHRlclRleHRgLCBgaW5zZXJ0VGV4dGAsIGFuZCBgdGV4dEVkaXRgLCBtdXN0IG5vdCBiZSBjaGFuZ2VkIGR1cmluZyByZXNvbHZlLlxuICovXG52YXIgQ29tcGxldGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25SZXF1ZXN0KSB7XG4gICAgQ29tcGxldGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb21wbGV0aW9uJztcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbXBsZXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IENvbXBsZXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gY29tcGxldGlvbiBpdGVtLlRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbX0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCkge1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnY29tcGxldGlvbkl0ZW0vcmVzb2x2ZSc7XG4gICAgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgfHwgKGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0gSG92ZXJSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogSG93IGEgc2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZC5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyBpbnZva2VkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyIG9yIGJ5IGEgY29tbWFuZC5cbiAgICAgKi9cbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZCBieSBhIHRyaWdnZXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5UcmlnZ2VyQ2hhcmFjdGVyID0gMjtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSBjdXJzb3IgbW92aW5nIG9yIGJ5IHRoZSBkb2N1bWVudCBjb250ZW50IGNoYW5naW5nLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5Db250ZW50Q2hhbmdlID0gMztcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSB7fSkpO1xudmFyIFNpZ25hdHVyZUhlbHBSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaWduYXR1cmVIZWxwUmVxdWVzdCkge1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2lnbmF0dXJlSGVscCc7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QpO1xufSkoU2lnbmF0dXJlSGVscFJlcXVlc3QgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSBTaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9ufVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhIHR5cGVkIGFycmF5IG9mXG4gKiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRGVmaW5pdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKERlZmluaXRpb25SZXF1ZXN0KSB7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kZWZpbml0aW9uJztcbiAgICBEZWZpbml0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERlZmluaXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IERlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0IHx8IChleHBvcnRzLlJlZmVyZW5jZXNSZXF1ZXN0ID0gUmVmZXJlbmNlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYSB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGZvciBhIGdpdmVuXG4gKiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn1cbiAqIHRoZSByZXF1ZXN0IHJlc3BvbnNlIGlzIGFuIGFycmF5IG9mIHR5cGUge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fVxuICogb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCkge1xuICAgIERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50SGlnaGxpZ2h0JztcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiB0ZXh0IGRvY3VtZW50IGFuZCByYW5nZS5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVxdWVzdCkge1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29kZUFjdGlvbic7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSBDb2RlQWN0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvZGUgYWN0aW9uLlRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSB0aGUgcmVzcG9uc2VcbiAqIGlzIG9mIHR5cGUge0BsaW5rIENvZGVBY3Rpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVBY3Rpb24vcmVzb2x2ZSc7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0gV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSByYW5nZSBpbnNpZGUgdGhlIHdvcmtzcGFjZVxuICogc3ltYm9sJ3MgbG9jYXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZVN5bWJvbC9yZXNvbHZlJztcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29kZSBsZW5zIGZvciB0aGUgZ2l2ZW4gdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIENvZGVMZW5zUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29kZUxlbnMnO1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVMZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlTGVuc1JlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBDb2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVmcmVzaCBhbGwgY29kZSBhY3Rpb25zXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9jb2RlTGVucy9yZWZyZXNoYDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGRvY3VtZW50IGxpbmtzXG4gKi9cbnZhciBEb2N1bWVudExpbmtSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50TGluayc7XG4gICAgRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBmb3JtYXQgYSB3aG9sZSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBmb3JtYXQgYSByYW5nZSBpbiBhIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yYW5nZUZvcm1hdHRpbmcnO1xuICAgIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IHJhbmdlcyBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG52YXIgRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yYW5nZXNGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QgPSBEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGZvcm1hdCBhIGRvY3VtZW50IG9uIHR5cGUuXG4gKi9cbnZhciBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L29uVHlwZUZvcm1hdHRpbmcnO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIFJlbmFtZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3I7XG4oZnVuY3Rpb24gKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCdzIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gc2VsZWN0IHRoZSBpZGVudGlmaWVyXG4gICAgICogYWNjb3JkaW5nIHRoZSB0byBsYW5ndWFnZSdzIHN5bnRheCBydWxlLlxuICAgICAqL1xuICAgIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yLklkZW50aWZpZXIgPSAxO1xufSkoUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgfHwgKGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgPSBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0gUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byB0ZXN0IGFuZCBwZXJmb3JtIHRoZSBzZXR1cCBuZWNlc3NhcnkgZm9yIGEgcmVuYW1lLlxuICpcbiAqIEBzaW5jZSAzLjE2IC0gc3VwcG9ydCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICovXG52YXIgUHJlcGFyZVJlbmFtZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFByZXBhcmVSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlUmVuYW1lJztcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShQcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHNlbmQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gZXhlY3V0ZSBhIGNvbW1hbmQuIFRoZSByZXF1ZXN0IG1pZ2h0IHJldHVyblxuICogYSB3b3Jrc3BhY2UgZWRpdCB3aGljaCB0aGUgY2xpZW50IHdpbGwgYXBwbHkgdG8gdGhlIHdvcmtzcGFjZS5cbiAqL1xudmFyIEV4ZWN1dGVDb21tYW5kUmVxdWVzdDtcbihmdW5jdGlvbiAoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0KSB7XG4gICAgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvZXhlY3V0ZUNvbW1hbmQnO1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWV0aG9kKTtcbn0pKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0gQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIyNDk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IGNhbiBiZSBlZGl0ZWQgdG9nZXRoZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9saW5rZWRFZGl0aW5nUmFuZ2UnO1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njg0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyS2luZCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIE1vbmlrZXIgdW5pcXVlbmVzcyBsZXZlbCB0byBkZWZpbmUgc2NvcGUgb2YgdGhlIG1vbmlrZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgVW5pcXVlbmVzc0xldmVsO1xuKGZ1bmN0aW9uIChVbmlxdWVuZXNzTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyBvbmx5IHVuaXF1ZSBpbnNpZGUgYSBkb2N1bWVudFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5kb2N1bWVudCA9ICdkb2N1bWVudCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSBhIHByb2plY3QgZm9yIHdoaWNoIGEgZHVtcCBnb3QgY3JlYXRlZFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5wcm9qZWN0ID0gJ3Byb2plY3QnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgdGhlIGdyb3VwIHRvIHdoaWNoIGEgcHJvamVjdCBiZWxvbmdzXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdyb3VwID0gJ2dyb3VwJztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBtb25pa2VyIHNjaGVtZS5cbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuc2NoZW1lID0gJ3NjaGVtZSc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdsb2JhbCA9ICdnbG9iYWwnO1xufSkoVW5pcXVlbmVzc0xldmVsIHx8IChleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IFVuaXF1ZW5lc3NMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBtb25pa2VyIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTW9uaWtlcktpbmQ7XG4oZnVuY3Rpb24gKE1vbmlrZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50IGEgc3ltYm9sIHRoYXQgaXMgaW1wb3J0ZWQgaW50byBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kaW1wb3J0ID0gJ2ltcG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGV4cG9ydGVkIGZyb20gYSBwcm9qZWN0XG4gICAgICovXG4gICAgTW9uaWtlcktpbmQuJGV4cG9ydCA9ICdleHBvcnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIHJlcHJlc2VudHMgYSBzeW1ib2wgdGhhdCBpcyBsb2NhbCB0byBhIHByb2plY3QgKGUuZy4gYSBsb2NhbFxuICAgICAqIHZhcmlhYmxlIG9mIGEgZnVuY3Rpb24sIGEgY2xhc3Mgbm90IHZpc2libGUgb3V0c2lkZSB0aGUgcHJvamVjdCwgLi4uKVxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLmxvY2FsID0gJ2xvY2FsJztcbn0pKE1vbmlrZXJLaW5kIHx8IChleHBvcnRzLk1vbmlrZXJLaW5kID0gTW9uaWtlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZ2V0IHRoZSBtb25pa2VyIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dCBkb2N1bWVudCBwb3NpdGlvbi5cbiAqIFRoZSByZXF1ZXN0IHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc30uXG4gKiBUaGUgcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgTW9uaWtlciBNb25pa2VyW119IG9yIGBudWxsYC5cbiAqL1xudmFyIE1vbmlrZXJSZXF1ZXN0O1xuKGZ1bmN0aW9uIChNb25pa2VyUmVxdWVzdCkge1xuICAgIE1vbmlrZXJSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvbW9uaWtlcic7XG4gICAgTW9uaWtlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBNb25pa2VyUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShNb25pa2VyUmVxdWVzdC5tZXRob2QpO1xufSkoTW9uaWtlclJlcXVlc3QgfHwgKGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBNb25pa2VyUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3OTI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODUyKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjMzKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIG5vdGVib29rIGNlbGwga2luZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxLaW5kO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSBtYXJrdXAtY2VsbCBpcyBmb3JtYXR0ZWQgc291cmNlIHRoYXQgaXMgdXNlZCBmb3IgZGlzcGxheS5cbiAgICAgKi9cbiAgICBOb3RlYm9va0NlbGxLaW5kLk1hcmt1cCA9IDE7XG4gICAgLyoqXG4gICAgICogQSBjb2RlLWNlbGwgaXMgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5Db2RlID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbEtpbmQuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbEtpbmQgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IE5vdGVib29rQ2VsbEtpbmQgPSB7fSkpO1xudmFyIEV4ZWN1dGlvblN1bW1hcnk7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZXhlY3V0aW9uT3JkZXIsIHN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBleGVjdXRpb25PcmRlciB9O1xuICAgICAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSB8fCBzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5leGVjdXRpb25PcmRlcikgJiYgKGNhbmRpZGF0ZS5zdWNjZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuc3VjY2VzcykpO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmUuZXhlY3V0aW9uT3JkZXIgPT09IG90aGVyLmV4ZWN1dGlvbk9yZGVyICYmIG9uZS5zdWNjZXNzID09PSBvdGhlci5zdWNjZXNzO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyA9IGVxdWFscztcbn0pKEV4ZWN1dGlvblN1bW1hcnkgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IEV4ZWN1dGlvblN1bW1hcnkgPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbDtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGtpbmQsIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQsIGRvY3VtZW50IH07XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgTm90ZWJvb2tDZWxsS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuRG9jdW1lbnRVcmkuaXMoY2FuZGlkYXRlLmRvY3VtZW50KSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5tZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlLm1ldGFkYXRhKSk7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGRpZmYob25lLCB0d28pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAob25lLmRvY3VtZW50ICE9PSB0d28uZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2RvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZS5raW5kICE9PSB0d28ua2luZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgna2luZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUuZXhlY3V0aW9uU3VtbWFyeSAhPT0gdHdvLmV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2V4ZWN1dGlvblN1bW1hcnknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9uZS5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkIHx8IHR3by5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSAmJiAhZXF1YWxzTWV0YWRhdGEob25lLm1ldGFkYXRhLCB0d28ubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdtZXRhZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob25lLmV4ZWN1dGlvblN1bW1hcnkgIT09IHVuZGVmaW5lZCB8fCB0d28uZXhlY3V0aW9uU3VtbWFyeSAhPT0gdW5kZWZpbmVkKSAmJiAhRXhlY3V0aW9uU3VtbWFyeS5lcXVhbHMob25lLmV4ZWN1dGlvblN1bW1hcnksIHR3by5leGVjdXRpb25TdW1tYXJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZXhlY3V0aW9uU3VtbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5kaWZmID0gZGlmZjtcbiAgICBmdW5jdGlvbiBlcXVhbHNNZXRhZGF0YShvbmUsIG90aGVyKSB7XG4gICAgICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uZSAhPT0gdHlwZW9mIG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25lQXJyYXkgPSBBcnJheS5pc0FycmF5KG9uZSk7XG4gICAgICAgIGNvbnN0IG90aGVyQXJyYXkgPSBBcnJheS5pc0FycmF5KG90aGVyKTtcbiAgICAgICAgaWYgKG9uZUFycmF5ICE9PSBvdGhlckFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZUFycmF5ICYmIG90aGVyQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lW2ldLCBvdGhlcltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMub2JqZWN0TGl0ZXJhbChvbmUpICYmIElzLm9iamVjdExpdGVyYWwob3RoZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBvbmVLZXlzID0gT2JqZWN0LmtleXMob25lKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKTtcbiAgICAgICAgICAgIGlmIChvbmVLZXlzLmxlbmd0aCAhPT0gb3RoZXJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uZUtleXMuc29ydCgpO1xuICAgICAgICAgICAgb3RoZXJLZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lS2V5cywgb3RoZXJLZXlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBvbmVLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lW3Byb3BdLCBvdGhlcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KShOb3RlYm9va0NlbGwgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsID0gTm90ZWJvb2tDZWxsID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50O1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbm90ZWJvb2tUeXBlLCB2ZXJzaW9uLCBjZWxscykge1xuICAgICAgICByZXR1cm4geyB1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLmludGVnZXIuaXMoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50LmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50IHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBOb3RlYm9va0RvY3VtZW50ID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9zeW5jJztcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0ge30pKTtcbi8qKlxuICogQSBub3RpZmljYXRpb24gc2VudCB3aGVuIGEgbm90ZWJvb2sgb3BlbnMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkT3Blbic7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxBcnJheUNoYW5nZSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5zdGFydCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEudWludGVnZXIuaXMoY2FuZGlkYXRlLmRlbGV0ZUNvdW50KSAmJiAoY2FuZGlkYXRlLmNlbGxzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY2VsbHMsIE5vdGVib29rQ2VsbC5pcykpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydCwgZGVsZXRlQ291bnQsIGNlbGxzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc3RhcnQsIGRlbGV0ZUNvdW50IH07XG4gICAgICAgIGlmIChjZWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2VsbHMgPSBjZWxscztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG59KShOb3RlYm9va0NlbGxBcnJheUNoYW5nZSB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZSA9IE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0ge30pKTtcbnZhciBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBkb2N1bWVudCBpcyBzYXZlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRTYXZlJztcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGNsb3Nlcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE2Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG52YXIgV29ya0RvbmVQcm9ncmVzcztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzcykge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3MudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gV29ya0RvbmVQcm9ncmVzcy50eXBlO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzLmlzID0gaXM7XG59KShXb3JrRG9uZVByb2dyZXNzIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSBXb3JrRG9uZVByb2dyZXNzID0ge30pKTtcbi8qKlxuICogVGhlIGB3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jcmVhdGVgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBpbml0aWF0ZSBwcm9ncmVzc1xuICogcmVwb3J0aW5nIGZyb20gdGhlIHNlcnZlci5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCkge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1ldGhvZCA9ICd3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jcmVhdGUnO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbGAgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSAgdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGNhbmNlbCBhIHByb2dyZXNzXG4gKiBpbml0aWF0ZWQgb24gdGhlIHNlcnZlciBzaWRlLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbikge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbCc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBzZWxlY3Rpb24gcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU2VsZWN0aW9uUmFuZ2UgU2VsZWN0aW9uUmFuZ2VbXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZVJlcXVlc3QpIHtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZWxlY3Rpb25SYW5nZSc7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IFNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIwNjc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vLS0tLS0tLSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zJyAtLS0tLVxudmFyIFRva2VuRm9ybWF0O1xuKGZ1bmN0aW9uIChUb2tlbkZvcm1hdCkge1xuICAgIFRva2VuRm9ybWF0LlJlbGF0aXZlID0gJ3JlbGF0aXZlJztcbn0pKFRva2VuRm9ybWF0IHx8IChleHBvcnRzLlRva2VuRm9ybWF0ID0gVG9rZW5Gb3JtYXQgPSB7fSkpO1xudmFyIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlKSB7XG4gICAgU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnO1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUmVnaXN0cmF0aW9uVHlwZShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc1JlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwvZGVsdGEnO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvcmFuZ2UnO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2Uvc2VtYW50aWNUb2tlbnMvcmVmcmVzaGA7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MzMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHNob3cgYSBkb2N1bWVudC4gVGhpcyByZXF1ZXN0IG1pZ2h0IG9wZW4gYW5cbiAqIGV4dGVybmFsIHByb2dyYW0gZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB0aGUgVVJJIHRvIG9wZW4uXG4gKiBGb3IgZXhhbXBsZSBhIHJlcXVlc3QgdG8gb3BlbiBgaHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vYFxuICogd2lsbCB2ZXJ5IGxpa2VseSBvcGVuIHRoZSBVUkkgaW4gYSBXRUIgYnJvd3Nlci5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4qL1xudmFyIFNob3dEb2N1bWVudFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dEb2N1bWVudFJlcXVlc3QpIHtcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0Lm1ldGhvZCA9ICd3aW5kb3cvc2hvd0RvY3VtZW50JztcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd0RvY3VtZW50UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaG93RG9jdW1lbnRSZXF1ZXN0Lm1ldGhvZCk7XG59KShTaG93RG9jdW1lbnRSZXF1ZXN0IHx8IChleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSBTaG93RG9jdW1lbnRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI2NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgVHlwZURlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlRGVmaW5pdGlvblJlcXVlc3QpIHtcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC90eXBlRGVmaW5pdGlvbic7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZURlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IFR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNjI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzdWx0IGEgYFR5cGVIaWVyYXJjaHlJdGVtYCBpbiBhIGRvY3VtZW50IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gKiBDYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCB0byBhIHN1YnR5cGVzIG9yIHN1cGVydHlwZXMgdHlwZSBoaWVyYXJjaHkuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlVHlwZUhpZXJhcmNoeSc7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdXBlcnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VwZXJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdWJ0eXBlcyBmb3IgYSBnaXZlbiBgVHlwZUhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1ldGhvZCA9ICd0eXBlSGllcmFyY2h5L3N1YnR5cGVzJztcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBUaGUgYHdvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzYCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGZldGNoIHRoZSBvcGVuIHdvcmtzcGFjZSBmb2xkZXJzLlxuICovXG52YXIgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzJztcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd29ya3NwYWNlL2RpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gdGhlIHdvcmtzcGFjZVxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyc7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODYzMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5vYmplY3RMaXRlcmFsID0gZXhwb3J0cy50eXBlZEFycmF5ID0gZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcbmZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGNoZWNrKTtcbn1cbmV4cG9ydHMudHlwZWRBcnJheSA9IHR5cGVkQXJyYXk7XG5mdW5jdGlvbiBvYmplY3RMaXRlcmFsKHZhbHVlKSB7XG4gICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcgY2xhc3MgaW5zdGFuY2VzIHBhc3MgdGhpcyBjaGVjayBhcyB3ZWxsLiBTaW5jZSB0aGUgTFNQXG4gICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAvLyBsaWtlIHRoaXM6IGBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpKSA9PT0gbnVsbGBcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMub2JqZWN0TGl0ZXJhbCA9IG9iamVjdExpdGVyYWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3MzA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDUpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODM0KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODE4KTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoYXJyLnNsaWNlKTtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZCA9ICRzbGljZSh0eXBlZEFycmF5LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG52YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCBuYW1lKSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2V0dGVyKHZhbHVlKTtcblx0XHRcdFx0Zm91bmQgPSAkc2xpY2UobmFtZSwgMSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDgzNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlKHN0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmUsIC4uLmFkZGVkTGluZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhdm9pZCB0b28gbWFueSBhcmd1bWVudHMgZm9yIHNwbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH1cbiAgICBwb3NpdGlvbkF0KG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH1cbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmNoYXJhY3RlciA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldCkge1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gbGluZU9mZnNldCAmJiBpc0VPTCh0aGlzLl9jb250ZW50LmNoYXJDb2RlQXQob2Zmc2V0IC0gMSkpKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgbGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5jcmVtZW50YWwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfVxufVxudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIGluaXRpYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBUZXh0RG9jdW1lbnQgYnkgbW9kaWZ5aW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgY2hhbmdlcyB2ZXJzaW9uIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dERvY3VtZW50LiBOb3RlOiBUaGF0J3MgdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShkb2N1bWVudCwgY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBGdWxsVGV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC51cGRhdGUoY2hhbmdlcywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHREb2N1bWVudC51cGRhdGU6IGRvY3VtZW50IG11c3QgYmUgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERvY3VtZW50LnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cy5tYXAoZ2V0V2VsbGZvcm1lZEVkaXQpLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygc29ydGVkRWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPCBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ID4gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cmluZyhsYXN0TW9kaWZpZWRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5uZXdUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2goZS5uZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHRleHQuc3Vic3RyKGxhc3RNb2RpZmllZE9mZnNldCkpO1xuICAgICAgICByZXR1cm4gc3BhbnMuam9pbignJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbmZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgLy8gc29ydGVkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICBsZXQgbGVmdElkeCA9IDA7XG4gICAgbGV0IHJpZ2h0SWR4ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgfVxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaXNFT0woY2gpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0T2Zmc2V0ICsgaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0VPTChjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IGNoYXIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZFJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKHRleHRFZGl0LnJhbmdlKTtcbiAgICBpZiAocmFuZ2UgIT09IHRleHRFZGl0LnJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IG5ld1RleHQ6IHRleHRFZGl0Lm5ld1RleHQsIHJhbmdlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0RWRpdDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjg1Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0ZWRUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGVkVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDaGFuZ2VBbm5vdGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25Db250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvblRyaWdnZXJLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZURlc2NyaXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlRGVzY3JpcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlTGVuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUxlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvckluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JQcmVzZW50YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9yUHJlc2VudGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tbWFuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tbWFuZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1UYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ3JlYXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ3JlYXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERlbGV0ZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIERlbGV0ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWNTZXZlcml0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1NldmVyaXR5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1RhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1RhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0OiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRIaWdobGlnaHRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRMaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudExpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFVyaTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRVcmkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBFT0w6ICgpID0+ICgvKiBiaW5kaW5nICovIEVPTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvbGRpbmdSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvcm1hdHRpbmdPcHRpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb3JtYXR0aW5nT3B0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEhvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBIb3ZlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50S2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludExhYmVsUGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50TGFiZWxQYXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25Db250ZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25JdGVtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVGV4dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVUZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFJlcGxhY2VFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRSZXBsYWNlRWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFRleHRGb3JtYXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRGb3JtYXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0TW9kZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0VGV4dE1vZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTG9jYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbkxpbms6ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uTGluayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmtlZFN0cmluZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya2VkU3RyaW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTWFya3VwQ29udGVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya3VwQ29udGVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cEtpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBhcmFtZXRlckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXJhbWV0ZXJJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBvc2l0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQb3NpdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJhbmdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJlbmFtZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIFJlbmFtZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZWxlY3RlZENvbXBsZXRpb25JbmZvOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZWxlY3RlZENvbXBsZXRpb25JbmZvKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VsZWN0aW9uUmFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbGVjdGlvblJhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbk1vZGlmaWVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNlbWFudGljVG9rZW5UeXBlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlblR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbWFudGljVG9rZW5zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2lnbmF0dXJlSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFNpZ25hdHVyZUluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3RyaW5nVmFsdWU6ICgpID0+ICgvKiBiaW5kaW5nICovIFN0cmluZ1ZhbHVlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFN5bWJvbEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN5bWJvbFRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRFZGl0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEl0ZW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVUkk6ICgpID0+ICgvKiBiaW5kaW5nICovIFVSSSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VDaGFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUNoYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VGb2xkZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUZvbGRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZVN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlU3ltYm9sKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW50ZWdlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50ZWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyB1aW50ZWdlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRG9jdW1lbnRVcmk7XG4oZnVuY3Rpb24gKERvY3VtZW50VXJpKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xudmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xudmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG52YXIgdWludGVnZXI7XG4oZnVuY3Rpb24gKHVpbnRlZ2VyKSB7XG4gICAgdWludGVnZXIuTUlOX1ZBTFVFID0gMDtcbiAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHVpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIHVpbnRlZ2VyLmlzID0gaXM7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3RlciB9O1xuICAgIH1cbiAgICBQb3NpdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBQb3NpdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmNoYXJhY3Rlcik7XG4gICAgfVxuICAgIFBvc2l0aW9uLmlzID0gaXM7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUmFuZ2V9IGxpdGVyYWxzLlxuICovXG52YXIgUmFuZ2U7XG4oZnVuY3Rpb24gKFJhbmdlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9uZSwgdHdvLCB0aHJlZSwgZm91cikge1xuICAgICAgICBpZiAoSXMudWludGVnZXIob25lKSAmJiBJcy51aW50ZWdlcih0d28pICYmIElzLnVpbnRlZ2VyKHRocmVlKSAmJiBJcy51aW50ZWdlcihmb3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZShvbmUsIHR3byksIGVuZDogUG9zaXRpb24uY3JlYXRlKHRocmVlLCBmb3VyKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBvc2l0aW9uLmlzKG9uZSkgJiYgUG9zaXRpb24uaXModHdvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IG9uZSwgZW5kOiB0d28gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzWyR7b25lfSwgJHt0d299LCAke3RocmVlfSwgJHtmb3VyfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbiBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4geyB1cmksIHJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnVyaSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbi5pcyA9IGlzO1xufSkoTG9jYXRpb24gfHwgKExvY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uTGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbkxpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQsXG4gICAgICAgICAgICBncmVlbixcbiAgICAgICAgICAgIGJsdWUsXG4gICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUucmVkLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmdyZWVuLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmJsdWUsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYWxwaGEsIDAsIDEpO1xuICAgIH1cbiAgICBDb2xvci5pcyA9IGlzO1xufSkoQ29sb3IgfHwgKENvbG9yID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9ySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvckluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBDb2xvci5pcyhjYW5kaWRhdGUuY29sb3IpO1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmlzID0gaXM7XG59KShDb2xvckluZm9ybWF0aW9uIHx8IChDb2xvckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yUHJlc2VudGF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgdGV4dEVkaXQsIGFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsVGV4dEVkaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbClcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRleHRFZGl0KSB8fCBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cykgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cywgVGV4dEVkaXQuaXMpKTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uaXMgPSBpcztcbn0pKENvbG9yUHJlc2VudGF0aW9uIHx8IChDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcmFuZ2Uga2luZHMuXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2VLaW5kO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VLaW5kKSB7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBjb21tZW50XG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5Db21tZW50ID0gJ2NvbW1lbnQnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGFuIGltcG9ydCBvciBpbmNsdWRlXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzID0gJ2ltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiA9ICdyZWdpb24nO1xufSkoRm9sZGluZ1JhbmdlS2luZCB8fCAoRm9sZGluZ1JhbmdlS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBmb2xkaW5nIHJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIEZvbGRpbmdSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2U7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRm9sZGluZ1JhbmdlIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnRDaGFyYWN0ZXIsIGVuZENoYXJhY3Rlciwga2luZCwgY29sbGFwc2VkVGV4dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmUsXG4gICAgICAgICAgICBlbmRMaW5lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHN0YXJ0Q2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0Q2hhcmFjdGVyID0gc3RhcnRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoZW5kQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZENoYXJhY3RlciA9IGVuZENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChraW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvbGxhcHNlZFRleHQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29sbGFwc2VkVGV4dCA9IGNvbGxhcHNlZFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvbGRpbmdSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSk7XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gfHwgKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxuICovXG52YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGVycm9yLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgaGludC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XG59KShEaWFnbm9zdGljU2V2ZXJpdHkgfHwgKERpYWdub3N0aWNTZXZlcml0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgRGlhZ25vc3RpY1RhZztcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1RhZykge1xuICAgIC8qKlxuICAgICAqIFVudXNlZCBvciB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgKiBhbiBlcnJvciBzcXVpZ2dsZS5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG9yIG9ic29sZXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlcmVkIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgc3RyaWtlIHRocm91Z2guXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbn0pKERpYWdub3N0aWNUYWcgfHwgKERpYWdub3N0aWNUYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlRGVzY3JpcHRpb247XG4oZnVuY3Rpb24gKENvZGVEZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaHJlZik7XG4gICAgfVxuICAgIENvZGVEZXNjcmlwdGlvbi5pcyA9IGlzO1xufSkoQ29kZURlc2NyaXB0aW9uIHx8IChDb2RlRGVzY3JpcHRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgRGlhZ25vc3RpYyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEaWFnbm9zdGljfSBsaXRlcmFscy5cbiAqL1xudmFyIERpYWdub3N0aWM7XG4oZnVuY3Rpb24gKERpYWdub3N0aWMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERpYWdub3N0aWMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCBzb3VyY2UsIHJlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSwgbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgdGl0bGUsIGNvbW1hbmQgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb21tYW5kLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbW1hbmR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb21tYW5kKTtcbiAgICB9XG4gICAgQ29tbWFuZC5pcyA9IGlzO1xufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSByZXBsYWNlLFxuICogaW5zZXJ0IGFuZCBkZWxldGUgZWRpdHMgbW9yZSBlYXNpbHkuXG4gKi9cbnZhciBUZXh0RWRpdDtcbihmdW5jdGlvbiAoVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zZXJ0IHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWxldGUgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xuICAgIH1cbiAgICBUZXh0RWRpdC5pcyA9IGlzO1xufSkoVGV4dEVkaXQgfHwgKFRleHRFZGl0ID0ge30pKTtcbnZhciBDaGFuZ2VBbm5vdGF0aW9uO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBuZWVkc0NvbmZpcm1hdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpICYmXG4gICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI7XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyIHx8IChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciA9IHt9KSk7XG52YXIgQW5ub3RhdGVkVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKEFubm90YXRlZFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQ6ICcnLCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSAmJiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmlzID0gaXM7XG59KShBbm5vdGF0ZWRUZXh0RWRpdCB8fCAoQW5ub3RhdGVkVGV4dEVkaXQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZVxuICogYW4gZWRpdCB0aGF0IG1hbmlwdWxhdGVzIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIFRleHREb2N1bWVudEVkaXQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0RG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudCwgZWRpdHMgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XG52YXIgQ3JlYXRlRmlsZTtcbihmdW5jdGlvbiAoQ3JlYXRlRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdjcmVhdGUnLFxuICAgICAgICAgICAgdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuaXMgPSBpcztcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xudmFyIFJlbmFtZUZpbGU7XG4oZnVuY3Rpb24gKFJlbmFtZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdyZW5hbWUnLFxuICAgICAgICAgICAgb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlbmFtZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5vbGRVcmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBSZW5hbWVGaWxlLmlzID0gaXM7XG59KShSZW5hbWVGaWxlIHx8IChSZW5hbWVGaWxlID0ge30pKTtcbnZhciBEZWxldGVGaWxlO1xuKGZ1bmN0aW9uIChEZWxldGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2RlbGV0ZScsXG4gICAgICAgICAgICB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5yZWN1cnNpdmUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xufSkoRGVsZXRlRmlsZSB8fCAoRGVsZXRlRmlsZSA9IHt9KSk7XG52YXIgV29ya3NwYWNlRWRpdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRWRpdC5pcyA9IGlzO1xufSkoV29ya3NwYWNlRWRpdCB8fCAoV29ya3NwYWNlRWRpdCA9IHt9KSk7XG5jbGFzcyBUZXh0RWRpdENoYW5nZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRzLCBjaGFuZ2VBbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLmVkaXRzID0gZWRpdHM7XG4gICAgICAgIHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMgPSBjaGFuZ2VBbm5vdGF0aW9ucztcbiAgICB9XG4gICAgaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LmRlbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZChlZGl0KSB7XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0cztcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZWRpdHMuc3BsaWNlKDAsIHRoaXMuZWRpdHMubGVuZ3RoKTtcbiAgICB9XG4gICAgYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGV4dCBlZGl0IGNoYW5nZSBpcyBub3QgY29uZmlndXJlZCB0byBtYW5hZ2UgY2hhbmdlIGFubm90YXRpb25zLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGhlbHBlciBjbGFzc1xuICovXG5jbGFzcyBDaGFuZ2VBbm5vdGF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIG1hbmFnZShpZE9yQW5ub3RhdGlvbiwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElkICR7aWR9IGlzIGFscmVhZHkgaW4gdXNlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uc1tpZF0gPSBhbm5vdGF0aW9uO1xuICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgbmV4dElkKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbmNsYXNzIFdvcmtzcGFjZUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iod29ya3NwYWNlRWRpdCkge1xuICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAod29ya3NwYWNlRWRpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0gd29ya3NwYWNlRWRpdDtcbiAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGNoYW5nZS5lZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2NoYW5nZS50ZXh0RG9jdW1lbnQudXJpXSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwod29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFdvcmtzcGFjZUVkaXR9IGxpdGVyYWxcbiAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZWRpdCgpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgfVxuICAgIGdldFRleHRFZGl0Q2hhbmdlKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50ID0geyB1cmk6IGtleS51cmksIHZlcnNpb246IGtleS52ZXJzaW9uIH07XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb2N1bWVudENoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlRmlsZSh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5hbWVGaWxlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUZpbGUodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAqL1xudmFyIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCB2ZXJzaW9uIH07XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbik7XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0IH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJdGVtIHx8IChUZXh0RG9jdW1lbnRJdGVtID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIHRoZSBjb250ZW50IHR5cGUgdGhhdCBhIGNsaWVudCBzdXBwb3J0cyBpbiB2YXJpb3VzXG4gKiByZXN1bHQgbGl0ZXJhbHMgbGlrZSBgSG92ZXJgLCBgUGFyYW1ldGVySW5mb2Agb3IgYENvbXBsZXRpb25JdGVtYC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGBNYXJrdXBLaW5kc2AgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIGAkYC4gVGhpcyBraW5kc1xuICogYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZS5cbiAqL1xudmFyIE1hcmt1cEtpbmQ7XG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0IGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5QbGFpblRleHQgPSAncGxhaW50ZXh0JztcbiAgICAvKipcbiAgICAgKiBNYXJrZG93biBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuTWFya2Rvd24gPSAnbWFya2Rvd24nO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbHVlIG9mIHRoZSB7QGxpbmsgTWFya3VwS2luZH0gdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbnZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ID0gMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kID0gMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciA9IDQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkID0gNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyA9IDc7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSA9IDg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID0gMTA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgPSAxMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSA9IDEzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkID0gMTQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgPSAxNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSA9IDE3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyID0gMTk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgPSAyMDtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0ID0gMjI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50ID0gMjM7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNTtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAqIHBsYWluIHRleHQgb3IgYSBzbmlwcGV0LlxuICovXG52YXIgSW5zZXJ0VGV4dEZvcm1hdDtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlBsYWluVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgc25pcHBldC5cbiAgICAgKlxuICAgICAqIEEgc25pcHBldCBjYW4gZGVmaW5lIHRhYiBzdG9wcyBhbmQgcGxhY2Vob2xkZXJzIHdpdGggYCQxYCwgYCQyYFxuICAgICAqIGFuZCBgJHszOmZvb31gLiBgJDBgIGRlZmluZXMgdGhlIGZpbmFsIHRhYiBzdG9wLCBpdCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBlbmQgb2YgdGhlIHNuaXBwZXQuIFBsYWNlaG9sZGVycyB3aXRoIGVxdWFsIGlkZW50aWZpZXJzIGFyZSBsaW5rZWQsXG4gICAgICogdGhhdCBpcyB0eXBpbmcgaW4gb25lIHdpbGwgdXBkYXRlIG90aGVycyB0b28uXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL2xhbmd1YWdlLXNlcnZlci1wcm90b2NvbC9zcGVjaWZpY2F0aW9ucy9zcGVjaWZpY2F0aW9uLWN1cnJlbnQvI3NuaXBwZXRfc3ludGF4XG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0ID0gMjtcbn0pKEluc2VydFRleHRGb3JtYXQgfHwgKEluc2VydFRleHRGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBDb21wbGV0aW9uIGl0ZW0gdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgY29tcGxldGlvblxuICogaXRlbS5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEluc2VydFJlcGxhY2VFZGl0O1xuKGZ1bmN0aW9uIChJbnNlcnRSZXBsYWNlRWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zZXJ0IC8gcmVwbGFjZSBlZGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRUZXh0TW9kZTtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zZXJ0aW9uIG9yIHJlcGxhY2Ugc3RyaW5ncyBpcyB0YWtlbiBhcyBpdCBpcy4gSWYgdGhlXG4gICAgICogdmFsdWUgaXMgbXVsdGkgbGluZSB0aGUgbGluZXMgYmVsb3cgdGhlIGN1cnNvciB3aWxsIGJlXG4gICAgICogaW5zZXJ0ZWQgdXNpbmcgdGhlIGluZGVudGF0aW9uIGRlZmluZWQgaW4gdGhlIHN0cmluZyB2YWx1ZS5cbiAgICAgKiBUaGUgY2xpZW50IHdpbGwgbm90IGFwcGx5IGFueSBraW5kIG9mIGFkanVzdG1lbnRzIHRvIHRoZVxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hc0lzID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGFkanVzdHMgbGVhZGluZyB3aGl0ZXNwYWNlIG9mIG5ldyBsaW5lcyBzbyB0aGF0XG4gICAgICogdGhleSBtYXRjaCB0aGUgaW5kZW50YXRpb24gdXAgdG8gdGhlIGN1cnNvciBvZiB0aGUgbGluZSBmb3JcbiAgICAgKiB3aGljaCB0aGUgaXRlbSBpcyBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIGEgbGluZSBsaWtlIHRoaXM6IDwydGFicz48Y3Vyc29yPjwzdGFicz5mb28uIEFjY2VwdGluZyBhXG4gICAgICogbXVsdGkgbGluZSBjb21wbGV0aW9uIGl0ZW0gaXMgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFuZCBhbGxcbiAgICAgKiBmb2xsb3dpbmcgbGluZXMgaW5zZXJ0ZWQgd2lsbCBiZSBpbmRlbnRlZCB1c2luZyAyIHRhYnMgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hZGp1c3RJbmRlbnRhdGlvbiA9IDI7XG59KShJbnNlcnRUZXh0TW9kZSB8fCAoSW5zZXJ0VGV4dE1vZGUgPSB7fSkpO1xudmFyIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkgfHwgY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMuaXMgPSBpcztcbn0pKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIHx8IChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21wbGV0aW9uSXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICogY29tcGxldGlvbiBpdGVtcy5cbiAqL1xudmFyIENvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBjb21wbGV0aW9uIGl0ZW0ncyBsYWJlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICByZXR1cm4geyBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbnZhciBDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBsZXRpb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cbiAgICAgKiBAcGFyYW0gaXNJbmNvbXBsZXRlIFRoZSBsaXN0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG52YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5pcyA9IGlzO1xufSkoTWFya2VkU3RyaW5nIHx8IChNYXJrZWRTdHJpbmcgPSB7fSkpO1xudmFyIEhvdmVyO1xuKGZ1bmN0aW9uIChIb3Zlcikge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgIE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICB9XG4gICAgSG92ZXIuaXMgPSBpcztcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQYXJhbWV0ZXJJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQYXJhbWV0ZXJJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoUGFyYW1ldGVySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhcmFtZXRlciBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhYmVsIEEgbGFiZWwgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudGF0aW9uIEEgZG9jIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb24gPyB7IGxhYmVsLCBkb2N1bWVudGF0aW9uIH0gOiB7IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24sIC4uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgbGFiZWwgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTaWduYXR1cmVJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTaWduYXR1cmVJbmZvcm1hdGlvbiB8fCAoU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA9IDM7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIERvY3VtZW50SGlnaGxpZ2h0IG5hbWVzcGFjZSB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9jdW1lbnRIaWdobGlnaHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdGhlIGhpZ2hsaWdodCBhcHBsaWVzIHRvLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBoaWdobGlnaHQga2luZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwga2luZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSB9O1xuICAgICAgICBpZiAoSXMubnVtYmVyKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRIaWdobGlnaHQuY3JlYXRlID0gY3JlYXRlO1xufSkoRG9jdW1lbnRIaWdobGlnaHQgfHwgKERvY3VtZW50SGlnaGxpZ2h0ID0ge30pKTtcbi8qKlxuICogQSBzeW1ib2wga2luZC5cbiAqL1xudmFyIFN5bWJvbEtpbmQ7XG4oZnVuY3Rpb24gKFN5bWJvbEtpbmQpIHtcbiAgICBTeW1ib2xLaW5kLkZpbGUgPSAxO1xuICAgIFN5bWJvbEtpbmQuTW9kdWxlID0gMjtcbiAgICBTeW1ib2xLaW5kLk5hbWVzcGFjZSA9IDM7XG4gICAgU3ltYm9sS2luZC5QYWNrYWdlID0gNDtcbiAgICBTeW1ib2xLaW5kLkNsYXNzID0gNTtcbiAgICBTeW1ib2xLaW5kLk1ldGhvZCA9IDY7XG4gICAgU3ltYm9sS2luZC5Qcm9wZXJ0eSA9IDc7XG4gICAgU3ltYm9sS2luZC5GaWVsZCA9IDg7XG4gICAgU3ltYm9sS2luZC5Db25zdHJ1Y3RvciA9IDk7XG4gICAgU3ltYm9sS2luZC5FbnVtID0gMTA7XG4gICAgU3ltYm9sS2luZC5JbnRlcmZhY2UgPSAxMTtcbiAgICBTeW1ib2xLaW5kLkZ1bmN0aW9uID0gMTI7XG4gICAgU3ltYm9sS2luZC5WYXJpYWJsZSA9IDEzO1xuICAgIFN5bWJvbEtpbmQuQ29uc3RhbnQgPSAxNDtcbiAgICBTeW1ib2xLaW5kLlN0cmluZyA9IDE1O1xuICAgIFN5bWJvbEtpbmQuTnVtYmVyID0gMTY7XG4gICAgU3ltYm9sS2luZC5Cb29sZWFuID0gMTc7XG4gICAgU3ltYm9sS2luZC5BcnJheSA9IDE4O1xuICAgIFN5bWJvbEtpbmQuT2JqZWN0ID0gMTk7XG4gICAgU3ltYm9sS2luZC5LZXkgPSAyMDtcbiAgICBTeW1ib2xLaW5kLk51bGwgPSAyMTtcbiAgICBTeW1ib2xLaW5kLkVudW1NZW1iZXIgPSAyMjtcbiAgICBTeW1ib2xLaW5kLlN0cnVjdCA9IDIzO1xuICAgIFN5bWJvbEtpbmQuRXZlbnQgPSAyNDtcbiAgICBTeW1ib2xLaW5kLk9wZXJhdG9yID0gMjU7XG4gICAgU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyID0gMjY7XG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcbi8qKlxuICogU3ltYm9sIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIHN5bWJvbC5cbiAqXG4gKiBAc2luY2UgMy4xNlxuICovXG52YXIgU3ltYm9sVGFnO1xuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBzeW1ib2wgYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIFN5bWJvbFRhZy5EZXByZWNhdGVkID0gMTtcbn0pKFN5bWJvbFRhZyB8fCAoU3ltYm9sVGFnID0ge30pKTtcbnZhciBTeW1ib2xJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU3ltYm9sSW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgcmVzb3VyY2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sIGNvbnRhaW5pbmcgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwga2luZCwgcmFuZ2UsIHVyaSwgY29udGFpbmVyTmFtZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBsb2NhdGlvbjogeyB1cmksIHJhbmdlIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTeW1ib2xJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTeW1ib2xJbmZvcm1hdGlvbiB8fCAoU3ltYm9sSW5mb3JtYXRpb24gPSB7fSkpO1xudmFyIFdvcmtzcGFjZVN5bWJvbDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdvcmtzcGFjZSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgcmVzb3VyY2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIEFuIG9wdGlvbnMgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgV29ya3NwYWNlU3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCB1cmksIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHsgbmFtZSwga2luZCwgbG9jYXRpb246IHsgdXJpLCByYW5nZSB9IH1cbiAgICAgICAgICAgIDogeyBuYW1lLCBraW5kLCBsb2NhdGlvbjogeyB1cmkgfSB9O1xuICAgIH1cbiAgICBXb3Jrc3BhY2VTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xufSkoV29ya3NwYWNlU3ltYm9sIHx8IChXb3Jrc3BhY2VTeW1ib2wgPSB7fSkpO1xudmFyIERvY3VtZW50U3ltYm9sO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25SYW5nZSBUaGUgc2VsZWN0aW9uUmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwgZGV0YWlsLCBraW5kLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50U3ltYm9sfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICBJcy5zdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmIElzLm51bWJlcihjYW5kaWRhdGUua2luZCkgJiZcbiAgICAgICAgICAgIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnNlbGVjdGlvblJhbmdlKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRlcHJlY2F0ZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5kZXByZWNhdGVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5jaGlsZHJlbikpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnRhZ3MgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS50YWdzKSk7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmlzID0gaXM7XG59KShEb2N1bWVudFN5bWJvbCB8fCAoRG9jdW1lbnRTeW1ib2wgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIGNvZGUgYWN0aW9uIGtpbmRzXG4gKi9cbnZhciBDb2RlQWN0aW9uS2luZDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBFbXB0eSBraW5kLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLkVtcHR5ID0gJyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBxdWlja2ZpeCBhY3Rpb25zOiAncXVpY2tmaXgnXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUXVpY2tGaXggPSAncXVpY2tmaXgnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgYWN0aW9uczogJ3JlZmFjdG9yJ1xuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yID0gJ3JlZmFjdG9yJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGV4dHJhY3Rpb24gYWN0aW9uczogJ3JlZmFjdG9yLmV4dHJhY3QnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGV4dHJhY3QgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gRXh0cmFjdCBtZXRob2RcbiAgICAgKiAtIEV4dHJhY3QgZnVuY3Rpb25cbiAgICAgKiAtIEV4dHJhY3QgdmFyaWFibGVcbiAgICAgKiAtIEV4dHJhY3QgaW50ZXJmYWNlIGZyb20gY2xhc3NcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yRXh0cmFjdCA9ICdyZWZhY3Rvci5leHRyYWN0JztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGlubGluZSBhY3Rpb25zOiAncmVmYWN0b3IuaW5saW5lJ1xuICAgICAqXG4gICAgICogRXhhbXBsZSBpbmxpbmUgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gSW5saW5lIGZ1bmN0aW9uXG4gICAgICogLSBJbmxpbmUgdmFyaWFibGVcbiAgICAgKiAtIElubGluZSBjb25zdGFudFxuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JJbmxpbmUgPSAncmVmYWN0b3IuaW5saW5lJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIHJld3JpdGUgYWN0aW9uczogJ3JlZmFjdG9yLnJld3JpdGUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHJld3JpdGUgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gQ29udmVydCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHRvIGNsYXNzXG4gICAgICogLSBBZGQgb3IgcmVtb3ZlIHBhcmFtZXRlclxuICAgICAqIC0gRW5jYXBzdWxhdGUgZmllbGRcbiAgICAgKiAtIE1ha2UgbWV0aG9kIHN0YXRpY1xuICAgICAqIC0gTW92ZSBtZXRob2QgdG8gYmFzZSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JSZXdyaXRlID0gJ3JlZmFjdG9yLnJld3JpdGUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3Igc291cmNlIGFjdGlvbnM6IGBzb3VyY2VgXG4gICAgICpcbiAgICAgKiBTb3VyY2UgY29kZSBhY3Rpb25zIGFwcGx5IHRvIHRoZSBlbnRpcmUgZmlsZS5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2UgPSAnc291cmNlJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGFuIG9yZ2FuaXplIGltcG9ydHMgc291cmNlIGFjdGlvbjogYHNvdXJjZS5vcmdhbml6ZUltcG9ydHNgXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlT3JnYW5pemVJbXBvcnRzID0gJ3NvdXJjZS5vcmdhbml6ZUltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYXV0by1maXggc291cmNlIGFjdGlvbnM6IGBzb3VyY2UuZml4QWxsYC5cbiAgICAgKlxuICAgICAqIEZpeCBhbGwgYWN0aW9ucyBhdXRvbWF0aWNhbGx5IGZpeCBlcnJvcnMgdGhhdCBoYXZlIGEgY2xlYXIgZml4IHRoYXQgZG8gbm90IHJlcXVpcmUgdXNlciBpbnB1dC5cbiAgICAgKiBUaGV5IHNob3VsZCBub3Qgc3VwcHJlc3MgZXJyb3JzIG9yIHBlcmZvcm0gdW5zYWZlIGZpeGVzIHN1Y2ggYXMgZ2VuZXJhdGluZyBuZXcgdHlwZXMgb3IgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE1LjBcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VGaXhBbGwgPSAnc291cmNlLmZpeEFsbCc7XG59KShDb2RlQWN0aW9uS2luZCB8fCAoQ29kZUFjdGlvbktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgcmVhc29uIHdoeSBjb2RlIGFjdGlvbnMgd2VyZSByZXF1ZXN0ZWQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgQ29kZUFjdGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSBleHBsaWNpdGx5IHJlcXVlc3RlZCBieSB0aGUgdXNlciBvciBieSBhbiBleHRlbnNpb24uXG4gICAgICovXG4gICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kLkludm9rZWQgPSAxO1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIGN1cnJlbnQgc2VsZWN0aW9uIGluIGEgZmlsZSBjaGFuZ2VzLCBidXQgY2FuXG4gICAgICogYWxzbyBiZSB0cmlnZ2VyZWQgd2hlbiBmaWxlIGNvbnRlbnQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMjtcbn0pKENvZGVBY3Rpb25UcmlnZ2VyS2luZCB8fCAoQ29kZUFjdGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVBY3Rpb25Db250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBsaXRlcmFscy5cbiAqL1xudmFyIENvZGVBY3Rpb25Db250ZXh0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uQ29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUFjdGlvbkNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZGlhZ25vc3RpY3MsIG9ubHksIHRyaWdnZXJLaW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbnZhciBDb2RlQWN0aW9uO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHRpdGxlIH07XG4gICAgICAgIGxldCBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVja0tpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21tYW5kLmlzKGtpbmRPckNvbW1hbmRPckVkaXQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrS2luZCAmJiBraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCA9PT0gdW5kZWZpbmVkIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2RlTGVuc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUxlbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29kZUxlbnN9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb21tYW5kKSB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIENvZGVMZW5zLmlzID0gaXM7XG59KShDb2RlTGVucyB8fCAoQ29kZUxlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRm9ybWF0dGluZ09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9ybWF0dGluZ09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgRm9ybWF0dGluZ09wdGlvbnM7XG4oZnVuY3Rpb24gKEZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzIH07XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5pcyA9IGlzO1xufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRMaW5rO1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERvY3VtZW50TGluayBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGFyZ2V0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0YXJnZXQsIGRhdGEgfTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50TGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRhcmdldCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50YXJnZXQpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmlzID0gaXM7XG59KShEb2N1bWVudExpbmsgfHwgKERvY3VtZW50TGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBTZWxlY3Rpb25SYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIHdvcmsgd2l0aFxuICogU2VsZWN0aW9uUmFuZ2UgbGl0ZXJhbHMuXG4gKi9cbnZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoY2FuZGlkYXRlLnBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IFNlbGVjdGlvblJhbmdlLmlzKGNhbmRpZGF0ZS5wYXJlbnQpKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuaXMgPSBpcztcbn0pKFNlbGVjdGlvblJhbmdlIHx8IChTZWxlY3Rpb25SYW5nZSA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gdHlwZXMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICogYW4gY2xpZW50cyBjYW4gc3BlY2lmeSBhZGRpdGlvbmFsIHRva2VuIHR5cGVzIHZpYSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5UeXBlcykge1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm5hbWVzcGFjZVwiXSA9IFwibmFtZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGdlbmVyaWMgdHlwZS4gQWN0cyBhcyBhIGZhbGxiYWNrIGZvciB0eXBlcyB3aGljaCBjYW4ndCBiZSBtYXBwZWQgdG9cbiAgICAgKiBhIHNwZWNpZmljIHR5cGUgbGlrZSBjbGFzcyBvciBlbnVtLlxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVcIl0gPSBcInR5cGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiaW50ZXJmYWNlXCJdID0gXCJpbnRlcmZhY2VcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwYXJhbWV0ZXJcIl0gPSBcInBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1NZW1iZXJcIl0gPSBcImVudW1NZW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtZXRob2RcIl0gPSBcIm1ldGhvZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtb2RpZmllclwiXSA9IFwibW9kaWZpZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImRlY29yYXRvclwiXSA9IFwiZGVjb3JhdG9yXCI7XG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbk1vZGlmaWVycztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbk1vZGlmaWVycykge1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWNsYXJhdGlvblwiXSA9IFwiZGVjbGFyYXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmaW5pdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJyZWFkb25seVwiXSA9IFwicmVhZG9ubHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wic3RhdGljXCJdID0gXCJzdGF0aWNcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVwcmVjYXRlZFwiXSA9IFwiZGVwcmVjYXRlZFwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhYnN0cmFjdFwiXSA9IFwiYWJzdHJhY3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYXN5bmNcIl0gPSBcImFzeW5jXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcIm1vZGlmaWNhdGlvblwiXSA9IFwibW9kaWZpY2F0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRvY3VtZW50YXRpb25cIl0gPSBcImRvY3VtZW50YXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmYXVsdExpYnJhcnlcIl0gPSBcImRlZmF1bHRMaWJyYXJ5XCI7XG59KShTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIHx8IChTZW1hbnRpY1Rva2VuTW9kaWZpZXJzID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjYW5kaWRhdGUucmVzdWx0SWQgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZGF0YSkgJiYgKGNhbmRpZGF0ZS5kYXRhLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgY2FuZGlkYXRlLmRhdGFbMF0gPT09ICdudW1iZXInKTtcbiAgICB9XG4gICAgU2VtYW50aWNUb2tlbnMuaXMgPSBpcztcbn0pKFNlbWFudGljVG9rZW5zIHx8IChTZW1hbnRpY1Rva2VucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVUZXh0cy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVRleHQ7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVGV4dCB8fCAoSW5saW5lVmFsdWVUZXh0ID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXApIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cCB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLmNhc2VTZW5zaXRpdmVMb29rdXApXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUpIHx8IGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUgPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgfHwgKElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb247XG4oZnVuY3Rpb24gKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZXhwcmVzc2lvbikgfHwgY2FuZGlkYXRlLmV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiB8fCAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVDb250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVDb250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoSW5saW5lVmFsdWVDb250ZXh0ID0ge30pKTtcbi8qKlxuICogSW5sYXkgaGludCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQW4gaW5sYXkgaGludCB0aGF0IGZvciBhIHR5cGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBJbmxheUhpbnRLaW5kLlR5cGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBpcyBmb3IgYSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5QYXJhbWV0ZXIgPSAyO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSB8fCB2YWx1ZSA9PT0gMjtcbiAgICB9XG4gICAgSW5sYXlIaW50S2luZC5pcyA9IGlzO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG52YXIgSW5sYXlIaW50TGFiZWxQYXJ0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRMYWJlbFBhcnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9XG4gICAgSW5sYXlIaW50TGFiZWxQYXJ0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbnZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBwb3NpdGlvbiwgbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmxhYmVsLCBJbmxheUhpbnRMYWJlbFBhcnQuaXMpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRleHRFZGl0cyA9PT0gdW5kZWZpbmVkKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbnZhciBTdHJpbmdWYWx1ZTtcbihmdW5jdGlvbiAoU3RyaW5nVmFsdWUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVTbmlwcGV0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6ICdzbmlwcGV0JywgdmFsdWUgfTtcbiAgICB9XG4gICAgU3RyaW5nVmFsdWUuY3JlYXRlU25pcHBldCA9IGNyZWF0ZVNuaXBwZXQ7XG59KShTdHJpbmdWYWx1ZSB8fCAoU3RyaW5nVmFsdWUgPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uSXRlbSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCkge1xuICAgICAgICByZXR1cm4geyBpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uSXRlbSB8fCAoSW5saW5lQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uTGlzdCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcykge1xuICAgICAgICByZXR1cm4geyBpdGVtcyB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uTGlzdCB8fCAoSW5saW5lQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IGFuIHtAbGluayBJbmxpbmVDb21wbGV0aW9uSXRlbVByb3ZpZGVyIGlubGluZSBjb21wbGV0aW9uIHByb3ZpZGVyfSB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG52YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDA7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgd2hpbGUgZWRpdGluZy5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMTtcbn0pKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTZWxlY3RlZENvbXBsZXRpb25JbmZvO1xuKGZ1bmN0aW9uIChTZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIFNlbGVjdGVkQ29tcGxldGlvbkluZm8uY3JlYXRlID0gY3JlYXRlO1xufSkoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB8fCAoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyA9IHt9KSk7XG52YXIgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25Db250ZXh0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiB7IHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25Db250ZXh0IHx8IChJbmxpbmVDb21wbGV0aW9uQ29udGV4dCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBVUkkuaXMoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRm9sZGVyLmlzID0gaXM7XG59KShXb3Jrc3BhY2VGb2xkZXIgfHwgKFdvcmtzcGFjZUZvbGRlciA9IHt9KSk7XG5jb25zdCBFT0wgPSBbJ1xcbicsICdcXHJcXG4nLCAnXFxyJ107XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG52YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElUZXh0RG9jdW1lbnQgbGl0ZXJhbCBmcm9tIHRoZSBnaXZlbiB1cmkgYW5kIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJVGV4dERvY3VtZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZUNvdW50KVxuICAgICAgICAgICAgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgbGV0IHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGUubmV3VGV4dCArIHRleHQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAvLyBzb3J0ZWRcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgICAgIG1lcmdlU29ydChsZWZ0LCBjb21wYXJlKTtcbiAgICAgICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgbGV0IGxlZnRJZHggPSAwO1xuICAgICAgICBsZXQgcmlnaHRJZHggPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgdXBkYXRlKGV2ZW50LCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBldmVudC50ZXh0O1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9XG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgbGV0IG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgfVxufVxudmFyIElzO1xuKGZ1bmN0aW9uIChJcykge1xuICAgIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlKTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2dsb2JhbCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRcdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuLyoqKioqKi8gXHRcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKioqKioqLyBcdFx0XHR9IGNhdGNoIChlKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9KSgpO1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuLyoqKioqKi8gXHRcdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIG1vZHVsZTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4oKCkgPT4ge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgTHVhU2VydmljZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTHVhU2VydmljZSlcbn0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2Jhc2Utc2VydmljZS50c1xudmFyIGJhc2Vfc2VydmljZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyNSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy9sdWFwYXJzZS9sdWFwYXJzZS5qc1xudmFyIGx1YXBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2wvbGliL2Jyb3dzZXIvbWFpbi5qc1xudmFyIG1haW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy50c1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzcwKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hY2UvcmFuZ2Utc2luZ2xldG9uLnRzXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5jbGFzcyBBY2VSYW5nZSB7XG4gICAgc3RhdGljIGdldENvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICBpZiAoIUFjZVJhbmdlLl9pbnN0YW5jZSAmJiBlZGl0b3IpIHtcbiAgICAgICAgICAgIEFjZVJhbmdlLl9pbnN0YW5jZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpLmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBY2VSYW5nZS5faW5zdGFuY2U7XG4gICAgfVxufVxuX2RlZmluZV9wcm9wZXJ0eShBY2VSYW5nZSwgXCJfaW5zdGFuY2VcIiwgdm9pZCAwKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3R5cGUtY29udmVydGVycy9jb21tb24tY29udmVydGVycy50c1xuXG5cblxudmFyIGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlcjtcbihmdW5jdGlvbihDb21tb25Db252ZXJ0ZXIpIHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemVSYW5nZXMoY29tcGxldGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25zICYmIGNvbXBsZXRpb25zLm1hcCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoZWxbXCJyYW5nZVwiXSkge1xuICAgICAgICAgICAgICAgIGVsW1wicmFuZ2VcIl0gPSB0b1JhbmdlKGVsW1wicmFuZ2VcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLm5vcm1hbGl6ZVJhbmdlcyA9IG5vcm1hbGl6ZVJhbmdlcztcbiAgICBmdW5jdGlvbiBjbGVhbkh0bWwoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88YVxccy8sIFwiPGEgdGFyZ2V0PSdfYmxhbmsnIFwiKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLmNsZWFuSHRtbCA9IGNsZWFuSHRtbDtcbiAgICBmdW5jdGlvbiB0b1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2UgfHwgIXJhbmdlLnN0YXJ0IHx8ICFyYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgUmFuZ2UgPSBBY2VSYW5nZS5nZXRDb25zdHJ1Y3RvcigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIudG9SYW5nZSA9IHRvUmFuZ2U7XG4gICAgZnVuY3Rpb24gY29udmVydEtpbmQoa2luZCkge1xuICAgICAgICBzd2l0Y2goa2luZCl7XG4gICAgICAgICAgICBjYXNlIFwicHJpbWl0aXZlVHlwZVwiOlxuICAgICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZDtcbiAgICAgICAgICAgIGNhc2UgXCJ2YXJpYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImxvY2FsVmFyaWFibGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGU7XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyVmFyaWFibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtZW1iZXJHZXRBY2Nlc3NvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm1lbWJlclNldEFjY2Vzc29yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyRnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RTaWduYXR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsU2lnbmF0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5kZXhTaWduYXR1cmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb247XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5FbnVtO1xuICAgICAgICAgICAgY2FzZSBcIm1vZHVsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuQ2xhc3M7XG4gICAgICAgICAgICBjYXNlIFwiaW50ZXJmYWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZTtcbiAgICAgICAgICAgIGNhc2UgXCJ3YXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5O1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIuY29udmVydEtpbmQgPSBjb252ZXJ0S2luZDtcbiAgICBmdW5jdGlvbiBleGNsdWRlQnlFcnJvck1lc3NhZ2UoZGlhZ25vc3RpY3MsIGVycm9yTWVzc2FnZXNUb0lnbm9yZSwgZmllbGROYW1lID0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgaWYgKCFlcnJvck1lc3NhZ2VzVG9JZ25vcmUpIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzLmZpbHRlcigoZWwpPT4hKDAsdXRpbHMvKiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5ICovLlRrKShlbFtmaWVsZE5hbWVdLCBlcnJvck1lc3NhZ2VzVG9JZ25vcmUpKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLmV4Y2x1ZGVCeUVycm9yTWVzc2FnZSA9IGV4Y2x1ZGVCeUVycm9yTWVzc2FnZTtcbn0pKGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlciB8fCAoY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyID0ge30pKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3R5cGUtY29udmVydGVycy9sc3AvbHNwLWNvbnZlcnRlcnMudHNcblxuXG5cblxuZnVuY3Rpb24gZnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGxpbmU6IHJhbmdlLnN0YXJ0LnJvdyxcbiAgICAgICAgICAgIGNoYXJhY3RlcjogcmFuZ2Uuc3RhcnQuY29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgbGluZTogcmFuZ2UuZW5kLnJvdyxcbiAgICAgICAgICAgIGNoYXJhY3RlcjogcmFuZ2UuZW5kLmNvbHVtblxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlRnJvbVBvc2l0aW9ucyhzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHJvdzogcmFuZ2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgcm93OiByYW5nZS5lbmQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogcmFuZ2UuZW5kLmNoYXJhY3RlclxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21Qb2ludChwb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IHBvaW50LnJvdyxcbiAgICAgICAgY2hhcmFjdGVyOiBwb2ludC5jb2x1bW5cbiAgICB9O1xufVxuZnVuY3Rpb24gdG9Qb2ludChwb3NpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvdzogcG9zaXRpb24ubGluZSxcbiAgICAgICAgY29sdW1uOiBwb3NpdGlvbi5jaGFyYWN0ZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9Bbm5vdGF0aW9ucyhkaWFnbm9zdGljcykge1xuICAgIHZhciBfZGlhZ25vc3RpY3M7XG4gICAgcmV0dXJuIChfZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcykgPT09IG51bGwgfHwgX2RpYWdub3N0aWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGlhZ25vc3RpY3MubWFwKChlbCk9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogZWwucmFuZ2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZWwucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyLFxuICAgICAgICAgICAgdGV4dDogZWwubWVzc2FnZSxcbiAgICAgICAgICAgIHR5cGU6IGVsLnNldmVyaXR5ID09PSAxID8gXCJlcnJvclwiIDogZWwuc2V2ZXJpdHkgPT09IDIgPyBcIndhcm5pbmdcIiA6IFwiaW5mb1wiLFxuICAgICAgICAgICAgY29kZTogZWwuY29kZVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZnJvbUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgdmFyIF9hbm5vdGF0aW9ucztcbiAgICByZXR1cm4gKF9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zKSA9PT0gbnVsbCB8fCBfYW5ub3RhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9ucy5tYXAoKGVsKT0+e1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBlbC5yb3csXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogZWwuY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZWwucm93LFxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGVsLmNvbHVtblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiBlbC50ZXh0LFxuICAgICAgICAgICAgc2V2ZXJpdHk6IGVsLnR5cGUgPT09IFwiZXJyb3JcIiA/IDEgOiBlbC50eXBlID09PSBcIndhcm5pbmdcIiA/IDIgOiAzLFxuICAgICAgICAgICAgY29kZTogZWxbXCJjb2RlXCJdXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb24oaXRlbSkge1xuICAgIHZhciBfaXRlbV90ZXh0RWRpdCwgX2l0ZW1fY29tbWFuZDtcbiAgICBsZXQgaXRlbUtpbmQgPSBpdGVtLmtpbmQ7XG4gICAgbGV0IGtpbmQgPSBpdGVtS2luZCA/IE9iamVjdC5rZXlzKENvbXBsZXRpb25JdGVtS2luZClbT2JqZWN0LnZhbHVlcyhDb21wbGV0aW9uSXRlbUtpbmQpLmluZGV4T2YoaXRlbUtpbmQpXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCwgX3JlZjtcbiAgICBsZXQgdGV4dCA9IChfcmVmID0gKF9pdGVtX3RleHRFZGl0X25ld1RleHQgPSAoX2l0ZW1fdGV4dEVkaXQgPSBpdGVtLnRleHRFZGl0KSA9PT0gbnVsbCB8fCBfaXRlbV90ZXh0RWRpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fdGV4dEVkaXQubmV3VGV4dCkgIT09IG51bGwgJiYgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCAhPT0gdm9pZCAwID8gX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCA6IGl0ZW0uaW5zZXJ0VGV4dCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGl0ZW0ubGFiZWw7XG4gICAgbGV0IGZpbHRlclRleHQ7XG4gICAgLy8gZmlsdGVyaW5nIHdvdWxkIGhhcHBlbiBvbiBhY2UgZWRpdG9yIHNpZGVcbiAgICAvL1RPRE86IGlmIGZpbHRlcmluZyBhbmQgc29ydGluZyBhcmUgb24gc2VydmVyIHNpZGUsIHdlIHNob3VsZCBkaXNhYmxlIEZpbHRlcmVkTGlzdCBpbiBhY2UgY29tcGxldGVyXG4gICAgaWYgKGl0ZW0uZmlsdGVyVGV4dCkge1xuICAgICAgICBjb25zdCBmaXJzdFdvcmRNYXRjaCA9IGl0ZW0uZmlsdGVyVGV4dC5tYXRjaCgvXFx3Ky8pO1xuICAgICAgICBjb25zdCBmaXJzdFdvcmQgPSBmaXJzdFdvcmRNYXRjaCA/IGZpcnN0V29yZE1hdGNoWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKGZpcnN0V29yZCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZFJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke2ZpcnN0V29yZH1cXFxcYmAsICdpJyk7XG4gICAgICAgICAgICBpZiAoIXdvcmRSZWdleC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGV4dC5pbmNsdWRlcyhpdGVtLmZpbHRlclRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tbWFuZCA9ICgoX2l0ZW1fY29tbWFuZCA9IGl0ZW0uY29tbWFuZCkgPT09IG51bGwgfHwgX2l0ZW1fY29tbWFuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fY29tbWFuZC5jb21tYW5kKSA9PSBcImVkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3RcIiA/IFwic3RhcnRBdXRvY29tcGxldGVcIiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcmFuZ2UgPSBpdGVtLnRleHRFZGl0ID8gZ2V0VGV4dEVkaXRSYW5nZShpdGVtLnRleHRFZGl0LCBmaWx0ZXJUZXh0KSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY29tcGxldGlvbiA9IHtcbiAgICAgICAgbWV0YToga2luZCxcbiAgICAgICAgY2FwdGlvbjogaXRlbS5sYWJlbCxcbiAgICAgICAgc2NvcmU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgY29tcGxldGlvbltcImNvbW1hbmRcIl0gPSBjb21tYW5kO1xuICAgIGNvbXBsZXRpb25bXCJyYW5nZVwiXSA9IHJhbmdlO1xuICAgIGNvbXBsZXRpb25bXCJpdGVtXCJdID0gaXRlbTtcbiAgICBpZiAoaXRlbS5pbnNlcnRUZXh0Rm9ybWF0ID09IEluc2VydFRleHRGb3JtYXQuU25pcHBldCkge1xuICAgICAgICBjb21wbGV0aW9uW1wic25pcHBldFwiXSA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGlvbltcInZhbHVlXCJdID0gdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogXCJcIjtcbiAgICB9XG4gICAgY29tcGxldGlvbltcImRvY3VtZW50YXRpb25cIl0gPSBpdGVtLmRvY3VtZW50YXRpb247IC8vVE9ETzogdGhpcyBpcyB3b3JrYXJvdW5kIGZvciBzZXJ2aWNlcyB3aXRoIGluc3RhbnQgY29tcGxldGlvblxuICAgIGNvbXBsZXRpb25bXCJwb3NpdGlvblwiXSA9IGl0ZW1bXCJwb3NpdGlvblwiXTtcbiAgICBjb21wbGV0aW9uW1wic2VydmljZVwiXSA9IGl0ZW1bXCJzZXJ2aWNlXCJdOyAvL1RPRE86IHNpbmNlIHdlIGhhdmUgbXVsdGlwbGUgc2VydmVycywgd2UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAvLyBzZXJ2ZXIgdG8gdXNlIGZvciByZXNvbHZpbmdcbiAgICByZXR1cm4gY29tcGxldGlvbjtcbn1cbmZ1bmN0aW9uIHRvQ29tcGxldGlvbnMoY29tcGxldGlvbnMpIHtcbiAgICBpZiAoY29tcGxldGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgY29tYmluZWRDb21wbGV0aW9ucyA9IGdldENvbXBsZXRpb25JdGVtcyhjb21wbGV0aW9ucyk7XG4gICAgICAgIHJldHVybiBjb21iaW5lZENvbXBsZXRpb25zLm1hcCgoaXRlbSk9PnRvQ29tcGxldGlvbihpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGdldENvbXBsZXRpb25JdGVtcyhjb21wbGV0aW9ucykge1xuICAgIHJldHVybiBjb21wbGV0aW9ucy5tYXAoKGVsKT0+e1xuICAgICAgICBpZiAoIWVsLmNvbXBsZXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsbENvbXBsZXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbC5jb21wbGV0aW9ucykpIHtcbiAgICAgICAgICAgIGFsbENvbXBsZXRpb25zID0gZWwuY29tcGxldGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxDb21wbGV0aW9ucyA9IGVsLmNvbXBsZXRpb25zLml0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxDb21wbGV0aW9ucy5tYXAoKGl0ZW0pPT57XG4gICAgICAgICAgICBpdGVtW1wic2VydmljZVwiXSA9IGVsLnNlcnZpY2U7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfSkuZmxhdCgpO1xufVxuZnVuY3Rpb24gdG9JbmxpbmVDb21wbGV0aW9uKGl0ZW0pIHtcbiAgICB2YXIgX2l0ZW1fY29tbWFuZDtcbiAgICBsZXQgdGV4dCA9IHR5cGVvZiBpdGVtLmluc2VydFRleHQgPT09IFwic3RyaW5nXCIgPyBpdGVtLmluc2VydFRleHQgOiBpdGVtLmluc2VydFRleHQudmFsdWU7XG4gICAgbGV0IGZpbHRlclRleHQ7XG4gICAgLy8gZmlsdGVyaW5nIHdvdWxkIGhhcHBlbiBvbiBhY2UgZWRpdG9yIHNpZGVcbiAgICAvL1RPRE86IGlmIGZpbHRlcmluZyBhbmQgc29ydGluZyBhcmUgb24gc2VydmVyIHNpZGUsIHdlIHNob3VsZCBkaXNhYmxlIEZpbHRlcmVkTGlzdCBpbiBhY2UgY29tcGxldGVyXG4gICAgaWYgKGl0ZW0uZmlsdGVyVGV4dCkge1xuICAgICAgICBjb25zdCBmaXJzdFdvcmRNYXRjaCA9IGl0ZW0uZmlsdGVyVGV4dC5tYXRjaCgvXFx3Ky8pO1xuICAgICAgICBjb25zdCBmaXJzdFdvcmQgPSBmaXJzdFdvcmRNYXRjaCA/IGZpcnN0V29yZE1hdGNoWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKGZpcnN0V29yZCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZFJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke2ZpcnN0V29yZH1cXFxcYmAsICdpJyk7XG4gICAgICAgICAgICBpZiAoIXdvcmRSZWdleC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGV4dC5pbmNsdWRlcyhpdGVtLmZpbHRlclRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tbWFuZCA9ICgoX2l0ZW1fY29tbWFuZCA9IGl0ZW0uY29tbWFuZCkgPT09IG51bGwgfHwgX2l0ZW1fY29tbWFuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fY29tbWFuZC5jb21tYW5kKSA9PSBcImVkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3RcIiA/IFwic3RhcnRBdXRvY29tcGxldGVcIiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcmFuZ2UgPSBpdGVtLnJhbmdlID8gZ2V0SW5saW5lQ29tcGxldGlvblJhbmdlKGl0ZW0ucmFuZ2UsIGZpbHRlclRleHQpIDogdW5kZWZpbmVkO1xuICAgIGxldCBjb21wbGV0aW9uID0ge307XG4gICAgY29tcGxldGlvbltcImNvbW1hbmRcIl0gPSBjb21tYW5kO1xuICAgIGNvbXBsZXRpb25bXCJyYW5nZVwiXSA9IHJhbmdlO1xuICAgIGNvbXBsZXRpb25bXCJpdGVtXCJdID0gaXRlbTtcbiAgICBpZiAodHlwZW9mIGl0ZW0uaW5zZXJ0VGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb21wbGV0aW9uW1wic25pcHBldFwiXSA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGlvbltcInZhbHVlXCJdID0gdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogXCJcIjtcbiAgICB9XG4gICAgY29tcGxldGlvbltcInBvc2l0aW9uXCJdID0gaXRlbVtcInBvc2l0aW9uXCJdO1xuICAgIGNvbXBsZXRpb25bXCJzZXJ2aWNlXCJdID0gaXRlbVtcInNlcnZpY2VcIl07IC8vVE9ETzogc2luY2Ugd2UgaGF2ZSBtdWx0aXBsZSBzZXJ2ZXJzLCB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgIC8vIHNlcnZlciB0byB1c2UgZm9yIHJlc29sdmluZ1xuICAgIHJldHVybiBjb21wbGV0aW9uO1xufVxuZnVuY3Rpb24gdG9JbmxpbmVDb21wbGV0aW9ucyhjb21wbGV0aW9ucykge1xuICAgIGlmIChjb21wbGV0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBjb21iaW5lZENvbXBsZXRpb25zID0gZ2V0Q29tcGxldGlvbkl0ZW1zKGNvbXBsZXRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkQ29tcGxldGlvbnMubWFwKChpdGVtKT0+dG9JbmxpbmVDb21wbGV0aW9uKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gdG9SZXNvbHZlZENvbXBsZXRpb24oY29tcGxldGlvbiwgaXRlbSkge1xuICAgIGNvbXBsZXRpb25bXCJkb2NNYXJrZG93blwiXSA9IGZyb21NYXJrdXBDb250ZW50KGl0ZW0uZG9jdW1lbnRhdGlvbik7XG4gICAgcmV0dXJuIGNvbXBsZXRpb247XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb25JdGVtKGNvbXBsZXRpb24pIHtcbiAgICBsZXQgY29tbWFuZDtcbiAgICBpZiAoY29tcGxldGlvbltcImNvbW1hbmRcIl0pIHtcbiAgICAgICAgY29tbWFuZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcInRyaWdnZXJTdWdnZXN0XCIsXG4gICAgICAgICAgICBjb21tYW5kOiBjb21wbGV0aW9uW1wiY29tbWFuZFwiXVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgX2NvbXBsZXRpb25fY2FwdGlvbjtcbiAgICBsZXQgY29tcGxldGlvbkl0ZW0gPSB7XG4gICAgICAgIGxhYmVsOiAoX2NvbXBsZXRpb25fY2FwdGlvbiA9IGNvbXBsZXRpb24uY2FwdGlvbikgIT09IG51bGwgJiYgX2NvbXBsZXRpb25fY2FwdGlvbiAhPT0gdm9pZCAwID8gX2NvbXBsZXRpb25fY2FwdGlvbiA6IFwiXCIsXG4gICAgICAgIGtpbmQ6IENvbW1vbkNvbnZlcnRlci5jb252ZXJ0S2luZChjb21wbGV0aW9uLm1ldGEpLFxuICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBjb21wbGV0aW9uW1wic25pcHBldFwiXSA/IEluc2VydFRleHRGb3JtYXQuU25pcHBldCA6IEluc2VydFRleHRGb3JtYXQuUGxhaW5UZXh0LFxuICAgICAgICBkb2N1bWVudGF0aW9uOiBjb21wbGV0aW9uW1wiZG9jdW1lbnRhdGlvblwiXVxuICAgIH07XG4gICAgaWYgKGNvbXBsZXRpb25bXCJyYW5nZVwiXSkge1xuICAgICAgICB2YXIgX2NvbXBsZXRpb25fc25pcHBldDtcbiAgICAgICAgY29tcGxldGlvbkl0ZW0udGV4dEVkaXQgPSB7XG4gICAgICAgICAgICByYW5nZTogZnJvbVJhbmdlKGNvbXBsZXRpb25bXCJyYW5nZVwiXSksXG4gICAgICAgICAgICBuZXdUZXh0OiAoX2NvbXBsZXRpb25fc25pcHBldCA9IGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdKSAhPT0gbnVsbCAmJiBfY29tcGxldGlvbl9zbmlwcGV0ICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9zbmlwcGV0IDogY29tcGxldGlvbltcInZhbHVlXCJdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb21wbGV0aW9uX3NuaXBwZXQxO1xuICAgICAgICBjb21wbGV0aW9uSXRlbS5pbnNlcnRUZXh0ID0gKF9jb21wbGV0aW9uX3NuaXBwZXQxID0gY29tcGxldGlvbltcInNuaXBwZXRcIl0pICE9PSBudWxsICYmIF9jb21wbGV0aW9uX3NuaXBwZXQxICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9zbmlwcGV0MSA6IGNvbXBsZXRpb25bXCJ2YWx1ZVwiXTtcbiAgICB9XG4gICAgY29tcGxldGlvbkl0ZW1bXCJmaWxlTmFtZVwiXSA9IGNvbXBsZXRpb25bXCJmaWxlTmFtZVwiXTtcbiAgICBjb21wbGV0aW9uSXRlbVtcInBvc2l0aW9uXCJdID0gY29tcGxldGlvbltcInBvc2l0aW9uXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wiaXRlbVwiXSA9IGNvbXBsZXRpb25bXCJpdGVtXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wic2VydmljZVwiXSA9IGNvbXBsZXRpb25bXCJzZXJ2aWNlXCJdOyAvL1RPRE86XG4gICAgcmV0dXJuIGNvbXBsZXRpb25JdGVtO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEVkaXRSYW5nZSh0ZXh0RWRpdCwgZmlsdGVyVGV4dCkge1xuICAgIGNvbnN0IGZpbHRlckxlbmd0aCA9IGZpbHRlclRleHQgPyBmaWx0ZXJUZXh0Lmxlbmd0aCA6IDA7XG4gICAgaWYgKFwiaW5zZXJ0XCIgaW4gdGV4dEVkaXQgJiYgXCJyZXBsYWNlXCIgaW4gdGV4dEVkaXQpIHtcbiAgICAgICAgbGV0IG1lcmdlZFJhbmdlcyA9IG1lcmdlUmFuZ2VzKFtcbiAgICAgICAgICAgIHRvUmFuZ2UodGV4dEVkaXQuaW5zZXJ0KSxcbiAgICAgICAgICAgIHRvUmFuZ2UodGV4dEVkaXQucmVwbGFjZSlcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBtZXJnZWRSYW5nZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dEVkaXQucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC09IGZpbHRlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRvUmFuZ2UodGV4dEVkaXQucmFuZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldElubGluZUNvbXBsZXRpb25SYW5nZShyYW5nZSwgZmlsdGVyVGV4dCkge1xuICAgIGNvbnN0IGZpbHRlckxlbmd0aCA9IGZpbHRlclRleHQgPyBmaWx0ZXJUZXh0Lmxlbmd0aCA6IDA7XG4gICAgcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC09IGZpbHRlckxlbmd0aDtcbiAgICByZXR1cm4gdG9SYW5nZShyYW5nZSk7XG59XG5mdW5jdGlvbiB0b1Rvb2x0aXAoaG92ZXIpIHtcbiAgICB2YXIgX2hvdmVyX2ZpbmQ7XG4gICAgaWYgKCFob3ZlcikgcmV0dXJuO1xuICAgIGxldCBjb250ZW50ID0gaG92ZXIubWFwKChlbCk9PntcbiAgICAgICAgaWYgKCFlbCB8fCAhZWwuY29udGVudHMpIHJldHVybjtcbiAgICAgICAgaWYgKE1hcmt1cENvbnRlbnQuaXMoZWwuY29udGVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU1hcmt1cENvbnRlbnQoZWwuY29udGVudHMpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hcmtlZFN0cmluZy5pcyhlbC5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwuY29udGVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJgYGBcIiArIGVsLmNvbnRlbnRzLnZhbHVlICsgXCJgYGBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50cyA9IGVsLmNvbnRlbnRzLm1hcCgoZWwpPT57XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcYFxcYFxcYCR7ZWwudmFsdWV9XFxgXFxgXFxgYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudHMuam9pbihcIlxcblxcblwiKTtcbiAgICAgICAgfVxuICAgIH0pLmZpbHRlcihub3RFbXB0eSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgLy9UT0RPOiBpdCBjb3VsZCBiZSBtZXJnZWQgd2l0aGluIGFsbCByYW5nZXMgaW4gZnV0dXJlXG4gICAgbGV0IGxzcFJhbmdlID0gKF9ob3Zlcl9maW5kID0gaG92ZXIuZmluZCgoZWwpPT57XG4gICAgICAgIHZhciBfZWw7XG4gICAgICAgIHJldHVybiAoX2VsID0gZWwpID09PSBudWxsIHx8IF9lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsLnJhbmdlO1xuICAgIH0pKSA9PT0gbnVsbCB8fCBfaG92ZXJfZmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hvdmVyX2ZpbmQucmFuZ2U7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChsc3BSYW5nZSkgcmFuZ2UgPSB0b1JhbmdlKGxzcFJhbmdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgICB0ZXh0OiBjb250ZW50LmpvaW4oXCJcXG5cXG5cIilcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21TaWduYXR1cmVIZWxwKHNpZ25hdHVyZUhlbHApIHtcbiAgICBpZiAoIXNpZ25hdHVyZUhlbHApIHJldHVybjtcbiAgICBsZXQgY29udGVudCA9IHNpZ25hdHVyZUhlbHAubWFwKChlbCk9PntcbiAgICAgICAgdmFyIF9lbCwgX2VsMTtcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc2lnbmF0dXJlSW5kZXggPSAoKF9lbCA9IGVsKSA9PT0gbnVsbCB8fCBfZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbC5hY3RpdmVTaWduYXR1cmUpIHx8IDA7XG4gICAgICAgIGxldCBhY3RpdmVTaWduYXR1cmUgPSBlbC5zaWduYXR1cmVzW3NpZ25hdHVyZUluZGV4XTtcbiAgICAgICAgaWYgKCFhY3RpdmVTaWduYXR1cmUpIHJldHVybjtcbiAgICAgICAgbGV0IGFjdGl2ZVBhcmFtID0gKF9lbDEgPSBlbCkgPT09IG51bGwgfHwgX2VsMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsMS5hY3RpdmVQYXJhbWV0ZXI7XG4gICAgICAgIGxldCBjb250ZW50cyA9IGFjdGl2ZVNpZ25hdHVyZS5sYWJlbDtcbiAgICAgICAgaWYgKGFjdGl2ZVBhcmFtICE9IHVuZGVmaW5lZCAmJiBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVycyAmJiBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVyc1thY3RpdmVQYXJhbV0pIHtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IGFjdGl2ZVNpZ25hdHVyZS5wYXJhbWV0ZXJzW2FjdGl2ZVBhcmFtXS5sYWJlbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMucmVwbGFjZShwYXJhbSwgYCoqJHtwYXJhbX0qKmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbikge1xuICAgICAgICAgICAgaWYgKE1hcmt1cENvbnRlbnQuaXMoYWN0aXZlU2lnbmF0dXJlLmRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzICsgXCJcXG5cXG5cIiArIGZyb21NYXJrdXBDb250ZW50KGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgKz0gXCJcXG5cXG5cIiArIGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICAgICAgfVxuICAgIH0pLmZpbHRlcihub3RFbXB0eSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrZG93blwiLFxuICAgICAgICAgICAgdGV4dDogY29udGVudC5qb2luKFwiXFxuXFxuXCIpXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbU1hcmt1cENvbnRlbnQoY29udGVudCkge1xuICAgIGlmICghY29udGVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudC52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tQWNlRGVsdGEoZGVsdGEsIGVvbCkge1xuICAgIGNvbnN0IHRleHQgPSBkZWx0YS5saW5lcy5sZW5ndGggPiAxID8gZGVsdGEubGluZXMuam9pbihlb2wpIDogZGVsdGEubGluZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2U6IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHJhbmdlRnJvbVBvc2l0aW9ucyhmcm9tUG9pbnQoZGVsdGEuc3RhcnQpLCBmcm9tUG9pbnQoZGVsdGEuc3RhcnQpKSA6IHJhbmdlRnJvbVBvc2l0aW9ucyhmcm9tUG9pbnQoZGVsdGEuc3RhcnQpLCBmcm9tUG9pbnQoZGVsdGEuZW5kKSksXG4gICAgICAgIHRleHQ6IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHRleHQgOiBcIlwiXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckRpYWdub3N0aWNzKGRpYWdub3N0aWNzLCBmaWx0ZXJFcnJvcnMpIHtcbiAgICByZXR1cm4gY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyLmV4Y2x1ZGVCeUVycm9yTWVzc2FnZShkaWFnbm9zdGljcywgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkubWFwKChlbCk9PntcbiAgICAgICAgaWYgKCgwLHV0aWxzLyogY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSAqLy5UaykoZWwubWVzc2FnZSwgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nKSkge1xuICAgICAgICAgICAgZWwuc2V2ZXJpdHkgPSBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKCgwLHV0aWxzLyogY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSAqLy5UaykoZWwubWVzc2FnZSwgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvKSkge1xuICAgICAgICAgICAgZWwuc2V2ZXJpdHkgPSBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRIaWdobGlnaHRzKGRvY3VtZW50SGlnaGxpZ2h0cykge1xuICAgIHJldHVybiBkb2N1bWVudEhpZ2hsaWdodHMubWFwKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSBlbC5raW5kID09IDIgPyBcImxhbmd1YWdlX2hpZ2hsaWdodF9yZWFkXCIgOiBlbC5raW5kID09IDMgPyBcImxhbmd1YWdlX2hpZ2hsaWdodF93cml0ZVwiIDogXCJsYW5ndWFnZV9oaWdobGlnaHRfdGV4dFwiO1xuICAgICAgICByZXR1cm4gdG9NYXJrZXJHcm91cEl0ZW0oQ29tbW9uQ29udmVydGVyLnRvUmFuZ2UodG9SYW5nZShlbC5yYW5nZSkpLCBjbGFzc05hbWUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9NYXJrZXJHcm91cEl0ZW0ocmFuZ2UsIGNsYXNzTmFtZSwgdG9vbHRpcFRleHQpIHtcbiAgICBsZXQgbWFya2VyR3JvdXBJdGVtID0ge1xuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfTtcbiAgICBpZiAodG9vbHRpcFRleHQpIHtcbiAgICAgICAgbWFya2VyR3JvdXBJdGVtW1widG9vbHRpcFRleHRcIl0gPSB0b29sdGlwVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlckdyb3VwSXRlbTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2x1YS9sdWEtc2VydmljZS50c1xuZnVuY3Rpb24gbHVhX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cblxuXG5jbGFzcyBMdWFTZXJ2aWNlIGV4dGVuZHMgYmFzZV9zZXJ2aWNlLkJhc2VTZXJ2aWNlIHtcbiAgICBhc3luYyBkb1ZhbGlkYXRpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXREb2N1bWVudFZhbHVlKGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGVycm9ycyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kc2VydmljZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgdGhpcy4kc2VydmljZS5TeW50YXhFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGUuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGUuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyRGlhZ25vc3RpY3MoZXJyb3JzLCB0aGlzLm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobW9kZSl7XG4gICAgICAgIHN1cGVyKG1vZGUpO1xuICAgICAgICBsdWFfc2VydmljZV9kZWZpbmVfcHJvcGVydHkodGhpcywgXCIkc2VydmljZVwiLCB2b2lkIDApO1xuICAgICAgICBsdWFfc2VydmljZV9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHtcbiAgICAgICAgICAgIGRpYWdub3N0aWNQcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIGludGVyRmlsZURlcGVuZGVuY2llczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VEaWFnbm9zdGljczogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kc2VydmljZSA9IGx1YXBhcnNlO1xuICAgIH1cbn1cblxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImEiLCJpIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJwcm9jZXNzIiwiY29uc29sZSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9yZXF1aXJlIiwiX3JlcXVpcmUkY29kZXMiLCJjb2RlcyIsIkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9JTlZBTElEX0FSR19WQUxVRSIsIkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSIsIkVSUl9NSVNTSU5HX0FSR1MiLCJBc3NlcnRpb25FcnJvciIsIl9yZXF1aXJlMiIsImluc3BlY3QiLCJfcmVxdWlyZSR0eXBlcyIsInR5cGVzIiwiaXNQcm9taXNlIiwiaXNSZWdFeHAiLCJvYmplY3RBc3NpZ24iLCJPYmplY3QiLCJhc3NpZ24iLCJvYmplY3RJcyIsImlzIiwiZXJyb3JDYWNoZSIsIk1hcCIsImlzRGVlcEVxdWFsIiwiaXNEZWVwU3RyaWN0RXF1YWwiLCJwYXJzZUV4cHJlc3Npb25BdCIsImZpbmROb2RlQXJvdW5kIiwiZGVjb2RlciIsImxhenlMb2FkQ29tcGFyaXNvbiIsImNvbXBhcmlzb24iLCJlc2NhcGVTZXF1ZW5jZXNSZWdFeHAiLCJtZXRhIiwiZXNjYXBlRm4iLCJzdHIiLCJjaGFyQ29kZUF0Iiwid2FybmVkIiwiYXNzZXJ0Iiwib2siLCJOT19FWENFUFRJT05fU0VOVElORUwiLCJpbm5lckZhaWwiLCJtZXNzYWdlIiwiRXJyb3IiLCJmYWlsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcGVyYXRvciIsInN0YWNrU3RhcnRGbiIsImFyZ3NMZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpbnRlcm5hbE1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJ3YXJuIiwiZW1pdFdhcm5pbmciLCJiaW5kIiwiZXJyQXJncyIsImVyciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJpbm5lck9rIiwiZm4iLCJhcmdMZW4iLCJ2YWx1ZSIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiYXBwbHkiLCJjb25jYXQiLCJlcXVhbCIsIm5vdEVxdWFsIiwiZGVlcEVxdWFsIiwibm90RGVlcEVxdWFsIiwiZGVlcFN0cmljdEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsIkNvbXBhcmlzb24iLCJrZXlzIiwiX3RoaXMiLCJmb3JFYWNoIiwia2V5IiwidGVzdCIsImNvbXBhcmVFeGNlcHRpb25LZXkiLCJiIiwibmFtZSIsImV4cGVjdGVkRXhjZXB0aW9uIiwibXNnIiwicHVzaCIsImlzUHJvdG90eXBlT2YiLCJjYWxsIiwiZ2V0QWN0dWFsIiwiZSIsImNoZWNrSXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwid2FpdEZvckFjdHVhbCIsInByb21pc2VGbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzdWx0UHJvbWlzZSIsImV4cGVjdHNFcnJvciIsImVycm9yIiwiZGV0YWlscyIsImZuVHlwZSIsImV4cGVjdHNOb0Vycm9yIiwidGhyb3dzIiwiX2xlbjIiLCJfa2V5MiIsInJlamVjdHMiLCJfbGVuMyIsIl9rZXkzIiwicmVzdWx0IiwiZG9lc05vdFRocm93IiwiX2xlbjQiLCJfa2V5NCIsImRvZXNOb3RSZWplY3QiLCJfbGVuNSIsIl9rZXk1IiwiaWZFcnJvciIsIm5ld0VyciIsIm9yaWdTdGFjayIsInN0YWNrIiwidG1wMiIsInNwbGl0Iiwic2hpZnQiLCJ0bXAxIiwicG9zIiwiaW5kZXhPZiIsInNsaWNlIiwiam9pbiIsInN0cmljdCIsIl9sZW42IiwiX2tleTYiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0Iiwic291cmNlIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiQ2xhc3MiLCJfY2FjaGUiLCJfaXNOYXRpdmVGdW5jdGlvbiIsImhhcyIsImdldCIsInNldCIsIldyYXBwZXIiLCJfY29uc3RydWN0IiwiX2dldFByb3RvdHlwZU9mIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkRhdGUiLCJ0b1N0cmluZyIsIlBhcmVudCIsIkZ1bmN0aW9uIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImdldFByb3RvdHlwZU9mIiwiZW5kc1dpdGgiLCJzZWFyY2giLCJ0aGlzX2xlbiIsInN1YnN0cmluZyIsInJlcGVhdCIsImNvdW50IiwiTWF0aCIsImZsb29yIiwibWF4Q291bnQiLCJsb2ciLCJibHVlIiwiZ3JlZW4iLCJyZWQiLCJ3aGl0ZSIsImtSZWFkYWJsZU9wZXJhdG9yIiwic3RyaWN0RXF1YWxPYmplY3QiLCJub3RTdHJpY3RFcXVhbE9iamVjdCIsIm5vdElkZW50aWNhbCIsImtNYXhTaG9ydExlbmd0aCIsImNvcHlFcnJvciIsImluc3BlY3RWYWx1ZSIsInZhbCIsImNvbXBhY3QiLCJjdXN0b21JbnNwZWN0IiwiZGVwdGgiLCJtYXhBcnJheUxlbmd0aCIsIkluZmluaXR5Iiwic2hvd0hpZGRlbiIsImJyZWFrTGVuZ3RoIiwic2hvd1Byb3h5Iiwic29ydGVkIiwiZ2V0dGVycyIsImNyZWF0ZUVyckRpZmYiLCJvdGhlciIsInJlcyIsImxhc3RQb3MiLCJlbmQiLCJza2lwcGVkIiwiYWN0dWFsSW5zcGVjdGVkIiwiYWN0dWFsTGluZXMiLCJleHBlY3RlZExpbmVzIiwiaW5kaWNhdG9yIiwiaW5wdXRMZW5ndGgiLCJtYXhMZW5ndGgiLCJzdGRlcnIiLCJpc1RUWSIsImNvbHVtbnMiLCJwb3AiLCJtYXhMaW5lcyIsIm1heCIsIl9hY3R1YWxMaW5lcyIsInByaW50ZWRMaW5lcyIsInNraXBwZWRNc2ciLCJjdXIiLCJleHBlY3RlZExpbmUiLCJhY3R1YWxMaW5lIiwiZGl2ZXJnaW5nTGluZXMiLCJfRXJyb3IiLCJvcHRpb25zIiwibGltaXQiLCJzdGFja1RyYWNlTGltaXQiLCJTdHJpbmciLCJnZXRDb2xvckRlcHRoIiwiYmFzZSIsIl9yZXMiLCJrbm93bk9wZXJhdG9ycyIsImNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImN1c3RvbSIsInJlY3Vyc2VUaW1lcyIsImN0eCIsInV0aWwiLCJjcmVhdGVFcnJvclR5cGUiLCJCYXNlIiwiZ2V0TWVzc2FnZSIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIk5vZGVFcnJvciIsIl9CYXNlIiwib25lT2YiLCJ0aGluZyIsImlzQXJyYXkiLCJsZW4iLCJtYXAiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwiaW5jbHVkZXMiLCJzdGFydCIsImRldGVybWluZXIiLCJyZXBsYWNlIiwidHlwZSIsInJlYXNvbiIsImluc3BlY3RlZCIsIlJhbmdlRXJyb3IiLCJpbnB1dCIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIl9zIiwibmV4dCIsImRvbmUiLCJyZWdleEZsYWdzU3VwcG9ydGVkIiwiZmxhZ3MiLCJhcnJheUZyb21TZXQiLCJhcnJheSIsImFycmF5RnJvbU1hcCIsIm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyIsIm51bWJlcklzTmFOIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmN1cnJ5VGhpcyIsImYiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwib2JqZWN0VG9TdHJpbmciLCJpc0FueUFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc0RhdGUiLCJpc01hcCIsImlzU2V0IiwiaXNOYXRpdmVFcnJvciIsImlzQm94ZWRQcmltaXRpdmUiLCJpc051bWJlck9iamVjdCIsImlzU3RyaW5nT2JqZWN0IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCaWdJbnRPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc05vbkluZGV4IiwicG93IiwiZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzIiwiY29tcGFyZSIsIngiLCJ5IiwibWluIiwiT05MWV9FTlVNRVJBQkxFIiwia1N0cmljdCIsImtMb29zZSIsImtOb0l0ZXJhdG9yIiwia0lzQXJyYXkiLCJrSXNTZXQiLCJrSXNNYXAiLCJhcmVTaW1pbGFyUmVnRXhwcyIsIlJlZ0V4cCIsImFyZVNpbWlsYXJGbG9hdEFycmF5cyIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJhcmVTaW1pbGFyVHlwZWRBcnJheXMiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImFyZUVxdWFsQXJyYXlCdWZmZXJzIiwiYnVmMSIsImJ1ZjIiLCJpc0VxdWFsQm94ZWRQcmltaXRpdmUiLCJ2YWwxIiwidmFsMiIsInZhbHVlT2YiLCJCb29sZWFuIiwiQmlnSW50IiwiaW5uZXJEZWVwRXF1YWwiLCJtZW1vcyIsInZhbDFUYWciLCJ2YWwyVGFnIiwia2V5czEiLCJrZXlzMiIsImtleUNoZWNrIiwiZ2V0VGltZSIsIl9rZXlzIiwiX2tleXMyIiwic2l6ZSIsImdldEVudW1lcmFibGVzIiwiayIsIml0ZXJhdGlvblR5cGUiLCJhS2V5cyIsImJLZXlzIiwic3ltYm9sS2V5c0EiLCJzeW1ib2xLZXlzQiIsIl9zeW1ib2xLZXlzQiIsInBvc2l0aW9uIiwidmFsMk1lbW9BIiwidmFsMk1lbW9CIiwiYXJlRXEiLCJvYmpFcXVpdiIsImRlbGV0ZSIsInNldEhhc0VxdWFsRWxlbWVudCIsIm1lbW8iLCJzZXRWYWx1ZXMiLCJmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMiLCJwcmltIiwic2V0TWlnaHRIYXZlTG9vc2VQcmltIiwiYWx0VmFsdWUiLCJtYXBNaWdodEhhdmVMb29zZVByaW0iLCJpdGVtIiwiY3VyQiIsInNldEVxdWl2IiwiYVZhbHVlcyIsIlNldCIsImFkZCIsImJWYWx1ZXMiLCJfdmFsIiwibWFwSGFzRXF1YWxFbnRyeSIsImtleTEiLCJpdGVtMSIsImtleTIiLCJtYXBFcXVpdiIsImFFbnRyaWVzIiwiX2FFbnRyaWVzJGkiLCJpdGVtMiIsImJFbnRyaWVzIiwiX2kyIiwiX2JFbnRyaWVzJF9pIiwia2V5c0EiLCJHZXRJbnRyaW5zaWMiLCJjYWxsQmluZCIsIiRpbmRleE9mIiwiY2FsbEJvdW5kSW50cmluc2ljIiwiYWxsb3dNaXNzaW5nIiwiaW50cmluc2ljIiwic2V0RnVuY3Rpb25MZW5ndGgiLCIkVHlwZUVycm9yIiwiJGFwcGx5IiwiJGNhbGwiLCIkcmVmbGVjdEFwcGx5IiwiJGRlZmluZVByb3BlcnR5IiwiJG1heCIsIm9yaWdpbmFsRnVuY3Rpb24iLCJmdW5jIiwiYXBwbHlCaW5kIiwibm93IiwidGltZXMiLCJnIiwid2luZG93IiwiZnVuY3Rpb25zIiwiaW5mbyIsInRpbWUiLCJ0aW1lRW5kIiwidHJhY2UiLCJkaXIiLCJjb25zb2xlQXNzZXJ0IiwidHVwbGUiLCJsYWJlbCIsImR1cmF0aW9uIiwiZm9ybWF0Iiwib2JqZWN0IiwiZXhwcmVzc2lvbiIsIiRTeW50YXhFcnJvciIsImdvcGQiLCJkZWZpbmVEYXRhUHJvcGVydHkiLCJwcm9wZXJ0eSIsIm5vbkVudW1lcmFibGUiLCJub25Xcml0YWJsZSIsIm5vbkNvbmZpZ3VyYWJsZSIsImxvb3NlIiwiZGVzYyIsImhhc1N5bWJvbHMiLCJ0b1N0ciIsImlzRnVuY3Rpb24iLCJzdXBwb3J0c0Rlc2NyaXB0b3JzIiwicHJlZGljYXRlIiwiZGVmaW5lUHJvcGVydGllcyIsInByZWRpY2F0ZXMiLCJFdmFsRXJyb3IiLCJTeW50YXhFcnJvciIsIlVSSUVycm9yIiwiZmlyc3RTb3VyY2UiLCJ0byIsIm5leHRTb3VyY2UiLCJrZXlzQXJyYXkiLCJuZXh0SW5kZXgiLCJuZXh0S2V5IiwicG9seWZpbGwiLCJpc0NhbGxhYmxlIiwiZm9yRWFjaEFycmF5IiwicmVjZWl2ZXIiLCJmb3JFYWNoU3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwiZm9yRWFjaE9iamVjdCIsImxpc3QiLCJ0aGlzQXJnIiwiRVJST1JfTUVTU0FHRSIsImZ1bmNUeXBlIiwiY29uY2F0dHkiLCJqIiwic2xpY3kiLCJhcnJMaWtlIiwiam9pbnkiLCJqb2luZXIiLCJ0aGF0IiwiYm91bmQiLCJiaW5kZXIiLCJib3VuZExlbmd0aCIsImJvdW5kQXJncyIsIkVtcHR5IiwiaW1wbGVtZW50YXRpb24iLCIkRXJyb3IiLCIkRXZhbEVycm9yIiwiJFJhbmdlRXJyb3IiLCIkUmVmZXJlbmNlRXJyb3IiLCIkVVJJRXJyb3IiLCIkRnVuY3Rpb24iLCJnZXRFdmFsbGVkQ29uc3RydWN0b3IiLCJleHByZXNzaW9uU3ludGF4IiwiJGdPUEQiLCJ0aHJvd1R5cGVFcnJvciIsIlRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiY2FsbGVlVGhyb3dzIiwiZ09QRHRocm93cyIsImhhc1Byb3RvIiwiZ2V0UHJvdG8iLCJuZWVkc0V2YWwiLCJUeXBlZEFycmF5IiwiSU5UUklOU0lDUyIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJBdG9taWNzIiwiQmlnSW50NjRBcnJheSIsIkJpZ1VpbnQ2NEFycmF5IiwiRGF0YVZpZXciLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJldmFsIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiSlNPTiIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlNoYXJlZEFycmF5QnVmZmVyIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiV2Vha01hcCIsIldlYWtSZWYiLCJXZWFrU2V0IiwiZXJyb3JQcm90byIsImRvRXZhbCIsImdlbiIsIkxFR0FDWV9BTElBU0VTIiwiaGFzT3duIiwiJGNvbmNhdCIsIiRzcGxpY2VBcHBseSIsInNwbGljZSIsIiRyZXBsYWNlIiwiJHN0clNsaWNlIiwiJGV4ZWMiLCJleGVjIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImZpcnN0IiwibGFzdCIsIm1hdGNoIiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJnZXRCYXNlSW50cmluc2ljIiwiaW50cmluc2ljTmFtZSIsImFsaWFzIiwicGFydHMiLCJpbnRyaW5zaWNCYXNlTmFtZSIsImludHJpbnNpY1JlYWxOYW1lIiwic2tpcEZ1cnRoZXJDYWNoaW5nIiwiaXNPd24iLCJwYXJ0IiwiaGFzUHJvcGVydHlEZXNjcmlwdG9ycyIsImhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnIiwiZm9vIiwiJE9iamVjdCIsIm9yaWdTeW1ib2wiLCJoYXNTeW1ib2xTaGFtIiwiaGFzTmF0aXZlU3ltYm9scyIsInN5bU9iaiIsInN5bVZhbCIsImdldE93blByb3BlcnR5TmFtZXMiLCJzeW1zIiwiaGFzVG9TdHJpbmdUYWdTaGFtcyIsInRvU3RyaW5nVGFnIiwiJGhhc093biIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaGFzVG9TdHJpbmdUYWciLCJjYWxsQm91bmQiLCIkdG9TdHJpbmciLCJpc1N0YW5kYXJkQXJndW1lbnRzIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsInN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMiLCJmblRvU3RyIiwicmVmbGVjdEFwcGx5IiwiYmFkQXJyYXlMaWtlIiwiaXNDYWxsYWJsZU1hcmtlciIsIl8iLCJjb25zdHJ1Y3RvclJlZ2V4IiwiaXNFUzZDbGFzc0ZuIiwiaXNFUzZDbGFzc0Z1bmN0aW9uIiwiZm5TdHIiLCJ0cnlGdW5jdGlvbk9iamVjdCIsInRyeUZ1bmN0aW9uVG9TdHIiLCJvYmplY3RDbGFzcyIsImZuQ2xhc3MiLCJnZW5DbGFzcyIsImRkYUNsYXNzIiwiZGRhQ2xhc3MyIiwiZGRhQ2xhc3MzIiwiaXNJRTY4IiwiaXNEREEiLCJpc0RvY3VtZW50RG90QWxsIiwiZG9jdW1lbnQiLCJhbGwiLCJzdHJDbGFzcyIsImlzRm5SZWdleCIsImdldEdlbmVyYXRvckZ1bmMiLCJHZW5lcmF0b3JGdW5jdGlvbiIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5lcmF0b3JGdW5jIiwiZ2V0UG9seWZpbGwiLCJzaGltIiwiTmFOIiwic2hpbU51bWJlcklzTmFOIiwidGVzdElzTmFOIiwid2hpY2hUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwibm1kIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyIsIl9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fIiwib2JqZWN0VHlwZXMiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtb2R1bGVFeHBvcnRzIiwiZ2xvYmFsIiwidmVyc2lvbiIsImZlYXR1cmVzIiwiZW5jb2RpbmdNb2RlIiwiZGVmYXVsdE9wdGlvbnMiLCJ3YWl0IiwiY29tbWVudHMiLCJzY29wZSIsImxvY2F0aW9ucyIsInJhbmdlcyIsIm9uQ3JlYXRlTm9kZSIsIm9uQ3JlYXRlU2NvcGUiLCJvbkRlc3Ryb3lTY29wZSIsIm9uTG9jYWxEZWNsYXJhdGlvbiIsImx1YVZlcnNpb24iLCJlbmNvZGVVVEY4IiwiY29kZXBvaW50IiwiaGlnaE1hc2siLCJmcm9tQ2hhckNvZGUiLCJ0b0hleCIsIm51bSIsImRpZ2l0cyIsImNoZWNrQ2hhcnMiLCJyeCIsInMiLCJtIiwicmFpc2UiLCJlcnJvcnMiLCJpbnZhbGlkQ29kZVVuaXQiLCJ0b1VwcGVyQ2FzZSIsImVuY29kaW5nTW9kZXMiLCJmaXh1cCIsImVuY29kZUJ5dGUiLCJkaXNjYXJkU3RyaW5ncyIsIkVPRiIsIlN0cmluZ0xpdGVyYWwiLCJLZXl3b3JkIiwiSWRlbnRpZmllciIsIk51bWVyaWNMaXRlcmFsIiwiUHVuY3R1YXRvciIsIkJvb2xlYW5MaXRlcmFsIiwiTmlsTGl0ZXJhbCIsIlZhcmFyZ0xpdGVyYWwiLCJ0b2tlblR5cGVzIiwidW5leHBlY3RlZCIsInVuZXhwZWN0ZWRFT0YiLCJleHBlY3RlZFRva2VuIiwidW5maW5pc2hlZFN0cmluZyIsIm1hbGZvcm1lZE51bWJlciIsImRlY2ltYWxFc2NhcGVUb29MYXJnZSIsImludmFsaWRFc2NhcGUiLCJoZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQiLCJicmFjZUV4cGVjdGVkIiwidG9vTGFyZ2VDb2RlcG9pbnQiLCJ1bmZpbmlzaGVkTG9uZ1N0cmluZyIsInVuZmluaXNoZWRMb25nQ29tbWVudCIsImFtYmlndW91c1N5bnRheCIsIm5vTG9vcFRvQnJlYWsiLCJsYWJlbEFscmVhZHlEZWZpbmVkIiwibGFiZWxOb3RWaXNpYmxlIiwiZ290b0p1bXBJbkxvY2FsU2NvcGUiLCJjYW5ub3RVc2VWYXJhcmciLCJhc3QiLCJsYWJlbFN0YXRlbWVudCIsImJyZWFrU3RhdGVtZW50IiwiZ290b1N0YXRlbWVudCIsInJldHVyblN0YXRlbWVudCIsImlmU3RhdGVtZW50IiwiY2xhdXNlcyIsImlmQ2xhdXNlIiwiY29uZGl0aW9uIiwiYm9keSIsImVsc2VpZkNsYXVzZSIsImVsc2VDbGF1c2UiLCJ3aGlsZVN0YXRlbWVudCIsImRvU3RhdGVtZW50IiwicmVwZWF0U3RhdGVtZW50IiwibG9jYWxTdGF0ZW1lbnQiLCJ2YXJpYWJsZXMiLCJpbml0IiwiYXNzaWdubWVudFN0YXRlbWVudCIsImNhbGxTdGF0ZW1lbnQiLCJmdW5jdGlvblN0YXRlbWVudCIsImlkZW50aWZpZXIiLCJwYXJhbWV0ZXJzIiwiaXNMb2NhbCIsImZvck51bWVyaWNTdGF0ZW1lbnQiLCJ2YXJpYWJsZSIsInN0ZXAiLCJmb3JHZW5lcmljU3RhdGVtZW50IiwiaXRlcmF0b3JzIiwiY2h1bmsiLCJsaXRlcmFsIiwicmF3IiwidGFibGVLZXkiLCJ0YWJsZUtleVN0cmluZyIsInRhYmxlVmFsdWUiLCJ0YWJsZUNvbnN0cnVjdG9yRXhwcmVzc2lvbiIsImZpZWxkcyIsImJpbmFyeUV4cHJlc3Npb24iLCJsZWZ0IiwicmlnaHQiLCJ1bmFyeUV4cHJlc3Npb24iLCJhcmd1bWVudCIsIm1lbWJlckV4cHJlc3Npb24iLCJpbmRleGVyIiwiaW5kZXhFeHByZXNzaW9uIiwiaW5kZXgiLCJjYWxsRXhwcmVzc2lvbiIsInRhYmxlQ2FsbEV4cHJlc3Npb24iLCJzdHJpbmdDYWxsRXhwcmVzc2lvbiIsImNvbW1lbnQiLCJmaW5pc2hOb2RlIiwibm9kZSIsInRyYWNrTG9jYXRpb25zIiwibG9jYXRpb24iLCJjb21wbGV0ZSIsImJsZXNzIiwiZWxlbWVudCIsImluZGV4T2ZPYmplY3QiLCJzcHJpbnRmIiwiZGVzdCIsInNyYyIsInByb3AiLCJmaXh1cEVycm9yIiwibGluZSIsImNvbHVtbiIsInRva2VuIiwiY29sIiwibGluZVN0YXJ0IiwicmFuZ2UiLCJ0b2tlblZhbHVlIiwicmFpc2VVbmV4cGVjdGVkVG9rZW4iLCJmb3VuZCIsIm5lYXIiLCJsb29rYWhlYWQiLCJwcmV2aW91c1Rva2VuIiwidG9rZW5TdGFydCIsImxleCIsInNraXBXaGl0ZVNwYWNlIiwic2NhbkNvbW1lbnQiLCJjaGFyQ29kZSIsImlzSWRlbnRpZmllclN0YXJ0Iiwic2NhbklkZW50aWZpZXJPcktleXdvcmQiLCJzY2FuU3RyaW5nTGl0ZXJhbCIsInNjYW5OdW1lcmljTGl0ZXJhbCIsImlzRGVjRGlnaXQiLCJzY2FuVmFyYXJnTGl0ZXJhbCIsInNjYW5QdW5jdHVhdG9yIiwiYml0d2lzZU9wZXJhdG9ycyIsImxhYmVscyIsInNjYW5Mb25nU3RyaW5nTGl0ZXJhbCIsImludGVnZXJEaXZpc2lvbiIsImNvbnN1bWVFT0wiLCJwZWVrQ2hhckNvZGUiLCJpc0xpbmVUZXJtaW5hdG9yIiwiaXNXaGl0ZVNwYWNlIiwiaXNJZGVudGlmaWVyUGFydCIsImlzS2V5d29yZCIsImRlbGltaXRlciIsImJlZ2luTGluZSIsImJlZ2luTGluZVN0YXJ0Iiwic3RyaW5nU3RhcnQiLCJiZWZvcmVFc2NhcGUiLCJlc2NhcGVWYWx1ZSIsInJlYWRFc2NhcGVTZXF1ZW5jZSIsImxhc3RMaW5lIiwibGFzdExpbmVTdGFydCIsInJlYWRMb25nU3RyaW5nIiwiY2hhcmFjdGVyIiwicmVhZEhleExpdGVyYWwiLCJyZWFkRGVjTGl0ZXJhbCIsImZvdW5kSW1hZ2luYXJ5VW5pdCIsInJlYWRJbWFnaW5hcnlVbml0U3VmZml4IiwiZm91bmRJbnQ2NFN1ZmZpeCIsInJlYWRJbnQ2NFN1ZmZpeCIsImhhc0ZyYWN0aW9uUGFydCIsImltYWdpbmFyeU51bWJlcnMiLCJpbnRlZ2VyU3VmZml4ZXMiLCJmcmFjdGlvbiIsImJpbmFyeUV4cG9uZW50IiwiYmluYXJ5U2lnbiIsImRpZ2l0IiwiZnJhY3Rpb25TdGFydCIsImV4cG9uZW50U3RhcnQiLCJkaWdpdFN0YXJ0IiwiaXNIZXhEaWdpdCIsImZvdW5kRnJhY3Rpb24iLCJmb3VuZEJpbmFyeUV4cG9uZW50IiwiZm91bmRFeHBvbmVudCIsInJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2UiLCJzZXF1ZW5jZVN0YXJ0IiwiZXNjU3RhcnQiLCJmcmFnIiwiZGRkIiwic2tpcFdoaXRlc3BhY2VFc2NhcGUiLCJoZXhFc2NhcGVzIiwidW5pY29kZUVzY2FwZXMiLCJzdHJpY3RFc2NhcGVzIiwiY29udGVudCIsImlzTG9uZyIsImNvbW1lbnRTdGFydCIsImxpbmVTdGFydENvbW1lbnQiLCJsaW5lQ29tbWVudCIsImxvYyIsImlzQ29tbWVudCIsImxldmVsIiwidGVybWluYXRvciIsImZpcnN0TGluZSIsImNvbnN1bWUiLCJleHBlY3QiLCJleHRlbmRlZElkZW50aWZpZXJzIiwiaWQiLCJjb250ZXh0dWFsR290byIsImlzVW5hcnkiLCJpc0Jsb2NrRm9sbG93Iiwic2NvcGVzIiwic2NvcGVEZXB0aCIsImdsb2JhbHMiLCJjcmVhdGVTY29wZSIsImRlc3Ryb3lTY29wZSIsInNjb3BlSWRlbnRpZmllck5hbWUiLCJzY29wZUlkZW50aWZpZXIiLCJhdHRhY2hTY29wZSIsInNjb3BlSGFzTmFtZSIsImNyZWF0ZUxvY2F0aW9uTWFya2VyIiwiTWFya2VyIiwibWFya0xvY2F0aW9uIiwicHVzaExvY2F0aW9uIiwibWFya2VyIiwiRnVsbEZsb3dDb250ZXh0IiwicGVuZGluZ0dvdG9zIiwiaXNJbkxvb3AiLCJpc0xvb3AiLCJwdXNoU2NvcGUiLCJsb2NhbHMiLCJkZWZlcnJlZEdvdG9zIiwicG9wU2NvcGUiLCJ0aGVHb3RvIiwibWF4RGVwdGgiLCJhZGRHb3RvIiwibG9jYWxDb3VudHMiLCJhZGRMYWJlbCIsImN1cnJlbnRTY29wZSIsIm5ld0dvdG9zIiwibG9jYWxDb3VudCIsImFkZExvY2FsIiwicmFpc2VEZWZlcnJlZEVycm9ycyIsImJhZHMiLCJMb29wRmxvd0NvbnRleHQiLCJsb29wTGV2ZWxzIiwibGV2ZWxzIiwibGV2bGVuIiwibWFrZUZsb3dDb250ZXh0IiwicGFyc2VDaHVuayIsImZsb3dDb250ZXh0IiwiYWxsb3dWYXJhcmciLCJwYXJzZUJsb2NrIiwiYmxvY2siLCJzdGF0ZW1lbnQiLCJyZWxheGVkQnJlYWsiLCJwYXJzZVN0YXRlbWVudCIsInBhcnNlTGFiZWxTdGF0ZW1lbnQiLCJlbXB0eVN0YXRlbWVudCIsInBhcnNlTG9jYWxTdGF0ZW1lbnQiLCJwYXJzZUlmU3RhdGVtZW50IiwicGFyc2VSZXR1cm5TdGF0ZW1lbnQiLCJwYXJzZUZ1bmN0aW9uTmFtZSIsInBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsInBhcnNlUmVwZWF0U3RhdGVtZW50IiwicGFyc2VCcmVha1N0YXRlbWVudCIsInBhcnNlRG9TdGF0ZW1lbnQiLCJwYXJzZUdvdG9TdGF0ZW1lbnQiLCJwYXJzZUFzc2lnbm1lbnRPckNhbGxTdGF0ZW1lbnQiLCJuYW1lVG9rZW4iLCJwYXJzZUlkZW50aWZpZXIiLCJnb3RvVG9rZW4iLCJwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbiIsImV4cHJlc3Npb25zIiwicGFyc2VFeHByZXNzaW9uIiwiZGVjbFRva2VuIiwibCIsInByZXZpb3VzIiwic3RhcnRNYXJrZXIiLCJsdmFsdWUiLCJ0YXJnZXRzIiwiYm90aCIsIm5ld0Jhc2UiLCJwYXJzZVByZWZpeEV4cHJlc3Npb25QYXJ0IiwidmFsdWVzIiwicGFyYW1ldGVyIiwicGFyc2VQcmltYXJ5RXhwcmVzc2lvbiIsInBhcnNlVGFibGVDb25zdHJ1Y3RvciIsInBhcnNlU3ViRXhwcmVzc2lvbiIsImJpbmFyeVByZWNlZGVuY2UiLCJtaW5QcmVjZWRlbmNlIiwicGFyc2VQcmVmaXhFeHByZXNzaW9uIiwicHJlY2VkZW5jZSIsInBhcnNlQ2FsbEV4cHJlc3Npb24iLCJ0YWJsZSIsImxpdGVyYWxzIiwicGFyc2UiLCJ2ZXJzaW9uRmVhdHVyZXMiLCJfaW5wdXQiLCJfb3B0aW9ucyIsIndyaXRlIiwic2hpbU9iamVjdElzIiwidGVzdE9iamVjdElzIiwia2V5c1NoaW0iLCJpc0FyZ3MiLCJpc0VudW1lcmFibGUiLCJoYXNEb250RW51bUJ1ZyIsImhhc1Byb3RvRW51bUJ1ZyIsImRvbnRFbnVtcyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhjbHVkZWRLZXlzIiwiJGFwcGxpY2F0aW9uQ2FjaGUiLCIkY29uc29sZSIsIiRleHRlcm5hbCIsIiRmcmFtZSIsIiRmcmFtZUVsZW1lbnQiLCIkZnJhbWVzIiwiJGlubmVySGVpZ2h0IiwiJGlubmVyV2lkdGgiLCIkb25tb3pmdWxsc2NyZWVuY2hhbmdlIiwiJG9ubW96ZnVsbHNjcmVlbmVycm9yIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkcGFyZW50IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJpc09iamVjdCIsImlzU3RyaW5nIiwidGhlS2V5cyIsInNraXBQcm90byIsInNraXBDb25zdHJ1Y3RvciIsIm9yaWdLZXlzIiwib3JpZ2luYWxLZXlzIiwic2hpbU9iamVjdEtleXMiLCJrZXlzV29ya3NXaXRoQXJndW1lbnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibmV4dFRpY2siLCJJdGVtIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiaGFzRGVzY3JpcHRvcnMiLCJnT1BEIiwiJGZsb29yIiwiZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSIsImZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImQiLCJCYXNlU2VydmljZSIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIm4iLCJfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9kZWZpbmVfcHJvcGVydHkiLCJhZGREb2N1bWVudCIsImRvY3VtZW50cyIsInVyaSIsIlYiLCJsYW5ndWFnZUlkIiwidGV4dCIsImdldERvY3VtZW50IiwicmVtb3ZlRG9jdW1lbnQiLCJyZW5hbWVEb2N1bWVudCIsIm5ld0RvY3VtZW50VXJpIiwicHJldmlvdXNEb2N1bWVudCIsImdldFRleHQiLCJnZXREb2N1bWVudFZhbHVlIiwiX3RoaXNfZ2V0RG9jdW1lbnQiLCJzZXRWYWx1ZSIsInNldEdsb2JhbE9wdGlvbnMiLCJnbG9iYWxPcHRpb25zIiwic2V0V29ya3NwYWNlIiwid29ya3NwYWNlVXJpIiwic2V0T3B0aW9ucyIsImRvY3VtZW50VXJpIiwibWVyZ2UiLCJyTCIsImdldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJhcHBseURlbHRhcyIsImRlbHRhcyIsInVwZGF0ZSIsImRvQ29tcGxldGUiLCJkb0lubGluZUNvbXBsZXRlIiwiZG9Ib3ZlciIsImRvUmVzb2x2ZSIsImRvVmFsaWRhdGlvbiIsInByb3ZpZGVTaWduYXR1cmVIZWxwIiwiZmluZERvY3VtZW50SGlnaGxpZ2h0cyIsIm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUiLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJlcnJvckNvZGVzVG9JZ25vcmUiLCJlcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsImVycm9yQ29kZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyIsImdldFNlbWFudGljVG9rZW5zIiwiZGlzcG9zZSIsImNsb3NlQ29ubmVjdGlvbiIsImdldENvZGVBY3Rpb25zIiwiY29udGV4dCIsImV4ZWN1dGVDb21tYW5kIiwiY29tbWFuZCIsInNlbmRBcHBsaWVkUmVzdWx0IiwiY2FsbGJhY2tJZCIsInNlbmRSZXF1ZXN0Iiwic2VuZFJlc3BvbnNlIiwibW9kZSIsInRleHREb2N1bWVudCIsImRpYWdub3N0aWMiLCJkeW5hbWljUmVnaXN0cmF0aW9uIiwicmVsYXRlZERvY3VtZW50U3VwcG9ydCIsInB1Ymxpc2hEaWFnbm9zdGljcyIsInJlbGF0ZWRJbmZvcm1hdGlvbiIsInZlcnNpb25TdXBwb3J0IiwidGFnU3VwcG9ydCIsInZhbHVlU2V0IiwiRGlhZ25vc3RpY1RhZyIsIlVubmVjZXNzYXJ5IiwiRGVwcmVjYXRlZCIsImhvdmVyIiwiY29udGVudEZvcm1hdCIsInN5bmNocm9uaXphdGlvbiIsIndpbGxTYXZlIiwiZGlkU2F2ZSIsIndpbGxTYXZlV2FpdFVudGlsIiwiZm9ybWF0dGluZyIsImNvbXBsZXRpb24iLCJjb21wbGV0aW9uSXRlbSIsInNuaXBwZXRTdXBwb3J0IiwiY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQiLCJkb2N1bWVudGF0aW9uRm9ybWF0IiwiZGVwcmVjYXRlZFN1cHBvcnQiLCJwcmVzZWxlY3RTdXBwb3J0IiwiY29udGV4dFN1cHBvcnQiLCJzaWduYXR1cmVIZWxwIiwic2lnbmF0dXJlSW5mb3JtYXRpb24iLCJhY3RpdmVQYXJhbWV0ZXJTdXBwb3J0IiwiZG9jdW1lbnRIaWdobGlnaHQiLCJzZW1hbnRpY1Rva2VucyIsIm11bHRpbGluZVRva2VuU3VwcG9ydCIsIm92ZXJsYXBwaW5nVG9rZW5TdXBwb3J0IiwidG9rZW5Nb2RpZmllcnMiLCJmb3JtYXRzIiwicmVxdWVzdHMiLCJmdWxsIiwiZGVsdGEiLCJhdWdtZW50c1N5bnRheFRva2VucyIsImNvZGVBY3Rpb24iLCJpbmxpbmVDb21wbGV0aW9uIiwic2hvd0RvY3VtZW50Iiwic3VwcG9ydCIsIndvcmtzcGFjZSIsImRpZENoYW5nZUNvbmZpZ3VyYXRpb24iLCJhcHBseUVkaXQiLCJ3b3Jrc3BhY2VFZGl0IiwiZmFpbHVyZUhhbmRsaW5nIiwibm9ybWFsaXplc0xpbmVFbmRpbmdzIiwiZG9jdW1lbnRDaGFuZ2VzIiwic2VydmljZU5hbWUiLCJzZXJ2aWNlRGF0YSIsImNsYXNzTmFtZSIsIm1vZGVzIiwiVGsiLCJjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5IiwibWVyZ2VPYmplY3RzIiwib2JqMSIsIm9iajIiLCJleGNsdWRlVW5kZWZpbmVkIiwiZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyIsIm1lcmdlZE9iamVjdHMiLCJmaWx0ZXJlZEVudHJpZXMiLCJlbnRyaWVzIiwiZnJvbUVudHJpZXMiLCJub3RFbXB0eSIsImlzRW1wdHlSYW5nZSIsInJvdyIsIm1lcmdlUmFuZ2VzIiwic29ydCIsImNvbXBhcmVQb2ludHMiLCJjbXAiLCJwMSIsInAyIiwicmVnZXhwQXJyYXkiLCJjb252ZXJ0VG9VcmkiLCJmaWxlUGF0aCIsIlVSSSIsImZpbGUiLCJpc0J1ZmZlciIsImFyZyIsImNvcHkiLCJmaWxsIiwicmVhZFVJbnQ4IiwiaXNBcmd1bWVudHNPYmplY3QiLCJCaWdJbnRTdXBwb3J0ZWQiLCJTeW1ib2xTdXBwb3J0ZWQiLCJPYmplY3RUb1N0cmluZyIsIm51bWJlclZhbHVlIiwic3RyaW5nVmFsdWUiLCJib29sZWFuVmFsdWUiLCJiaWdJbnRWYWx1ZSIsInN5bWJvbFZhbHVlIiwiY2hlY2tCb3hlZFByaW1pdGl2ZSIsInByb3RvdHlwZVZhbHVlT2YiLCJpc1ZpZXciLCJpc0RhdGFWaWV3IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc0JpZ0ludDY0QXJyYXkiLCJpc0JpZ1VpbnQ2NEFycmF5IiwiaXNNYXBUb1N0cmluZyIsIndvcmtpbmciLCJpc1NldFRvU3RyaW5nIiwiaXNXZWFrTWFwVG9TdHJpbmciLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXRUb1N0cmluZyIsImlzV2Vha1NldCIsImlzQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzQXJyYXlCdWZmZXIiLCJpc0RhdGFWaWV3VG9TdHJpbmciLCJTaGFyZWRBcnJheUJ1ZmZlckNvcHkiLCJpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmciLCJpc1NoYXJlZEFycmF5QnVmZmVyIiwiaXNBc3luY0Z1bmN0aW9uIiwiaXNNYXBJdGVyYXRvciIsImlzU2V0SXRlcmF0b3IiLCJpc0dlbmVyYXRvck9iamVjdCIsImlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSIsIm1ldGhvZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9ycyIsImZvcm1hdFJlZ0V4cCIsIm9iamVjdHMiLCJzdHJpbmdpZnkiLCJpc051bGwiLCJkZXByZWNhdGUiLCJub0RlcHJlY2F0aW9uIiwiZGVwcmVjYXRlZCIsInRocm93RGVwcmVjYXRpb24iLCJ0cmFjZURlcHJlY2F0aW9uIiwiZGVidWdzIiwiZGVidWdFbnZSZWdleCIsIk5PREVfREVCVUciLCJkZWJ1Z0VudiIsImRlYnVnbG9nIiwicGlkIiwib3B0cyIsInNlZW4iLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJjb2xvcnMiLCJpc0Jvb2xlYW4iLCJfZXh0ZW5kIiwiaXNVbmRlZmluZWQiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJzdHlsZXMiLCJzdHlsZVR5cGUiLCJzdHlsZSIsImFycmF5VG9IYXNoIiwiaGFzaCIsImlkeCIsInJldCIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiaXNFcnJvciIsImZvcm1hdEVycm9yIiwiYnJhY2VzIiwidG9VVENTdHJpbmciLCJvdXRwdXQiLCJmb3JtYXRBcnJheSIsImZvcm1hdFByb3BlcnR5IiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJzaW1wbGUiLCJpc051bWJlciIsIm51bUxpbmVzRXN0IiwicmVkdWNlIiwicHJldiIsImFyIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwia0N1c3RvbVByb21pc2lmaWVkU3ltYm9sIiwicHJvbWlzaWZ5Iiwib3JpZ2luYWwiLCJwcm9taXNlUmVzb2x2ZSIsInByb21pc2VSZWplY3QiLCJwcm9taXNlIiwicmVqZWN0IiwiY2FsbGJhY2tpZnlPblJlamVjdGVkIiwiY2IiLCJuZXdSZWFzb24iLCJjYWxsYmFja2lmeSIsImNhbGxiYWNraWZpZWQiLCJtYXliZUNiIiwicmVqIiwiX19jcmVhdGVCaW5kaW5nIiwiazIiLCJfX2VzTW9kdWxlIiwiX19leHBvcnRTdGFyIiwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24iLCJCcm93c2VyTWVzc2FnZVdyaXRlciIsIkJyb3dzZXJNZXNzYWdlUmVhZGVyIiwicmlsXzEiLCJkZWZhdWx0IiwiaW5zdGFsbCIsImFwaV8xIiwiQWJzdHJhY3RNZXNzYWdlUmVhZGVyIiwibGlzdGVuIiwiY2FsbGJhY2siLCJfb25EYXRhIiwiZXZlbnQiLCJwb3J0IiwiRW1pdHRlciIsIl9tZXNzYWdlTGlzdGVuZXIiLCJmaXJlIiwiZGF0YSIsImFkZEV2ZW50TGlzdGVuZXIiLCJmaXJlRXJyb3IiLCJvbm1lc3NhZ2UiLCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXIiLCJwb3N0TWVzc2FnZSIsImhhbmRsZUVycm9yIiwiZXJyb3JDb3VudCIsInJlYWRlciIsIndyaXRlciIsImxvZ2dlciIsIk51bGxMb2dnZXIiLCJDb25uZWN0aW9uU3RyYXRlZ3kiLCJjb25uZWN0aW9uU3RyYXRlZ3kiLCJNZXNzYWdlQnVmZmVyIiwiQWJzdHJhY3RNZXNzYWdlQnVmZmVyIiwiZW1wdHlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiX2VuY29kaW5nIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJlbmNvZGluZyIsImFzY2lpRGVjb2RlciIsImRlY29kZSIsIlRleHREZWNvZGVyIiwiYXNOYXRpdmUiLCJhbGxvY05hdGl2ZSIsIlJlYWRhYmxlU3RyZWFtV3JhcHBlciIsIm9uQ2xvc2UiLCJsaXN0ZW5lciIsInNvY2tldCIsIkRpc3Bvc2FibGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25FcnJvciIsIm9uRW5kIiwib25EYXRhIiwiYmxvYiIsImFycmF5QnVmZmVyIiwiUkFMIiwiV3JpdGFibGVTdHJlYW1XcmFwcGVyIiwic2VuZCIsImNsb3NlIiwiX3RleHRFbmNvZGVyIiwiX3JpbCIsImZyZWV6ZSIsIm1lc3NhZ2VCdWZmZXIiLCJhcHBsaWNhdGlvbkpzb24iLCJlbmNvZGVyIiwiY2hhcnNldCIsInN0cmVhbSIsImFzUmVhZGFibGVTdHJlYW0iLCJhc1dyaXRhYmxlU3RyZWFtIiwidGltZXIiLCJtcyIsImhhbmRsZSIsInNldEltbWVkaWF0ZSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlJJTCIsIlByb2dyZXNzVHlwZSIsIlByb2dyZXNzVG9rZW4iLCJDb25uZWN0aW9uT3B0aW9ucyIsIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIiLCJNZXNzYWdlV3JpdGVyIiwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIiwiTWVzc2FnZVJlYWRlciIsIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSIsIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuU291cmNlIiwiRXZlbnQiLCJMUlVDYWNoZSIsIlRvdWNoIiwiTGlua2VkTWFwIiwiUGFyYW1ldGVyU3RydWN0dXJlcyIsIk5vdGlmaWNhdGlvblR5cGU5IiwiTm90aWZpY2F0aW9uVHlwZTgiLCJOb3RpZmljYXRpb25UeXBlNyIsIk5vdGlmaWNhdGlvblR5cGU2IiwiTm90aWZpY2F0aW9uVHlwZTUiLCJOb3RpZmljYXRpb25UeXBlNCIsIk5vdGlmaWNhdGlvblR5cGUzIiwiTm90aWZpY2F0aW9uVHlwZTIiLCJOb3RpZmljYXRpb25UeXBlMSIsIk5vdGlmaWNhdGlvblR5cGUwIiwiTm90aWZpY2F0aW9uVHlwZSIsIkVycm9yQ29kZXMiLCJSZXNwb25zZUVycm9yIiwiUmVxdWVzdFR5cGU5IiwiUmVxdWVzdFR5cGU4IiwiUmVxdWVzdFR5cGU3IiwiUmVxdWVzdFR5cGU2IiwiUmVxdWVzdFR5cGU1IiwiUmVxdWVzdFR5cGU0IiwiUmVxdWVzdFR5cGUzIiwiUmVxdWVzdFR5cGUyIiwiUmVxdWVzdFR5cGUxIiwiUmVxdWVzdFR5cGUwIiwiUmVxdWVzdFR5cGUiLCJNZXNzYWdlIiwiTWVzc2FnZVN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDb25uZWN0aW9uRXJyb3IiLCJDb25uZWN0aW9uRXJyb3JzIiwiTG9nVHJhY2VOb3RpZmljYXRpb24iLCJTZXRUcmFjZU5vdGlmaWNhdGlvbiIsIlRyYWNlRm9ybWF0IiwiVHJhY2VWYWx1ZXMiLCJUcmFjZSIsIm1lc3NhZ2VzXzEiLCJsaW5rZWRNYXBfMSIsImRpc3Bvc2FibGVfMSIsImV2ZW50c18xIiwiY2FuY2VsbGF0aW9uXzEiLCJzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xIiwibWVzc2FnZVJlYWRlcl8xIiwibWVzc2FnZVdyaXRlcl8xIiwibWVzc2FnZUJ1ZmZlcl8xIiwiY29ubmVjdGlvbl8xIiwicmFsXzEiLCJJcyIsIk5vbmUiLCJpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCIsIm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiQ2FuY2VsbGVkIiwiY2FuZGlkYXRlIiwiYm9vbGVhbiIsInNob3J0Y3V0RXZlbnQiLCJNdXRhYmxlVG9rZW4iLCJjYW5jZWwiLCJfaXNDYW5jZWxsZWQiLCJfZW1pdHRlciIsIl90b2tlbiIsIlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IiwiSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IiwiQ2FuY2VsTm90aWZpY2F0aW9uIiwiUHJvZ3Jlc3NOb3RpZmljYXRpb24iLCJTdGFyUmVxdWVzdEhhbmRsZXIiLCJPZmYiLCJNZXNzYWdlcyIsIkNvbXBhY3QiLCJWZXJib3NlIiwidG9Mb3dlckNhc2UiLCJUZXh0IiwiY2FuY2VsVW5kaXNwYXRjaGVkIiwia2luZCIsImNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlIiwic2VuZENhbmNlbGxhdGlvbiIsImNvbm4iLCJzZW5kTm90aWZpY2F0aW9uIiwiY2xlYW51cCIsInNlbmRlciIsImhhbmRsZU1lc3NhZ2UiLCJjYW5jZWxsYXRpb25TdHJhdGVneSIsIm1lc3NhZ2VTdHJhdGVneSIsIkNvbm5lY3Rpb25TdGF0ZSIsIm1lc3NhZ2VSZWFkZXIiLCJtZXNzYWdlV3JpdGVyIiwiX2xvZ2dlciIsInNlcXVlbmNlTnVtYmVyIiwibm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIiLCJ1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlciIsInN0YXJSZXF1ZXN0SGFuZGxlciIsInJlcXVlc3RIYW5kbGVycyIsInN0YXJOb3RpZmljYXRpb25IYW5kbGVyIiwibm90aWZpY2F0aW9uSGFuZGxlcnMiLCJwcm9ncmVzc0hhbmRsZXJzIiwibWVzc2FnZVF1ZXVlIiwicmVzcG9uc2VQcm9taXNlcyIsImtub3duQ2FuY2VsZWRSZXF1ZXN0cyIsInJlcXVlc3RUb2tlbnMiLCJ0cmFjZUZvcm1hdCIsInRyYWNlciIsInN0YXRlIiwiTmV3IiwiZXJyb3JFbWl0dGVyIiwiY2xvc2VFbWl0dGVyIiwidW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlciIsInVuaGFuZGxlZFByb2dyZXNzRW1pdHRlciIsImRpc3Bvc2VFbWl0dGVyIiwiY3JlYXRlUmVxdWVzdFF1ZXVlS2V5IiwiY3JlYXRlUmVzcG9uc2VRdWV1ZUtleSIsImNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5IiwiYWRkTWVzc2FnZVRvUXVldWUiLCJpc1JlcXVlc3QiLCJpc1Jlc3BvbnNlIiwiX21lc3NhZ2UiLCJpc0xpc3RlbmluZyIsIkxpc3RlbmluZyIsImlzQ2xvc2VkIiwiQ2xvc2VkIiwiaXNEaXNwb3NlZCIsIkRpc3Bvc2VkIiwiY2xvc2VIYW5kbGVyIiwicmVhZEVycm9ySGFuZGxlciIsIndyaXRlRXJyb3JIYW5kbGVyIiwidHJpZ2dlck1lc3NhZ2VRdWV1ZSIsInByb2Nlc3NNZXNzYWdlUXVldWUiLCJoYW5kbGVSZXF1ZXN0IiwiaXNOb3RpZmljYXRpb24iLCJoYW5kbGVOb3RpZmljYXRpb24iLCJoYW5kbGVSZXNwb25zZSIsImhhbmRsZUludmFsaWRNZXNzYWdlIiwiY2FuY2VsSWQiLCJwYXJhbXMiLCJ0b0NhbmNlbCIsInN0cmF0ZWd5IiwicmVzcG9uc2UiLCJ0cmFjZVNlbmRpbmdSZXNwb25zZSIsImNhbmNlbGxhdGlvblRva2VuIiwidHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbiIsInJlcXVlc3RNZXNzYWdlIiwicmVwbHkiLCJyZXN1bHRPckVycm9yIiwic3RhcnRUaW1lIiwianNvbnJwYyIsInRvSnNvbiIsInJlcGx5RXJyb3IiLCJyZXBseVN1Y2Nlc3MiLCJ0cmFjZVJlY2VpdmVkUmVxdWVzdCIsInJlcXVlc3RIYW5kbGVyIiwiaGFuZGxlciIsInRva2VuS2V5IiwiY2FuY2VsbGF0aW9uU291cmNlIiwiaGFuZGxlclJlc3VsdCIsIm51bWJlck9mUGFyYW1zIiwiSW52YWxpZFBhcmFtcyIsInBhcmFtZXRlclN0cnVjdHVyZXMiLCJieU5hbWUiLCJieVBvc2l0aW9uIiwiSW50ZXJuYWxFcnJvciIsIk1ldGhvZE5vdEZvdW5kIiwicmVzcG9uc2VNZXNzYWdlIiwicmVzcG9uc2VQcm9taXNlIiwidHJhY2VSZWNlaXZlZFJlc3BvbnNlIiwibm90aWZpY2F0aW9uSGFuZGxlciIsInJlc3BvbnNlSGFuZGxlciIsInN0cmluZ2lmeVRyYWNlIiwidHJhY2VTZW5kaW5nUmVxdWVzdCIsImxvZ0xTUE1lc3NhZ2UiLCJ0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24iLCJ0aW1lclN0YXJ0IiwibHNwTWVzc2FnZSIsImlzTFNQTWVzc2FnZSIsInRocm93SWZDbG9zZWRPckRpc3Bvc2VkIiwidGhyb3dJZkxpc3RlbmluZyIsIkFscmVhZHlMaXN0ZW5pbmciLCJ0aHJvd0lmTm90TGlzdGVuaW5nIiwidW5kZWZpbmVkVG9OdWxsIiwicGFyYW0iLCJudWxsVG9VbmRlZmluZWQiLCJpc05hbWVkUGFyYW0iLCJjb21wdXRlU2luZ2xlUGFyYW0iLCJhdXRvIiwiY29tcHV0ZU1lc3NhZ2VQYXJhbXMiLCJjb25uZWN0aW9uIiwibWVzc2FnZVBhcmFtcyIsInBhcmFtU3RhcnQiLCJwYXJhbUVuZCIsIm5vdGlmaWNhdGlvbk1lc3NhZ2UiLCJvbk5vdGlmaWNhdGlvbiIsIm9uUHJvZ3Jlc3MiLCJfdHlwZSIsInNlbmRQcm9ncmVzcyIsIm9uVW5oYW5kbGVkUHJvZ3Jlc3MiLCJkaXNwb3NhYmxlIiwiZW5hYmxlQ2FuY2VsbGF0aW9uIiwicmVzb2x2ZVdpdGhDbGVhbnVwIiwiciIsInJlamVjdFdpdGhDbGVhbnVwIiwiTWVzc2FnZVdyaXRlRXJyb3IiLCJvblJlcXVlc3QiLCJoYXNQZW5kaW5nUmVzcG9uc2UiLCJfdmFsdWUiLCJfdHJhY2VyIiwic2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zIiwiX3NlbmROb3RpZmljYXRpb24iLCJfdHJhY2VGb3JtYXQiLCJvblVuaGFuZGxlZE5vdGlmaWNhdGlvbiIsIm9uRGlzcG9zZSIsIlBlbmRpbmdSZXNwb25zZVJlamVjdGVkIiwidmVyYm9zZSIsIl9kaXNwb3NhYmxlIiwiQ2FsbGJhY2tMaXN0IiwiYnVja2V0IiwiX2NhbGxiYWNrcyIsIl9jb250ZXh0cyIsInJlbW92ZSIsImZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCIsImludm9rZSIsImNhbGxiYWNrcyIsImNvbnRleHRzIiwiaXNFbXB0eSIsIl9ldmVudCIsInRoaXNBcmdzIiwiZGlzcG9zYWJsZXMiLCJvbkZpcnN0TGlzdGVuZXJBZGQiLCJfbm9vcCIsIm9uTGFzdExpc3RlbmVyUmVtb3ZlIiwic3RyaW5nQXJyYXkiLCJldmVyeSIsImVsZW0iLCJfYSIsIkZpcnN0IiwiQXNPbGQiLCJMYXN0IiwiQXNOZXciLCJjbGVhciIsIl9tYXAiLCJfaGVhZCIsIl90YWlsIiwiX3NpemUiLCJfc3RhdGUiLCJ0b3VjaCIsImFkZEl0ZW1MYXN0IiwiYWRkSXRlbUZpcnN0IiwicmVtb3ZlSXRlbSIsImNhbGxiYWNrZm4iLCJjdXJyZW50IiwidHJpbU9sZCIsIm5ld1NpemUiLCJjdXJyZW50U2l6ZSIsInRvSlNPTiIsImZyb21KU09OIiwiX2xpbWl0IiwiY2hlY2tUcmltIiwicmF0aW8iLCJfcmF0aW8iLCJwZWVrIiwicm91bmQiLCJDUiIsIkxGIiwiQ1JMRiIsImFwcGVuZCIsInRvQXBwZW5kIiwiX2NodW5rcyIsIl90b3RhbExlbmd0aCIsInRyeVJlYWRIZWFkZXJzIiwibG93ZXJDYXNlS2V5cyIsImNodW5rSW5kZXgiLCJjaHVua0J5dGVzUmVhZCIsIl9yZWFkIiwiaGVhZGVycyIsImhlYWRlciIsInRyaW0iLCJ0cnlSZWFkQm9keSIsIm51bWJlck9mQnl0ZXMiLCJieXRlQ291bnQiLCJyZXN1bHRPZmZzZXQiLCJjaHVua1BhcnQiLCJzZW1hcGhvcmVfMSIsIm9uUGFydGlhbE1lc3NhZ2UiLCJhc0Vycm9yIiwiZmlyZUNsb3NlIiwicGFydGlhbE1lc3NhZ2VFbWl0dGVyIiwiZmlyZVBhcnRpYWxNZXNzYWdlIiwiUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyIsImZyb21PcHRpb25zIiwiY29udGVudERlY29kZXIiLCJjb250ZW50RGVjb2RlcnMiLCJjb250ZW50VHlwZURlY29kZXIiLCJjb250ZW50VHlwZURlY29kZXJzIiwicGFydGlhbE1lc3NhZ2VUaW1lb3V0IiwiX3BhcnRpYWxNZXNzYWdlVGltZW91dCIsIm5leHRNZXNzYWdlTGVuZ3RoIiwibWVzc2FnZVRva2VuIiwicGFydGlhbE1lc3NhZ2VUaW1lciIsInJlYWRhYmxlIiwiY29udGVudExlbmd0aCIsInNldFBhcnRpYWxNZXNzYWdlVGltZXIiLCJjbGVhclBhcnRpYWxNZXNzYWdlVGltZXIiLCJyZWFkU2VtYXBob3JlIiwibG9jayIsImJ5dGVzIiwid2FpdGluZ1RpbWUiLCJTZW1hcGhvcmUiLCJDb250ZW50TGVuZ3RoIiwiUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyIsImNvbnRlbnRUeXBlRW5jb2RlciIsImNvbnRlbnRFbmNvZGVyIiwid3JpdGVTZW1hcGhvcmUiLCJwYXlsb2FkIiwiZG9Xcml0ZSIsIkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSIsIlBhcnNlRXJyb3IiLCJJbnZhbGlkUmVxdWVzdCIsImpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsInNlcnZlckVycm9yU3RhcnQiLCJNZXNzYWdlUmVhZEVycm9yIiwiQ29ubmVjdGlvbkluYWN0aXZlIiwiU2VydmVyTm90SW5pdGlhbGl6ZWQiLCJVbmtub3duRXJyb3JDb2RlIiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCIsInNlcnZlckVycm9yRW5kIiwiX3BhcmFtZXRlclN0cnVjdHVyZXMiLCJfcmFsIiwicmFsIiwidGh1bmsiLCJfd2FpdGluZyIsInJ1bk5leHQiLCJhY3RpdmUiLCJfYWN0aXZlIiwiX2NhcGFjaXR5IiwiZG9SdW5OZXh0IiwiY2FwYWNpdHkiLCJDYW5jZWxsYXRpb25TdGF0ZSIsIkNvbnRpbnVlIiwicmVxdWVzdCIsImJ1ZmZlcnMiLCIkY2FuY2VsbGF0aW9uRGF0YSIsIl9jb25uIiwic3RvcmUiLCJTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIiwibG9hZCIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24iLCJicm93c2VyXzEiLCJMU1BFcnJvckNvZGVzIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQiLCJSZXF1ZXN0RmFpbGVkIiwiU2VydmVyQ2FuY2VsbGVkIiwiQ29udGVudE1vZGlmaWVkIiwiUmVxdWVzdENhbmNlbGxlZCIsImxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCIsInZzY29kZV9qc29ucnBjXzEiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZSIsIlByb3RvY29sUmVxdWVzdFR5cGUwIiwiUmVnaXN0cmF0aW9uVHlwZSIsIk1lc3NhZ2VEaXJlY3Rpb24iLCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJtZXNzYWdlRGlyZWN0aW9uIiwiY2xpZW50VG9TZXJ2ZXIiLCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3QiLCJEb2N1bWVudENvbG9yUmVxdWVzdCIsIkNvbmZpZ3VyYXRpb25SZXF1ZXN0Iiwic2VydmVyVG9DbGllbnQiLCJEZWNsYXJhdGlvblJlcXVlc3QiLCJfX25vRHluYW1pY0ltcG9ydCIsIkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCIsIldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCIsIkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQiLCJEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSIsInJldHJpZ2dlclJlcXVlc3QiLCJGdWxsIiwiVW5jaGFuZ2VkIiwicGFydGlhbFJlc3VsdCIsIldpbGxEZWxldGVGaWxlc1JlcXVlc3QiLCJEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiIsIkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCIsIkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCIsIkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCIsImZvbGRlciIsIkZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0IiwiRm9sZGluZ1JhbmdlUmVxdWVzdCIsIkltcGxlbWVudGF0aW9uUmVxdWVzdCIsIklubGF5SGludFJlZnJlc2hSZXF1ZXN0IiwiSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QiLCJJbmxheUhpbnRSZXF1ZXN0IiwiSW5saW5lQ29tcGxldGlvblJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0IiwiSW5saW5lVmFsdWVSZXF1ZXN0IiwiV29ya3NwYWNlU3ltYm9sUmVxdWVzdCIsIkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCIsIkNvZGVBY3Rpb25SZXF1ZXN0IiwiRG9jdW1lbnRTeW1ib2xSZXF1ZXN0IiwiRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0IiwiUmVmZXJlbmNlc1JlcXVlc3QiLCJEZWZpbml0aW9uUmVxdWVzdCIsIlNpZ25hdHVyZUhlbHBSZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kIiwiSG92ZXJSZXF1ZXN0IiwiQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IiwiQ29tcGxldGlvblJlcXVlc3QiLCJDb21wbGV0aW9uVHJpZ2dlcktpbmQiLCJQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24iLCJXYXRjaEtpbmQiLCJSZWxhdGl2ZVBhdHRlcm4iLCJGaWxlQ2hhbmdlVHlwZSIsIkRpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiIsIldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCIsIldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50U2F2ZVJlYXNvbiIsIkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCIsIkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTeW5jS2luZCIsIlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIiwiTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiIsIlNob3dNZXNzYWdlUmVxdWVzdCIsIlNob3dNZXNzYWdlTm90aWZpY2F0aW9uIiwiTWVzc2FnZVR5cGUiLCJEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uIiwiRXhpdE5vdGlmaWNhdGlvbiIsIlNodXRkb3duUmVxdWVzdCIsIkluaXRpYWxpemVkTm90aWZpY2F0aW9uIiwiSW5pdGlhbGl6ZUVycm9yQ29kZXMiLCJJbml0aWFsaXplUmVxdWVzdCIsIldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIiwiVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyIsIlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMiLCJQb3NpdGlvbkVuY29kaW5nS2luZCIsIkZhaWx1cmVIYW5kbGluZ0tpbmQiLCJSZXNvdXJjZU9wZXJhdGlvbktpbmQiLCJVbnJlZ2lzdHJhdGlvblJlcXVlc3QiLCJSZWdpc3RyYXRpb25SZXF1ZXN0IiwiRG9jdW1lbnRTZWxlY3RvciIsIk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciIsIk5vdGVib29rRG9jdW1lbnRGaWx0ZXIiLCJUZXh0RG9jdW1lbnRGaWx0ZXIiLCJNb25pa2VyUmVxdWVzdCIsIk1vbmlrZXJLaW5kIiwiVW5pcXVlbmVzc0xldmVsIiwiTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCIsIlNob3dEb2N1bWVudFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUiLCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVxdWVzdCIsIlRva2VuRm9ybWF0IiwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiIsIldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzcyIsIlNlbGVjdGlvblJhbmdlUmVxdWVzdCIsIkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24iLCJXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCIsIlR5cGVEZWZpbml0aW9uUmVxdWVzdCIsIkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QiLCJFeGVjdXRlQ29tbWFuZFJlcXVlc3QiLCJQcmVwYXJlUmVuYW1lUmVxdWVzdCIsIlJlbmFtZVJlcXVlc3QiLCJQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciIsIkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCIsIkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVxdWVzdCIsIkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QiLCJDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0IiwiQ29kZUxlbnNSZXF1ZXN0IiwiV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QiLCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0NlbGxBcnJheUNoYW5nZSIsIkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlIiwiTm90ZWJvb2tEb2N1bWVudCIsIk5vdGVib29rQ2VsbCIsIkV4ZWN1dGlvblN1bW1hcnkiLCJOb3RlYm9va0NlbGxLaW5kIiwiVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0IiwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCIsIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xIiwicHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMSIsInByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEiLCJwcm90b2NvbF93b3Jrc3BhY2VGb2xkZXJfMSIsInByb3RvY29sX2NvbmZpZ3VyYXRpb25fMSIsInByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSIsInByb3RvY29sX2ZvbGRpbmdSYW5nZV8xIiwicHJvdG9jb2xfZGVjbGFyYXRpb25fMSIsInByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEiLCJwcm90b2NvbF9wcm9ncmVzc18xIiwicHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xIiwicHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSIsInByb3RvY29sX3Nob3dEb2N1bWVudF8xIiwicHJvdG9jb2xfbGlua2VkRWRpdGluZ1JhbmdlXzEiLCJwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xIiwicHJvdG9jb2xfbW9uaWtlcl8xIiwicHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xIiwicHJvdG9jb2xfaW5saW5lVmFsdWVfMSIsInByb3RvY29sX2lubGF5SGludF8xIiwicHJvdG9jb2xfZGlhZ25vc3RpY18xIiwicHJvdG9jb2xfbm90ZWJvb2tfMSIsInByb3RvY29sX2lubGluZUNvbXBsZXRpb25fMSIsImxhbmd1YWdlIiwic2NoZW1lIiwicGF0dGVybiIsIm9iamVjdExpdGVyYWwiLCJub3RlYm9va1R5cGUiLCJub3RlYm9vayIsIkNyZWF0ZSIsIlJlbmFtZSIsIkRlbGV0ZSIsIkFib3J0IiwiVHJhbnNhY3Rpb25hbCIsIlRleHRPbmx5VHJhbnNhY3Rpb25hbCIsIlVuZG8iLCJVVEY4IiwiVVRGMTYiLCJVVEYzMiIsImhhc0lkIiwiZG9jdW1lbnRTZWxlY3RvciIsIndvcmtEb25lUHJvZ3Jlc3MiLCJoYXNXb3JrRG9uZVByb2dyZXNzIiwidW5rbm93blByb3RvY29sVmVyc2lvbiIsIldhcm5pbmciLCJJbmZvIiwiTG9nIiwiRGVidWciLCJJbmNyZW1lbnRhbCIsImlzSW5jcmVtZW50YWwiLCJyYW5nZUxlbmd0aCIsImlzRnVsbCIsIk1hbnVhbCIsIkFmdGVyRGVsYXkiLCJGb2N1c091dCIsIkNyZWF0ZWQiLCJDaGFuZ2VkIiwiRGVsZXRlZCIsImJhc2VVcmkiLCJXb3Jrc3BhY2VGb2xkZXIiLCJDaGFuZ2UiLCJJbnZva2VkIiwiVHJpZ2dlckNoYXJhY3RlciIsIlRyaWdnZXJGb3JJbmNvbXBsZXRlQ29tcGxldGlvbnMiLCJDb250ZW50Q2hhbmdlIiwicHJvamVjdCIsImdyb3VwIiwiJGltcG9ydCIsIiRleHBvcnQiLCJsb2NhbCIsIk1hcmt1cCIsIkNvZGUiLCJleGVjdXRpb25PcmRlciIsInN1Y2Nlc3MiLCJ1aW50ZWdlciIsImVxdWFscyIsIm9uZSIsIkRvY3VtZW50VXJpIiwibWV0YWRhdGEiLCJkaWZmIiwidHdvIiwiZXhlY3V0aW9uU3VtbWFyeSIsImVxdWFsc01ldGFkYXRhIiwib25lQXJyYXkiLCJvdGhlckFycmF5Iiwib25lS2V5cyIsIm90aGVyS2V5cyIsImNlbGxzIiwiaW50ZWdlciIsInR5cGVkQXJyYXkiLCJyZWdpc3RyYXRpb25NZXRob2QiLCJkZWxldGVDb3VudCIsIlJlbGF0aXZlIiwiY2hlY2siLCJhdmFpbGFibGVUeXBlZEFycmF5cyIsImdsb2JhbFRoaXMiLCJ0eXBlZEFycmF5cyIsIiRzbGljZSIsImNhY2hlIiwicHJvdG8iLCJzdXBlclByb3RvIiwidHJ5VHlwZWRBcnJheXMiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImdldHRlciIsInRyeVNsaWNlcyIsInRyeUFsbFNsaWNlcyIsInRhZyIsInBvc3NpYmxlTmFtZXMiLCJvdXQiLCJfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXyIsIlRleHREb2N1bWVudCIsIkZ1bGxUZXh0RG9jdW1lbnQiLCJfdXJpIiwiX2xhbmd1YWdlSWQiLCJfdmVyc2lvbiIsIm9mZnNldEF0IiwiX2NvbnRlbnQiLCJjaGFuZ2VzIiwiY2hhbmdlIiwiZ2V0V2VsbGZvcm1lZFJhbmdlIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibGluZU9mZnNldHMiLCJfbGluZU9mZnNldHMiLCJhZGRlZExpbmVPZmZzZXRzIiwiY29tcHV0ZUxpbmVPZmZzZXRzIiwiZ2V0TGluZU9mZnNldHMiLCJwb3NpdGlvbkF0IiwibG93IiwiaGlnaCIsIm1pZCIsImVuc3VyZUJlZm9yZUVPTCIsImxpbmVPZmZzZXQiLCJuZXh0TGluZU9mZnNldCIsImlzRU9MIiwibGluZUNvdW50IiwiYXBwbHlFZGl0cyIsImVkaXRzIiwic29ydGVkRWRpdHMiLCJtZXJnZVNvcnQiLCJnZXRXZWxsZm9ybWVkRWRpdCIsImxhc3RNb2RpZmllZE9mZnNldCIsInNwYW5zIiwibmV3VGV4dCIsImxlZnRJZHgiLCJyaWdodElkeCIsImlzQXRMaW5lU3RhcnQiLCJ0ZXh0T2Zmc2V0IiwiY2giLCJjaGFyIiwidGV4dEVkaXQiLCJBbm5vdGF0ZWRUZXh0RWRpdCIsIkNoYW5nZUFubm90YXRpb24iLCJDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciIsIkNvZGVBY3Rpb24iLCJDb2RlQWN0aW9uQ29udGV4dCIsIkNvZGVBY3Rpb25LaW5kIiwiQ29kZUFjdGlvblRyaWdnZXJLaW5kIiwiQ29kZURlc2NyaXB0aW9uIiwiQ29kZUxlbnMiLCJDb2xvciIsIkNvbG9ySW5mb3JtYXRpb24iLCJDb2xvclByZXNlbnRhdGlvbiIsIkNvbW1hbmQiLCJDb21wbGV0aW9uSXRlbSIsIkNvbXBsZXRpb25JdGVtS2luZCIsIkNvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIiwiQ29tcGxldGlvbkl0ZW1UYWciLCJDb21wbGV0aW9uTGlzdCIsIkNyZWF0ZUZpbGUiLCJEZWxldGVGaWxlIiwiRGlhZ25vc3RpYyIsIkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24iLCJEaWFnbm9zdGljU2V2ZXJpdHkiLCJEb2N1bWVudEhpZ2hsaWdodCIsIkRvY3VtZW50SGlnaGxpZ2h0S2luZCIsIkRvY3VtZW50TGluayIsIkRvY3VtZW50U3ltYm9sIiwiRU9MIiwiRm9sZGluZ1JhbmdlIiwiRm9sZGluZ1JhbmdlS2luZCIsIkZvcm1hdHRpbmdPcHRpb25zIiwiSG92ZXIiLCJJbmxheUhpbnQiLCJJbmxheUhpbnRLaW5kIiwiSW5sYXlIaW50TGFiZWxQYXJ0IiwiSW5saW5lQ29tcGxldGlvbkNvbnRleHQiLCJJbmxpbmVDb21wbGV0aW9uSXRlbSIsIklubGluZUNvbXBsZXRpb25MaXN0IiwiSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kIiwiSW5saW5lVmFsdWVDb250ZXh0IiwiSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24iLCJJbmxpbmVWYWx1ZVRleHQiLCJJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIiwiSW5zZXJ0UmVwbGFjZUVkaXQiLCJJbnNlcnRUZXh0Rm9ybWF0IiwiSW5zZXJ0VGV4dE1vZGUiLCJMb2NhdGlvbiIsIkxvY2F0aW9uTGluayIsIk1hcmtlZFN0cmluZyIsIk1hcmt1cENvbnRlbnQiLCJNYXJrdXBLaW5kIiwiT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiUGFyYW1ldGVySW5mb3JtYXRpb24iLCJQb3NpdGlvbiIsIlJhbmdlIiwiUmVuYW1lRmlsZSIsIlNlbGVjdGVkQ29tcGxldGlvbkluZm8iLCJTZWxlY3Rpb25SYW5nZSIsIlNlbWFudGljVG9rZW5Nb2RpZmllcnMiLCJTZW1hbnRpY1Rva2VuVHlwZXMiLCJTZW1hbnRpY1Rva2VucyIsIlNpZ25hdHVyZUluZm9ybWF0aW9uIiwiU3RyaW5nVmFsdWUiLCJTeW1ib2xJbmZvcm1hdGlvbiIsIlN5bWJvbEtpbmQiLCJTeW1ib2xUYWciLCJUZXh0RG9jdW1lbnRFZGl0IiwiVGV4dERvY3VtZW50SWRlbnRpZmllciIsIlRleHREb2N1bWVudEl0ZW0iLCJUZXh0RWRpdCIsIlZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJXb3Jrc3BhY2VDaGFuZ2UiLCJXb3Jrc3BhY2VFZGl0IiwiV29ya3NwYWNlU3ltYm9sIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwidGhyZWUiLCJmb3VyIiwidGFyZ2V0VXJpIiwidGFyZ2V0UmFuZ2UiLCJ0YXJnZXRTZWxlY3Rpb25SYW5nZSIsIm9yaWdpblNlbGVjdGlvblJhbmdlIiwiYWxwaGEiLCJudW1iZXJSYW5nZSIsImNvbG9yIiwiYWRkaXRpb25hbFRleHRFZGl0cyIsIkNvbW1lbnQiLCJJbXBvcnRzIiwiUmVnaW9uIiwic3RhcnRDaGFyYWN0ZXIiLCJlbmRDaGFyYWN0ZXIiLCJjb2xsYXBzZWRUZXh0IiwiZGVmaW5lZCIsIkluZm9ybWF0aW9uIiwiSGludCIsImhyZWYiLCJzZXZlcml0eSIsImNvZGVEZXNjcmlwdGlvbiIsImluc2VydCIsImRlbCIsIm5lZWRzQ29uZmlybWF0aW9uIiwiZGVzY3JpcHRpb24iLCJhbm5vdGF0aW9uIiwiYW5ub3RhdGlvbklkIiwib3ZlcndyaXRlIiwiaWdub3JlSWZFeGlzdHMiLCJvbGRVcmkiLCJuZXdVcmkiLCJyZWN1cnNpdmUiLCJpZ25vcmVJZk5vdEV4aXN0cyIsIlRleHRFZGl0Q2hhbmdlSW1wbCIsImVkaXQiLCJhc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyIsImNoYW5nZUFubm90YXRpb25zIiwibWFuYWdlIiwiQ2hhbmdlQW5ub3RhdGlvbnMiLCJfYW5ub3RhdGlvbnMiLCJpZE9yQW5ub3RhdGlvbiIsIm5leHRJZCIsIl9jb3VudGVyIiwiYW5ub3RhdGlvbnMiLCJpbml0RG9jdW1lbnRDaGFuZ2VzIiwiX2NoYW5nZUFubm90YXRpb25zIiwiX3dvcmtzcGFjZUVkaXQiLCJnZXRUZXh0RWRpdENoYW5nZSIsIl90ZXh0RWRpdENoYW5nZXMiLCJ0ZXh0RG9jdW1lbnRFZGl0IiwiaW5pdENoYW5nZXMiLCJjcmVhdGVGaWxlIiwib3B0aW9uc09yQW5ub3RhdGlvbiIsIm9wZXJhdGlvbiIsInJlbmFtZUZpbGUiLCJkZWxldGVGaWxlIiwidGV4dEVkaXRDaGFuZ2UiLCJQbGFpblRleHQiLCJNYXJrZG93biIsIk1ldGhvZCIsIkZpZWxkIiwiVmFyaWFibGUiLCJJbnRlcmZhY2UiLCJNb2R1bGUiLCJQcm9wZXJ0eSIsIlVuaXQiLCJWYWx1ZSIsIkVudW0iLCJTbmlwcGV0IiwiRmlsZSIsIlJlZmVyZW5jZSIsIkZvbGRlciIsIkVudW1NZW1iZXIiLCJDb25zdGFudCIsIlN0cnVjdCIsIk9wZXJhdG9yIiwiVHlwZVBhcmFtZXRlciIsImFzSXMiLCJhZGp1c3RJbmRlbnRhdGlvbiIsImRldGFpbCIsIml0ZW1zIiwiaXNJbmNvbXBsZXRlIiwiZnJvbVBsYWluVGV4dCIsInBsYWluVGV4dCIsImNvbnRlbnRzIiwiZG9jdW1lbnRhdGlvbiIsIlJlYWQiLCJXcml0ZSIsIk5hbWVzcGFjZSIsIlBhY2thZ2UiLCJLZXkiLCJOdWxsIiwiY29udGFpbmVyTmFtZSIsInNlbGVjdGlvblJhbmdlIiwiY2hpbGRyZW4iLCJ0YWdzIiwiUXVpY2tGaXgiLCJSZWZhY3RvciIsIlJlZmFjdG9yRXh0cmFjdCIsIlJlZmFjdG9ySW5saW5lIiwiUmVmYWN0b3JSZXdyaXRlIiwiU291cmNlIiwiU291cmNlT3JnYW5pemVJbXBvcnRzIiwiU291cmNlRml4QWxsIiwiQXV0b21hdGljIiwiZGlhZ25vc3RpY3MiLCJvbmx5IiwidHJpZ2dlcktpbmQiLCJraW5kT3JDb21tYW5kT3JFZGl0IiwiY2hlY2tLaW5kIiwiaXNQcmVmZXJyZWQiLCJ0YWJTaXplIiwiaW5zZXJ0U3BhY2VzIiwicGFyZW50IiwicmVzdWx0SWQiLCJ2YXJpYWJsZU5hbWUiLCJjYXNlU2Vuc2l0aXZlTG9va3VwIiwiZnJhbWVJZCIsInN0b3BwZWRMb2NhdGlvbiIsIlR5cGUiLCJQYXJhbWV0ZXIiLCJ0b29sdGlwIiwidGV4dEVkaXRzIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJjcmVhdGVTbmlwcGV0IiwiaW5zZXJ0VGV4dCIsImZpbHRlclRleHQiLCJzZWxlY3RlZENvbXBsZXRpb25JbmZvIiwiaXNMaW5lU3RhcnQiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImxvYWRlZCIsImRlZmluaXRpb24iLCJwYXRocyIsIkx1YVNlcnZpY2UiLCJiYXNlX3NlcnZpY2UiLCJsdWFwYXJzZSIsIm1haW4iLCJ1dGlscyIsIkFjZVJhbmdlIiwiZ2V0Q29uc3RydWN0b3IiLCJlZGl0b3IiLCJfaW5zdGFuY2UiLCJnZXRTZWxlY3Rpb25SYW5nZSIsImNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlciIsIkNvbW1vbkNvbnZlcnRlciIsIm5vcm1hbGl6ZVJhbmdlcyIsImNvbXBsZXRpb25zIiwiZWwiLCJ0b1JhbmdlIiwiY2xlYW5IdG1sIiwiaHRtbCIsImZyb21Qb2ludHMiLCJjb252ZXJ0S2luZCIsImV4Y2x1ZGVCeUVycm9yTWVzc2FnZSIsImZpZWxkTmFtZSIsImZyb21SYW5nZSIsInJhbmdlRnJvbVBvc2l0aW9ucyIsImZyb21Qb2ludCIsInBvaW50IiwidG9Qb2ludCIsInRvQW5ub3RhdGlvbnMiLCJfZGlhZ25vc3RpY3MiLCJmcm9tQW5ub3RhdGlvbnMiLCJ0b0NvbXBsZXRpb24iLCJfaXRlbV90ZXh0RWRpdCIsIl9pdGVtX2NvbW1hbmQiLCJpdGVtS2luZCIsIl9pdGVtX3RleHRFZGl0X25ld1RleHQiLCJfcmVmIiwiZmlyc3RXb3JkTWF0Y2giLCJmaXJzdFdvcmQiLCJ3b3JkUmVnZXgiLCJnZXRUZXh0RWRpdFJhbmdlIiwiY2FwdGlvbiIsInNjb3JlIiwiaW5zZXJ0VGV4dEZvcm1hdCIsInRvQ29tcGxldGlvbnMiLCJjb21iaW5lZENvbXBsZXRpb25zIiwiZ2V0Q29tcGxldGlvbkl0ZW1zIiwiYWxsQ29tcGxldGlvbnMiLCJzZXJ2aWNlIiwiZmxhdCIsInRvSW5saW5lQ29tcGxldGlvbiIsImdldElubGluZUNvbXBsZXRpb25SYW5nZSIsInRvSW5saW5lQ29tcGxldGlvbnMiLCJ0b1Jlc29sdmVkQ29tcGxldGlvbiIsImZyb21NYXJrdXBDb250ZW50IiwidG9Db21wbGV0aW9uSXRlbSIsIl9jb21wbGV0aW9uX2NhcHRpb24iLCJfY29tcGxldGlvbl9zbmlwcGV0IiwiX2NvbXBsZXRpb25fc25pcHBldDEiLCJmaWx0ZXJMZW5ndGgiLCJtZXJnZWRSYW5nZXMiLCJ0b1Rvb2x0aXAiLCJfaG92ZXJfZmluZCIsImxzcFJhbmdlIiwiZmluZCIsIl9lbCIsImZyb21TaWduYXR1cmVIZWxwIiwiX2VsMSIsInNpZ25hdHVyZUluZGV4IiwiYWN0aXZlU2lnbmF0dXJlIiwic2lnbmF0dXJlcyIsImFjdGl2ZVBhcmFtIiwiYWN0aXZlUGFyYW1ldGVyIiwiZnJvbUFjZURlbHRhIiwiZW9sIiwibGluZXMiLCJhY3Rpb24iLCJmaWx0ZXJEaWFnbm9zdGljcyIsImZpbHRlckVycm9ycyIsImZyb21Eb2N1bWVudEhpZ2hsaWdodHMiLCJkb2N1bWVudEhpZ2hsaWdodHMiLCJ0b01hcmtlckdyb3VwSXRlbSIsInRvb2x0aXBUZXh0IiwibWFya2VyR3JvdXBJdGVtIiwibHVhX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5IiwiJHNlcnZpY2UiLCJkaWFnbm9zdGljUHJvdmlkZXIiLCJpbnRlckZpbGVEZXBlbmRlbmNpZXMiLCJ3b3Jrc3BhY2VEaWFnbm9zdGljcyJdLCJzb3VyY2VSb290IjoiIn0=