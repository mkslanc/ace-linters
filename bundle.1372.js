(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[1372],{

/***/ 21372:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 6093: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_511__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_511__(9907);
                /* provided dependency */ var console = __nested_webpack_require_511__(4364);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_511__(1342), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_511__(9801);
                var _require2 = __nested_webpack_require_511__(6827), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_511__(6827).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_511__(3046).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_511__(5968);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_511__(5656);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 9801: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_31729__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_31729__(9907);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_31729__(6827), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_31729__(1342), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 1342: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65318__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65318__(6093);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65318__(6827);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65318__(6093);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 5656: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76379__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76379__(5968);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76379__(7838);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76379__(6827).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 9818: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_107933__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_107933__(528);
                var callBind = __nested_webpack_require_107933__(8498);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 8498: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108660__)=>{
                "use strict";
                var bind = __nested_webpack_require_108660__(9138);
                var GetIntrinsic = __nested_webpack_require_108660__(528);
                var setFunctionLength = __nested_webpack_require_108660__(6108);
                var $TypeError = __nested_webpack_require_108660__(3468);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $defineProperty = __nested_webpack_require_108660__(4940);
                var $max = GetIntrinsic('%Math.max%');
                module1.exports = function callBind(originalFunction) {
                    if (typeof originalFunction !== 'function') {
                        throw new $TypeError('a function is required');
                    }
                    var func = $reflectApply(bind, $call, arguments);
                    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 4364: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110259__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110259__(6827);
                var assert = __nested_webpack_require_110259__(6093);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110259__.g !== "undefined" && __nested_webpack_require_110259__.g.console) {
                    console = __nested_webpack_require_110259__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 686: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_113941__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_113941__(4940);
                var $SyntaxError = __nested_webpack_require_113941__(5731);
                var $TypeError = __nested_webpack_require_113941__(3468);
                var gopd = __nested_webpack_require_113941__(9336);
                /** @type {import('.')} */ module1.exports = function defineDataProperty(obj, property, value) {
                    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
                        throw new $TypeError('`obj` must be an object or a function`');
                    }
                    if (typeof property !== 'string' && typeof property !== 'symbol') {
                        throw new $TypeError('`property` must be a string or a symbol`');
                    }
                    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
                        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
                        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
                        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
                        throw new $TypeError('`loose`, if provided, must be a boolean');
                    }
                    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                    var nonWritable = arguments.length > 4 ? arguments[4] : null;
                    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                    var loose = arguments.length > 6 ? arguments[6] : false;
                    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
                    if ($defineProperty) {
                        $defineProperty(obj, property, {
                            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                            value: value,
                            writable: nonWritable === null && desc ? desc.writable : !nonWritable
                        });
                    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
                        obj[property] = value; // eslint-disable-line no-param-reassign
                    } else {
                        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
                    }
                };
            /***/ },
            /***/ 1857: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_117229__)=>{
                "use strict";
                var keys = __nested_webpack_require_117229__(9228);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var hasPropertyDescriptors = __nested_webpack_require_117229__(7239)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        origDefineProperty(object, name, {
                            configurable: true,
                            enumerable: false,
                            value: value,
                            writable: true
                        });
                    } else {
                        object[name] = value; // eslint-disable-line no-param-reassign
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4940: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_119612__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_119612__(528);
                /** @type {import('.')} */ var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = false;
                    }
                }
                module1.exports = $defineProperty;
            /***/ },
            /***/ 6729: /***/ (module1)=>{
                "use strict";
                /** @type {import('./eval')} */ module1.exports = EvalError;
            /***/ },
            /***/ 9838: /***/ (module1)=>{
                "use strict";
                /** @type {import('.')} */ module1.exports = Error;
            /***/ },
            /***/ 1155: /***/ (module1)=>{
                "use strict";
                /** @type {import('./range')} */ module1.exports = RangeError;
            /***/ },
            /***/ 4943: /***/ (module1)=>{
                "use strict";
                /** @type {import('./ref')} */ module1.exports = ReferenceError;
            /***/ },
            /***/ 5731: /***/ (module1)=>{
                "use strict";
                /** @type {import('./syntax')} */ module1.exports = SyntaxError;
            /***/ },
            /***/ 3468: /***/ (module1)=>{
                "use strict";
                /** @type {import('./type')} */ module1.exports = TypeError;
            /***/ },
            /***/ 2140: /***/ (module1)=>{
                "use strict";
                /** @type {import('./uri')} */ module1.exports = URIError;
            /***/ },
            /***/ 3046: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 705: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123458__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_123458__(9617);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 8794: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var toStr = Object.prototype.toString;
                var max = Math.max;
                var funcType = '[object Function]';
                var concatty = function concatty(a, b) {
                    var arr = [];
                    for(var i = 0; i < a.length; i += 1){
                        arr[i] = a[i];
                    }
                    for(var j = 0; j < b.length; j += 1){
                        arr[j + a.length] = b[j];
                    }
                    return arr;
                };
                var slicy = function slicy(arrLike, offset) {
                    var arr = [];
                    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
                        arr[j] = arrLike[i];
                    }
                    return arr;
                };
                var joiny = function(arr, joiner) {
                    var str = '';
                    for(var i = 0; i < arr.length; i += 1){
                        str += arr[i];
                        if (i + 1 < arr.length) {
                            str += joiner;
                        }
                    }
                    return str;
                };
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, concatty(args, arguments));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        }
                        return target.apply(that, concatty(args, arguments));
                    };
                    var boundLength = max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs[i] = '$' + i;
                    }
                    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 9138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129177__)=>{
                "use strict";
                var implementation = __nested_webpack_require_129177__(8794);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 528: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129458__)=>{
                "use strict";
                var undefined1;
                var $Error = __nested_webpack_require_129458__(9838);
                var $EvalError = __nested_webpack_require_129458__(6729);
                var $RangeError = __nested_webpack_require_129458__(1155);
                var $ReferenceError = __nested_webpack_require_129458__(4943);
                var $SyntaxError = __nested_webpack_require_129458__(5731);
                var $TypeError = __nested_webpack_require_129458__(3468);
                var $URIError = __nested_webpack_require_129458__(2140);
                var $Function = Function;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_129458__(3558)();
                var hasProto = __nested_webpack_require_129458__(6869)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    __proto__: null,
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': $Error,
                    '%eval%': eval,
                    '%EvalError%': $EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': $RangeError,
                    '%ReferenceError%': $ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': $URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    __proto__: null,
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_129458__(9138);
                var hasOwn = __nested_webpack_require_129458__(8554);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 9336: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153336__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_153336__(528);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 7239: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153926__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_153926__(4940);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    return !!$defineProperty;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!$defineProperty) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 6869: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 3558: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155488__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_155488__(2908);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 2908: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 1913: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159247__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_159247__(2908);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 8554: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159599__)=>{
                "use strict";
                var call = Function.prototype.call;
                var $hasOwn = Object.prototype.hasOwnProperty;
                var bind = __nested_webpack_require_159599__(9138);
                /** @type {import('.')} */ module1.exports = bind.call(call, $hasOwn);
            /***/ },
            /***/ 5615: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 5387: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_161386__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_161386__(1913)();
                var callBound = __nested_webpack_require_161386__(9818);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9617: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 2625: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168446__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_168446__(1913)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 8006: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 7838: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170415__)=>{
                "use strict";
                var callBind = __nested_webpack_require_170415__(8498);
                var define1 = __nested_webpack_require_170415__(1857);
                var implementation = __nested_webpack_require_170415__(8006);
                var getPolyfill = __nested_webpack_require_170415__(1591);
                var shim = __nested_webpack_require_170415__(1641);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1591: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171214__)=>{
                "use strict";
                var implementation = __nested_webpack_require_171214__(8006);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 1641: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171690__)=>{
                "use strict";
                var define1 = __nested_webpack_require_171690__(1857);
                var getPolyfill = __nested_webpack_require_171690__(1591);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5943: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_172458__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_172458__(2730);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 98: /***/ function(module1, exports1, __nested_webpack_require_172791__) {
                /* module decorator */ module1 = __nested_webpack_require_172791__.nmd(module1);
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /* global exports:true, module:true, require:true, define:true, global:true */ 
                (function(root, name, factory) {
                    'use strict';
                    // Used to determine if values are of the language type `Object`
                    var objectTypes = {
                        'function': true,
                        'object': true
                    }, freeExports = objectTypes[typeof exports1] && exports1 && !exports1.nodeType && exports1, freeModule = objectTypes["object"] && module1 && !module1.nodeType && module1, freeGlobal = freeExports && freeModule && typeof __nested_webpack_require_172791__.g === 'object' && __nested_webpack_require_172791__.g, moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                    /* istanbul ignore else */ if (freeGlobal && (freeGlobal.global === freeGlobal || /* istanbul ignore next */ freeGlobal.window === freeGlobal || /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {
                        root = freeGlobal;
                    }
                    // Some AMD build optimizers, like r.js, check for specific condition
                    // patterns like the following:
                    /* istanbul ignore if */ if (true) {
                        // defined as an anonymous module.
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                            exports1
                        ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports1, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        // In case the source has been processed and wrapped in a define module use
                        // the supplied `exports` object.
                        if (freeExports && moduleExports) factory(freeModule.exports);
                    } else /* istanbul ignore else */ {}
                })(this, 'luaparse', function(exports1) {
                    'use strict';
                    exports1.version = "0.3.1";
                    var input, options, length, features, encodingMode;
                    // Options can be set either globally on the parser object through
                    // defaultOptions, or during the parse call.
                    var defaultOptions = exports1.defaultOptions = {
                        // Explicitly tell the parser when the input ends.
                        wait: false,
                        comments: true,
                        scope: false,
                        locations: false,
                        ranges: false,
                        onCreateNode: null,
                        onCreateScope: null,
                        onDestroyScope: null,
                        onLocalDeclaration: null,
                        luaVersion: '5.1',
                        encodingMode: 'none'
                    };
                    function encodeUTF8(codepoint, highMask) {
                        highMask = highMask || 0;
                        if (codepoint < 0x80) {
                            return String.fromCharCode(codepoint);
                        } else if (codepoint < 0x800) {
                            return String.fromCharCode(highMask | 0xc0 | codepoint >> 6, highMask | 0x80 | codepoint & 0x3f);
                        } else if (codepoint < 0x10000) {
                            return String.fromCharCode(highMask | 0xe0 | codepoint >> 12, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else /* istanbul ignore else */ if (codepoint < 0x110000) {
                            return String.fromCharCode(highMask | 0xf0 | codepoint >> 18, highMask | 0x80 | codepoint >> 12 & 0x3f, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else {
                            // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993
                            return null;
                        }
                    }
                    function toHex(num, digits) {
                        var result = num.toString(16);
                        while(result.length < digits)result = '0' + result;
                        return result;
                    }
                    function checkChars(rx) {
                        return function(s) {
                            var m = rx.exec(s);
                            if (!m) return s;
                            raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());
                        };
                    }
                    var encodingModes = {
                        // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding
                        // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;
                        // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks
                        'pseudo-latin1': {
                            fixup: checkChars(/[^\x00-\xff]/),
                            encodeByte: function(value) {
                                if (value === null) return '';
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function(codepoint) {
                                return encodeUTF8(codepoint);
                            }
                        },
                        // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding
                        'x-user-defined': {
                            fixup: checkChars(/[^\x00-\x7f\uf780-\uf7ff]/),
                            encodeByte: function(value) {
                                if (value === null) return '';
                                if (value >= 0x80) return String.fromCharCode(value | 0xf700);
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function(codepoint) {
                                return encodeUTF8(codepoint, 0xf700);
                            }
                        },
                        // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is
                        'none': {
                            discardStrings: true,
                            fixup: function(s) {
                                return s;
                            },
                            encodeByte: function(value) {
                                return '';
                            },
                            encodeUTF8: function(codepoint) {
                                return '';
                            }
                        }
                    };
                    // The available tokens expressed as enum flags so they can be checked with
                    // bitwise operations.
                    var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8, NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64, NilLiteral = 128, VarargLiteral = 256;
                    exports1.tokenTypes = {
                        EOF: EOF,
                        StringLiteral: StringLiteral,
                        Keyword: Keyword,
                        Identifier: Identifier,
                        NumericLiteral: NumericLiteral,
                        Punctuator: Punctuator,
                        BooleanLiteral: BooleanLiteral,
                        NilLiteral: NilLiteral,
                        VarargLiteral: VarargLiteral
                    };
                    // As this parser is a bit different from luas own, the error messages
                    // will be different in some situations.
                    var errors = exports1.errors = {
                        unexpected: 'unexpected %1 \'%2\' near \'%3\'',
                        unexpectedEOF: 'unexpected symbol near \'<eof>\'',
                        expected: '\'%1\' expected near \'%2\'',
                        expectedToken: '%1 expected near \'%2\'',
                        unfinishedString: 'unfinished string near \'%1\'',
                        malformedNumber: 'malformed number near \'%1\'',
                        decimalEscapeTooLarge: 'decimal escape too large near \'%1\'',
                        invalidEscape: 'invalid escape sequence near \'%1\'',
                        hexadecimalDigitExpected: 'hexadecimal digit expected near \'%1\'',
                        braceExpected: 'missing \'%1\' near \'%2\'',
                        tooLargeCodepoint: 'UTF-8 value too large near \'%1\'',
                        unfinishedLongString: 'unfinished long string (starting at line %1) near \'%2\'',
                        unfinishedLongComment: 'unfinished long comment (starting at line %1) near \'%2\'',
                        ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \'%1\'',
                        noLoopToBreak: 'no loop to break near \'%1\'',
                        labelAlreadyDefined: 'label \'%1\' already defined on line %2',
                        labelNotVisible: 'no visible label \'%1\' for <goto>',
                        gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \'%2\'',
                        cannotUseVararg: 'cannot use \'...\' outside a vararg function near \'%1\'',
                        invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'
                    };
                    // ### Abstract Syntax Tree
                    //
                    // The default AST structure is inspired by the Mozilla Parser API but can
                    // easily be customized by overriding these functions.
                    var ast = exports1.ast = {
                        labelStatement: function(label) {
                            return {
                                type: 'LabelStatement',
                                label: label
                            };
                        },
                        breakStatement: function() {
                            return {
                                type: 'BreakStatement'
                            };
                        },
                        gotoStatement: function(label) {
                            return {
                                type: 'GotoStatement',
                                label: label
                            };
                        },
                        returnStatement: function(args) {
                            return {
                                type: 'ReturnStatement',
                                'arguments': args
                            };
                        },
                        ifStatement: function(clauses) {
                            return {
                                type: 'IfStatement',
                                clauses: clauses
                            };
                        },
                        ifClause: function(condition, body) {
                            return {
                                type: 'IfClause',
                                condition: condition,
                                body: body
                            };
                        },
                        elseifClause: function(condition, body) {
                            return {
                                type: 'ElseifClause',
                                condition: condition,
                                body: body
                            };
                        },
                        elseClause: function(body) {
                            return {
                                type: 'ElseClause',
                                body: body
                            };
                        },
                        whileStatement: function(condition, body) {
                            return {
                                type: 'WhileStatement',
                                condition: condition,
                                body: body
                            };
                        },
                        doStatement: function(body) {
                            return {
                                type: 'DoStatement',
                                body: body
                            };
                        },
                        repeatStatement: function(condition, body) {
                            return {
                                type: 'RepeatStatement',
                                condition: condition,
                                body: body
                            };
                        },
                        localStatement: function(variables, init) {
                            return {
                                type: 'LocalStatement',
                                variables: variables,
                                init: init
                            };
                        },
                        assignmentStatement: function(variables, init) {
                            return {
                                type: 'AssignmentStatement',
                                variables: variables,
                                init: init
                            };
                        },
                        callStatement: function(expression) {
                            return {
                                type: 'CallStatement',
                                expression: expression
                            };
                        },
                        functionStatement: function(identifier, parameters, isLocal, body) {
                            return {
                                type: 'FunctionDeclaration',
                                identifier: identifier,
                                isLocal: isLocal,
                                parameters: parameters,
                                body: body
                            };
                        },
                        forNumericStatement: function(variable, start, end, step, body) {
                            return {
                                type: 'ForNumericStatement',
                                variable: variable,
                                start: start,
                                end: end,
                                step: step,
                                body: body
                            };
                        },
                        forGenericStatement: function(variables, iterators, body) {
                            return {
                                type: 'ForGenericStatement',
                                variables: variables,
                                iterators: iterators,
                                body: body
                            };
                        },
                        chunk: function(body) {
                            return {
                                type: 'Chunk',
                                body: body
                            };
                        },
                        identifier: function(name) {
                            return {
                                type: 'Identifier',
                                name: name
                            };
                        },
                        literal: function(type, value, raw) {
                            type = type === StringLiteral ? 'StringLiteral' : type === NumericLiteral ? 'NumericLiteral' : type === BooleanLiteral ? 'BooleanLiteral' : type === NilLiteral ? 'NilLiteral' : 'VarargLiteral';
                            return {
                                type: type,
                                value: value,
                                raw: raw
                            };
                        },
                        tableKey: function(key, value) {
                            return {
                                type: 'TableKey',
                                key: key,
                                value: value
                            };
                        },
                        tableKeyString: function(key, value) {
                            return {
                                type: 'TableKeyString',
                                key: key,
                                value: value
                            };
                        },
                        tableValue: function(value) {
                            return {
                                type: 'TableValue',
                                value: value
                            };
                        },
                        tableConstructorExpression: function(fields) {
                            return {
                                type: 'TableConstructorExpression',
                                fields: fields
                            };
                        },
                        binaryExpression: function(operator, left, right) {
                            var type = 'and' === operator || 'or' === operator ? 'LogicalExpression' : 'BinaryExpression';
                            return {
                                type: type,
                                operator: operator,
                                left: left,
                                right: right
                            };
                        },
                        unaryExpression: function(operator, argument) {
                            return {
                                type: 'UnaryExpression',
                                operator: operator,
                                argument: argument
                            };
                        },
                        memberExpression: function(base, indexer, identifier) {
                            return {
                                type: 'MemberExpression',
                                indexer: indexer,
                                identifier: identifier,
                                base: base
                            };
                        },
                        indexExpression: function(base, index) {
                            return {
                                type: 'IndexExpression',
                                base: base,
                                index: index
                            };
                        },
                        callExpression: function(base, args) {
                            return {
                                type: 'CallExpression',
                                base: base,
                                'arguments': args
                            };
                        },
                        tableCallExpression: function(base, args) {
                            return {
                                type: 'TableCallExpression',
                                base: base,
                                'arguments': args
                            };
                        },
                        stringCallExpression: function(base, argument) {
                            return {
                                type: 'StringCallExpression',
                                base: base,
                                argument: argument
                            };
                        },
                        comment: function(value, raw) {
                            return {
                                type: 'Comment',
                                value: value,
                                raw: raw
                            };
                        }
                    };
                    // Wrap up the node object.
                    function finishNode(node) {
                        // Pop a `Marker` off the location-array and attach its location data.
                        if (trackLocations) {
                            var location = locations.pop();
                            location.complete();
                            location.bless(node);
                        }
                        if (options.onCreateNode) options.onCreateNode(node);
                        return node;
                    }
                    // Helpers
                    // -------
                    var slice = Array.prototype.slice, toString = Object.prototype.toString;
                    var indexOf = /* istanbul ignore next */ function(array, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i] === element) return i;
                        }
                        return -1;
                    };
                    /* istanbul ignore else */ if (Array.prototype.indexOf) indexOf = function(array, element) {
                        return array.indexOf(element);
                    };
                    // Iterate through an array of objects and return the index of an object
                    // with a matching property.
                    function indexOfObject(array, property, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i][property] === element) return i;
                        }
                        return -1;
                    }
                    // A sprintf implementation using %index (beginning at 1) to input
                    // arguments in the format string.
                    //
                    // Example:
                    //
                    //     // Unexpected function in token
                    //     sprintf('Unexpected %2 in %1.', 'token', 'function');
                    function sprintf(format) {
                        var args = slice.call(arguments, 1);
                        format = format.replace(/%(\d)/g, function(match, index) {
                            return '' + args[index - 1] || /* istanbul ignore next */ '';
                        });
                        return format;
                    }
                    // Polyfill for `Object.assign`.
                    var assign = /* istanbul ignore next */ function(dest) {
                        var args = slice.call(arguments, 1), src, prop;
                        for(var i = 0, length = args.length; i < length; ++i){
                            src = args[i];
                            for(prop in src)/* istanbul ignore else */ if (Object.prototype.hasOwnProperty.call(src, prop)) {
                                dest[prop] = src[prop];
                            }
                        }
                        return dest;
                    };
                    /* istanbul ignore else */ if (Object.assign) assign = Object.assign;
                    // ### Error functions
                    exports1.SyntaxError = SyntaxError;
                    // XXX: Eliminate this function and change the error type to be different from SyntaxError.
                    // This will unfortunately be a breaking change, because some downstream users depend
                    // on the error thrown being an instance of SyntaxError. For example, the Ace editor:
                    // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>
                    function fixupError(e) {
                        /* istanbul ignore if */ if (!Object.create) return e;
                        return Object.create(e, {
                            'line': {
                                'writable': true,
                                value: e.line
                            },
                            'index': {
                                'writable': true,
                                value: e.index
                            },
                            'column': {
                                'writable': true,
                                value: e.column
                            }
                        });
                    }
                    // #### Raise an exception.
                    //
                    // Raise an exception by passing a token, a string format and its paramters.
                    //
                    // The passed tokens location will automatically be added to the error
                    // message if it exists, if not it will default to the lexers current
                    // position.
                    //
                    // Example:
                    //
                    //     // [1:0] expected [ near (
                    //     raise(token, "expected %1 near %2", '[', token.value);
                    function raise(token) {
                        var message = sprintf.apply(null, slice.call(arguments, 1)), error, col;
                        if (token === null || typeof token.line === 'undefined') {
                            col = index - lineStart + 1;
                            error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));
                            error.index = index;
                            error.line = line;
                            error.column = col;
                        } else {
                            col = token.range[0] - token.lineStart;
                            error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));
                            error.line = token.line;
                            error.index = token.range[0];
                            error.column = col;
                        }
                        throw error;
                    }
                    function tokenValue(token) {
                        var raw = input.slice(token.range[0], token.range[1]);
                        if (raw) return raw;
                        return token.value;
                    }
                    // #### Raise an unexpected token error.
                    //
                    // Example:
                    //
                    //     // expected <name> near '0'
                    //     raiseUnexpectedToken('<name>', token);
                    function raiseUnexpectedToken(type, token) {
                        raise(token, errors.expectedToken, type, tokenValue(token));
                    }
                    // #### Raise a general unexpected error
                    //
                    // Usage should pass either a token object or a symbol string which was
                    // expected. We can also specify a nearby token such as <eof>, this will
                    // default to the currently active token.
                    //
                    // Example:
                    //
                    //     // Unexpected symbol 'end' near '<eof>'
                    //     unexpected(token);
                    //
                    // If there's no token in the buffer it means we have reached <eof>.
                    function unexpected(found) {
                        var near = tokenValue(lookahead);
                        if ('undefined' !== typeof found.type) {
                            var type;
                            switch(found.type){
                                case StringLiteral:
                                    type = 'string';
                                    break;
                                case Keyword:
                                    type = 'keyword';
                                    break;
                                case Identifier:
                                    type = 'identifier';
                                    break;
                                case NumericLiteral:
                                    type = 'number';
                                    break;
                                case Punctuator:
                                    type = 'symbol';
                                    break;
                                case BooleanLiteral:
                                    type = 'boolean';
                                    break;
                                case NilLiteral:
                                    return raise(found, errors.unexpected, 'symbol', 'nil', near);
                                case EOF:
                                    return raise(found, errors.unexpectedEOF);
                            }
                            return raise(found, errors.unexpected, type, tokenValue(found), near);
                        }
                        return raise(found, errors.unexpected, 'symbol', found, near);
                    }
                    // Lexer
                    // -----
                    //
                    // The lexer, or the tokenizer reads the input string character by character
                    // and derives a token left-right. To be as efficient as possible the lexer
                    // prioritizes the common cases such as identifiers. It also works with
                    // character codes instead of characters as string comparisons was the
                    // biggest bottleneck of the parser.
                    //
                    // If `options.comments` is enabled, all comments encountered will be stored
                    // in an array which later will be appended to the chunk object. If disabled,
                    // they will simply be disregarded.
                    //
                    // When the lexer has derived a valid token, it will be returned as an object
                    // containing its value and as well as its position in the input string (this
                    // is always enabled to provide proper debug messages).
                    //
                    // `lex()` starts lexing and returns the following token in the stream.
                    var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;
                    exports1.lex = lex;
                    function lex() {
                        skipWhiteSpace();
                        // Skip comments beginning with --
                        while(45 === input.charCodeAt(index) && 45 === input.charCodeAt(index + 1)){
                            scanComment();
                            skipWhiteSpace();
                        }
                        if (index >= length) return {
                            type: EOF,
                            value: '<eof>',
                            line: line,
                            lineStart: lineStart,
                            range: [
                                index,
                                index
                            ]
                        };
                        var charCode = input.charCodeAt(index), next = input.charCodeAt(index + 1);
                        // Memorize the range index where the token begins.
                        tokenStart = index;
                        if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();
                        switch(charCode){
                            case 39:
                            case 34:
                                return scanStringLiteral();
                            case 48:
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                            case 56:
                            case 57:
                                return scanNumericLiteral();
                            case 46:
                                // If the dot is followed by a digit it's a float.
                                if (isDecDigit(next)) return scanNumericLiteral();
                                if (46 === next) {
                                    if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();
                                    return scanPunctuator('..');
                                }
                                return scanPunctuator('.');
                            case 61:
                                if (61 === next) return scanPunctuator('==');
                                return scanPunctuator('=');
                            case 62:
                                if (features.bitwiseOperators) {
                                    if (62 === next) return scanPunctuator('>>');
                                }
                                if (61 === next) return scanPunctuator('>=');
                                return scanPunctuator('>');
                            case 60:
                                if (features.bitwiseOperators) {
                                    if (60 === next) return scanPunctuator('<<');
                                }
                                if (61 === next) return scanPunctuator('<=');
                                return scanPunctuator('<');
                            case 126:
                                if (61 === next) return scanPunctuator('~=');
                                if (!features.bitwiseOperators) break;
                                return scanPunctuator('~');
                            case 58:
                                if (features.labels) {
                                    if (58 === next) return scanPunctuator('::');
                                }
                                return scanPunctuator(':');
                            case 91:
                                // Check for a multiline string, they begin with [= or [[
                                if (91 === next || 61 === next) return scanLongStringLiteral();
                                return scanPunctuator('[');
                            case 47:
                                // Check for integer division op (//)
                                if (features.integerDivision) {
                                    if (47 === next) return scanPunctuator('//');
                                }
                                return scanPunctuator('/');
                            case 38:
                            case 124:
                                if (!features.bitwiseOperators) break;
                            /* fall through */ case 42:
                            case 94:
                            case 37:
                            case 44:
                            case 123:
                            case 125:
                            case 93:
                            case 40:
                            case 41:
                            case 59:
                            case 35:
                            case 45:
                            case 43:
                                return scanPunctuator(input.charAt(index));
                        }
                        return unexpected(input.charAt(index));
                    }
                    // Whitespace has no semantic meaning in lua so simply skip ahead while
                    // tracking the encounted newlines. Any kind of eol sequence is counted as a
                    // single line.
                    function consumeEOL() {
                        var charCode = input.charCodeAt(index), peekCharCode = input.charCodeAt(index + 1);
                        if (isLineTerminator(charCode)) {
                            // Count \n\r and \r\n as one newline.
                            if (10 === charCode && 13 === peekCharCode) ++index;
                            if (13 === charCode && 10 === peekCharCode) ++index;
                            ++line;
                            lineStart = ++index;
                            return true;
                        }
                        return false;
                    }
                    function skipWhiteSpace() {
                        while(index < length){
                            var charCode = input.charCodeAt(index);
                            if (isWhiteSpace(charCode)) {
                                ++index;
                            } else if (!consumeEOL()) {
                                break;
                            }
                        }
                    }
                    // Identifiers, keywords, booleans and nil all look the same syntax wise. We
                    // simply go through them one by one and defaulting to an identifier if no
                    // previous case matched.
                    function scanIdentifierOrKeyword() {
                        var value, type;
                        // Slicing the input string is prefered before string concatenation in a
                        // loop for performance reasons.
                        while(isIdentifierPart(input.charCodeAt(++index)));
                        value = encodingMode.fixup(input.slice(tokenStart, index));
                        // Decide on the token type and possibly cast the value.
                        if (isKeyword(value)) {
                            type = Keyword;
                        } else if ('true' === value || 'false' === value) {
                            type = BooleanLiteral;
                            value = 'true' === value;
                        } else if ('nil' === value) {
                            type = NilLiteral;
                            value = null;
                        } else {
                            type = Identifier;
                        }
                        return {
                            type: type,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Once a punctuator reaches this function it should already have been
                    // validated so we simply return it as a token.
                    function scanPunctuator(value) {
                        index += value.length;
                        return {
                            type: Punctuator,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // A vararg literal consists of three dots.
                    function scanVarargLiteral() {
                        index += 3;
                        return {
                            type: VarargLiteral,
                            value: '...',
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Find the string literal by matching the delimiter marks used.
                    function scanStringLiteral() {
                        var delimiter = input.charCodeAt(index++), beginLine = line, beginLineStart = lineStart, stringStart = index, string = encodingMode.discardStrings ? null : '', charCode;
                        for(;;){
                            charCode = input.charCodeAt(index++);
                            if (delimiter === charCode) break;
                            // EOF or `\n` terminates a string literal. If we haven't found the
                            // ending delimiter by now, raise an exception.
                            if (index > length || isLineTerminator(charCode)) {
                                string += input.slice(stringStart, index - 1);
                                raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));
                            }
                            if (92 === charCode) {
                                if (!encodingMode.discardStrings) {
                                    var beforeEscape = input.slice(stringStart, index - 1);
                                    string += encodingMode.fixup(beforeEscape);
                                }
                                var escapeValue = readEscapeSequence();
                                if (!encodingMode.discardStrings) string += escapeValue;
                                stringStart = index;
                            }
                        }
                        if (!encodingMode.discardStrings) {
                            string += encodingMode.encodeByte(null);
                            string += encodingMode.fixup(input.slice(stringStart, index - 1));
                        }
                        return {
                            type: StringLiteral,
                            value: string,
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Expect a multiline string literal and return it as a regular string
                    // literal, if it doesn't validate into a valid multiline string, throw an
                    // exception.
                    function scanLongStringLiteral() {
                        var beginLine = line, beginLineStart = lineStart, string = readLongString(false);
                        // Fail if it's not a multiline literal.
                        if (false === string) raise(token, errors.expected, '[', tokenValue(token));
                        return {
                            type: StringLiteral,
                            value: encodingMode.discardStrings ? null : encodingMode.fixup(string),
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Numeric literals will be returned as floating-point numbers instead of
                    // strings. The raw value should be retrieved from slicing the input string
                    // later on in the process.
                    //
                    // If a hexadecimal number is encountered, it will be converted.
                    function scanNumericLiteral() {
                        var character = input.charAt(index), next = input.charAt(index + 1);
                        var literal = '0' === character && 'xX'.indexOf(next || null) >= 0 ? readHexLiteral() : readDecLiteral();
                        var foundImaginaryUnit = readImaginaryUnitSuffix(), foundInt64Suffix = readInt64Suffix();
                        if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {
                            raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        }
                        return {
                            type: NumericLiteral,
                            value: literal.value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    function readImaginaryUnitSuffix() {
                        if (!features.imaginaryNumbers) return;
                        // Imaginary unit number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ('iI'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            return true;
                        } else {
                            return false;
                        }
                    }
                    function readInt64Suffix() {
                        if (!features.integerSuffixes) return;
                        // Int64/uint64 number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ('uU'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                    ++index;
                                    return 'ULL';
                                } else {
                                    // UL but no L
                                    raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                                }
                            } else {
                                // U but no L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                return 'LL';
                            } else {
                                // First L but no second L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        }
                    }
                    // Lua hexadecimals have an optional fraction part and an optional binary
                    // exoponent part. These are not included in JavaScript so we will compute
                    // all three parts separately and then sum them up at the end of the function
                    // with the following algorithm.
                    //
                    //     Digit := toDec(digit)
                    //     Fraction := toDec(fraction) / 16 ^ fractionCount
                    //     BinaryExp := 2 ^ binaryExp
                    //     Number := ( Digit + Fraction ) * BinaryExp
                    function readHexLiteral() {
                        var fraction = 0 // defaults to 0 as it gets summed
                        , binaryExponent = 1 // defaults to 1 as it gets multiplied
                        , binarySign = 1 // positive
                        , digit, fractionStart, exponentStart, digitStart;
                        digitStart = index += 2; // Skip 0x part
                        // A minimum of one hex digit is required.
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        while(isHexDigit(input.charCodeAt(index)))++index;
                        // Convert the hexadecimal digit to base 10.
                        digit = parseInt(input.slice(digitStart, index), 16);
                        // Fraction part is optional.
                        var foundFraction = false;
                        if ('.' === input.charAt(index)) {
                            foundFraction = true;
                            fractionStart = ++index;
                            while(isHexDigit(input.charCodeAt(index)))++index;
                            fraction = input.slice(fractionStart, index);
                            // Empty fraction parts should default to 0, others should be converted
                            // 0.x form so we can use summation at the end.
                            fraction = fractionStart === index ? 0 : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);
                        }
                        // Binary exponents are optional
                        var foundBinaryExponent = false;
                        if ('pP'.indexOf(input.charAt(index) || null) >= 0) {
                            foundBinaryExponent = true;
                            ++index;
                            // Sign part is optional and defaults to 1 (positive).
                            if ('+-'.indexOf(input.charAt(index) || null) >= 0) binarySign = '+' === input.charAt(index++) ? 1 : -1;
                            exponentStart = index;
                            // The binary exponent sign requires a decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                            binaryExponent = input.slice(exponentStart, index);
                            // Calculate the binary exponent of the number.
                            binaryExponent = Math.pow(2, binaryExponent * binarySign);
                        }
                        return {
                            value: (digit + fraction) * binaryExponent,
                            hasFractionPart: foundFraction || foundBinaryExponent
                        };
                    }
                    // Decimal numbers are exactly the same in Lua and in JavaScript, because of
                    // this we check where the token ends and then parse it with native
                    // functions.
                    function readDecLiteral() {
                        while(isDecDigit(input.charCodeAt(index)))++index;
                        // Fraction part is optional
                        var foundFraction = false;
                        if ('.' === input.charAt(index)) {
                            foundFraction = true;
                            ++index;
                            // Fraction part defaults to 0
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        // Exponent part is optional.
                        var foundExponent = false;
                        if ('eE'.indexOf(input.charAt(index) || null) >= 0) {
                            foundExponent = true;
                            ++index;
                            // Sign part is optional.
                            if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;
                            // An exponent is required to contain at least one decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        return {
                            value: parseFloat(input.slice(tokenStart, index)),
                            hasFractionPart: foundFraction || foundExponent
                        };
                    }
                    function readUnicodeEscapeSequence() {
                        var sequenceStart = index++;
                        if (input.charAt(index++) !== '{') raise(null, errors.braceExpected, '{', '\\' + input.slice(sequenceStart, index));
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));
                        while(input.charCodeAt(index) === 0x30)++index;
                        var escStart = index;
                        while(isHexDigit(input.charCodeAt(index))){
                            ++index;
                            if (index - escStart > 6) raise(null, errors.tooLargeCodepoint, '\\' + input.slice(sequenceStart, index));
                        }
                        var b = input.charAt(index++);
                        if (b !== '}') {
                            if (b === '"' || b === "'") raise(null, errors.braceExpected, '}', '\\' + input.slice(sequenceStart, index--));
                            else raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));
                        }
                        var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);
                        var frag = '\\' + input.slice(sequenceStart, index);
                        if (codepoint > 0x10ffff) {
                            raise(null, errors.tooLargeCodepoint, frag);
                        }
                        return encodingMode.encodeUTF8(codepoint, frag);
                    }
                    // Translate escape sequences to the actual characters.
                    function readEscapeSequence() {
                        var sequenceStart = index;
                        switch(input.charAt(index)){
                            // Lua allow the following escape sequences.
                            case 'a':
                                ++index;
                                return '\x07';
                            case 'n':
                                ++index;
                                return '\n';
                            case 'r':
                                ++index;
                                return '\r';
                            case 't':
                                ++index;
                                return '\t';
                            case 'v':
                                ++index;
                                return '\x0b';
                            case 'b':
                                ++index;
                                return '\b';
                            case 'f':
                                ++index;
                                return '\f';
                            // Backslash at the end of the line. We treat all line endings as equivalent,
                            // and as representing the [LF] character (code 10). Lua 5.1 through 5.3
                            // have been verified to behave the same way.
                            case '\r':
                            case '\n':
                                consumeEOL();
                                return '\n';
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                                // \ddd, where ddd is a sequence of up to three decimal digits.
                                while(isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3)++index;
                                var frag = input.slice(sequenceStart, index);
                                var ddd = parseInt(frag, 10);
                                if (ddd > 255) {
                                    raise(null, errors.decimalEscapeTooLarge, '\\' + ddd);
                                }
                                return encodingMode.encodeByte(ddd, '\\' + frag);
                            case 'z':
                                if (features.skipWhitespaceEscape) {
                                    ++index;
                                    skipWhiteSpace();
                                    return '';
                                }
                                break;
                            case 'x':
                                if (features.hexEscapes) {
                                    // \xXX, where XX is a sequence of exactly two hexadecimal digits
                                    if (isHexDigit(input.charCodeAt(index + 1)) && isHexDigit(input.charCodeAt(index + 2))) {
                                        index += 3;
                                        return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\' + input.slice(sequenceStart, index));
                                    }
                                    raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index + 2));
                                }
                                break;
                            case 'u':
                                if (features.unicodeEscapes) return readUnicodeEscapeSequence();
                                break;
                            case '\\':
                            case '"':
                            case "'":
                                return input.charAt(index++);
                        }
                        if (features.strictEscapes) raise(null, errors.invalidEscape, '\\' + input.slice(sequenceStart, index + 1));
                        return input.charAt(index++);
                    }
                    // Comments begin with -- after which it will be decided if they are
                    // multiline comments or not.
                    //
                    // The multiline functionality works the exact same way as with string
                    // literals so we reuse the functionality.
                    function scanComment() {
                        tokenStart = index;
                        index += 2; // --
                        var character = input.charAt(index), content = '', isLong = false, commentStart = index, lineStartComment = lineStart, lineComment = line;
                        if ('[' === character) {
                            content = readLongString(true);
                            // This wasn't a multiline comment after all.
                            if (false === content) content = character;
                            else isLong = true;
                        }
                        // Scan until next line as long as it's not a multiline comment.
                        if (!isLong) {
                            while(index < length){
                                if (isLineTerminator(input.charCodeAt(index))) break;
                                ++index;
                            }
                            if (options.comments) content = input.slice(commentStart, index);
                        }
                        if (options.comments) {
                            var node = ast.comment(content, input.slice(tokenStart, index));
                            // `Marker`s depend on tokens available in the parser and as comments are
                            // intercepted in the lexer all location data is set manually.
                            if (options.locations) {
                                node.loc = {
                                    start: {
                                        line: lineComment,
                                        column: tokenStart - lineStartComment
                                    },
                                    end: {
                                        line: line,
                                        column: index - lineStart
                                    }
                                };
                            }
                            if (options.ranges) {
                                node.range = [
                                    tokenStart,
                                    index
                                ];
                            }
                            if (options.onCreateNode) options.onCreateNode(node);
                            comments.push(node);
                        }
                    }
                    // Read a multiline string by calculating the depth of `=` characters and
                    // then appending until an equal depth is found.
                    function readLongString(isComment) {
                        var level = 0, content = '', terminator = false, character, stringStart, firstLine = line;
                        ++index; // [
                        // Calculate the depth of the comment.
                        while('=' === input.charAt(index + level))++level;
                        // Exit, this is not a long string afterall.
                        if ('[' !== input.charAt(index + level)) return false;
                        index += level + 1;
                        // If the first character is a newline, ignore it and begin on next line.
                        if (isLineTerminator(input.charCodeAt(index))) consumeEOL();
                        stringStart = index;
                        while(index < length){
                            // To keep track of line numbers run the `consumeEOL()` which increments
                            // its counter.
                            while(isLineTerminator(input.charCodeAt(index)))consumeEOL();
                            character = input.charAt(index++);
                            // Once the delimiter is found, iterate through the depth count and see
                            // if it matches.
                            if (']' === character) {
                                terminator = true;
                                for(var i = 0; i < level; ++i){
                                    if ('=' !== input.charAt(index + i)) terminator = false;
                                }
                                if (']' !== input.charAt(index + level)) terminator = false;
                            }
                            // We reached the end of the multiline string. Get out now.
                            if (terminator) {
                                content += input.slice(stringStart, index - 1);
                                index += level + 1;
                                return content;
                            }
                        }
                        raise(null, isComment ? errors.unfinishedLongComment : errors.unfinishedLongString, firstLine, '<eof>');
                    }
                    // ## Lex functions and helpers.
                    // Read the next token.
                    //
                    // This is actually done by setting the current token to the lookahead and
                    // reading in the new lookahead token.
                    function next() {
                        previousToken = token;
                        token = lookahead;
                        lookahead = lex();
                    }
                    // Consume a token if its value matches. Once consumed or not, return the
                    // success of the operation.
                    function consume(value) {
                        if (value === token.value) {
                            next();
                            return true;
                        }
                        return false;
                    }
                    // Expect the next token value to match. If not, throw an exception.
                    function expect(value) {
                        if (value === token.value) next();
                        else raise(token, errors.expected, value, tokenValue(token));
                    }
                    // ### Validation functions
                    function isWhiteSpace(charCode) {
                        return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;
                    }
                    function isLineTerminator(charCode) {
                        return 10 === charCode || 13 === charCode;
                    }
                    function isDecDigit(charCode) {
                        return charCode >= 48 && charCode <= 57;
                    }
                    function isHexDigit(charCode) {
                        return charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70;
                    }
                    // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards
                    // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).
                    // On the other hand, LuaJIT allows arbitrary octets ≥ 128 in identifiers.
                    function isIdentifierStart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    }
                    function isIdentifierPart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode || charCode >= 48 && charCode <= 57) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    }
                    // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)
                    //
                    // `true`, `false` and `nil` will not be considered keywords, but literals.
                    function isKeyword(id) {
                        switch(id.length){
                            case 2:
                                return 'do' === id || 'if' === id || 'in' === id || 'or' === id;
                            case 3:
                                return 'and' === id || 'end' === id || 'for' === id || 'not' === id;
                            case 4:
                                if ('else' === id || 'then' === id) return true;
                                if (features.labels && !features.contextualGoto) return 'goto' === id;
                                return false;
                            case 5:
                                return 'break' === id || 'local' === id || 'until' === id || 'while' === id;
                            case 6:
                                return 'elseif' === id || 'repeat' === id || 'return' === id;
                            case 8:
                                return 'function' === id;
                        }
                        return false;
                    }
                    function isUnary(token) {
                        if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;
                        if (Keyword === token.type) return 'not' === token.value;
                        return false;
                    }
                    // Check if the token syntactically closes a block.
                    function isBlockFollow(token) {
                        if (EOF === token.type) return true;
                        if (Keyword !== token.type) return false;
                        switch(token.value){
                            case 'else':
                            case 'elseif':
                            case 'end':
                            case 'until':
                                return true;
                            default:
                                return false;
                        }
                    }
                    // Scope
                    // -----
                    // Store each block scope as a an array of identifier names. Each scope is
                    // stored in an FILO-array.
                    var scopes, scopeDepth, globals;
                    // Create a new scope inheriting all declarations from the previous scope.
                    function createScope() {
                        var scope = scopes[scopeDepth++].slice();
                        scopes.push(scope);
                        if (options.onCreateScope) options.onCreateScope();
                    }
                    // Exit and remove the current scope.
                    function destroyScope() {
                        var scope = scopes.pop();
                        --scopeDepth;
                        if (options.onDestroyScope) options.onDestroyScope();
                    }
                    // Add identifier name to the current scope if it doesnt already exist.
                    function scopeIdentifierName(name) {
                        if (options.onLocalDeclaration) options.onLocalDeclaration(name);
                        if (-1 !== indexOf(scopes[scopeDepth], name)) return;
                        scopes[scopeDepth].push(name);
                    }
                    // Add identifier to the current scope
                    function scopeIdentifier(node) {
                        scopeIdentifierName(node.name);
                        attachScope(node, true);
                    }
                    // Attach scope information to node. If the node is global, store it in the
                    // globals array so we can return the information to the user.
                    function attachScope(node, isLocal) {
                        if (!isLocal && -1 === indexOfObject(globals, 'name', node.name)) globals.push(node);
                        node.isLocal = isLocal;
                    }
                    // Is the identifier name available in this scope.
                    function scopeHasName(name) {
                        return -1 !== indexOf(scopes[scopeDepth], name);
                    }
                    // Location tracking
                    // -----------------
                    //
                    // Locations are stored in FILO-array as a `Marker` object consisting of both
                    // `loc` and `range` data. Once a `Marker` is popped off the list an end
                    // location is added and the data is attached to a syntax node.
                    var locations = [], trackLocations;
                    function createLocationMarker() {
                        return new Marker(token);
                    }
                    function Marker(token) {
                        if (options.locations) {
                            this.loc = {
                                start: {
                                    line: token.line,
                                    column: token.range[0] - token.lineStart
                                },
                                end: {
                                    line: 0,
                                    column: 0
                                }
                            };
                        }
                        if (options.ranges) this.range = [
                            token.range[0],
                            0
                        ];
                    }
                    // Complete the location data stored in the `Marker` by adding the location
                    // of the *previous token* as an end location.
                    Marker.prototype.complete = function() {
                        if (options.locations) {
                            this.loc.end.line = previousToken.lastLine || previousToken.line;
                            this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);
                        }
                        if (options.ranges) {
                            this.range[1] = previousToken.range[1];
                        }
                    };
                    Marker.prototype.bless = function(node) {
                        if (this.loc) {
                            var loc = this.loc;
                            node.loc = {
                                start: {
                                    line: loc.start.line,
                                    column: loc.start.column
                                },
                                end: {
                                    line: loc.end.line,
                                    column: loc.end.column
                                }
                            };
                        }
                        if (this.range) {
                            node.range = [
                                this.range[0],
                                this.range[1]
                            ];
                        }
                    };
                    // Create a new `Marker` and add it to the FILO-array.
                    function markLocation() {
                        if (trackLocations) locations.push(createLocationMarker());
                    }
                    // Push an arbitrary `Marker` object onto the FILO-array.
                    function pushLocation(marker) {
                        if (trackLocations) locations.push(marker);
                    }
                    // Control flow tracking
                    // ---------------------
                    // A context object that validates loop breaks and `goto`-based control flow.
                    function FullFlowContext() {
                        this.scopes = [];
                        this.pendingGotos = [];
                    }
                    FullFlowContext.prototype.isInLoop = function() {
                        var i = this.scopes.length;
                        while(i-- > 0){
                            if (this.scopes[i].isLoop) return true;
                        }
                        return false;
                    };
                    FullFlowContext.prototype.pushScope = function(isLoop) {
                        var scope = {
                            labels: {},
                            locals: [],
                            deferredGotos: [],
                            isLoop: !!isLoop
                        };
                        this.scopes.push(scope);
                    };
                    FullFlowContext.prototype.popScope = function() {
                        for(var i = 0; i < this.pendingGotos.length; ++i){
                            var theGoto = this.pendingGotos[i];
                            if (theGoto.maxDepth >= this.scopes.length) {
                                if (--theGoto.maxDepth <= 0) raise(theGoto.token, errors.labelNotVisible, theGoto.target);
                            }
                        }
                        this.scopes.pop();
                    };
                    FullFlowContext.prototype.addGoto = function(target, token) {
                        var localCounts = [];
                        for(var i = 0; i < this.scopes.length; ++i){
                            var scope = this.scopes[i];
                            localCounts.push(scope.locals.length);
                            if (Object.prototype.hasOwnProperty.call(scope.labels, target)) return;
                        }
                        this.pendingGotos.push({
                            maxDepth: this.scopes.length,
                            target: target,
                            token: token,
                            localCounts: localCounts
                        });
                    };
                    FullFlowContext.prototype.addLabel = function(name, token) {
                        var scope = this.currentScope();
                        if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {
                            raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);
                        } else {
                            var newGotos = [];
                            for(var i = 0; i < this.pendingGotos.length; ++i){
                                var theGoto = this.pendingGotos[i];
                                if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {
                                    if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {
                                        scope.deferredGotos.push(theGoto);
                                    }
                                    continue;
                                }
                                newGotos.push(theGoto);
                            }
                            this.pendingGotos = newGotos;
                        }
                        scope.labels[name] = {
                            localCount: scope.locals.length,
                            line: token.line
                        };
                    };
                    FullFlowContext.prototype.addLocal = function(name, token) {
                        this.currentScope().locals.push({
                            name: name,
                            token: token
                        });
                    };
                    FullFlowContext.prototype.currentScope = function() {
                        return this.scopes[this.scopes.length - 1];
                    };
                    FullFlowContext.prototype.raiseDeferredErrors = function() {
                        var scope = this.currentScope();
                        var bads = scope.deferredGotos;
                        for(var i = 0; i < bads.length; ++i){
                            var theGoto = bads[i];
                            raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);
                        }
                    // Would be dead code currently, but may be useful later
                    // if (bads.length)
                    //   scope.deferredGotos = [];
                    };
                    // Simplified context that only checks the validity of loop breaks.
                    function LoopFlowContext() {
                        this.level = 0;
                        this.loopLevels = [];
                    }
                    LoopFlowContext.prototype.isInLoop = function() {
                        return !!this.loopLevels.length;
                    };
                    LoopFlowContext.prototype.pushScope = function(isLoop) {
                        ++this.level;
                        if (isLoop) this.loopLevels.push(this.level);
                    };
                    LoopFlowContext.prototype.popScope = function() {
                        var levels = this.loopLevels;
                        var levlen = levels.length;
                        if (levlen) {
                            if (levels[levlen - 1] === this.level) levels.pop();
                        }
                        --this.level;
                    };
                    LoopFlowContext.prototype.addGoto = LoopFlowContext.prototype.addLabel = /* istanbul ignore next */ function() {
                        throw new Error('This should never happen');
                    };
                    LoopFlowContext.prototype.addLocal = LoopFlowContext.prototype.raiseDeferredErrors = function() {};
                    function makeFlowContext() {
                        return features.labels ? new FullFlowContext() : new LoopFlowContext();
                    }
                    // Parse functions
                    // ---------------
                    // Chunk is the main program object. Syntactically it's the same as a block.
                    //
                    //     chunk ::= block
                    function parseChunk() {
                        next();
                        markLocation();
                        if (options.scope) createScope();
                        var flowContext = makeFlowContext();
                        flowContext.allowVararg = true;
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        if (EOF !== token.type) unexpected(token);
                        // If the body is empty no previousToken exists when finishNode runs.
                        if (trackLocations && !body.length) previousToken = token;
                        return finishNode(ast.chunk(body));
                    }
                    // A block contains a list of statements with an optional return statement
                    // as its last statement.
                    //
                    //     block ::= {stat} [retstat]
                    function parseBlock(flowContext) {
                        var block = [], statement;
                        while(!isBlockFollow(token)){
                            // Return has to be the last statement in a block.
                            // Likewise 'break' in Lua older than 5.2
                            if ('return' === token.value || !features.relaxedBreak && 'break' === token.value) {
                                block.push(parseStatement(flowContext));
                                break;
                            }
                            statement = parseStatement(flowContext);
                            consume(';');
                            // Statements are only added if they are returned, this allows us to
                            // ignore some statements, such as EmptyStatement.
                            if (statement) block.push(statement);
                        }
                        // Doesn't really need an ast node
                        return block;
                    }
                    // There are two types of statements, simple and compound.
                    //
                    //     statement ::= break | goto | do | while | repeat | return
                    //          | if | for | function | local | label | assignment
                    //          | functioncall | ';'
                    function parseStatement(flowContext) {
                        markLocation();
                        if (Punctuator === token.type) {
                            if (consume('::')) return parseLabelStatement(flowContext);
                        }
                        // When a `;` is encounted, simply eat it without storing it.
                        if (features.emptyStatement) {
                            if (consume(';')) {
                                if (trackLocations) locations.pop();
                                return;
                            }
                        }
                        flowContext.raiseDeferredErrors();
                        if (Keyword === token.type) {
                            switch(token.value){
                                case 'local':
                                    next();
                                    return parseLocalStatement(flowContext);
                                case 'if':
                                    next();
                                    return parseIfStatement(flowContext);
                                case 'return':
                                    next();
                                    return parseReturnStatement(flowContext);
                                case 'function':
                                    next();
                                    var name = parseFunctionName();
                                    return parseFunctionDeclaration(name);
                                case 'while':
                                    next();
                                    return parseWhileStatement(flowContext);
                                case 'for':
                                    next();
                                    return parseForStatement(flowContext);
                                case 'repeat':
                                    next();
                                    return parseRepeatStatement(flowContext);
                                case 'break':
                                    next();
                                    if (!flowContext.isInLoop()) raise(token, errors.noLoopToBreak, token.value);
                                    return parseBreakStatement();
                                case 'do':
                                    next();
                                    return parseDoStatement(flowContext);
                                case 'goto':
                                    next();
                                    return parseGotoStatement(flowContext);
                            }
                        }
                        if (features.contextualGoto && token.type === Identifier && token.value === 'goto' && lookahead.type === Identifier && lookahead.value !== 'goto') {
                            next();
                            return parseGotoStatement(flowContext);
                        }
                        // Assignments memorizes the location and pushes it manually for wrapper nodes.
                        if (trackLocations) locations.pop();
                        return parseAssignmentOrCallStatement(flowContext);
                    }
                    // ## Statements
                    //     label ::= '::' Name '::'
                    function parseLabelStatement(flowContext) {
                        var nameToken = token, label = parseIdentifier();
                        if (options.scope) {
                            scopeIdentifierName('::' + nameToken.value + '::');
                            attachScope(label, true);
                        }
                        expect('::');
                        flowContext.addLabel(nameToken.value, nameToken);
                        return finishNode(ast.labelStatement(label));
                    }
                    //     break ::= 'break'
                    function parseBreakStatement() {
                        return finishNode(ast.breakStatement());
                    }
                    //     goto ::= 'goto' Name
                    function parseGotoStatement(flowContext) {
                        var name = token.value, gotoToken = previousToken, label = parseIdentifier();
                        flowContext.addGoto(name, gotoToken);
                        return finishNode(ast.gotoStatement(label));
                    }
                    //     do ::= 'do' block 'end'
                    function parseDoStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect('end');
                        return finishNode(ast.doStatement(body));
                    }
                    //     while ::= 'while' exp 'do' block 'end'
                    function parseWhileStatement(flowContext) {
                        var condition = parseExpectedExpression(flowContext);
                        expect('do');
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect('end');
                        return finishNode(ast.whileStatement(condition, body));
                    }
                    //     repeat ::= 'repeat' block 'until' exp
                    function parseRepeatStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        expect('until');
                        flowContext.raiseDeferredErrors();
                        var condition = parseExpectedExpression(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        return finishNode(ast.repeatStatement(condition, body));
                    }
                    //     retstat ::= 'return' [exp {',' exp}] [';']
                    function parseReturnStatement(flowContext) {
                        var expressions = [];
                        if ('end' !== token.value) {
                            var expression = parseExpression(flowContext);
                            if (null != expression) expressions.push(expression);
                            while(consume(',')){
                                expression = parseExpectedExpression(flowContext);
                                expressions.push(expression);
                            }
                            consume(';'); // grammar tells us ; is optional here.
                        }
                        return finishNode(ast.returnStatement(expressions));
                    }
                    //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'
                    //     elif ::= 'elseif' exp 'then' block
                    function parseIfStatement(flowContext) {
                        var clauses = [], condition, body, marker;
                        // IfClauses begin at the same location as the parent IfStatement.
                        // It ends at the start of `end`, `else`, or `elseif`.
                        if (trackLocations) {
                            marker = locations[locations.length - 1];
                            locations.push(marker);
                        }
                        condition = parseExpectedExpression(flowContext);
                        expect('then');
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        clauses.push(finishNode(ast.ifClause(condition, body)));
                        if (trackLocations) marker = createLocationMarker();
                        while(consume('elseif')){
                            pushLocation(marker);
                            condition = parseExpectedExpression(flowContext);
                            expect('then');
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseifClause(condition, body)));
                            if (trackLocations) marker = createLocationMarker();
                        }
                        if (consume('else')) {
                            // Include the `else` in the location of ElseClause.
                            if (trackLocations) {
                                marker = new Marker(previousToken);
                                locations.push(marker);
                            }
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseClause(body)));
                        }
                        expect('end');
                        return finishNode(ast.ifStatement(clauses));
                    }
                    // There are two types of for statements, generic and numeric.
                    //
                    //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'
                    //     for ::= namelist 'in' explist 'do' block 'end'
                    //     namelist ::= Name {',' Name}
                    //     explist ::= exp {',' exp}
                    function parseForStatement(flowContext) {
                        var variable = parseIdentifier(), body;
                        // The start-identifier is local.
                        if (options.scope) {
                            createScope();
                            scopeIdentifier(variable);
                        }
                        // If the first expression is followed by a `=` punctuator, this is a
                        // Numeric For Statement.
                        if (consume('=')) {
                            // Start expression
                            var start = parseExpectedExpression(flowContext);
                            expect(',');
                            // End expression
                            var end = parseExpectedExpression(flowContext);
                            // Optional step expression
                            var step = consume(',') ? parseExpectedExpression(flowContext) : null;
                            expect('do');
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect('end');
                            if (options.scope) destroyScope();
                            return finishNode(ast.forNumericStatement(variable, start, end, step, body));
                        } else {
                            // The namelist can contain one or more identifiers.
                            var variables = [
                                variable
                            ];
                            while(consume(',')){
                                variable = parseIdentifier();
                                // Each variable in the namelist is locally scoped.
                                if (options.scope) scopeIdentifier(variable);
                                variables.push(variable);
                            }
                            expect('in');
                            var iterators = [];
                            // One or more expressions in the explist.
                            do {
                                var expression = parseExpectedExpression(flowContext);
                                iterators.push(expression);
                            }while (consume(','))
                            expect('do');
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect('end');
                            if (options.scope) destroyScope();
                            return finishNode(ast.forGenericStatement(variables, iterators, body));
                        }
                    }
                    // Local statements can either be variable assignments or function
                    // definitions. If a function definition is found, it will be delegated to
                    // `parseFunctionDeclaration()` with the isLocal flag.
                    //
                    // This AST structure might change into a local assignment with a function
                    // child.
                    //
                    //     local ::= 'local' 'function' Name funcdecl
                    //        | 'local' Name {',' Name} ['=' exp {',' exp}]
                    function parseLocalStatement(flowContext) {
                        var name, declToken = previousToken;
                        if (Identifier === token.type) {
                            var variables = [], init = [];
                            do {
                                name = parseIdentifier();
                                variables.push(name);
                                flowContext.addLocal(name.name, declToken);
                            }while (consume(','))
                            if (consume('=')) {
                                do {
                                    var expression = parseExpectedExpression(flowContext);
                                    init.push(expression);
                                }while (consume(','))
                            }
                            // Declarations doesn't exist before the statement has been evaluated.
                            // Therefore assignments can't use their declarator. And the identifiers
                            // shouldn't be added to the scope until the statement is complete.
                            if (options.scope) {
                                for(var i = 0, l = variables.length; i < l; ++i){
                                    scopeIdentifier(variables[i]);
                                }
                            }
                            return finishNode(ast.localStatement(variables, init));
                        }
                        if (consume('function')) {
                            name = parseIdentifier();
                            flowContext.addLocal(name.name, declToken);
                            if (options.scope) {
                                scopeIdentifier(name);
                                createScope();
                            }
                            // MemberExpressions are not allowed in local function statements.
                            return parseFunctionDeclaration(name, true);
                        } else {
                            raiseUnexpectedToken('<name>', token);
                        }
                    }
                    //     assignment ::= varlist '=' explist
                    //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name
                    //     varlist ::= var {',' var}
                    //     explist ::= exp {',' exp}
                    //
                    //     call ::= callexp
                    //     callexp ::= prefixexp args | prefixexp ':' Name args
                    function parseAssignmentOrCallStatement(flowContext) {
                        // Keep a reference to the previous token for better error messages in case
                        // of invalid statement
                        var previous = token, marker, startMarker;
                        var lvalue, base, name;
                        var targets = [];
                        if (trackLocations) startMarker = createLocationMarker();
                        do {
                            if (trackLocations) marker = createLocationMarker();
                            if (Identifier === token.type) {
                                name = token.value;
                                base = parseIdentifier();
                                // Set the parent scope.
                                if (options.scope) attachScope(base, scopeHasName(name));
                                lvalue = true;
                            } else if ('(' === token.value) {
                                next();
                                base = parseExpectedExpression(flowContext);
                                expect(')');
                                lvalue = false;
                            } else {
                                return unexpected(token);
                            }
                            both: for(;;){
                                var newBase;
                                switch(StringLiteral === token.type ? '"' : token.value){
                                    case '.':
                                    case '[':
                                        lvalue = true;
                                        break;
                                    case ':':
                                    case '(':
                                    case '{':
                                    case '"':
                                        lvalue = null;
                                        break;
                                    default:
                                        break both;
                                }
                                base = parsePrefixExpressionPart(base, marker, flowContext);
                            }
                            targets.push(base);
                            if (',' !== token.value) break;
                            if (!lvalue) {
                                return unexpected(token);
                            }
                            next();
                        }while (true)
                        if (targets.length === 1 && lvalue === null) {
                            pushLocation(marker);
                            return finishNode(ast.callStatement(targets[0]));
                        } else if (!lvalue) {
                            return unexpected(token);
                        }
                        expect('=');
                        var values = [];
                        do {
                            values.push(parseExpectedExpression(flowContext));
                        }while (consume(','))
                        pushLocation(startMarker);
                        return finishNode(ast.assignmentStatement(targets, values));
                    }
                    // ### Non-statements
                    //     Identifier ::= Name
                    function parseIdentifier() {
                        markLocation();
                        var identifier = token.value;
                        if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);
                        next();
                        return finishNode(ast.identifier(identifier));
                    }
                    // Parse the functions parameters and body block. The name should already
                    // have been parsed and passed to this declaration function. By separating
                    // this we allow for anonymous functions in expressions.
                    //
                    // For local functions there's a boolean parameter which needs to be set
                    // when parsing the declaration.
                    //
                    //     funcdecl ::= '(' [parlist] ')' block 'end'
                    //     parlist ::= Name {',' Name} | [',' '...'] | '...'
                    function parseFunctionDeclaration(name, isLocal) {
                        var flowContext = makeFlowContext();
                        flowContext.pushScope();
                        var parameters = [];
                        expect('(');
                        // The declaration has arguments
                        if (!consume(')')) {
                            // Arguments are a comma separated list of identifiers, optionally ending
                            // with a vararg.
                            while(true){
                                if (Identifier === token.type) {
                                    var parameter = parseIdentifier();
                                    // Function parameters are local.
                                    if (options.scope) scopeIdentifier(parameter);
                                    parameters.push(parameter);
                                    if (consume(',')) continue;
                                } else if (VarargLiteral === token.type) {
                                    flowContext.allowVararg = true;
                                    parameters.push(parsePrimaryExpression(flowContext));
                                } else {
                                    raiseUnexpectedToken('<name> or \'...\'', token);
                                }
                                expect(')');
                                break;
                            }
                        }
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        expect('end');
                        if (options.scope) destroyScope();
                        isLocal = isLocal || false;
                        return finishNode(ast.functionStatement(name, parameters, isLocal, body));
                    }
                    // Parse the function name as identifiers and member expressions.
                    //
                    //     Name {'.' Name} [':' Name]
                    function parseFunctionName() {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        base = parseIdentifier();
                        if (options.scope) {
                            attachScope(base, scopeHasName(base.name));
                            createScope();
                        }
                        while(consume('.')){
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, '.', name));
                        }
                        if (consume(':')) {
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, ':', name));
                            if (options.scope) scopeIdentifierName('self');
                        }
                        return base;
                    }
                    //     tableconstructor ::= '{' [fieldlist] '}'
                    //     fieldlist ::= field {fieldsep field} fieldsep
                    //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp
                    //
                    //     fieldsep ::= ',' | ';'
                    function parseTableConstructor(flowContext) {
                        var fields = [], key, value;
                        while(true){
                            markLocation();
                            if (Punctuator === token.type && consume('[')) {
                                key = parseExpectedExpression(flowContext);
                                expect(']');
                                expect('=');
                                value = parseExpectedExpression(flowContext);
                                fields.push(finishNode(ast.tableKey(key, value)));
                            } else if (Identifier === token.type) {
                                if ('=' === lookahead.value) {
                                    key = parseIdentifier();
                                    next();
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableKeyString(key, value)));
                                } else {
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableValue(value)));
                                }
                            } else {
                                if (null == (value = parseExpression(flowContext))) {
                                    locations.pop();
                                    break;
                                }
                                fields.push(finishNode(ast.tableValue(value)));
                            }
                            if (',;'.indexOf(token.value) >= 0) {
                                next();
                                continue;
                            }
                            break;
                        }
                        expect('}');
                        return finishNode(ast.tableConstructorExpression(fields));
                    }
                    // Expression parser
                    // -----------------
                    //
                    // Expressions are evaluated and always return a value. If nothing is
                    // matched null will be returned.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    //
                    //     primary ::= nil | false | true | Number | String | '...'
                    //          | functiondef | tableconstructor
                    //
                    //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'
                    //          | '.' Name | ':' Name args | args }
                    //
                    function parseExpression(flowContext) {
                        var expression = parseSubExpression(0, flowContext);
                        return expression;
                    }
                    // Parse an expression expecting it to be valid.
                    function parseExpectedExpression(flowContext) {
                        var expression = parseExpression(flowContext);
                        if (null == expression) raiseUnexpectedToken('<expression>', token);
                        else return expression;
                    }
                    // Return the precedence priority of the operator.
                    //
                    // As unary `-` can't be distinguished from binary `-`, unary precedence
                    // isn't described in this table but in `parseSubExpression()` itself.
                    //
                    // As this function gets hit on every expression it's been optimized due to
                    // the expensive CompareICStub which took ~8% of the parse time.
                    function binaryPrecedence(operator) {
                        var charCode = operator.charCodeAt(0), length = operator.length;
                        if (1 === length) {
                            switch(charCode){
                                case 94:
                                    return 12; // ^
                                case 42:
                                case 47:
                                case 37:
                                    return 10; // * / %
                                case 43:
                                case 45:
                                    return 9; // + -
                                case 38:
                                    return 6; // &
                                case 126:
                                    return 5; // ~
                                case 124:
                                    return 4; // |
                                case 60:
                                case 62:
                                    return 3; // < >
                            }
                        } else if (2 === length) {
                            switch(charCode){
                                case 47:
                                    return 10; // //
                                case 46:
                                    return 8; // ..
                                case 60:
                                case 62:
                                    if ('<<' === operator || '>>' === operator) return 7; // << >>
                                    return 3; // <= >=
                                case 61:
                                case 126:
                                    return 3; // == ~=
                                case 111:
                                    return 1; // or
                            }
                        } else if (97 === charCode && 'and' === operator) return 2;
                        return 0;
                    }
                    // Implement an operator-precedence parser to handle binary operator
                    // precedence.
                    //
                    // We use this algorithm because it's compact, it's fast and Lua core uses
                    // the same so we can be sure our expressions are parsed in the same manner
                    // without excessive amounts of tests.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    function parseSubExpression(minPrecedence, flowContext) {
                        var operator = token.value, expression, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // UnaryExpression
                        if (isUnary(token)) {
                            markLocation();
                            next();
                            var argument = parseSubExpression(10, flowContext);
                            if (argument == null) raiseUnexpectedToken('<expression>', token);
                            expression = finishNode(ast.unaryExpression(operator, argument));
                        }
                        if (null == expression) {
                            // PrimaryExpression
                            expression = parsePrimaryExpression(flowContext);
                            // PrefixExpression
                            if (null == expression) {
                                expression = parsePrefixExpression(flowContext);
                            }
                        }
                        // This is not a valid left hand expression.
                        if (null == expression) return null;
                        var precedence;
                        while(true){
                            operator = token.value;
                            precedence = Punctuator === token.type || Keyword === token.type ? binaryPrecedence(operator) : 0;
                            if (precedence === 0 || precedence <= minPrecedence) break;
                            // Right-hand precedence operators
                            if ('^' === operator || '..' === operator) --precedence;
                            next();
                            var right = parseSubExpression(precedence, flowContext);
                            if (null == right) raiseUnexpectedToken('<expression>', token);
                            // Push in the marker created before the loop to wrap its entirety.
                            if (trackLocations) locations.push(marker);
                            expression = finishNode(ast.binaryExpression(operator, expression, right));
                        }
                        return expression;
                    }
                    //     prefixexp ::= prefix {suffix}
                    //     prefix ::= Name | '(' exp ')'
                    //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args
                    //
                    //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parsePrefixExpressionPart(base, marker, flowContext) {
                        var expression, identifier;
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case '[':
                                    pushLocation(marker);
                                    next();
                                    expression = parseExpectedExpression(flowContext);
                                    expect(']');
                                    return finishNode(ast.indexExpression(base, expression));
                                case '.':
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    return finishNode(ast.memberExpression(base, '.', identifier));
                                case ':':
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    base = finishNode(ast.memberExpression(base, ':', identifier));
                                    // Once a : is found, this has to be a CallExpression, otherwise
                                    // throw an error.
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                                case '(':
                                case '{':
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                            }
                        } else if (StringLiteral === token.type) {
                            pushLocation(marker);
                            return parseCallExpression(base, flowContext);
                        }
                        return null;
                    }
                    function parsePrefixExpression(flowContext) {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // The prefix
                        if (Identifier === token.type) {
                            name = token.value;
                            base = parseIdentifier();
                            // Set the parent scope.
                            if (options.scope) attachScope(base, scopeHasName(name));
                        } else if (consume('(')) {
                            base = parseExpectedExpression(flowContext);
                            expect(')');
                        } else {
                            return null;
                        }
                        // The suffix
                        for(;;){
                            var newBase = parsePrefixExpressionPart(base, marker, flowContext);
                            if (newBase === null) break;
                            base = newBase;
                        }
                        return base;
                    }
                    //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parseCallExpression(base, flowContext) {
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case '(':
                                    if (!features.emptyStatement) {
                                        if (token.line !== previousToken.line) raise(null, errors.ambiguousSyntax, token.value);
                                    }
                                    next();
                                    // List of expressions
                                    var expressions = [];
                                    var expression = parseExpression(flowContext);
                                    if (null != expression) expressions.push(expression);
                                    while(consume(',')){
                                        expression = parseExpectedExpression(flowContext);
                                        expressions.push(expression);
                                    }
                                    expect(')');
                                    return finishNode(ast.callExpression(base, expressions));
                                case '{':
                                    markLocation();
                                    next();
                                    var table = parseTableConstructor(flowContext);
                                    return finishNode(ast.tableCallExpression(base, table));
                            }
                        } else if (StringLiteral === token.type) {
                            return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));
                        }
                        raiseUnexpectedToken('function arguments', token);
                    }
                    //     primary ::= String | Numeric | nil | true | false
                    //          | functiondef | tableconstructor | '...'
                    function parsePrimaryExpression(flowContext) {
                        var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral, value = token.value, type = token.type, marker;
                        if (trackLocations) marker = createLocationMarker();
                        if (type === VarargLiteral && !flowContext.allowVararg) {
                            raise(token, errors.cannotUseVararg, token.value);
                        }
                        if (type & literals) {
                            pushLocation(marker);
                            var raw = input.slice(token.range[0], token.range[1]);
                            next();
                            return finishNode(ast.literal(type, value, raw));
                        } else if (Keyword === type && 'function' === value) {
                            pushLocation(marker);
                            next();
                            if (options.scope) createScope();
                            return parseFunctionDeclaration(null);
                        } else if (consume('{')) {
                            pushLocation(marker);
                            return parseTableConstructor(flowContext);
                        }
                    }
                    // Parser
                    // ------
                    // Export the main parser.
                    //
                    //   - `wait` Hold parsing until end() is called. Defaults to false
                    //   - `comments` Store comments. Defaults to true.
                    //   - `scope` Track identifier scope. Defaults to false.
                    //   - `locations` Store location information. Defaults to false.
                    //   - `ranges` Store the start and end character locations. Defaults to
                    //     false.
                    //   - `onCreateNode` Callback which will be invoked when a syntax node is
                    //     created.
                    //   - `onCreateScope` Callback which will be invoked when a new scope is
                    //     created.
                    //   - `onDestroyScope` Callback which will be invoked when the current scope
                    //     is destroyed.
                    //
                    // Example:
                    //
                    //     var parser = require('luaparser');
                    //     parser.parse('i = 0');
                    exports1.parse = parse;
                    var versionFeatures = {
                        '5.1': {},
                        '5.2': {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            relaxedBreak: true
                        },
                        '5.3': {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            bitwiseOperators: true,
                            integerDivision: true,
                            relaxedBreak: true
                        },
                        'LuaJIT': {
                            // XXX: LuaJIT language features may depend on compilation options; may need to
                            // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT
                            // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?
                            labels: true,
                            contextualGoto: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            imaginaryNumbers: true,
                            integerSuffixes: true
                        }
                    };
                    function parse(_input, _options) {
                        if ('undefined' === typeof _options && 'object' === typeof _input) {
                            _options = _input;
                            _input = undefined;
                        }
                        if (!_options) _options = {};
                        input = _input || '';
                        options = assign({}, defaultOptions, _options);
                        // Rewind the lexer
                        index = 0;
                        line = 1;
                        lineStart = 0;
                        length = input.length;
                        // When tracking identifier scope, initialize with an empty scope.
                        scopes = [
                            []
                        ];
                        scopeDepth = 0;
                        globals = [];
                        locations = [];
                        if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {
                            throw new Error(sprintf("Lua version '%1' not supported", options.luaVersion));
                        }
                        features = assign({}, versionFeatures[options.luaVersion]);
                        if (options.extendedIdentifiers !== void 0) features.extendedIdentifiers = !!options.extendedIdentifiers;
                        if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {
                            throw new Error(sprintf("Encoding mode '%1' not supported", options.encodingMode));
                        }
                        encodingMode = encodingModes[options.encodingMode];
                        if (options.comments) comments = [];
                        if (!options.wait) return end();
                        return exports1;
                    }
                    // Write to the source code buffer without beginning the parse.
                    exports1.write = write;
                    function write(_input) {
                        input += String(_input);
                        length = input.length;
                        return exports1;
                    }
                    // Send an EOF and begin parsing.
                    exports1.end = end;
                    function end(_input) {
                        if ('undefined' !== typeof _input) write(_input);
                        // Ignore shebangs.
                        if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function(line) {
                            return line.replace(/./g, ' ');
                        });
                        length = input.length;
                        trackLocations = options.locations || options.ranges;
                        // Initialize with a lookahead token.
                        lookahead = lex();
                        var chunk = parseChunk();
                        if (options.comments) chunk.comments = comments;
                        if (options.scope) chunk.globals = globals;
                        /* istanbul ignore if */ if (locations.length > 0) throw new Error('Location tracking failed. This is most likely a bug in luaparse');
                        return chunk;
                    }
                });
            /* vim: set sw=2 ts=2 et tw=79 : */ /***/ },
            /***/ 2372: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 5968: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_302164__)=>{
                "use strict";
                var define1 = __nested_webpack_require_302164__(1857);
                var callBind = __nested_webpack_require_302164__(8498);
                var implementation = __nested_webpack_require_302164__(2372);
                var getPolyfill = __nested_webpack_require_302164__(1937);
                var shim = __nested_webpack_require_302164__(5087);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1937: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_302892__)=>{
                "use strict";
                var implementation = __nested_webpack_require_302892__(2372);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 5087: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_303264__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_303264__(1937);
                var define1 = __nested_webpack_require_303264__(1857);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 8160: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_303952__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_303952__(968); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 9228: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_309921__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_309921__(968);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_309921__(8160);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 968: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 9907: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 6108: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_320285__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_320285__(528);
                var define1 = __nested_webpack_require_320285__(686);
                var hasDescriptors = __nested_webpack_require_320285__(7239)();
                var gOPD = __nested_webpack_require_320285__(9336);
                var $TypeError = __nested_webpack_require_320285__(3468);
                var $floor = GetIntrinsic('%Math.floor%');
                /** @type {import('.')} */ module1.exports = function setFunctionLength(fn, length) {
                    if (typeof fn !== 'function') {
                        throw new $TypeError('`fn` is not a function');
                    }
                    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
                        throw new $TypeError('`length` must be a positive 32-bit integer');
                    }
                    var loose = arguments.length > 2 && !!arguments[2];
                    var functionLengthIsConfigurable = true;
                    var functionLengthIsWritable = true;
                    if ('length' in fn && gOPD) {
                        var desc = gOPD(fn, 'length');
                        if (desc && !desc.configurable) {
                            functionLengthIsConfigurable = false;
                        }
                        if (desc && !desc.writable) {
                            functionLengthIsWritable = false;
                        }
                    }
                    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                        if (hasDescriptors) {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length, true, true);
                        } else {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length);
                        }
                    }
                    return fn;
                };
            /***/ },
            /***/ 2125: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_322359__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_322359__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_322359__(5501);
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_322359__.n(vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__);
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_322359__(7770);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_322359__(8041);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, document1.text);
                    }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    renameDocument(document1, newDocumentUri) {
                        this.documents[newDocumentUri] = this.documents[document1.uri];
                        this.options[newDocumentUri] = this.options[document1.uri];
                        this.removeDocument(document1);
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setWorkspace(workspaceUri) {
                        this.workspaceUri = workspaceUri;
                    }
                    setOptions(documentUri, options, merge = false) {
                        this.options[documentUri] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_2__ /* .mergeObjects */ .rL)(options, this.options[documentUri]) : options;
                    }
                    getOption(documentUri, optionName) {
                        if (this.options[documentUri] && this.options[documentUri][optionName]) {
                            return this.options[documentUri][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    getSemanticTokens(document1, range) {
                        return Promise.resolve(null);
                    }
                    dispose() {
                        return Promise.resolve();
                    }
                    closeConnection() {
                        return Promise.resolve();
                    }
                    getCodeActions(document1, range, context) {
                        return Promise.resolve(null);
                    }
                    executeCommand(command, args) {
                        return Promise.resolve(null);
                    }
                    sendAppliedResult(result, callbackId) {}
                    constructor(mode, workspaceUri){
                        _define_property(this, "serviceName", void 0);
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        _define_property(this, "workspaceUri", void 0);
                        _define_property(this, "clientCapabilities", {
                            textDocument: {
                                diagnostic: {
                                    dynamicRegistration: true,
                                    relatedDocumentSupport: true
                                },
                                publishDiagnostics: {
                                    relatedInformation: true,
                                    versionSupport: false,
                                    tagSupport: {
                                        valueSet: [
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Unnecessary,
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Deprecated
                                        ]
                                    }
                                },
                                hover: {
                                    dynamicRegistration: true,
                                    contentFormat: [
                                        'markdown',
                                        'plaintext'
                                    ]
                                },
                                synchronization: {
                                    dynamicRegistration: true,
                                    willSave: false,
                                    didSave: false,
                                    willSaveWaitUntil: false
                                },
                                formatting: {
                                    dynamicRegistration: true
                                },
                                completion: {
                                    dynamicRegistration: true,
                                    completionItem: {
                                        snippetSupport: true,
                                        commitCharactersSupport: false,
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        deprecatedSupport: false,
                                        preselectSupport: false
                                    },
                                    contextSupport: false
                                },
                                signatureHelp: {
                                    signatureInformation: {
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        activeParameterSupport: true
                                    }
                                },
                                documentHighlight: {
                                    dynamicRegistration: true
                                },
                                semanticTokens: {
                                    multilineTokenSupport: false,
                                    overlappingTokenSupport: false,
                                    tokenTypes: [],
                                    tokenModifiers: [],
                                    formats: [
                                        "relative"
                                    ],
                                    requests: {
                                        full: {
                                            delta: false
                                        },
                                        range: true
                                    },
                                    augmentsSyntaxTokens: true
                                },
                                codeAction: {
                                    dynamicRegistration: true
                                }
                            },
                            workspace: {
                                didChangeConfiguration: {
                                    dynamicRegistration: true
                                },
                                executeCommand: {
                                    dynamicRegistration: true
                                },
                                applyEdit: true,
                                workspaceEdit: {
                                    failureHandling: "abort",
                                    normalizesLineEndings: false,
                                    documentChanges: false
                                }
                            }
                        });
                        this.mode = mode;
                        this.workspaceUri = workspaceUri;
                    }
                }
            /***/ },
            /***/ 7770: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_336001__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_336001__.d(__nested_webpack_exports__, {
                    /* harmony export */ Tk: ()=>/* binding */ checkValueAgainstRegexpArray,
                    /* harmony export */ rL: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, mergeRanges, convertToUri */ function mergeObjects(obj1, obj2, excludeUndefined = false) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    if (excludeUndefined) {
                        obj1 = excludeUndefinedValues(obj1);
                        obj2 = excludeUndefinedValues(obj2);
                    }
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function excludeUndefinedValues(obj) {
                    const filteredEntries = Object.entries(obj).filter(([_, value])=>value !== undefined);
                    return Object.fromEntries(filteredEntries);
                }
                function notEmpty1(value) {
                    return value !== null && value !== undefined;
                }
                //taken with small changes from ace-code
                function mergeRanges1(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
                function convertToUri(filePath) {
                    //already URI
                    if (filePath.startsWith("file:///")) {
                        return filePath;
                    }
                    return URI.file(filePath).toString();
                }
            /***/ },
            /***/ 5272: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 1531: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_340389__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_340389__(5387);
                var isGeneratorFunction = __nested_webpack_require_340389__(2625);
                var whichTypedArray = __nested_webpack_require_340389__(2730);
                var isTypedArray = __nested_webpack_require_340389__(5943);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 6827: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_352866__)=>{
                /* provided dependency */ var process = __nested_webpack_require_352866__(9907);
                /* provided dependency */ var console = __nested_webpack_require_352866__(4364);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_352866__(1531);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_352866__(5272);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_352866__(5615);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 9208: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_384464__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_384464__(9110);
            /***/ },
            /***/ 9110: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_385023__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_385023__(3312);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_385023__(7672);
                __exportStar(__nested_webpack_require_385023__(7672), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3312: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_389438__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_389438__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_389438__(7672);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 7672: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_397817__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_397817__(7162);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_397817__(1109);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_397817__(8844);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_397817__(2479);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_397817__(6957);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_397817__(3489);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_397817__(656);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_397817__(9036);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_397817__(9805);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_397817__(4054);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_397817__(5091);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 6957: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_415881__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_415881__(5091);
                const Is = __nested_webpack_require_415881__(6618);
                const events_1 = __nested_webpack_require_415881__(2479);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 4054: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_420815__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_420815__(5091);
                const Is = __nested_webpack_require_420815__(6618);
                const messages_1 = __nested_webpack_require_420815__(7162);
                const linkedMap_1 = __nested_webpack_require_420815__(1109);
                const events_1 = __nested_webpack_require_420815__(2479);
                const cancellation_1 = __nested_webpack_require_420815__(6957);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy = exports1.MessageStrategy || (exports1.MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8844: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            /***/ },
            /***/ 2479: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_491907__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_491907__(5091);
                var Event;
                (function(Event) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event.None = function() {
                        return _disposable;
                    };
                })(Event = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 6618: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 1109: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 9805: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 656: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_527599__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_527599__(5091);
                const Is = __nested_webpack_require_527599__(6618);
                const events_1 = __nested_webpack_require_527599__(2479);
                const semaphore_1 = __nested_webpack_require_527599__(418);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders(true);
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('content-length');
                                if (!contentLength) {
                                    this.fireError(new Error('Header must provide a Content-Length property.'));
                                    return;
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    this.fireError(new Error('Content-Length value must be a number.'));
                                    return;
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            // Make sure that we convert one received message after the
                            // other. Otherwise it could happen that a decoding of a second
                            // smaller message finished before the decoding of a first larger
                            // message and then we would deliver the second message first.
                            this.readSemaphore.lock(async ()=>{
                                const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                this.callback(message);
                            }).catch((error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 9036: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_538860__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_538860__(5091);
                const Is = __nested_webpack_require_538860__(6618);
                const semaphore_1 = __nested_webpack_require_538860__(418);
                const events_1 = __nested_webpack_require_538860__(2479);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 7162: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_545745__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_545745__(6618);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            /***/ },
            /***/ 5091: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 418: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_561252__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_561252__(5091);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 3489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_564695__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_564695__(6957);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 5501: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_568600__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_568600__(9208);
                __exportStar(__nested_webpack_require_568600__(9208), exports1);
                __exportStar(__nested_webpack_require_568600__(3147), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 3147: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_570789__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_570789__(9110), exports1);
                __exportStar(__nested_webpack_require_570789__(7717), exports1);
                __exportStar(__nested_webpack_require_570789__(8431), exports1);
                __exportStar(__nested_webpack_require_570789__(1815), exports1);
                var connection_1 = __nested_webpack_require_570789__(291);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes = exports1.LSPErrorCodes || (exports1.LSPErrorCodes = {}));
            /***/ },
            /***/ 291: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_574938__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_574938__(9110);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8431: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_576175__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_576175__(9110);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection = exports1.MessageDirection || (exports1.MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 7602: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_578901__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_578901__(8431);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest = exports1.CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest = exports1.CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 3747: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_581932__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_581932__(8431);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest = exports1.DocumentColorRequest || (exports1.DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest = exports1.ColorPresentationRequest || (exports1.ColorPresentationRequest = {}));
            /***/ },
            /***/ 7639: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_584235__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_584235__(8431);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest = exports1.ConfigurationRequest || (exports1.ConfigurationRequest = {}));
            /***/ },
            /***/ 5581: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_586017__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_586017__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest = exports1.DeclarationRequest || (exports1.DeclarationRequest = {}));
            /***/ },
            /***/ 1494: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_587682__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_587682__(9110);
                const Is = __nested_webpack_require_587682__(8633);
                const messages_1 = __nested_webpack_require_587682__(8431);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData = exports1.DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind = exports1.DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest = exports1.DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest = exports1.WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest = exports1.DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 4781: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_591926__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_591926__(8431);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind = exports1.FileOperationPatternKind || (exports1.FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest = exports1.WillCreateFilesRequest || (exports1.WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification = exports1.DidCreateFilesNotification || (exports1.DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest = exports1.WillRenameFilesRequest || (exports1.WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification = exports1.DidRenameFilesNotification || (exports1.DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification = exports1.DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest = exports1.WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 1203: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_597931__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_597931__(8431);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest = exports1.FoldingRangeRequest || (exports1.FoldingRangeRequest = {}));
            /***/ },
            /***/ 7287: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_599370__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_599370__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest = exports1.ImplementationRequest || (exports1.ImplementationRequest = {}));
            /***/ },
            /***/ 9383: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_601019__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_601019__(8431);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest = exports1.InlayHintRequest || (exports1.InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest = exports1.InlayHintResolveRequest || (exports1.InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest = exports1.InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 3491: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_603822__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_603822__(8431);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest = exports1.InlineValueRequest || (exports1.InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest = exports1.InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 1815: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_605888__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = void 0;
                const messages_1 = __nested_webpack_require_605888__(8431);
                const vscode_languageserver_types_1 = __nested_webpack_require_605888__(7717);
                const Is = __nested_webpack_require_605888__(8633);
                const protocol_implementation_1 = __nested_webpack_require_605888__(7287);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_605888__(9264);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_605888__(6860);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_605888__(7639);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_605888__(3747);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_605888__(1203);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_605888__(5581);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_605888__(1530);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_605888__(4166);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_605888__(7602);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_605888__(2067);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_605888__(4333);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_605888__(2249);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_605888__(4781);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_605888__(7684);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_605888__(7062);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_605888__(3491);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_605888__(9383);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_605888__(1494);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_605888__(4792);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter = exports1.TextDocumentFilter || (exports1.TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter = exports1.NotebookDocumentFilter || (exports1.NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter = exports1.NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector = exports1.DocumentSelector || (exports1.DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest = exports1.RegistrationRequest || (exports1.RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest = exports1.UnregistrationRequest || (exports1.UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind = exports1.ResourceOperationKind || (exports1.ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind = exports1.FailureHandlingKind || (exports1.FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind = exports1.PositionEncodingKind || (exports1.PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions = exports1.StaticRegistrationOptions || (exports1.StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions = exports1.TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions = exports1.WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest = exports1.InitializeRequest || (exports1.InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes = exports1.InitializeErrorCodes || (exports1.InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification = exports1.InitializedNotification || (exports1.InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest = exports1.ShutdownRequest || (exports1.ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification = exports1.ExitNotification || (exports1.ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification = exports1.DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification = exports1.ShowMessageNotification || (exports1.ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest = exports1.ShowMessageRequest || (exports1.ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification = exports1.LogMessageNotification || (exports1.LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification = exports1.TelemetryEventNotification || (exports1.TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind = exports1.TextDocumentSyncKind || (exports1.TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification = exports1.DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent = exports1.TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification = exports1.DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification = exports1.DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification = exports1.DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason = exports1.TextDocumentSaveReason || (exports1.TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification = exports1.WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification = exports1.DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType = exports1.FileChangeType || (exports1.FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern = exports1.RelativePattern || (exports1.RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind = exports1.WatchKind || (exports1.WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification = exports1.PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind = exports1.CompletionTriggerKind || (exports1.CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest = exports1.CompletionRequest || (exports1.CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest = exports1.CompletionResolveRequest || (exports1.CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest = exports1.HoverRequest || (exports1.HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind = exports1.SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest = exports1.SignatureHelpRequest || (exports1.SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest = exports1.DefinitionRequest || (exports1.DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest = exports1.ReferencesRequest || (exports1.ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest = exports1.DocumentHighlightRequest || (exports1.DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest = exports1.DocumentSymbolRequest || (exports1.DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest = exports1.CodeActionRequest || (exports1.CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest = exports1.CodeActionResolveRequest || (exports1.CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest = exports1.WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest = exports1.WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest = exports1.CodeLensRequest || (exports1.CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest = exports1.CodeLensResolveRequest || (exports1.CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest = exports1.CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest = exports1.DocumentLinkRequest || (exports1.DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest = exports1.DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = {}));
                /**
 * A request to to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest = exports1.DocumentFormattingRequest || (exports1.DocumentFormattingRequest = {}));
                /**
 * A request to to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest = exports1.DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest = exports1.DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior = exports1.PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest = exports1.RenameRequest || (exports1.RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest = exports1.PrepareRenameRequest || (exports1.PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest = exports1.ExecuteCommandRequest || (exports1.ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest = exports1.ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 2249: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_675004__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_675004__(8431);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest = exports1.LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 7684: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_676377__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_676377__(8431);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel = exports1.UniquenessLevel || (exports1.UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind = exports1.MonikerKind || (exports1.MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest = exports1.MonikerRequest || (exports1.MonikerRequest = {}));
            /***/ },
            /***/ 4792: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_679411__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_679411__(7717);
                const Is = __nested_webpack_require_679411__(8633);
                const messages_1 = __nested_webpack_require_679411__(8431);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind = exports1.NotebookCellKind || (exports1.NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary = exports1.ExecutionSummary || (exports1.ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell = exports1.NotebookCell || (exports1.NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument = exports1.NotebookDocument || (exports1.NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType = exports1.NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification = exports1.DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange = exports1.NotebookCellArrayChange || (exports1.NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification = exports1.DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 4166: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_692988__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_692988__(9110);
                const messages_1 = __nested_webpack_require_692988__(8431);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress = exports1.WorkDoneProgress || (exports1.WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest = exports1.WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 1530: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_695829__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_695829__(8431);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest = exports1.SelectionRangeRequest || (exports1.SelectionRangeRequest = {}));
            /***/ },
            /***/ 2067: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_697309__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_697309__(8431);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat = exports1.TokenFormat || (exports1.TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType = exports1.SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest = exports1.SemanticTokensRequest || (exports1.SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest = exports1.SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest = exports1.SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest = exports1.SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 4333: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_701620__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_701620__(8431);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest = exports1.ShowDocumentRequest || (exports1.ShowDocumentRequest = {}));
            /***/ },
            /***/ 9264: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_703098__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_703098__(8431);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest = exports1.TypeDefinitionRequest || (exports1.TypeDefinitionRequest = {}));
            /***/ },
            /***/ 7062: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_704747__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_704747__(8431);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest = exports1.TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest = exports1.TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest = exports1.TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 6860: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_707681__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_707681__(8431);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest = exports1.WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification = exports1.DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 8633: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 7717: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_712576__)=>{
                "use strict";
                __nested_webpack_require_712576__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_712576__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind1,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat1,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString1,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent1,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI1,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI1;
                (function(URI1) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI1.is = is;
                })(URI1 || (URI1 = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line: line,
                            character: character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri: uri,
                            range: range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri: targetUri,
                            targetRange: targetRange,
                            targetSelectionRange: targetSelectionRange,
                            originSelectionRange: originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red: red,
                            green: green,
                            blue: blue,
                            alpha: alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range: range,
                            color: color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label: label,
                            textEdit: textEdit,
                            additionalTextEdits: additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        var result = {
                            startLine: startLine,
                            endLine: endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location: location,
                            message: message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        var result = {
                            range: range,
                            message: message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command) {
                        var args = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            args[_i - 2] = arguments[_i];
                        }
                        var result = {
                            title: title,
                            command: command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range: range,
                            newText: newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range: range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        var result = {
                            label: label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        var candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range: range,
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range: range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument: textDocument,
                            edits: edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'create',
                            uri: uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        var result = {
                            kind: 'rename',
                            oldUri: oldUri,
                            newUri: newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'delete',
                            uri: uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                var TextEditChangeImpl = /** @class */ function() {
                    function TextEditChangeImpl(edits, changeAnnotations) {
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                    TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.delete = function(range, annotation) {
                        var edit;
                        var id;
                        if (annotation === undefined) {
                            edit = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.add = function(edit) {
                        this.edits.push(edit);
                    };
                    TextEditChangeImpl.prototype.all = function() {
                        return this.edits;
                    };
                    TextEditChangeImpl.prototype.clear = function() {
                        this.edits.splice(0, this.edits.length);
                    };
                    TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {
                        if (value === undefined) {
                            throw new Error("Text edit change is not configured to manage change annotations.");
                        }
                    };
                    return TextEditChangeImpl;
                }();
                /**
 * A helper class
 */ var ChangeAnnotations = /** @class */ function() {
                    function ChangeAnnotations(annotations) {
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                    ChangeAnnotations.prototype.all = function() {
                        return this._annotations;
                    };
                    Object.defineProperty(ChangeAnnotations.prototype, "size", {
                        get: function() {
                            return this._size;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {
                        var id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error("Id ".concat(id, " is already in use."));
                        }
                        if (annotation === undefined) {
                            throw new Error("No annotation provided for id ".concat(id));
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    };
                    ChangeAnnotations.prototype.nextId = function() {
                        this._counter++;
                        return this._counter.toString();
                    };
                    return ChangeAnnotations;
                }();
                /**
 * A workspace change helps constructing changes to a workspace.
 */ var WorkspaceChange = /** @class */ function() {
                    function WorkspaceChange(workspaceEdit) {
                        var _this = this;
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach(function(change) {
                                    if (TextDocumentEdit.is(change)) {
                                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach(function(key) {
                                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    _this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                    Object.defineProperty(WorkspaceChange.prototype, "edit", {
                        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */ get: function() {
                            this.initDocumentChanges();
                            if (this._changeAnnotations !== undefined) {
                                if (this._changeAnnotations.size === 0) {
                                    this._workspaceEdit.changeAnnotations = undefined;
                                } else {
                                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                }
                            }
                            return this._workspaceEdit;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    WorkspaceChange.prototype.getTextEditChange = function(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            var textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            var result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                var edits = [];
                                var textDocumentEdit = {
                                    textDocument: textDocument,
                                    edits: edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            var result = this._textEditChanges[key];
                            if (!result) {
                                var edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    };
                    WorkspaceChange.prototype.initDocumentChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    };
                    WorkspaceChange.prototype.initChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    };
                    WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    return WorkspaceChange;
                }();
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri: uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri: uri,
                            languageId: languageId,
                            version: version,
                            text: text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        var candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent1;
                (function(MarkupContent1) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent1.is = is;
                })(MarkupContent1 || (MarkupContent1 = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind1;
                (function(CompletionItemKind1) {
                    CompletionItemKind1.Text = 1;
                    CompletionItemKind1.Method = 2;
                    CompletionItemKind1.Function = 3;
                    CompletionItemKind1.Constructor = 4;
                    CompletionItemKind1.Field = 5;
                    CompletionItemKind1.Variable = 6;
                    CompletionItemKind1.Class = 7;
                    CompletionItemKind1.Interface = 8;
                    CompletionItemKind1.Module = 9;
                    CompletionItemKind1.Property = 10;
                    CompletionItemKind1.Unit = 11;
                    CompletionItemKind1.Value = 12;
                    CompletionItemKind1.Enum = 13;
                    CompletionItemKind1.Keyword = 14;
                    CompletionItemKind1.Snippet = 15;
                    CompletionItemKind1.Color = 16;
                    CompletionItemKind1.File = 17;
                    CompletionItemKind1.Reference = 18;
                    CompletionItemKind1.Folder = 19;
                    CompletionItemKind1.EnumMember = 20;
                    CompletionItemKind1.Constant = 21;
                    CompletionItemKind1.Struct = 22;
                    CompletionItemKind1.Event = 23;
                    CompletionItemKind1.Operator = 24;
                    CompletionItemKind1.TypeParameter = 25;
                })(CompletionItemKind1 || (CompletionItemKind1 = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat1;
                (function(InsertTextFormat1) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
                })(InsertTextFormat1 || (InsertTextFormat1 = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText: newText,
                            insert: insert,
                            replace: replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label: label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString1;
                (function(MarkedString1) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString1.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        var candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString1.is = is;
                })(MarkedString1 || (MarkedString1 = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        var candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent1.is(candidate.contents) || MarkedString1.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString1.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label: label,
                            documentation: documentation
                        } : {
                            label: label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation) {
                        var parameters = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            parameters[_i - 2] = arguments[_i];
                        }
                        var result = {
                            label: label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        var result = {
                            range: range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        var result = {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        } : {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        var result = {
                            name: name,
                            detail: detail,
                            kind: kind,
                            range: range,
                            selectionRange: selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        var result = {
                            diagnostics: diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        var result = {
                            title: title
                        };
                        var checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        var result = {
                            range: range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize: tabSize,
                            insertSpaces: insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range: range,
                            target: target,
                            data: data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range: range,
                            parent: parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range: range,
                            text: text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range: range,
                            variableName: variableName,
                            caseSensitiveLookup: caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range: range,
                            expression: expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId: frameId,
                            stoppedLocation: stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value: value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        var result = {
                            position: position,
                            label: label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && URI1.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                var EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits, function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = text.length;
                        for(var i = sortedEdits.length - 1; i >= 0; i--){
                            var e = sortedEdits[i];
                            var startOffset = document1.offsetAt(e.range.start);
                            var endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        var p = data.length / 2 | 0;
                        var left = data.slice(0, p);
                        var right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        var leftIdx = 0;
                        var rightIdx = 0;
                        var i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            var ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            var lineOffsets = [];
                            var text = this._content;
                            var isLineStart = true;
                            for(var i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                var ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullTextDocument;
                }();
                var Is;
                (function(Is) {
                    var toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ },
            /***/ 2730: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_823680__)=>{
                "use strict";
                var forEach = __nested_webpack_require_823680__(705);
                var availableTypedArrays = __nested_webpack_require_823680__(4834);
                var callBind = __nested_webpack_require_823680__(8498);
                var callBound = __nested_webpack_require_823680__(9818);
                var gOPD = __nested_webpack_require_823680__(9336);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_823680__(1913)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_823680__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 4834: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_827927__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_827927__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ },
            /***/ 8041: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_829041__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_829041__.d(__nested_webpack_exports__, {
                    /* harmony export */ V: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            const start = this.offsetAt(range.start);
                            const end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(changes, version) {
                        for (const change of changes){
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                const range = getWellformedRange(change.range);
                                // update content
                                const startOffset = this.offsetAt(range.start);
                                const endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                const startLine = Math.max(range.start.line, 0);
                                const endLine = Math.max(range.end.line, 0);
                                let lineOffsets = this._lineOffsets;
                                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(let i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                const diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        const lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            const mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        const line = low - 1;
                        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
                        return {
                            line,
                            character: offset - lineOffsets[line]
                        };
                    }
                    offsetAt(position) {
                        const lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        const lineOffset = lineOffsets[position.line];
                        if (position.character <= 0) {
                            return lineOffset;
                        }
                        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        const offset = Math.min(lineOffset + position.character, nextLineOffset);
                        return this.ensureBeforeEOL(offset, lineOffset);
                    }
                    ensureBeforeEOL(offset, lineOffset) {
                        while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))){
                            offset--;
                        }
                        return offset;
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    static isIncremental(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    static isFull(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        const text = document1.getText();
                        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b)=>{
                            const diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = 0;
                        const spans = [];
                        for (const e of sortedEdits){
                            const startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    const p = data.length / 2 | 0;
                    const left = data.slice(0, p);
                    const right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    let leftIdx = 0;
                    let rightIdx = 0;
                    let i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        const ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
                    const result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(let i = 0; i < text.length; i++){
                        const ch = text.charCodeAt(i);
                        if (isEOL(ch)) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function isEOL(char) {
                    return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;
                }
                function getWellformedRange(range) {
                    const start = range.start;
                    const end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    const range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range
                        };
                    }
                    return textEdit;
                }
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_843559__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ id: moduleId,
                /******/ loaded: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_843559__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.loaded = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __nested_webpack_require_843559__.n = (module1)=>{
                /******/ var getter = module1 && module1.__esModule ? /******/ ()=>module1['default'] : /******/ ()=>module1;
                /******/ __nested_webpack_require_843559__.d(getter, {
                    a: getter
                });
                /******/ return getter;
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_843559__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_843559__.o(definition, key) && !__nested_webpack_require_843559__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_843559__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_843559__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_843559__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/node module decorator */ /******/ (()=>{
            /******/ __nested_webpack_require_843559__.nmd = (module1)=>{
                /******/ module1.paths = [];
                /******/ if (!module1.children) module1.children = [];
                /******/ return module1;
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_843559__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_843559__.d(__nested_webpack_exports__, {
                LuaService: ()=>/* binding */ LuaService
            });
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_843559__(2125);
            // EXTERNAL MODULE: ../../node_modules/luaparse/luaparse.js
            var luaparse = __nested_webpack_require_843559__(98);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var main = __nested_webpack_require_843559__(5501);
            // EXTERNAL MODULE: ./src/utils.ts
            var utils = __nested_webpack_require_843559__(7770);
            ; // CONCATENATED MODULE: ./src/ace/range-singleton.ts
            function _define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class AceRange {
                static getConstructor(editor) {
                    if (!AceRange._instance && editor) {
                        AceRange._instance = editor.getSelectionRange().constructor;
                    }
                    return AceRange._instance;
                }
            }
            _define_property(AceRange, "_instance", void 0);
            ; // CONCATENATED MODULE: ./src/type-converters/common-converters.ts
            var common_converters_CommonConverter;
            (function(CommonConverter1) {
                function normalizeRanges(completions) {
                    return completions && completions.map((el)=>{
                        if (el["range"]) {
                            el["range"] = toRange(el["range"]);
                        }
                        return el;
                    });
                }
                CommonConverter1.normalizeRanges = normalizeRanges;
                function cleanHtml(html) {
                    return html.replace(/<a\s/, "<a target='_blank' ");
                }
                CommonConverter1.cleanHtml = cleanHtml;
                function toRange(range) {
                    if (!range || !range.start || !range.end) {
                        return;
                    }
                    let Range = AceRange.getConstructor();
                    // @ts-ignore
                    return Range.fromPoints(range.start, range.end);
                }
                CommonConverter1.toRange = toRange;
                function convertKind(kind) {
                    switch(kind){
                        case "primitiveType":
                        case "keyword":
                            return main.CompletionItemKind.Keyword;
                        case "variable":
                        case "localVariable":
                            return main.CompletionItemKind.Variable;
                        case "memberVariable":
                        case "memberGetAccessor":
                        case "memberSetAccessor":
                            return main.CompletionItemKind.Field;
                        case "function":
                        case "memberFunction":
                        case "constructSignature":
                        case "callSignature":
                        case "indexSignature":
                            return main.CompletionItemKind.Function;
                        case "enum":
                            return main.CompletionItemKind.Enum;
                        case "module":
                            return main.CompletionItemKind.Module;
                        case "class":
                            return main.CompletionItemKind.Class;
                        case "interface":
                            return main.CompletionItemKind.Interface;
                        case "warning":
                            return main.CompletionItemKind.File;
                    }
                    return main.CompletionItemKind.Property;
                }
                CommonConverter1.convertKind = convertKind;
                function excludeByErrorMessage(diagnostics, errorMessagesToIgnore, fieldName = "message") {
                    if (!errorMessagesToIgnore) return diagnostics;
                    return diagnostics.filter((el)=>!(0, utils /* checkValueAgainstRegexpArray */ .Tk)(el[fieldName], errorMessagesToIgnore));
                }
                CommonConverter1.excludeByErrorMessage = excludeByErrorMessage;
            })(common_converters_CommonConverter || (common_converters_CommonConverter = {}));
            ; // CONCATENATED MODULE: ./src/type-converters/lsp/lsp-converters.ts
            function fromRange(range) {
                return {
                    start: {
                        line: range.start.row,
                        character: range.start.column
                    },
                    end: {
                        line: range.end.row,
                        character: range.end.column
                    }
                };
            }
            function rangeFromPositions(start, end) {
                return {
                    start: start,
                    end: end
                };
            }
            function toRange(range) {
                return {
                    start: {
                        row: range.start.line,
                        column: range.start.character
                    },
                    end: {
                        row: range.end.line,
                        column: range.end.character
                    }
                };
            }
            function fromPoint(point) {
                return {
                    line: point.row,
                    character: point.column
                };
            }
            function toPoint(position) {
                return {
                    row: position.line,
                    column: position.character
                };
            }
            function toAnnotations(diagnostics) {
                var _diagnostics;
                return (_diagnostics = diagnostics) === null || _diagnostics === void 0 ? void 0 : _diagnostics.map((el)=>{
                    return {
                        row: el.range.start.line,
                        column: el.range.start.character,
                        text: el.message,
                        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info",
                        code: el.code
                    };
                });
            }
            function fromAnnotations(annotations) {
                var _annotations;
                return (_annotations = annotations) === null || _annotations === void 0 ? void 0 : _annotations.map((el)=>{
                    return {
                        range: {
                            start: {
                                line: el.row,
                                character: el.column
                            },
                            end: {
                                line: el.row,
                                character: el.column
                            }
                        },
                        message: el.text,
                        severity: el.type === "error" ? 1 : el.type === "warning" ? 2 : 3,
                        code: el["code"]
                    };
                });
            }
            function toCompletion(item) {
                var _item_textEdit, _item_command;
                let itemKind = item.kind;
                let kind = itemKind ? Object.keys(CompletionItemKind)[Object.values(CompletionItemKind).indexOf(itemKind)] : undefined;
                var _item_textEdit_newText, _ref;
                let text = (_ref = (_item_textEdit_newText = (_item_textEdit = item.textEdit) === null || _item_textEdit === void 0 ? void 0 : _item_textEdit.newText) !== null && _item_textEdit_newText !== void 0 ? _item_textEdit_newText : item.insertText) !== null && _ref !== void 0 ? _ref : item.label;
                let filterText;
                // filtering would happen on ace editor side
                //TODO: if filtering and sorting are on server side, we should disable FilteredList in ace completer
                if (item.filterText) {
                    const firstWordMatch = item.filterText.match(/\w+/);
                    const firstWord = firstWordMatch ? firstWordMatch[0] : null;
                    if (firstWord) {
                        const wordRegex = new RegExp(`\\b${firstWord}\\b`, 'i');
                        if (!wordRegex.test(text)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    } else {
                        if (!text.includes(item.filterText)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    }
                }
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.textEdit ? getTextEditRange(item.textEdit, filterText) : undefined;
                let completion = {
                    meta: kind,
                    caption: item.label,
                    score: undefined
                };
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (item.insertTextFormat == InsertTextFormat.Snippet) {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["documentation"] = item.documentation; //TODO: this is workaround for services with instant completion
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = completions.map((el)=>{
                        if (!el.completions) {
                            return [];
                        }
                        let allCompletions;
                        if (Array.isArray(el.completions)) {
                            allCompletions = el.completions;
                        } else {
                            allCompletions = el.completions.items;
                        }
                        return allCompletions.map((item)=>{
                            item["service"] = el.service;
                            return item;
                        });
                    }).flat();
                    return combinedCompletions.map((item)=>toCompletion(item));
                }
                return [];
            }
            function toResolvedCompletion(completion, item) {
                completion["docMarkdown"] = fromMarkupContent(item.documentation);
                return completion;
            }
            function toCompletionItem(completion) {
                let command;
                if (completion["command"]) {
                    command = {
                        title: "triggerSuggest",
                        command: completion["command"]
                    };
                }
                var _completion_caption;
                let completionItem = {
                    label: (_completion_caption = completion.caption) !== null && _completion_caption !== void 0 ? _completion_caption : "",
                    kind: CommonConverter.convertKind(completion.meta),
                    command: command,
                    insertTextFormat: completion["snippet"] ? InsertTextFormat.Snippet : InsertTextFormat.PlainText,
                    documentation: completion["documentation"]
                };
                if (completion["range"]) {
                    var _completion_snippet;
                    completionItem.textEdit = {
                        range: fromRange(completion["range"]),
                        newText: (_completion_snippet = completion["snippet"]) !== null && _completion_snippet !== void 0 ? _completion_snippet : completion["value"]
                    };
                } else {
                    var _completion_snippet1;
                    completionItem.insertText = (_completion_snippet1 = completion["snippet"]) !== null && _completion_snippet1 !== void 0 ? _completion_snippet1 : completion["value"];
                }
                completionItem["fileName"] = completion["fileName"];
                completionItem["position"] = completion["position"];
                completionItem["item"] = completion["item"];
                completionItem["service"] = completion["service"]; //TODO:
                return completionItem;
            }
            function getTextEditRange(textEdit, filterText) {
                const filterLength = filterText ? filterText.length : 0;
                if ("insert" in textEdit && "replace" in textEdit) {
                    let mergedRanges = mergeRanges([
                        toRange(textEdit.insert),
                        toRange(textEdit.replace)
                    ]);
                    return mergedRanges[0];
                } else {
                    textEdit.range.start.character -= filterLength;
                    return toRange(textEdit.range);
                }
            }
            function toTooltip(hover) {
                var _hover_find;
                if (!hover) return;
                let content = hover.map((el)=>{
                    if (!el || !el.contents) return;
                    if (MarkupContent.is(el.contents)) {
                        return fromMarkupContent(el.contents);
                    } else if (MarkedString.is(el.contents)) {
                        if (typeof el.contents === "string") {
                            return el.contents;
                        }
                        return "```" + el.contents.value + "```";
                    } else {
                        let contents = el.contents.map((el)=>{
                            if (typeof el !== "string") {
                                return `\`\`\`${el.value}\`\`\``;
                            } else {
                                return el;
                            }
                        });
                        return contents.join("\n\n");
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                //TODO: it could be merged within all ranges in future
                let lspRange = (_hover_find = hover.find((el)=>{
                    var _el;
                    return (_el = el) === null || _el === void 0 ? void 0 : _el.range;
                })) === null || _hover_find === void 0 ? void 0 : _hover_find.range;
                let range;
                if (lspRange) range = toRange(lspRange);
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    },
                    range: range
                };
            }
            function fromSignatureHelp(signatureHelp) {
                if (!signatureHelp) return;
                let content = signatureHelp.map((el)=>{
                    var _el, _el1;
                    if (!el) return;
                    let signatureIndex = ((_el = el) === null || _el === void 0 ? void 0 : _el.activeSignature) || 0;
                    let activeSignature = el.signatures[signatureIndex];
                    if (!activeSignature) return;
                    let activeParam = (_el1 = el) === null || _el1 === void 0 ? void 0 : _el1.activeParameter;
                    let contents = activeSignature.label;
                    if (activeParam != undefined && activeSignature.parameters && activeSignature.parameters[activeParam]) {
                        let param = activeSignature.parameters[activeParam].label;
                        if (typeof param == "string") {
                            contents = contents.replace(param, `**${param}**`);
                        }
                    }
                    if (activeSignature.documentation) {
                        if (MarkupContent.is(activeSignature.documentation)) {
                            return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
                        } else {
                            contents += "\n\n" + activeSignature.documentation;
                            return contents;
                        }
                    } else {
                        return contents;
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            }
            function fromMarkupContent(content) {
                if (!content) return;
                if (typeof content === "string") {
                    return content;
                } else {
                    return content.value;
                }
            }
            function fromAceDelta(delta, eol) {
                const text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
                return {
                    range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
                    text: delta.action === "insert" ? text : ""
                };
            }
            function filterDiagnostics(diagnostics, filterErrors) {
                return common_converters_CommonConverter.excludeByErrorMessage(diagnostics, filterErrors.errorMessagesToIgnore).map((el)=>{
                    if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsWarning)) {
                        el.severity = main.DiagnosticSeverity.Warning;
                    } else if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsInfo)) {
                        el.severity = main.DiagnosticSeverity.Information;
                    }
                    return el;
                });
            }
            function fromDocumentHighlights(documentHighlights) {
                return documentHighlights.map(function(el) {
                    let className = el.kind == 2 ? "language_highlight_read" : el.kind == 3 ? "language_highlight_write" : "language_highlight_text";
                    return toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), className);
                });
            }
            function toMarkerGroupItem(range, className, tooltipText) {
                let markerGroupItem = {
                    range: range,
                    className: className
                };
                if (tooltipText) {
                    markerGroupItem["tooltipText"] = tooltipText;
                }
                return markerGroupItem;
            }
            ; // CONCATENATED MODULE: ./src/services/lua/lua-service.ts
            function lua_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class LuaService extends base_service.BaseService {
                async doValidation(document1) {
                    let value = this.getDocumentValue(document1.uri);
                    if (!value) return [];
                    let errors = [];
                    try {
                        this.$service.parse(value);
                    } catch (e) {
                        if (e instanceof this.$service.SyntaxError) {
                            errors.push({
                                range: {
                                    start: {
                                        line: e.line - 1,
                                        character: e.column
                                    },
                                    end: {
                                        line: e.line - 1,
                                        character: e.column
                                    }
                                },
                                message: e.message,
                                severity: 1
                            });
                        }
                    }
                    return filterDiagnostics(errors, this.optionsToFilterDiagnostics);
                }
                constructor(mode){
                    super(mode);
                    lua_service_define_property(this, "$service", void 0);
                    lua_service_define_property(this, "serviceCapabilities", {
                        diagnosticProvider: {
                            interFileDependencies: true,
                            workspaceDiagnostics: true
                        }
                    });
                    this.$service = luaparse;
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TmdzQyw0QkFBNEIsSUFBSSxFQUFFLFlBQVksS0FBSztvQkFDbkRBLDRCQUE0QixJQUFJLEVBQUUsdUJBQXVCO3dCQUNyREUsb0JBQW9COzRCQUNoQkMsdUJBQXVCOzRCQUN2QkMsc0JBQXNCO3dCQUMxQjtvQkFDSjtvQkFDQSxJQUFJLENBQUNILFFBQVEsR0FBR2pGO2dCQUNwQjtZQUNKO1FBRUE7UUFFQSxNQUFNLEdBQUksT0FBT2hyQywwQkFBbUJBO0lBQ3BDLE1BQU0sR0FBRztBQUVUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNlLWxpbnRlcnMtcm9vdC8uL3BhY2thZ2VzL2FjZS1saW50ZXJzL2J1aWxkL2x1YS1zZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDYwOTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwNyk7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gICAgRVJSX0FNQklHVU9VU19BUkdVTUVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTO1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MDEpO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpLnR5cGVzKSxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogKF9fd2VicGFja19yZXF1aXJlX18oMzA0NikuYXNzaWduKTtcbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IF9fd2VicGFja19yZXF1aXJlX18oNTk2OCk7XG52YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKTtcbnZhciBpc0RlZXBFcXVhbDtcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcbnZhciBwYXJzZUV4cHJlc3Npb25BdDtcbnZhciBmaW5kTm9kZUFyb3VuZDtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjU2KTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdKSk7XG5cbnZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07XG59O1xuXG52YXIgd2FybmVkID0gZmFsc2U7IC8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcbnZhciBOT19FWENFUFRJT05fU0VOVElORUwgPSB7fTsgLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZTtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGbikge1xuICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbnRlcm5hbE1lc3NhZ2U7XG5cbiAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICB3YXJuKCdhc3NlcnQuZmFpbCgpIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgYXNzZXJ0LnN0cmljdEVxdWFsKCkgaW5zdGVhZCBvciBvbmx5IHBhc3MgYSBtZXNzYWdlLicsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDA5NCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzTGVuID09PSAyKSBvcGVyYXRvciA9ICchPSc7XG4gIH1cblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtZXNzYWdlO1xuICB2YXIgZXJyQXJncyA9IHtcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSB1bmRlZmluZWQgPyAnZmFpbCcgOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsXG4gIH07XG5cbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKGVyckFyZ3MpO1xuXG4gIGlmIChpbnRlcm5hbE1lc3NhZ2UpIHtcbiAgICBlcnIubWVzc2FnZSA9IGludGVybmFsTWVzc2FnZTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmFzc2VydC5mYWlsID0gZmFpbDsgLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogdmFsdWUsXG4gICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhdmFsdWUuXG5cblxuZnVuY3Rpb24gb2soKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0Lm9rID0gb2s7IC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3Rcbi8vIGVxdWFsIHdpdGggIT0uXG5cblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJyE9JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG5cblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuXG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5cbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKG9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKGFjdHVhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAob2JqW2tleV0pICYmIG9ialtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBhY3R1YWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1lc3NhZ2UsIGtleXMsIGZuKSB7XG4gIGlmICghKGtleSBpbiBhY3R1YWwpIHx8ICFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSkpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIGNyZWF0ZSBhIG5pY2Ugb3V0cHV0LlxuICAgICAgdmFyIGEgPSBuZXcgQ29tcGFyaXNvbihhY3R1YWwsIGtleXMpO1xuICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLmFjdHVhbCA9IGFjdHVhbDtcbiAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCwgbXNnLCBmbikge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2V4cGVjdGVkJywgWydGdW5jdGlvbicsICdSZWdFeHAnXSwgZXhwZWN0ZWQpO1xuICAgIH0gLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG5cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZFxuICAgIC8vIGFzIHdlbGwuXG5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlcnJvcicsIGV4cGVjdGVkLCAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKGV4cGVjdGVkW2tleV0pICYmIGV4cGVjdGVkW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbXNnLCBrZXlzLCBmbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gR3VhcmQgaW5zdGFuY2VvZiBhZ2FpbnN0IGFycm93IGZ1bmN0aW9ucyBhcyB0aGV5IGRvbid0IGhhdmUgYSBwcm90b3R5cGUuXG5cblxuICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3R1YWwoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCAnRnVuY3Rpb24nLCBmbik7XG4gIH1cblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xuICAvLyBBY2NlcHQgbmF0aXZlIEVTNiBwcm9taXNlcyBhbmQgcHJvbWlzZXMgdGhhdCBhcmUgaW1wbGVtZW50ZWQgaW4gYSBzaW1pbGFyXG4gIC8vIHdheS4gRG8gbm90IGFjY2VwdCB0aGVuYWJsZXMgdGhhdCB1c2UgYSBmdW5jdGlvbiBhcyBgb2JqYCBhbmQgdGhhdCBoYXZlIG5vXG4gIC8vIGBjYXRjaGAgaGFuZGxlci5cbiAgLy8gVE9ETzogdGhlbmFibGVzIGFyZSBjaGVja2VkIHVwIHVudGlsIHRoZXkgaGF2ZSB0aGUgY29ycmVjdCBtZXRob2RzLFxuICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cbiAgcmV0dXJuIGlzUHJvbWlzZShvYmopIHx8IG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNhdGNoID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdFByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIHByb21pc2VGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm4oKTsgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG5cbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnaW5zdGFuY2Ugb2YgUHJvbWlzZScsICdwcm9taXNlRm4nLCByZXN1bHRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGVycm9yICE9IG51bGwgJiYgX3R5cGVvZihlcnJvcikgIT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgdmFyIGRldGFpbHMgPSAnJztcblxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XG4gICAgICBkZXRhaWxzICs9IFwiIChcIi5jb25jYXQoZXJyb3IubmFtZSwgXCIpXCIpO1xuICAgIH1cblxuICAgIGRldGFpbHMgKz0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAncmVqZWN0cycgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBleHBlY3RlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscyksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcblxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgXCJcXG5cIikgKyBcIkFjdHVhbCBtZXNzYWdlOiBcXFwiXCIuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgXCJcXFwiXCIpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IGFjdHVhbDtcbn1cblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIHRocm93cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFtyZWplY3RzLCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhmbikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xuXG4gICAgaWYgKF90eXBlb2YoZXJyKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmxlbmd0aCA9PT0gMCAmJiBlcnIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBlcnIsXG4gICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yXG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG5cbiAgICB2YXIgb3JpZ1N0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAvLyBjcmVhdGVkIG9uZXMuXG4gICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB0bXAyLnNoaWZ0KCk7IC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cblxuICAgICAgdmFyIHRtcDEgPSBuZXdFcnIuc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XG5cbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld0Vyci5zdGFjayA9IFwiXCIuY29uY2F0KHRtcDEuam9pbignXFxuJyksIFwiXFxuXCIpLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXdFcnI7XG4gIH1cbn07IC8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5cblxuZnVuY3Rpb24gc3RyaWN0KCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgwMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXG5cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDEzNDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuIC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkzKTtcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdChfdHlwZW9mKGFjdHVhbCkpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdpcyBpbnZhbGlkJztcbiAgaWYgKHV0aWwgPT09IHVuZGVmaW5lZCkgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyk7XG4gIHZhciBpbnNwZWN0ZWQgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuXG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgaW5zcGVjdGVkID0gXCJcIi5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksIFwiLi4uXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIi5jb25jYXQobmFtZSwgXCInIFwiKS5jb25jYXQocmVhc29uLCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChpbnNwZWN0ZWQpO1xufSwgVHlwZUVycm9yLCBSYW5nZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZTtcblxuICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHR5cGUgPSBcImluc3RhbmNlIG9mIFwiLmNvbmNhdCh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJ0eXBlIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5Myk7XG4gIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB2YXIgbXNnID0gJ1RoZSAnO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoYSwgXCJcXFwiXCIpO1xuICB9KTtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICBtc2cgKz0gXCIsIGFuZCBcIi5jb25jYXQoYXJnc1tsZW4gLSAxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY1Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcblxudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogX193ZWJwYWNrX3JlcXVpcmVfXyg3ODM4KTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gKF9fd2VicGFja19yZXF1aXJlX18oNjgyNykudHlwZXMpLFxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgaXNEYXRlID0gX3JlcXVpcmUkdHlwZXMuaXNEYXRlLFxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICBpc1NldCA9IF9yZXF1aXJlJHR5cGVzLmlzU2V0LFxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgIGlzTnVtYmVyT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNOdW1iZXJPYmplY3QsXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgaXNCaWdJbnRPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0JpZ0ludE9iamVjdCxcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgaXNGbG9hdDY0QXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cblxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7IC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgcmV0dXJuIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPyBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncyA6IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gIHJldHVybiBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cblxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xuICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdHJpY3QgPyBvYmplY3RJcyh2YWwxLCB2YWwyKSA6IHRydWU7XG4gIH0gLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuXG5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwxKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSk7XG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XG5cbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG5cblxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG5cblxuICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpOyAvLyBUaGUgcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcblxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG5cbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYUtleXMubGVuZ3RoID09PSAwICYmIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fCBpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCB8fCB2YWwxLnNpemUgPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cblxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG5cbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuXG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuXG5mdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gR28gbG9va2luZy5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VxdWFsaXR5X2NvbXBhcmlzb25zX2FuZF9zYW1lbmVzcyNMb29zZV9lcXVhbGl0eV91c2luZ1xuLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuLy8gY2FuIG1hdGNoIGxvdHMgb2YgZGlmZmVyZW50IHN0cmluZyB2YWx1ZXMgKGUuZy4sIDFuID09ICcrMDAwMDEnKS5cblxuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWU7XG4gIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuXG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XG5cbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5cbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gIC8vIHBhaXJ3aXNlLlxuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07IC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuXG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldOyAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtMSwgaXRlbTIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBmYWxzZSwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gIC8vIFNldHMgYW5kIG1hcHMgZG9uJ3QgaGF2ZSB0aGVpciBlbnRyaWVzIGFjY2Vzc2libGUgdmlhIG5vcm1hbCBvYmplY3RcbiAgLy8gcHJvcGVydGllcy5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG5cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2tleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODE4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xuXG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0OTgpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0OTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG52YXIgc2V0RnVuY3Rpb25MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxMDgpO1xuXG52YXIgJFR5cGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2OCk7XG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTQwKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRpZiAodHlwZW9mIG9yaWdpbmFsRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSxcblx0XHR0cnVlXG5cdCk7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzNjQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KVxudmFyIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5MylcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09IFwidW5kZWZpbmVkXCIgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NDApO1xuXG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcblxudmFyIGdvcGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMzYpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVEYXRhUHJvcGVydHkoXG5cdG9iaixcblx0cHJvcGVydHksXG5cdHZhbHVlXG4pIHtcblx0aWYgKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BvYmpgIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25gJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgcHJvcGVydHlgIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBzeW1ib2xgJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHR5cGVvZiBhcmd1bWVudHNbM10gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbM10gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkVudW1lcmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB0eXBlb2YgYXJndW1lbnRzWzRdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzRdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Xcml0YWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIHR5cGVvZiBhcmd1bWVudHNbNV0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNV0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkNvbmZpZ3VyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIHR5cGVvZiBhcmd1bWVudHNbNl0gIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbG9vc2VgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBub25FbnVtZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXHR2YXIgbm9uV3JpdGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cdHZhciBub25Db25maWd1cmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG5cblx0LyogQHR5cGUge2ZhbHNlIHwgVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8dW5rbm93bj59ICovXG5cdHZhciBkZXNjID0gISFnb3BkICYmIGdvcGQob2JqLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IG5vbkNvbmZpZ3VyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5jb25maWd1cmFibGUgOiAhbm9uQ29uZmlndXJhYmxlLFxuXHRcdFx0ZW51bWVyYWJsZTogbm9uRW51bWVyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5lbnVtZXJhYmxlIDogIW5vbkVudW1lcmFibGUsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogbm9uV3JpdGFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2Mud3JpdGFibGUgOiAhbm9uV3JpdGFibGVcblx0XHR9KTtcblx0fSBlbHNlIGlmIChsb29zZSB8fCAoIW5vbkVudW1lcmFibGUgJiYgIW5vbldyaXRhYmxlICYmICFub25Db25maWd1cmFibGUpKSB7XG5cdFx0Ly8gbXVzdCBmYWxsIGJhY2sgdG8gW1tTZXRdXSwgYW5kIHdhcyBub3QgZXhwbGljaXRseSBhc2tlZCB0byBtYWtlIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1jb25maWd1cmFibGVcblx0XHRvYmpbcHJvcGVydHldID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgYSBwcm9wZXJ0eSBhcyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1lbnVtZXJhYmxlLicpO1xuXHR9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIyOCk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMzkpKCk7XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gb3JpZ0RlZmluZVByb3BlcnR5ICYmIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKHByZWRpY2F0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0aWYgKG9iamVjdFtuYW1lXSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDk0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NzI5OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZXZhbCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFdmFsRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4Mzg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE1NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5NDM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWYnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU3MzE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zeW50YXgnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gU3ludGF4RXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjE0MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VyaScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBVUklFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzA0Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGFzc2lnblxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnbixcbiAgcG9seWZpbGw6IHBvbHlmaWxsXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjE3KTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc5NDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbnZhciBjb25jYXR0eSA9IGZ1bmN0aW9uIGNvbmNhdHR5KGEsIGIpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGFycltqICsgYS5sZW5ndGhdID0gYltqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIHNsaWN5ID0gZnVuY3Rpb24gc2xpY3koYXJyTGlrZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQgfHwgMCwgaiA9IDA7IGkgPCBhcnJMaWtlLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgICAgYXJyW2pdID0gYXJyTGlrZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBqb2lueSA9IGZ1bmN0aW9uIChhcnIsIGpvaW5lcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYXJyW2ldO1xuICAgICAgICBpZiAoaSArIDEgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHIgKz0gam9pbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmFwcGx5KHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY3koYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICApO1xuXG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzW2ldID0gJyQnICsgaTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgam9pbnkoYm91bmRBcmdzLCAnLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODc5NCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTgzOCk7XG52YXIgJEV2YWxFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcyOSk7XG52YXIgJFJhbmdlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNTUpO1xudmFyICRSZWZlcmVuY2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0Myk7XG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcbnZhciAkVVJJRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNDApO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1NTgpKCk7XG52YXIgaGFzUHJvdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NjkpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogJEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6ICRFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogJFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogJFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiAkVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTQpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTMzNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzIzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0MCk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0cmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1NTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MDgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTA4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTEzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkwOCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1NTQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgJGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEzOCk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChjYWxsLCAkaGFzT3duKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYxNTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xudmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxOCk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2MTc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgZGRhQ2xhc3MgPSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nOyAvLyBJRSAxMVxudmFyIGRkYUNsYXNzMiA9ICdbb2JqZWN0IEhUTUwgZG9jdW1lbnQuYWxsIGNsYXNzXSc7XG52YXIgZGRhQ2xhc3MzID0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJzsgLy8gSUUgOS0xMFxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2BcblxudmFyIGlzSUU2OCA9ICEoMCBpbiBbLF0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNwYXJzZS1hcnJheXMsIGNvbW1hLXNwYWNpbmdcblxudmFyIGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcpIHtcblx0Ly8gRmlyZWZveCAzIGNhbm9uaWNhbGl6ZXMgRERBIHRvIHVuZGVmaW5lZCB3aGVuIGl0J3Mgbm90IGFjY2Vzc2VkIGRpcmVjdGx5XG5cdHZhciBhbGwgPSBkb2N1bWVudC5hbGw7XG5cdGlmICh0b1N0ci5jYWxsKGFsbCkgPT09IHRvU3RyLmNhbGwoZG9jdW1lbnQuYWxsKSkge1xuXHRcdGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCh2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFscyBkb2N1bWVudDogZmFsc2UgKi9cblx0XHRcdC8vIGluIElFIDYtOCwgdHlwZW9mIGRvY3VtZW50LmFsbCBpcyBcIm9iamVjdFwiIGFuZCBpdCdzIHRydXRoeVxuXHRcdFx0aWYgKChpc0lFNjggfHwgIXZhbHVlKSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0c3RyID09PSBkZGFDbGFzc1xuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczJcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MzIC8vIG9wZXJhIDEyLjE2XG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IG9iamVjdENsYXNzIC8vIElFIDYtOFxuXHRcdFx0XHRcdCkgJiYgdmFsdWUoJycpID09IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJlZmxlY3RBcHBseSh2YWx1ZSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpICYmIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRpZiAoc3RyQ2xhc3MgIT09IGZuQ2xhc3MgJiYgc3RyQ2xhc3MgIT09IGdlbkNsYXNzICYmICEoL15cXFtvYmplY3QgSFRNTC8pLnRlc3Qoc3RyQ2xhc3MpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODAwNjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzgzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDk4KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkxKTtcbnZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQxKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY0MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1Nyk7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OTEpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5NDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MzApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRyZXR1cm4gISF3aGljaFR5cGVkQXJyYXkodmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTg6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIG1vZHVsZSBkZWNvcmF0b3IgKi8gbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQobW9kdWxlKTtcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIGdsb2JhbCBleHBvcnRzOnRydWUsIG1vZHVsZTp0cnVlLCByZXF1aXJlOnRydWUsIGRlZmluZTp0cnVlLCBnbG9iYWw6dHJ1ZSAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIG5hbWUsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGBcbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICAgICAnZnVuY3Rpb24nOiB0cnVlXG4gICAgICAsICdvYmplY3QnOiB0cnVlXG4gICAgfVxuICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYFxuICAgICwgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzXG4gICAgLy8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcbiAgICAsIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1tcIm9iamVjdFwiXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGVcbiAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLCBhbmRcbiAgICAvLyB1c2UgaXQgYXMgYHdpbmRvd2BcbiAgICAsIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPT09ICdvYmplY3QnICYmIF9fd2VicGFja19yZXF1aXJlX18uZ1xuICAgIC8vIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYFxuICAgICwgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcbiAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG4gICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb25cbiAgLy8gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHRydWUpIHtcbiAgICAvLyBkZWZpbmVkIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW2V4cG9ydHNdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXG5cdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxuXHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgICAvLyBJbiBjYXNlIHRoZSBzb3VyY2UgaGFzIGJlZW4gcHJvY2Vzc2VkIGFuZCB3cmFwcGVkIGluIGEgZGVmaW5lIG1vZHVsZSB1c2VcbiAgICAvLyB0aGUgc3VwcGxpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgICBpZiAoZnJlZUV4cG9ydHMgJiYgbW9kdWxlRXhwb3J0cykgZmFjdG9yeShmcmVlTW9kdWxlLmV4cG9ydHMpO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuXG4gIC8vIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyB7fVxufSh0aGlzLCAnbHVhcGFyc2UnLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZXhwb3J0cy52ZXJzaW9uID0gXCIwLjMuMVwiO1xuXG4gIHZhciBpbnB1dCwgb3B0aW9ucywgbGVuZ3RoLCBmZWF0dXJlcywgZW5jb2RpbmdNb2RlO1xuXG4gIC8vIE9wdGlvbnMgY2FuIGJlIHNldCBlaXRoZXIgZ2xvYmFsbHkgb24gdGhlIHBhcnNlciBvYmplY3QgdGhyb3VnaFxuICAvLyBkZWZhdWx0T3B0aW9ucywgb3IgZHVyaW5nIHRoZSBwYXJzZSBjYWxsLlxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIEV4cGxpY2l0bHkgdGVsbCB0aGUgcGFyc2VyIHdoZW4gdGhlIGlucHV0IGVuZHMuXG4gICAgICB3YWl0OiBmYWxzZVxuICAgIC8vIFN0b3JlIGNvbW1lbnRzIGFzIGFuIGFycmF5IGluIHRoZSBjaHVuayBvYmplY3QuXG4gICAgLCBjb21tZW50czogdHJ1ZVxuICAgIC8vIFRyYWNrIGlkZW50aWZpZXIgc2NvcGVzIGJ5IGFkZGluZyBhbiBpc0xvY2FsIGF0dHJpYnV0ZSB0byBlYWNoXG4gICAgLy8gaWRlbnRpZmllci1ub2RlLlxuICAgICwgc2NvcGU6IGZhbHNlXG4gICAgLy8gU3RvcmUgbG9jYXRpb24gaW5mb3JtYXRpb24gb24gZWFjaCBzeW50YXggbm9kZSBhc1xuICAgIC8vIGBsb2M6IHsgc3RhcnQ6IHsgbGluZSwgY29sdW1uIH0sIGVuZDogeyBsaW5lLCBjb2x1bW4gfSB9YC5cbiAgICAsIGxvY2F0aW9uczogZmFsc2VcbiAgICAvLyBTdG9yZSB0aGUgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgbG9jYXRpb25zIG9uIGVhY2ggc3ludGF4IG5vZGUgYXNcbiAgICAvLyBgcmFuZ2U6IFtzdGFydCwgZW5kXWAuXG4gICAgLCByYW5nZXM6IGZhbHNlXG4gICAgLy8gQSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIHN5bnRheCBub2RlIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICAvLyBUaGUgbm9kZSB3aGljaCBoYXMgYmVlbiBjcmVhdGVkIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlci5cbiAgICAsIG9uQ3JlYXRlTm9kZTogbnVsbFxuICAgIC8vIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBuZXcgc2NvcGUgaXMgY3JlYXRlZC5cbiAgICAsIG9uQ3JlYXRlU2NvcGU6IG51bGxcbiAgICAvLyBBIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBjdXJyZW50IHNjb3BlIGlzIGRlc3Ryb3llZC5cbiAgICAsIG9uRGVzdHJveVNjb3BlOiBudWxsXG4gICAgLy8gQSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIGxvY2FsIHZhcmlhYmxlIGlzIGRlY2xhcmVkIGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgIC8vIFRoZSB2YXJpYWJsZSdzIG5hbWUgd2lsbCBiZSBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyXG4gICAgLCBvbkxvY2FsRGVjbGFyYXRpb246IG51bGxcbiAgICAvLyBUaGUgdmVyc2lvbiBvZiBMdWEgdGFyZ2V0ZWQgYnkgdGhlIHBhcnNlciAoc3RyaW5nOyBhbGxvd2VkIHZhbHVlcyBhcmVcbiAgICAvLyAnNS4xJywgJzUuMicsICc1LjMnKS5cbiAgICAsIGx1YVZlcnNpb246ICc1LjEnXG4gICAgLy8gRW5jb2RpbmcgbW9kZTogaG93IHRvIGludGVycHJldCBjb2RlIHVuaXRzIGhpZ2hlciB0aGFuIFUrMDA3RiBpbiBpbnB1dFxuICAgICwgZW5jb2RpbmdNb2RlOiAnbm9uZSdcbiAgfTtcblxuICBmdW5jdGlvbiBlbmNvZGVVVEY4KGNvZGVwb2ludCwgaGlnaE1hc2spIHtcbiAgICBoaWdoTWFzayA9IGhpZ2hNYXNrIHx8IDA7XG5cbiAgICBpZiAoY29kZXBvaW50IDwgMHg4MCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZXBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVwb2ludCA8IDB4ODAwKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgaGlnaE1hc2sgfCAweGMwIHwgIChjb2RlcG9pbnQgPj4gIDYpICAgICAgICAsXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICggY29kZXBvaW50ICAgICAgICAmIDB4M2YpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZXBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIGhpZ2hNYXNrIHwgMHhlMCB8ICAoY29kZXBvaW50ID4+IDEyKSAgICAgICAgLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoKGNvZGVwb2ludCA+PiAgNikgJiAweDNmKSxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKCBjb2RlcG9pbnQgICAgICAgICYgMHgzZilcbiAgICAgICk7XG4gICAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChjb2RlcG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIGhpZ2hNYXNrIHwgMHhmMCB8ICAoY29kZXBvaW50ID4+IDE4KSAgICAgICAgLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoKGNvZGVwb2ludCA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKChjb2RlcG9pbnQgPj4gIDYpICYgMHgzZiksXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICggY29kZXBvaW50ICAgICAgICAmIDB4M2YpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBMdWEgNS40IGFsbG93cyB1cCB0byBzaXgtYnl0ZSBzZXF1ZW5jZXMsIGFzIGluIFVURi04OjE5OTNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSGV4KG51bSwgZGlnaXRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBkaWdpdHMpXG4gICAgICByZXN1bHQgPSAnMCcgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2hhcnMocngpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHMpIHtcbiAgICAgIHZhciBtID0gcnguZXhlYyhzKTtcbiAgICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICByYWlzZShudWxsLCBlcnJvcnMuaW52YWxpZENvZGVVbml0LCB0b0hleChtWzBdLmNoYXJDb2RlQXQoMCksIDQpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH07XG4gIH1cblxuICB2YXIgZW5jb2RpbmdNb2RlcyA9IHtcbiAgICAvLyBgcHNldWRvLWxhdGluMWAgZW5jb2RpbmcgbW9kZTogYXNzdW1lIHRoZSBpbnB1dCB3YXMgZGVjb2RlZCB3aXRoIHRoZSBsYXRpbjEgZW5jb2RpbmdcbiAgICAvLyBXQVJOSU5HOiBsYXRpbjEgZG9lcyAqKk5PVCoqIG1lYW4gY3AxMjUyIGhlcmUgbGlrZSBpbiB0aGUgYm9uZS1oZWFkZWQgV0hBVFdHIHN0YW5kYXJkO1xuICAgIC8vIGl0IG1lYW5zIHRydWUgSVNPL0lFQyA4ODU5LTEgaWRlbnRpdHktbWFwcGVkIHRvIEJhc2ljIExhdGluIGFuZCBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2tzXG4gICAgJ3BzZXVkby1sYXRpbjEnOiB7XG4gICAgICBmaXh1cDogY2hlY2tDaGFycygvW15cXHgwMC1cXHhmZl0vKSxcbiAgICAgIGVuY29kZUJ5dGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZW5jb2RlVVRGODogZnVuY3Rpb24gKGNvZGVwb2ludCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVRGOChjb2RlcG9pbnQpO1xuICAgICAgfSxcbiAgICB9LFxuXG4gICAgLy8gYHgtdXNlci1kZWZpbmVkYCBlbmNvZGluZyBtb2RlOiBhc3N1bWUgdGhlIGlucHV0IHdhcyBkZWNvZGVkIHdpdGggdGhlIFdIQVRXRyBgeC11c2VyLWRlZmluZWRgIGVuY29kaW5nXG4gICAgJ3gtdXNlci1kZWZpbmVkJzoge1xuICAgICAgZml4dXA6IGNoZWNrQ2hhcnMoL1teXFx4MDAtXFx4N2ZcXHVmNzgwLVxcdWY3ZmZdLyksXG4gICAgICBlbmNvZGVCeXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ODApXG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgfCAweGY3MDApO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZW5jb2RlVVRGODogZnVuY3Rpb24gKGNvZGVwb2ludCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVRGOChjb2RlcG9pbnQsIDB4ZjcwMCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGBub25lYCBlbmNvZGluZyBtb2RlOiBkaXNyZWdhcmQgaW50cmVwcmV0YXRpb24gb2Ygc3RyaW5nIGxpdGVyYWxzLCBsZWF2ZSBpZGVudGlmaWVycyBhcy1pc1xuICAgICdub25lJzoge1xuICAgICAgZGlzY2FyZFN0cmluZ3M6IHRydWUsXG4gICAgICBmaXh1cDogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuICAgICAgZW5jb2RlQnl0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0sXG4gICAgICBlbmNvZGVVVEY4OiBmdW5jdGlvbiAoY29kZXBvaW50KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGF2YWlsYWJsZSB0b2tlbnMgZXhwcmVzc2VkIGFzIGVudW0gZmxhZ3Mgc28gdGhleSBjYW4gYmUgY2hlY2tlZCB3aXRoXG4gIC8vIGJpdHdpc2Ugb3BlcmF0aW9ucy5cblxuICB2YXIgRU9GID0gMSwgU3RyaW5nTGl0ZXJhbCA9IDIsIEtleXdvcmQgPSA0LCBJZGVudGlmaWVyID0gOFxuICAgICwgTnVtZXJpY0xpdGVyYWwgPSAxNiwgUHVuY3R1YXRvciA9IDMyLCBCb29sZWFuTGl0ZXJhbCA9IDY0XG4gICAgLCBOaWxMaXRlcmFsID0gMTI4LCBWYXJhcmdMaXRlcmFsID0gMjU2O1xuXG4gIGV4cG9ydHMudG9rZW5UeXBlcyA9IHsgRU9GOiBFT0YsIFN0cmluZ0xpdGVyYWw6IFN0cmluZ0xpdGVyYWxcbiAgICAsIEtleXdvcmQ6IEtleXdvcmQsIElkZW50aWZpZXI6IElkZW50aWZpZXIsIE51bWVyaWNMaXRlcmFsOiBOdW1lcmljTGl0ZXJhbFxuICAgICwgUHVuY3R1YXRvcjogUHVuY3R1YXRvciwgQm9vbGVhbkxpdGVyYWw6IEJvb2xlYW5MaXRlcmFsXG4gICAgLCBOaWxMaXRlcmFsOiBOaWxMaXRlcmFsLCBWYXJhcmdMaXRlcmFsOiBWYXJhcmdMaXRlcmFsXG4gIH07XG5cbiAgLy8gQXMgdGhpcyBwYXJzZXIgaXMgYSBiaXQgZGlmZmVyZW50IGZyb20gbHVhcyBvd24sIHRoZSBlcnJvciBtZXNzYWdlc1xuICAvLyB3aWxsIGJlIGRpZmZlcmVudCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAgdmFyIGVycm9ycyA9IGV4cG9ydHMuZXJyb3JzID0ge1xuICAgICAgdW5leHBlY3RlZDogJ3VuZXhwZWN0ZWQgJTEgXFwnJTJcXCcgbmVhciBcXCclM1xcJydcbiAgICAsIHVuZXhwZWN0ZWRFT0Y6ICd1bmV4cGVjdGVkIHN5bWJvbCBuZWFyIFxcJzxlb2Y+XFwnJ1xuICAgICwgZXhwZWN0ZWQ6ICdcXCclMVxcJyBleHBlY3RlZCBuZWFyIFxcJyUyXFwnJ1xuICAgICwgZXhwZWN0ZWRUb2tlbjogJyUxIGV4cGVjdGVkIG5lYXIgXFwnJTJcXCcnXG4gICAgLCB1bmZpbmlzaGVkU3RyaW5nOiAndW5maW5pc2hlZCBzdHJpbmcgbmVhciBcXCclMVxcJydcbiAgICAsIG1hbGZvcm1lZE51bWJlcjogJ21hbGZvcm1lZCBudW1iZXIgbmVhciBcXCclMVxcJydcbiAgICAsIGRlY2ltYWxFc2NhcGVUb29MYXJnZTogJ2RlY2ltYWwgZXNjYXBlIHRvbyBsYXJnZSBuZWFyIFxcJyUxXFwnJ1xuICAgICwgaW52YWxpZEVzY2FwZTogJ2ludmFsaWQgZXNjYXBlIHNlcXVlbmNlIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBoZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQ6ICdoZXhhZGVjaW1hbCBkaWdpdCBleHBlY3RlZCBuZWFyIFxcJyUxXFwnJ1xuICAgICwgYnJhY2VFeHBlY3RlZDogJ21pc3NpbmcgXFwnJTFcXCcgbmVhciBcXCclMlxcJydcbiAgICAsIHRvb0xhcmdlQ29kZXBvaW50OiAnVVRGLTggdmFsdWUgdG9vIGxhcmdlIG5lYXIgXFwnJTFcXCcnXG4gICAgLCB1bmZpbmlzaGVkTG9uZ1N0cmluZzogJ3VuZmluaXNoZWQgbG9uZyBzdHJpbmcgKHN0YXJ0aW5nIGF0IGxpbmUgJTEpIG5lYXIgXFwnJTJcXCcnXG4gICAgLCB1bmZpbmlzaGVkTG9uZ0NvbW1lbnQ6ICd1bmZpbmlzaGVkIGxvbmcgY29tbWVudCAoc3RhcnRpbmcgYXQgbGluZSAlMSkgbmVhciBcXCclMlxcJydcbiAgICAsIGFtYmlndW91c1N5bnRheDogJ2FtYmlndW91cyBzeW50YXggKGZ1bmN0aW9uIGNhbGwgeCBuZXcgc3RhdGVtZW50KSBuZWFyIFxcJyUxXFwnJ1xuICAgICwgbm9Mb29wVG9CcmVhazogJ25vIGxvb3AgdG8gYnJlYWsgbmVhciBcXCclMVxcJydcbiAgICAsIGxhYmVsQWxyZWFkeURlZmluZWQ6ICdsYWJlbCBcXCclMVxcJyBhbHJlYWR5IGRlZmluZWQgb24gbGluZSAlMidcbiAgICAsIGxhYmVsTm90VmlzaWJsZTogJ25vIHZpc2libGUgbGFiZWwgXFwnJTFcXCcgZm9yIDxnb3RvPidcbiAgICAsIGdvdG9KdW1wSW5Mb2NhbFNjb3BlOiAnPGdvdG8gJTE+IGp1bXBzIGludG8gdGhlIHNjb3BlIG9mIGxvY2FsIFxcJyUyXFwnJ1xuICAgICwgY2Fubm90VXNlVmFyYXJnOiAnY2Fubm90IHVzZSBcXCcuLi5cXCcgb3V0c2lkZSBhIHZhcmFyZyBmdW5jdGlvbiBuZWFyIFxcJyUxXFwnJ1xuICAgICwgaW52YWxpZENvZGVVbml0OiAnY29kZSB1bml0IFUrJTEgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgZW5jb2RpbmcgbW9kZSdcbiAgfTtcblxuICAvLyAjIyMgQWJzdHJhY3QgU3ludGF4IFRyZWVcbiAgLy9cbiAgLy8gVGhlIGRlZmF1bHQgQVNUIHN0cnVjdHVyZSBpcyBpbnNwaXJlZCBieSB0aGUgTW96aWxsYSBQYXJzZXIgQVBJIGJ1dCBjYW5cbiAgLy8gZWFzaWx5IGJlIGN1c3RvbWl6ZWQgYnkgb3ZlcnJpZGluZyB0aGVzZSBmdW5jdGlvbnMuXG5cbiAgdmFyIGFzdCA9IGV4cG9ydHMuYXN0ID0ge1xuICAgICAgbGFiZWxTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdMYWJlbFN0YXRlbWVudCdcbiAgICAgICAgLCBsYWJlbDogbGFiZWxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBicmVha1N0YXRlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdCcmVha1N0YXRlbWVudCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBnb3RvU3RhdGVtZW50OiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnR290b1N0YXRlbWVudCdcbiAgICAgICAgLCBsYWJlbDogbGFiZWxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCByZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1JldHVyblN0YXRlbWVudCdcbiAgICAgICAgLCAnYXJndW1lbnRzJzogYXJnc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGlmU3RhdGVtZW50OiBmdW5jdGlvbihjbGF1c2VzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdJZlN0YXRlbWVudCdcbiAgICAgICAgLCBjbGF1c2VzOiBjbGF1c2VzXG4gICAgICB9O1xuICAgIH1cbiAgICAsIGlmQ2xhdXNlOiBmdW5jdGlvbihjb25kaXRpb24sIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0lmQ2xhdXNlJ1xuICAgICAgICAsIGNvbmRpdGlvbjogY29uZGl0aW9uXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG4gICAgLCBlbHNlaWZDbGF1c2U6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRWxzZWlmQ2xhdXNlJ1xuICAgICAgICAsIGNvbmRpdGlvbjogY29uZGl0aW9uXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG4gICAgLCBlbHNlQ2xhdXNlOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdFbHNlQ2xhdXNlJ1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCB3aGlsZVN0YXRlbWVudDogZnVuY3Rpb24oY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdXaGlsZVN0YXRlbWVudCdcbiAgICAgICAgLCBjb25kaXRpb246IGNvbmRpdGlvblxuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBkb1N0YXRlbWVudDogZnVuY3Rpb24oYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRG9TdGF0ZW1lbnQnXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHJlcGVhdFN0YXRlbWVudDogZnVuY3Rpb24oY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdSZXBlYXRTdGF0ZW1lbnQnXG4gICAgICAgICwgY29uZGl0aW9uOiBjb25kaXRpb25cbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgbG9jYWxTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHZhcmlhYmxlcywgaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnTG9jYWxTdGF0ZW1lbnQnXG4gICAgICAgICwgdmFyaWFibGVzOiB2YXJpYWJsZXNcbiAgICAgICAgLCBpbml0OiBpbml0XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgYXNzaWdubWVudFN0YXRlbWVudDogZnVuY3Rpb24odmFyaWFibGVzLCBpbml0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50U3RhdGVtZW50J1xuICAgICAgICAsIHZhcmlhYmxlczogdmFyaWFibGVzXG4gICAgICAgICwgaW5pdDogaW5pdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGNhbGxTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0NhbGxTdGF0ZW1lbnQnXG4gICAgICAgICwgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGZ1bmN0aW9uU3RhdGVtZW50OiBmdW5jdGlvbihpZGVudGlmaWVyLCBwYXJhbWV0ZXJzLCBpc0xvY2FsLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdGdW5jdGlvbkRlY2xhcmF0aW9uJ1xuICAgICAgICAsIGlkZW50aWZpZXI6IGlkZW50aWZpZXJcbiAgICAgICAgLCBpc0xvY2FsOiBpc0xvY2FsXG4gICAgICAgICwgcGFyYW1ldGVyczogcGFyYW1ldGVyc1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBmb3JOdW1lcmljU3RhdGVtZW50OiBmdW5jdGlvbih2YXJpYWJsZSwgc3RhcnQsIGVuZCwgc3RlcCwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRm9yTnVtZXJpY1N0YXRlbWVudCdcbiAgICAgICAgLCB2YXJpYWJsZTogdmFyaWFibGVcbiAgICAgICAgLCBzdGFydDogc3RhcnRcbiAgICAgICAgLCBlbmQ6IGVuZFxuICAgICAgICAsIHN0ZXA6IHN0ZXBcbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgZm9yR2VuZXJpY1N0YXRlbWVudDogZnVuY3Rpb24odmFyaWFibGVzLCBpdGVyYXRvcnMsIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0ZvckdlbmVyaWNTdGF0ZW1lbnQnXG4gICAgICAgICwgdmFyaWFibGVzOiB2YXJpYWJsZXNcbiAgICAgICAgLCBpdGVyYXRvcnM6IGl0ZXJhdG9yc1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBjaHVuazogZnVuY3Rpb24oYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQ2h1bmsnXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGlkZW50aWZpZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInXG4gICAgICAgICwgbmFtZTogbmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGxpdGVyYWw6IGZ1bmN0aW9uKHR5cGUsIHZhbHVlLCByYXcpIHtcbiAgICAgIHR5cGUgPSAodHlwZSA9PT0gU3RyaW5nTGl0ZXJhbCkgPyAnU3RyaW5nTGl0ZXJhbCdcbiAgICAgICAgOiAodHlwZSA9PT0gTnVtZXJpY0xpdGVyYWwpID8gJ051bWVyaWNMaXRlcmFsJ1xuICAgICAgICA6ICh0eXBlID09PSBCb29sZWFuTGl0ZXJhbCkgPyAnQm9vbGVhbkxpdGVyYWwnXG4gICAgICAgIDogKHR5cGUgPT09IE5pbExpdGVyYWwpID8gJ05pbExpdGVyYWwnXG4gICAgICAgIDogJ1ZhcmFyZ0xpdGVyYWwnO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgICAgLCByYXc6IHJhd1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHRhYmxlS2V5OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdUYWJsZUtleSdcbiAgICAgICAgLCBrZXk6IGtleVxuICAgICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLCB0YWJsZUtleVN0cmluZzogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVGFibGVLZXlTdHJpbmcnXG4gICAgICAgICwga2V5OiBrZXlcbiAgICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgICwgdGFibGVWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1RhYmxlVmFsdWUnXG4gICAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cblxuXG4gICAgLCB0YWJsZUNvbnN0cnVjdG9yRXhwcmVzc2lvbjogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdUYWJsZUNvbnN0cnVjdG9yRXhwcmVzc2lvbidcbiAgICAgICAgLCBmaWVsZHM6IGZpZWxkc1xuICAgICAgfTtcbiAgICB9XG4gICAgLCBiaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciB0eXBlID0gKCdhbmQnID09PSBvcGVyYXRvciB8fCAnb3InID09PSBvcGVyYXRvcikgP1xuICAgICAgICAnTG9naWNhbEV4cHJlc3Npb24nIDpcbiAgICAgICAgJ0JpbmFyeUV4cHJlc3Npb24nO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICAgICAgLCBsZWZ0OiBsZWZ0XG4gICAgICAgICwgcmlnaHQ6IHJpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAsIHVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24ob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdVbmFyeUV4cHJlc3Npb24nXG4gICAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgICAgICwgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICB9O1xuICAgIH1cbiAgICAsIG1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uKGJhc2UsIGluZGV4ZXIsIGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nXG4gICAgICAgICwgaW5kZXhlcjogaW5kZXhlclxuICAgICAgICAsIGlkZW50aWZpZXI6IGlkZW50aWZpZXJcbiAgICAgICAgLCBiYXNlOiBiYXNlXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgaW5kZXhFeHByZXNzaW9uOiBmdW5jdGlvbihiYXNlLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnSW5kZXhFeHByZXNzaW9uJ1xuICAgICAgICAsIGJhc2U6IGJhc2VcbiAgICAgICAgLCBpbmRleDogaW5kZXhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBjYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgYXJncykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQ2FsbEV4cHJlc3Npb24nXG4gICAgICAgICwgYmFzZTogYmFzZVxuICAgICAgICAsICdhcmd1bWVudHMnOiBhcmdzXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgdGFibGVDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgYXJncykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVGFibGVDYWxsRXhwcmVzc2lvbidcbiAgICAgICAgLCBiYXNlOiBiYXNlXG4gICAgICAgICwgJ2FyZ3VtZW50cyc6IGFyZ3NcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBzdHJpbmdDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgYXJndW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1N0cmluZ0NhbGxFeHByZXNzaW9uJ1xuICAgICAgICAsIGJhc2U6IGJhc2VcbiAgICAgICAgLCBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBjb21tZW50OiBmdW5jdGlvbih2YWx1ZSwgcmF3KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdDb21tZW50J1xuICAgICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgICAsIHJhdzogcmF3XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBXcmFwIHVwIHRoZSBub2RlIG9iamVjdC5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlKG5vZGUpIHtcbiAgICAvLyBQb3AgYSBgTWFya2VyYCBvZmYgdGhlIGxvY2F0aW9uLWFycmF5IGFuZCBhdHRhY2ggaXRzIGxvY2F0aW9uIGRhdGEuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBsb2NhdGlvbnMucG9wKCk7XG4gICAgICBsb2NhdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgbG9jYXRpb24uYmxlc3Mobm9kZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9uQ3JlYXRlTm9kZSkgb3B0aW9ucy5vbkNyZWF0ZU5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLVxuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICwgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgO1xuXG4gIHZhciBpbmRleE9mID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGFycmF5LCBlbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IGVsZW1lbnQpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKVxuICAgIGluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH07XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHJldHVybiB0aGUgaW5kZXggb2YgYW4gb2JqZWN0XG4gIC8vIHdpdGggYSBtYXRjaGluZyBwcm9wZXJ0eS5cblxuICBmdW5jdGlvbiBpbmRleE9mT2JqZWN0KGFycmF5LCBwcm9wZXJ0eSwgZWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGFycmF5W2ldW3Byb3BlcnR5XSA9PT0gZWxlbWVudCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIEEgc3ByaW50ZiBpbXBsZW1lbnRhdGlvbiB1c2luZyAlaW5kZXggKGJlZ2lubmluZyBhdCAxKSB0byBpbnB1dFxuICAvLyBhcmd1bWVudHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBVbmV4cGVjdGVkIGZ1bmN0aW9uIGluIHRva2VuXG4gIC8vICAgICBzcHJpbnRmKCdVbmV4cGVjdGVkICUyIGluICUxLicsICd0b2tlbicsICdmdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHNwcmludGYoZm9ybWF0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICByZXR1cm4gJycgKyBhcmdzW2luZGV4IC0gMV0gfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gJyc7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIC8vIFBvbHlmaWxsIGZvciBgT2JqZWN0LmFzc2lnbmAuXG5cbiAgdmFyIGFzc2lnbiA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICwgc3JjLCBwcm9wO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHNyYyA9IGFyZ3NbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc3JjKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgcHJvcCkpIHtcbiAgICAgICAgICBkZXN0W3Byb3BdID0gc3JjW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKE9iamVjdC5hc3NpZ24pXG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuICAvLyAjIyMgRXJyb3IgZnVuY3Rpb25zXG5cbiAgZXhwb3J0cy5TeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xuXG4gIC8vIFhYWDogRWxpbWluYXRlIHRoaXMgZnVuY3Rpb24gYW5kIGNoYW5nZSB0aGUgZXJyb3IgdHlwZSB0byBiZSBkaWZmZXJlbnQgZnJvbSBTeW50YXhFcnJvci5cbiAgLy8gVGhpcyB3aWxsIHVuZm9ydHVuYXRlbHkgYmUgYSBicmVha2luZyBjaGFuZ2UsIGJlY2F1c2Ugc29tZSBkb3duc3RyZWFtIHVzZXJzIGRlcGVuZFxuICAvLyBvbiB0aGUgZXJyb3IgdGhyb3duIGJlaW5nIGFuIGluc3RhbmNlIG9mIFN5bnRheEVycm9yLiBGb3IgZXhhbXBsZSwgdGhlIEFjZSBlZGl0b3I6XG4gIC8vIDxodHRwczovL2dpdGh1Yi5jb20vYWpheG9yZy9hY2UvYmxvYi80YzdlNWViM2Y1ZDVjYTk0MzQ4NDdiZTUxODM0YTRlNDE2NjFiODUyL2xpYi9hY2UvbW9kZS9sdWFfd29ya2VyLmpzI0w1NT5cblxuICBmdW5jdGlvbiBmaXh1cEVycm9yKGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIU9iamVjdC5jcmVhdGUpXG4gICAgICByZXR1cm4gZTtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShlLCB7XG4gICAgICAnbGluZSc6IHsgJ3dyaXRhYmxlJzogdHJ1ZSwgdmFsdWU6IGUubGluZSB9LFxuICAgICAgJ2luZGV4JzogeyAnd3JpdGFibGUnOiB0cnVlLCB2YWx1ZTogZS5pbmRleCB9LFxuICAgICAgJ2NvbHVtbic6IHsgJ3dyaXRhYmxlJzogdHJ1ZSwgdmFsdWU6IGUuY29sdW1uIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vICMjIyMgUmFpc2UgYW4gZXhjZXB0aW9uLlxuICAvL1xuICAvLyBSYWlzZSBhbiBleGNlcHRpb24gYnkgcGFzc2luZyBhIHRva2VuLCBhIHN0cmluZyBmb3JtYXQgYW5kIGl0cyBwYXJhbXRlcnMuXG4gIC8vXG4gIC8vIFRoZSBwYXNzZWQgdG9rZW5zIGxvY2F0aW9uIHdpbGwgYXV0b21hdGljYWxseSBiZSBhZGRlZCB0byB0aGUgZXJyb3JcbiAgLy8gbWVzc2FnZSBpZiBpdCBleGlzdHMsIGlmIG5vdCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxleGVycyBjdXJyZW50XG4gIC8vIHBvc2l0aW9uLlxuICAvL1xuICAvLyBFeGFtcGxlOlxuICAvL1xuICAvLyAgICAgLy8gWzE6MF0gZXhwZWN0ZWQgWyBuZWFyIChcbiAgLy8gICAgIHJhaXNlKHRva2VuLCBcImV4cGVjdGVkICUxIG5lYXIgJTJcIiwgJ1snLCB0b2tlbi52YWx1ZSk7XG5cbiAgZnVuY3Rpb24gcmFpc2UodG9rZW4pIHtcbiAgICB2YXIgbWVzc2FnZSA9IHNwcmludGYuYXBwbHkobnVsbCwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKVxuICAgICAgLCBlcnJvciwgY29sO1xuXG4gICAgaWYgKHRva2VuID09PSBudWxsIHx8IHR5cGVvZiB0b2tlbi5saW5lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29sID0gaW5kZXggLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgZXJyb3IgPSBmaXh1cEVycm9yKG5ldyBTeW50YXhFcnJvcihzcHJpbnRmKCdbJTE6JTJdICUzJywgbGluZSwgY29sLCBtZXNzYWdlKSkpO1xuICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcbiAgICAgIGVycm9yLmxpbmUgPSBsaW5lO1xuICAgICAgZXJyb3IuY29sdW1uID0gY29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2wgPSB0b2tlbi5yYW5nZVswXSAtIHRva2VuLmxpbmVTdGFydDtcbiAgICAgIGVycm9yID0gZml4dXBFcnJvcihuZXcgU3ludGF4RXJyb3Ioc3ByaW50ZignWyUxOiUyXSAlMycsIHRva2VuLmxpbmUsIGNvbCwgbWVzc2FnZSkpKTtcbiAgICAgIGVycm9yLmxpbmUgPSB0b2tlbi5saW5lO1xuICAgICAgZXJyb3IuaW5kZXggPSB0b2tlbi5yYW5nZVswXTtcbiAgICAgIGVycm9yLmNvbHVtbiA9IGNvbDtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblZhbHVlKHRva2VuKSB7XG4gICAgdmFyIHJhdyA9IGlucHV0LnNsaWNlKHRva2VuLnJhbmdlWzBdLCB0b2tlbi5yYW5nZVsxXSk7XG4gICAgaWYgKHJhdylcbiAgICAgIHJldHVybiByYXc7XG4gICAgcmV0dXJuIHRva2VuLnZhbHVlO1xuICB9XG5cbiAgLy8gIyMjIyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuICAvL1xuICAvLyBFeGFtcGxlOlxuICAvL1xuICAvLyAgICAgLy8gZXhwZWN0ZWQgPG5hbWU+IG5lYXIgJzAnXG4gIC8vICAgICByYWlzZVVuZXhwZWN0ZWRUb2tlbignPG5hbWU+JywgdG9rZW4pO1xuXG4gIGZ1bmN0aW9uIHJhaXNlVW5leHBlY3RlZFRva2VuKHR5cGUsIHRva2VuKSB7XG4gICAgcmFpc2UodG9rZW4sIGVycm9ycy5leHBlY3RlZFRva2VuLCB0eXBlLCB0b2tlblZhbHVlKHRva2VuKSk7XG4gIH1cblxuICAvLyAjIyMjIFJhaXNlIGEgZ2VuZXJhbCB1bmV4cGVjdGVkIGVycm9yXG4gIC8vXG4gIC8vIFVzYWdlIHNob3VsZCBwYXNzIGVpdGhlciBhIHRva2VuIG9iamVjdCBvciBhIHN5bWJvbCBzdHJpbmcgd2hpY2ggd2FzXG4gIC8vIGV4cGVjdGVkLiBXZSBjYW4gYWxzbyBzcGVjaWZ5IGEgbmVhcmJ5IHRva2VuIHN1Y2ggYXMgPGVvZj4sIHRoaXMgd2lsbFxuICAvLyBkZWZhdWx0IHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRva2VuLlxuICAvL1xuICAvLyBFeGFtcGxlOlxuICAvL1xuICAvLyAgICAgLy8gVW5leHBlY3RlZCBzeW1ib2wgJ2VuZCcgbmVhciAnPGVvZj4nXG4gIC8vICAgICB1bmV4cGVjdGVkKHRva2VuKTtcbiAgLy9cbiAgLy8gSWYgdGhlcmUncyBubyB0b2tlbiBpbiB0aGUgYnVmZmVyIGl0IG1lYW5zIHdlIGhhdmUgcmVhY2hlZCA8ZW9mPi5cblxuICBmdW5jdGlvbiB1bmV4cGVjdGVkKGZvdW5kKSB7XG4gICAgdmFyIG5lYXIgPSB0b2tlblZhbHVlKGxvb2thaGVhZCk7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZm91bmQudHlwZSkge1xuICAgICAgdmFyIHR5cGU7XG4gICAgICBzd2l0Y2ggKGZvdW5kLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTdHJpbmdMaXRlcmFsOiAgIHR5cGUgPSAnc3RyaW5nJzsgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBLZXl3b3JkOiAgICAgICAgIHR5cGUgPSAna2V5d29yZCc7ICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJZGVudGlmaWVyOiAgICAgIHR5cGUgPSAnaWRlbnRpZmllcic7ICBicmVhaztcbiAgICAgICAgY2FzZSBOdW1lcmljTGl0ZXJhbDogIHR5cGUgPSAnbnVtYmVyJzsgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQdW5jdHVhdG9yOiAgICAgIHR5cGUgPSAnc3ltYm9sJzsgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCb29sZWFuTGl0ZXJhbDogIHR5cGUgPSAnYm9vbGVhbic7ICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOaWxMaXRlcmFsOlxuICAgICAgICAgIHJldHVybiByYWlzZShmb3VuZCwgZXJyb3JzLnVuZXhwZWN0ZWQsICdzeW1ib2wnLCAnbmlsJywgbmVhcik7XG4gICAgICAgIGNhc2UgRU9GOlxuICAgICAgICAgIHJldHVybiByYWlzZShmb3VuZCwgZXJyb3JzLnVuZXhwZWN0ZWRFT0YpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhaXNlKGZvdW5kLCBlcnJvcnMudW5leHBlY3RlZCwgdHlwZSwgdG9rZW5WYWx1ZShmb3VuZCksIG5lYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcmFpc2UoZm91bmQsIGVycm9ycy51bmV4cGVjdGVkLCAnc3ltYm9sJywgZm91bmQsIG5lYXIpO1xuICB9XG5cbiAgLy8gTGV4ZXJcbiAgLy8gLS0tLS1cbiAgLy9cbiAgLy8gVGhlIGxleGVyLCBvciB0aGUgdG9rZW5pemVyIHJlYWRzIHRoZSBpbnB1dCBzdHJpbmcgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlclxuICAvLyBhbmQgZGVyaXZlcyBhIHRva2VuIGxlZnQtcmlnaHQuIFRvIGJlIGFzIGVmZmljaWVudCBhcyBwb3NzaWJsZSB0aGUgbGV4ZXJcbiAgLy8gcHJpb3JpdGl6ZXMgdGhlIGNvbW1vbiBjYXNlcyBzdWNoIGFzIGlkZW50aWZpZXJzLiBJdCBhbHNvIHdvcmtzIHdpdGhcbiAgLy8gY2hhcmFjdGVyIGNvZGVzIGluc3RlYWQgb2YgY2hhcmFjdGVycyBhcyBzdHJpbmcgY29tcGFyaXNvbnMgd2FzIHRoZVxuICAvLyBiaWdnZXN0IGJvdHRsZW5lY2sgb2YgdGhlIHBhcnNlci5cbiAgLy9cbiAgLy8gSWYgYG9wdGlvbnMuY29tbWVudHNgIGlzIGVuYWJsZWQsIGFsbCBjb21tZW50cyBlbmNvdW50ZXJlZCB3aWxsIGJlIHN0b3JlZFxuICAvLyBpbiBhbiBhcnJheSB3aGljaCBsYXRlciB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBjaHVuayBvYmplY3QuIElmIGRpc2FibGVkLFxuICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIGRpc3JlZ2FyZGVkLlxuICAvL1xuICAvLyBXaGVuIHRoZSBsZXhlciBoYXMgZGVyaXZlZCBhIHZhbGlkIHRva2VuLCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGFuIG9iamVjdFxuICAvLyBjb250YWluaW5nIGl0cyB2YWx1ZSBhbmQgYXMgd2VsbCBhcyBpdHMgcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmluZyAodGhpc1xuICAvLyBpcyBhbHdheXMgZW5hYmxlZCB0byBwcm92aWRlIHByb3BlciBkZWJ1ZyBtZXNzYWdlcykuXG4gIC8vXG4gIC8vIGBsZXgoKWAgc3RhcnRzIGxleGluZyBhbmQgcmV0dXJucyB0aGUgZm9sbG93aW5nIHRva2VuIGluIHRoZSBzdHJlYW0uXG5cbiAgdmFyIGluZGV4XG4gICAgLCB0b2tlblxuICAgICwgcHJldmlvdXNUb2tlblxuICAgICwgbG9va2FoZWFkXG4gICAgLCBjb21tZW50c1xuICAgICwgdG9rZW5TdGFydFxuICAgICwgbGluZVxuICAgICwgbGluZVN0YXJ0O1xuXG4gIGV4cG9ydHMubGV4ID0gbGV4O1xuXG4gIGZ1bmN0aW9uIGxleCgpIHtcbiAgICBza2lwV2hpdGVTcGFjZSgpO1xuXG4gICAgLy8gU2tpcCBjb21tZW50cyBiZWdpbm5pbmcgd2l0aCAtLVxuICAgIHdoaWxlICg0NSA9PT0gaW5wdXQuY2hhckNvZGVBdChpbmRleCkgJiZcbiAgICAgICAgICAgNDUgPT09IGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAxKSkge1xuICAgICAgc2NhbkNvbW1lbnQoKTtcbiAgICAgIHNraXBXaGl0ZVNwYWNlKCk7XG4gICAgfVxuICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHJldHVybiB7XG4gICAgICAgIHR5cGUgOiBFT0ZcbiAgICAgICwgdmFsdWU6ICc8ZW9mPidcbiAgICAgICwgbGluZTogbGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW2luZGV4LCBpbmRleF1cbiAgICB9O1xuXG4gICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleClcbiAgICAgICwgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgIC8vIE1lbW9yaXplIHRoZSByYW5nZSBpbmRleCB3aGVyZSB0aGUgdG9rZW4gYmVnaW5zLlxuICAgIHRva2VuU3RhcnQgPSBpbmRleDtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2hhckNvZGUpKSByZXR1cm4gc2NhbklkZW50aWZpZXJPcktleXdvcmQoKTtcblxuICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgIGNhc2UgMzk6IGNhc2UgMzQ6IC8vICdcIlxuICAgICAgICByZXR1cm4gc2NhblN0cmluZ0xpdGVyYWwoKTtcblxuICAgICAgY2FzZSA0ODogY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzpcbiAgICAgIGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDAtOVxuICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG5cbiAgICAgIGNhc2UgNDY6IC8vIC5cbiAgICAgICAgLy8gSWYgdGhlIGRvdCBpcyBmb2xsb3dlZCBieSBhIGRpZ2l0IGl0J3MgYSBmbG9hdC5cbiAgICAgICAgaWYgKGlzRGVjRGlnaXQobmV4dCkpIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgaWYgKDQ2ID09PSBuZXh0KSB7XG4gICAgICAgICAgaWYgKDQ2ID09PSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMikpIHJldHVybiBzY2FuVmFyYXJnTGl0ZXJhbCgpO1xuICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignLi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJy4nKTtcblxuICAgICAgY2FzZSA2MTogLy8gPVxuICAgICAgICBpZiAoNjEgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignPT0nKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc9Jyk7XG5cbiAgICAgIGNhc2UgNjI6IC8vID5cbiAgICAgICAgaWYgKGZlYXR1cmVzLmJpdHdpc2VPcGVyYXRvcnMpXG4gICAgICAgICAgaWYgKDYyID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJz4+Jyk7XG4gICAgICAgIGlmICg2MSA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc+PScpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJz4nKTtcblxuICAgICAgY2FzZSA2MDogLy8gPFxuICAgICAgICBpZiAoZmVhdHVyZXMuYml0d2lzZU9wZXJhdG9ycylcbiAgICAgICAgICBpZiAoNjAgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignPDwnKTtcbiAgICAgICAgaWYgKDYxID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJzw9Jyk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignPCcpO1xuXG4gICAgICBjYXNlIDEyNjogLy8gflxuICAgICAgICBpZiAoNjEgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignfj0nKTtcbiAgICAgICAgaWYgKCFmZWF0dXJlcy5iaXR3aXNlT3BlcmF0b3JzKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJ34nKTtcblxuICAgICAgY2FzZSA1ODogLy8gOlxuICAgICAgICBpZiAoZmVhdHVyZXMubGFiZWxzKVxuICAgICAgICAgIGlmICg1OCA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc6OicpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJzonKTtcblxuICAgICAgY2FzZSA5MTogLy8gW1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBtdWx0aWxpbmUgc3RyaW5nLCB0aGV5IGJlZ2luIHdpdGggWz0gb3IgW1tcbiAgICAgICAgaWYgKDkxID09PSBuZXh0IHx8IDYxID09PSBuZXh0KSByZXR1cm4gc2NhbkxvbmdTdHJpbmdMaXRlcmFsKCk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignWycpO1xuXG4gICAgICBjYXNlIDQ3OiAvLyAvXG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlZ2VyIGRpdmlzaW9uIG9wICgvLylcbiAgICAgICAgaWYgKGZlYXR1cmVzLmludGVnZXJEaXZpc2lvbilcbiAgICAgICAgICBpZiAoNDcgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignLy8nKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCcvJyk7XG5cbiAgICAgIGNhc2UgMzg6IGNhc2UgMTI0OiAvLyAmIHxcbiAgICAgICAgaWYgKCFmZWF0dXJlcy5iaXR3aXNlT3BlcmF0b3JzKVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGZhbGwgdGhyb3VnaCAqL1xuICAgICAgY2FzZSA0MjogY2FzZSA5NDogY2FzZSAzNzogY2FzZSA0NDogY2FzZSAxMjM6IGNhc2UgMTI1OlxuICAgICAgY2FzZSA5MzogY2FzZSA0MDogY2FzZSA0MTogY2FzZSA1OTogY2FzZSAzNTogY2FzZSA0NTpcbiAgICAgIGNhc2UgNDM6IC8vICogXiAlICwgeyB9IF0gKCApIDsgIyAtICtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKGlucHV0LmNoYXJBdChpbmRleCkpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmV4cGVjdGVkKGlucHV0LmNoYXJBdChpbmRleCkpO1xuICB9XG5cbiAgLy8gV2hpdGVzcGFjZSBoYXMgbm8gc2VtYW50aWMgbWVhbmluZyBpbiBsdWEgc28gc2ltcGx5IHNraXAgYWhlYWQgd2hpbGVcbiAgLy8gdHJhY2tpbmcgdGhlIGVuY291bnRlZCBuZXdsaW5lcy4gQW55IGtpbmQgb2YgZW9sIHNlcXVlbmNlIGlzIGNvdW50ZWQgYXMgYVxuICAvLyBzaW5nbGUgbGluZS5cblxuICBmdW5jdGlvbiBjb25zdW1lRU9MKCkge1xuICAgIHZhciBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpXG4gICAgICAsIHBlZWtDaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoYXJDb2RlKSkge1xuICAgICAgLy8gQ291bnQgXFxuXFxyIGFuZCBcXHJcXG4gYXMgb25lIG5ld2xpbmUuXG4gICAgICBpZiAoMTAgPT09IGNoYXJDb2RlICYmIDEzID09PSBwZWVrQ2hhckNvZGUpICsraW5kZXg7XG4gICAgICBpZiAoMTMgPT09IGNoYXJDb2RlICYmIDEwID09PSBwZWVrQ2hhckNvZGUpICsraW5kZXg7XG4gICAgICArK2xpbmU7XG4gICAgICBsaW5lU3RhcnQgPSArK2luZGV4O1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlU3BhY2UoKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgIGlmIChpc1doaXRlU3BhY2UoY2hhckNvZGUpKSB7XG4gICAgICAgICsraW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKCFjb25zdW1lRU9MKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWRlbnRpZmllcnMsIGtleXdvcmRzLCBib29sZWFucyBhbmQgbmlsIGFsbCBsb29rIHRoZSBzYW1lIHN5bnRheCB3aXNlLiBXZVxuICAvLyBzaW1wbHkgZ28gdGhyb3VnaCB0aGVtIG9uZSBieSBvbmUgYW5kIGRlZmF1bHRpbmcgdG8gYW4gaWRlbnRpZmllciBpZiBub1xuICAvLyBwcmV2aW91cyBjYXNlIG1hdGNoZWQuXG5cbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXJPcktleXdvcmQoKSB7XG4gICAgdmFyIHZhbHVlLCB0eXBlO1xuXG4gICAgLy8gU2xpY2luZyB0aGUgaW5wdXQgc3RyaW5nIGlzIHByZWZlcmVkIGJlZm9yZSBzdHJpbmcgY29uY2F0ZW5hdGlvbiBpbiBhXG4gICAgLy8gbG9vcCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydChpbnB1dC5jaGFyQ29kZUF0KCsraW5kZXgpKSk7XG4gICAgdmFsdWUgPSBlbmNvZGluZ01vZGUuZml4dXAoaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcblxuICAgIC8vIERlY2lkZSBvbiB0aGUgdG9rZW4gdHlwZSBhbmQgcG9zc2libHkgY2FzdCB0aGUgdmFsdWUuXG4gICAgaWYgKGlzS2V5d29yZCh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSBLZXl3b3JkO1xuICAgIH0gZWxzZSBpZiAoJ3RydWUnID09PSB2YWx1ZSB8fCAnZmFsc2UnID09PSB2YWx1ZSkge1xuICAgICAgdHlwZSA9IEJvb2xlYW5MaXRlcmFsO1xuICAgICAgdmFsdWUgPSAoJ3RydWUnID09PSB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICgnbmlsJyA9PT0gdmFsdWUpIHtcbiAgICAgIHR5cGUgPSBOaWxMaXRlcmFsO1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gSWRlbnRpZmllcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgLCBsaW5lOiBsaW5lXG4gICAgICAsIGxpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbdG9rZW5TdGFydCwgaW5kZXhdXG4gICAgfTtcbiAgfVxuXG4gIC8vIE9uY2UgYSBwdW5jdHVhdG9yIHJlYWNoZXMgdGhpcyBmdW5jdGlvbiBpdCBzaG91bGQgYWxyZWFkeSBoYXZlIGJlZW5cbiAgLy8gdmFsaWRhdGVkIHNvIHdlIHNpbXBseSByZXR1cm4gaXQgYXMgYSB0b2tlbi5cblxuICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcih2YWx1ZSkge1xuICAgIGluZGV4ICs9IHZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBQdW5jdHVhdG9yXG4gICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgLCBsaW5lOiBsaW5lXG4gICAgICAsIGxpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbdG9rZW5TdGFydCwgaW5kZXhdXG4gICAgfTtcbiAgfVxuXG4gIC8vIEEgdmFyYXJnIGxpdGVyYWwgY29uc2lzdHMgb2YgdGhyZWUgZG90cy5cblxuICBmdW5jdGlvbiBzY2FuVmFyYXJnTGl0ZXJhbCgpIHtcbiAgICBpbmRleCArPSAzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFZhcmFyZ0xpdGVyYWxcbiAgICAgICwgdmFsdWU6ICcuLi4nXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gRmluZCB0aGUgc3RyaW5nIGxpdGVyYWwgYnkgbWF0Y2hpbmcgdGhlIGRlbGltaXRlciBtYXJrcyB1c2VkLlxuXG4gIGZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICAgIHZhciBkZWxpbWl0ZXIgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspXG4gICAgICAsIGJlZ2luTGluZSA9IGxpbmVcbiAgICAgICwgYmVnaW5MaW5lU3RhcnQgPSBsaW5lU3RhcnRcbiAgICAgICwgc3RyaW5nU3RhcnQgPSBpbmRleFxuICAgICAgLCBzdHJpbmcgPSBlbmNvZGluZ01vZGUuZGlzY2FyZFN0cmluZ3MgPyBudWxsIDogJydcbiAgICAgICwgY2hhckNvZGU7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gICAgICBpZiAoZGVsaW1pdGVyID09PSBjaGFyQ29kZSkgYnJlYWs7XG4gICAgICAvLyBFT0Ygb3IgYFxcbmAgdGVybWluYXRlcyBhIHN0cmluZyBsaXRlcmFsLiBJZiB3ZSBoYXZlbid0IGZvdW5kIHRoZVxuICAgICAgLy8gZW5kaW5nIGRlbGltaXRlciBieSBub3csIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgIGlmIChpbmRleCA+IGxlbmd0aCB8fCBpc0xpbmVUZXJtaW5hdG9yKGNoYXJDb2RlKSkge1xuICAgICAgICBzdHJpbmcgKz0gaW5wdXQuc2xpY2Uoc3RyaW5nU3RhcnQsIGluZGV4IC0gMSk7XG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy51bmZpbmlzaGVkU3RyaW5nLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCAtIDEpKTtcbiAgICAgIH1cbiAgICAgIGlmICg5MiA9PT0gY2hhckNvZGUpIHsgLy8gYmFja3NsYXNoXG4gICAgICAgIGlmICghZW5jb2RpbmdNb2RlLmRpc2NhcmRTdHJpbmdzKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZUVzY2FwZSA9IGlucHV0LnNsaWNlKHN0cmluZ1N0YXJ0LCBpbmRleCAtIDEpO1xuICAgICAgICAgIHN0cmluZyArPSBlbmNvZGluZ01vZGUuZml4dXAoYmVmb3JlRXNjYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXNjYXBlVmFsdWUgPSByZWFkRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgaWYgKCFlbmNvZGluZ01vZGUuZGlzY2FyZFN0cmluZ3MpXG4gICAgICAgICAgc3RyaW5nICs9IGVzY2FwZVZhbHVlO1xuICAgICAgICBzdHJpbmdTdGFydCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncykge1xuICAgICAgc3RyaW5nICs9IGVuY29kaW5nTW9kZS5lbmNvZGVCeXRlKG51bGwpO1xuICAgICAgc3RyaW5nICs9IGVuY29kaW5nTW9kZS5maXh1cChpbnB1dC5zbGljZShzdHJpbmdTdGFydCwgaW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogU3RyaW5nTGl0ZXJhbFxuICAgICAgLCB2YWx1ZTogc3RyaW5nXG4gICAgICAsIGxpbmU6IGJlZ2luTGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGJlZ2luTGluZVN0YXJ0XG4gICAgICAsIGxhc3RMaW5lOiBsaW5lXG4gICAgICAsIGxhc3RMaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW3Rva2VuU3RhcnQsIGluZGV4XVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBlY3QgYSBtdWx0aWxpbmUgc3RyaW5nIGxpdGVyYWwgYW5kIHJldHVybiBpdCBhcyBhIHJlZ3VsYXIgc3RyaW5nXG4gIC8vIGxpdGVyYWwsIGlmIGl0IGRvZXNuJ3QgdmFsaWRhdGUgaW50byBhIHZhbGlkIG11bHRpbGluZSBzdHJpbmcsIHRocm93IGFuXG4gIC8vIGV4Y2VwdGlvbi5cblxuICBmdW5jdGlvbiBzY2FuTG9uZ1N0cmluZ0xpdGVyYWwoKSB7XG4gICAgdmFyIGJlZ2luTGluZSA9IGxpbmVcbiAgICAgICwgYmVnaW5MaW5lU3RhcnQgPSBsaW5lU3RhcnRcbiAgICAgICwgc3RyaW5nID0gcmVhZExvbmdTdHJpbmcoZmFsc2UpO1xuICAgIC8vIEZhaWwgaWYgaXQncyBub3QgYSBtdWx0aWxpbmUgbGl0ZXJhbC5cbiAgICBpZiAoZmFsc2UgPT09IHN0cmluZykgcmFpc2UodG9rZW4sIGVycm9ycy5leHBlY3RlZCwgJ1snLCB0b2tlblZhbHVlKHRva2VuKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTdHJpbmdMaXRlcmFsXG4gICAgICAsIHZhbHVlOiBlbmNvZGluZ01vZGUuZGlzY2FyZFN0cmluZ3MgPyBudWxsIDogZW5jb2RpbmdNb2RlLmZpeHVwKHN0cmluZylcbiAgICAgICwgbGluZTogYmVnaW5MaW5lXG4gICAgICAsIGxpbmVTdGFydDogYmVnaW5MaW5lU3RhcnRcbiAgICAgICwgbGFzdExpbmU6IGxpbmVcbiAgICAgICwgbGFzdExpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbdG9rZW5TdGFydCwgaW5kZXhdXG4gICAgfTtcbiAgfVxuXG4gIC8vIE51bWVyaWMgbGl0ZXJhbHMgd2lsbCBiZSByZXR1cm5lZCBhcyBmbG9hdGluZy1wb2ludCBudW1iZXJzIGluc3RlYWQgb2ZcbiAgLy8gc3RyaW5ncy4gVGhlIHJhdyB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkIGZyb20gc2xpY2luZyB0aGUgaW5wdXQgc3RyaW5nXG4gIC8vIGxhdGVyIG9uIGluIHRoZSBwcm9jZXNzLlxuICAvL1xuICAvLyBJZiBhIGhleGFkZWNpbWFsIG51bWJlciBpcyBlbmNvdW50ZXJlZCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQuXG5cbiAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgIHZhciBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQXQoaW5kZXgpXG4gICAgICAsIG5leHQgPSBpbnB1dC5jaGFyQXQoaW5kZXggKyAxKTtcblxuICAgIHZhciBsaXRlcmFsID0gKCcwJyA9PT0gY2hhcmFjdGVyICYmICd4WCcuaW5kZXhPZihuZXh0IHx8IG51bGwpID49IDApID9cbiAgICAgIHJlYWRIZXhMaXRlcmFsKCkgOiByZWFkRGVjTGl0ZXJhbCgpO1xuXG4gICAgdmFyIGZvdW5kSW1hZ2luYXJ5VW5pdCA9IHJlYWRJbWFnaW5hcnlVbml0U3VmZml4KClcbiAgICAgICwgZm91bmRJbnQ2NFN1ZmZpeCA9IHJlYWRJbnQ2NFN1ZmZpeCgpO1xuXG4gICAgaWYgKGZvdW5kSW50NjRTdWZmaXggJiYgKGZvdW5kSW1hZ2luYXJ5VW5pdCB8fCBsaXRlcmFsLmhhc0ZyYWN0aW9uUGFydCkpIHtcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTnVtZXJpY0xpdGVyYWxcbiAgICAgICwgdmFsdWU6IGxpdGVyYWwudmFsdWVcbiAgICAgICwgbGluZTogbGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW3Rva2VuU3RhcnQsIGluZGV4XVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSW1hZ2luYXJ5VW5pdFN1ZmZpeCgpIHtcbiAgICBpZiAoIWZlYXR1cmVzLmltYWdpbmFyeU51bWJlcnMpIHJldHVybjtcblxuICAgIC8vIEltYWdpbmFyeSB1bml0IG51bWJlciBzdWZmaXggaXMgb3B0aW9uYWwuXG4gICAgLy8gU2VlIGh0dHA6Ly9sdWFqaXQub3JnL2V4dF9mZmlfYXBpLmh0bWwjbGl0ZXJhbHNcbiAgICBpZiAoJ2lJJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgKytpbmRleDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEludDY0U3VmZml4KCkge1xuICAgIGlmICghZmVhdHVyZXMuaW50ZWdlclN1ZmZpeGVzKSByZXR1cm47XG5cbiAgICAvLyBJbnQ2NC91aW50NjQgbnVtYmVyIHN1ZmZpeCBpcyBvcHRpb25hbC5cbiAgICAvLyBTZWUgaHR0cDovL2x1YWppdC5vcmcvZXh0X2ZmaV9hcGkuaHRtbCNsaXRlcmFsc1xuXG4gICAgaWYgKCd1VScuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAoJ2xMJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgICArK2luZGV4O1xuICAgICAgICBpZiAoJ2xMJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgcmV0dXJuICdVTEwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVMIGJ1dCBubyBMXG4gICAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVSBidXQgbm8gTFxuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ2xMJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgICArK2luZGV4O1xuICAgICAgICBpZiAoJ2xMJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgcmV0dXJuICdMTCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmlyc3QgTCBidXQgbm8gc2Vjb25kIExcbiAgICAgICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTHVhIGhleGFkZWNpbWFscyBoYXZlIGFuIG9wdGlvbmFsIGZyYWN0aW9uIHBhcnQgYW5kIGFuIG9wdGlvbmFsIGJpbmFyeVxuICAvLyBleG9wb25lbnQgcGFydC4gVGhlc2UgYXJlIG5vdCBpbmNsdWRlZCBpbiBKYXZhU2NyaXB0IHNvIHdlIHdpbGwgY29tcHV0ZVxuICAvLyBhbGwgdGhyZWUgcGFydHMgc2VwYXJhdGVseSBhbmQgdGhlbiBzdW0gdGhlbSB1cCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvblxuICAvLyB3aXRoIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLlxuICAvL1xuICAvLyAgICAgRGlnaXQgOj0gdG9EZWMoZGlnaXQpXG4gIC8vICAgICBGcmFjdGlvbiA6PSB0b0RlYyhmcmFjdGlvbikgLyAxNiBeIGZyYWN0aW9uQ291bnRcbiAgLy8gICAgIEJpbmFyeUV4cCA6PSAyIF4gYmluYXJ5RXhwXG4gIC8vICAgICBOdW1iZXIgOj0gKCBEaWdpdCArIEZyYWN0aW9uICkgKiBCaW5hcnlFeHBcblxuICBmdW5jdGlvbiByZWFkSGV4TGl0ZXJhbCgpIHtcbiAgICB2YXIgZnJhY3Rpb24gPSAwIC8vIGRlZmF1bHRzIHRvIDAgYXMgaXQgZ2V0cyBzdW1tZWRcbiAgICAgICwgYmluYXJ5RXhwb25lbnQgPSAxIC8vIGRlZmF1bHRzIHRvIDEgYXMgaXQgZ2V0cyBtdWx0aXBsaWVkXG4gICAgICAsIGJpbmFyeVNpZ24gPSAxIC8vIHBvc2l0aXZlXG4gICAgICAsIGRpZ2l0LCBmcmFjdGlvblN0YXJ0LCBleHBvbmVudFN0YXJ0LCBkaWdpdFN0YXJ0O1xuXG4gICAgZGlnaXRTdGFydCA9IGluZGV4ICs9IDI7IC8vIFNraXAgMHggcGFydFxuXG4gICAgLy8gQSBtaW5pbXVtIG9mIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgaWYgKCFpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSlcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG5cbiAgICB3aGlsZSAoaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgLy8gQ29udmVydCB0aGUgaGV4YWRlY2ltYWwgZGlnaXQgdG8gYmFzZSAxMC5cbiAgICBkaWdpdCA9IHBhcnNlSW50KGlucHV0LnNsaWNlKGRpZ2l0U3RhcnQsIGluZGV4KSwgMTYpO1xuXG4gICAgLy8gRnJhY3Rpb24gcGFydCBpcyBvcHRpb25hbC5cbiAgICB2YXIgZm91bmRGcmFjdGlvbiA9IGZhbHNlO1xuICAgIGlmICgnLicgPT09IGlucHV0LmNoYXJBdChpbmRleCkpIHtcbiAgICAgIGZvdW5kRnJhY3Rpb24gPSB0cnVlO1xuICAgICAgZnJhY3Rpb25TdGFydCA9ICsraW5kZXg7XG5cbiAgICAgIHdoaWxlIChpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgKytpbmRleDtcbiAgICAgIGZyYWN0aW9uID0gaW5wdXQuc2xpY2UoZnJhY3Rpb25TdGFydCwgaW5kZXgpO1xuXG4gICAgICAvLyBFbXB0eSBmcmFjdGlvbiBwYXJ0cyBzaG91bGQgZGVmYXVsdCB0byAwLCBvdGhlcnMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICAgICAgLy8gMC54IGZvcm0gc28gd2UgY2FuIHVzZSBzdW1tYXRpb24gYXQgdGhlIGVuZC5cbiAgICAgIGZyYWN0aW9uID0gKGZyYWN0aW9uU3RhcnQgPT09IGluZGV4KSA/IDBcbiAgICAgICAgOiBwYXJzZUludChmcmFjdGlvbiwgMTYpIC8gTWF0aC5wb3coMTYsIGluZGV4IC0gZnJhY3Rpb25TdGFydCk7XG4gICAgfVxuXG4gICAgLy8gQmluYXJ5IGV4cG9uZW50cyBhcmUgb3B0aW9uYWxcbiAgICB2YXIgZm91bmRCaW5hcnlFeHBvbmVudCA9IGZhbHNlO1xuICAgIGlmICgncFAnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICBmb3VuZEJpbmFyeUV4cG9uZW50ID0gdHJ1ZTtcbiAgICAgICsraW5kZXg7XG5cbiAgICAgIC8vIFNpZ24gcGFydCBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMSAocG9zaXRpdmUpLlxuICAgICAgaWYgKCcrLScuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApXG4gICAgICAgIGJpbmFyeVNpZ24gPSAoJysnID09PSBpbnB1dC5jaGFyQXQoaW5kZXgrKykpID8gMSA6IC0xO1xuXG4gICAgICBleHBvbmVudFN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIC8vIFRoZSBiaW5hcnkgZXhwb25lbnQgc2lnbiByZXF1aXJlcyBhIGRlY2ltYWwgZGlnaXQuXG4gICAgICBpZiAoIWlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKVxuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgICB3aGlsZSAoaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgICBiaW5hcnlFeHBvbmVudCA9IGlucHV0LnNsaWNlKGV4cG9uZW50U3RhcnQsIGluZGV4KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiaW5hcnkgZXhwb25lbnQgb2YgdGhlIG51bWJlci5cbiAgICAgIGJpbmFyeUV4cG9uZW50ID0gTWF0aC5wb3coMiwgYmluYXJ5RXhwb25lbnQgKiBiaW5hcnlTaWduKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IChkaWdpdCArIGZyYWN0aW9uKSAqIGJpbmFyeUV4cG9uZW50LFxuICAgICAgaGFzRnJhY3Rpb25QYXJ0OiBmb3VuZEZyYWN0aW9uIHx8IGZvdW5kQmluYXJ5RXhwb25lbnRcbiAgICB9O1xuICB9XG5cbiAgLy8gRGVjaW1hbCBudW1iZXJzIGFyZSBleGFjdGx5IHRoZSBzYW1lIGluIEx1YSBhbmQgaW4gSmF2YVNjcmlwdCwgYmVjYXVzZSBvZlxuICAvLyB0aGlzIHdlIGNoZWNrIHdoZXJlIHRoZSB0b2tlbiBlbmRzIGFuZCB0aGVuIHBhcnNlIGl0IHdpdGggbmF0aXZlXG4gIC8vIGZ1bmN0aW9ucy5cblxuICBmdW5jdGlvbiByZWFkRGVjTGl0ZXJhbCgpIHtcbiAgICB3aGlsZSAoaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgLy8gRnJhY3Rpb24gcGFydCBpcyBvcHRpb25hbFxuICAgIHZhciBmb3VuZEZyYWN0aW9uID0gZmFsc2U7XG4gICAgaWYgKCcuJyA9PT0gaW5wdXQuY2hhckF0KGluZGV4KSkge1xuICAgICAgZm91bmRGcmFjdGlvbiA9IHRydWU7XG4gICAgICArK2luZGV4O1xuICAgICAgLy8gRnJhY3Rpb24gcGFydCBkZWZhdWx0cyB0byAwXG4gICAgICB3aGlsZSAoaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgfVxuXG4gICAgLy8gRXhwb25lbnQgcGFydCBpcyBvcHRpb25hbC5cbiAgICB2YXIgZm91bmRFeHBvbmVudCA9IGZhbHNlO1xuICAgIGlmICgnZUUnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICBmb3VuZEV4cG9uZW50ID0gdHJ1ZTtcbiAgICAgICsraW5kZXg7XG4gICAgICAvLyBTaWduIHBhcnQgaXMgb3B0aW9uYWwuXG4gICAgICBpZiAoJystJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkgKytpbmRleDtcbiAgICAgIC8vIEFuIGV4cG9uZW50IGlzIHJlcXVpcmVkIHRvIGNvbnRhaW4gYXQgbGVhc3Qgb25lIGRlY2ltYWwgZGlnaXQuXG4gICAgICBpZiAoIWlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKVxuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgICB3aGlsZSAoaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSksXG4gICAgICBoYXNGcmFjdGlvblBhcnQ6IGZvdW5kRnJhY3Rpb24gfHwgZm91bmRFeHBvbmVudFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5pY29kZUVzY2FwZVNlcXVlbmNlKCkge1xuICAgIHZhciBzZXF1ZW5jZVN0YXJ0ID0gaW5kZXgrKztcblxuICAgIGlmIChpbnB1dC5jaGFyQXQoaW5kZXgrKykgIT09ICd7JylcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5icmFjZUV4cGVjdGVkLCAneycsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KSk7XG4gICAgaWYgKCFpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSlcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5oZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KSk7XG5cbiAgICB3aGlsZSAoaW5wdXQuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MzApICsraW5kZXg7XG4gICAgdmFyIGVzY1N0YXJ0ID0gaW5kZXg7XG5cbiAgICB3aGlsZSAoaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAoaW5kZXggLSBlc2NTdGFydCA+IDYpXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy50b29MYXJnZUNvZGVwb2ludCwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcbiAgICB9XG5cbiAgICB2YXIgYiA9IGlucHV0LmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoYiAhPT0gJ30nKSB7XG4gICAgICBpZiAoKGIgPT09ICdcIicpIHx8IChiID09PSBcIidcIikpXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5icmFjZUV4cGVjdGVkLCAnfScsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4LS0pKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmhleGFkZWNpbWFsRGlnaXRFeHBlY3RlZCwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcbiAgICB9XG5cbiAgICB2YXIgY29kZXBvaW50ID0gcGFyc2VJbnQoaW5wdXQuc2xpY2UoZXNjU3RhcnQsIGluZGV4IC0gMSkgfHwgJzAnLCAxNik7XG4gICAgdmFyIGZyYWcgPSAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCk7XG5cbiAgICBpZiAoY29kZXBvaW50ID4gMHgxMGZmZmYpIHtcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy50b29MYXJnZUNvZGVwb2ludCwgZnJhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kaW5nTW9kZS5lbmNvZGVVVEY4KGNvZGVwb2ludCwgZnJhZyk7XG4gIH1cblxuICAvLyBUcmFuc2xhdGUgZXNjYXBlIHNlcXVlbmNlcyB0byB0aGUgYWN0dWFsIGNoYXJhY3RlcnMuXG4gIGZ1bmN0aW9uIHJlYWRFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICB2YXIgc2VxdWVuY2VTdGFydCA9IGluZGV4O1xuICAgIHN3aXRjaCAoaW5wdXQuY2hhckF0KGluZGV4KSkge1xuICAgICAgLy8gTHVhIGFsbG93IHRoZSBmb2xsb3dpbmcgZXNjYXBlIHNlcXVlbmNlcy5cbiAgICAgIGNhc2UgJ2EnOiArK2luZGV4OyByZXR1cm4gJ1xceDA3JztcbiAgICAgIGNhc2UgJ24nOiArK2luZGV4OyByZXR1cm4gJ1xcbic7XG4gICAgICBjYXNlICdyJzogKytpbmRleDsgcmV0dXJuICdcXHInO1xuICAgICAgY2FzZSAndCc6ICsraW5kZXg7IHJldHVybiAnXFx0JztcbiAgICAgIGNhc2UgJ3YnOiArK2luZGV4OyByZXR1cm4gJ1xceDBiJztcbiAgICAgIGNhc2UgJ2InOiArK2luZGV4OyByZXR1cm4gJ1xcYic7XG4gICAgICBjYXNlICdmJzogKytpbmRleDsgcmV0dXJuICdcXGYnO1xuXG4gICAgICAvLyBCYWNrc2xhc2ggYXQgdGhlIGVuZCBvZiB0aGUgbGluZS4gV2UgdHJlYXQgYWxsIGxpbmUgZW5kaW5ncyBhcyBlcXVpdmFsZW50LFxuICAgICAgLy8gYW5kIGFzIHJlcHJlc2VudGluZyB0aGUgW0xGXSBjaGFyYWN0ZXIgKGNvZGUgMTApLiBMdWEgNS4xIHRocm91Z2ggNS4zXG4gICAgICAvLyBoYXZlIGJlZW4gdmVyaWZpZWQgdG8gYmVoYXZlIHRoZSBzYW1lIHdheS5cbiAgICAgIGNhc2UgJ1xccic6XG4gICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjb25zdW1lRU9MKCk7XG4gICAgICAgIHJldHVybiAnXFxuJztcblxuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICAvLyBcXGRkZCwgd2hlcmUgZGRkIGlzIGEgc2VxdWVuY2Ugb2YgdXAgdG8gdGhyZWUgZGVjaW1hbCBkaWdpdHMuXG4gICAgICAgIHdoaWxlIChpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSAmJiBpbmRleCAtIHNlcXVlbmNlU3RhcnQgPCAzKSArK2luZGV4O1xuXG4gICAgICAgIHZhciBmcmFnID0gaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpO1xuICAgICAgICB2YXIgZGRkID0gcGFyc2VJbnQoZnJhZywgMTApO1xuICAgICAgICBpZiAoZGRkID4gMjU1KSB7XG4gICAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmRlY2ltYWxFc2NhcGVUb29MYXJnZSwgJ1xcXFwnICsgZGRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RpbmdNb2RlLmVuY29kZUJ5dGUoZGRkLCAnXFxcXCcgKyBmcmFnKTtcblxuICAgICAgY2FzZSAneic6XG4gICAgICAgIGlmIChmZWF0dXJlcy5za2lwV2hpdGVzcGFjZUVzY2FwZSkge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgc2tpcFdoaXRlU3BhY2UoKTtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICBpZiAoZmVhdHVyZXMuaGV4RXNjYXBlcykge1xuICAgICAgICAgIC8vIFxceFhYLCB3aGVyZSBYWCBpcyBhIHNlcXVlbmNlIG9mIGV4YWN0bHkgdHdvIGhleGFkZWNpbWFsIGRpZ2l0c1xuICAgICAgICAgIGlmIChpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAxKSkgJiZcbiAgICAgICAgICAgICAgaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMikpKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nTW9kZS5lbmNvZGVCeXRlKHBhcnNlSW50KGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQgKyAxLCBpbmRleCksIDE2KSwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmhleGFkZWNpbWFsRGlnaXRFeHBlY3RlZCwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXggKyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgICBpZiAoZmVhdHVyZXMudW5pY29kZUVzY2FwZXMpXG4gICAgICAgICAgcmV0dXJuIHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1xcXFwnOiBjYXNlICdcIic6IGNhc2UgXCInXCI6XG4gICAgICAgIHJldHVybiBpbnB1dC5jaGFyQXQoaW5kZXgrKyk7XG4gICAgfVxuXG4gICAgaWYgKGZlYXR1cmVzLnN0cmljdEVzY2FwZXMpXG4gICAgICByYWlzZShudWxsLCBlcnJvcnMuaW52YWxpZEVzY2FwZSwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXggKyAxKSk7XG4gICAgcmV0dXJuIGlucHV0LmNoYXJBdChpbmRleCsrKTtcbiAgfVxuXG4gIC8vIENvbW1lbnRzIGJlZ2luIHdpdGggLS0gYWZ0ZXIgd2hpY2ggaXQgd2lsbCBiZSBkZWNpZGVkIGlmIHRoZXkgYXJlXG4gIC8vIG11bHRpbGluZSBjb21tZW50cyBvciBub3QuXG4gIC8vXG4gIC8vIFRoZSBtdWx0aWxpbmUgZnVuY3Rpb25hbGl0eSB3b3JrcyB0aGUgZXhhY3Qgc2FtZSB3YXkgYXMgd2l0aCBzdHJpbmdcbiAgLy8gbGl0ZXJhbHMgc28gd2UgcmV1c2UgdGhlIGZ1bmN0aW9uYWxpdHkuXG5cbiAgZnVuY3Rpb24gc2NhbkNvbW1lbnQoKSB7XG4gICAgdG9rZW5TdGFydCA9IGluZGV4O1xuICAgIGluZGV4ICs9IDI7IC8vIC0tXG5cbiAgICB2YXIgY2hhcmFjdGVyID0gaW5wdXQuY2hhckF0KGluZGV4KVxuICAgICAgLCBjb250ZW50ID0gJydcbiAgICAgICwgaXNMb25nID0gZmFsc2VcbiAgICAgICwgY29tbWVudFN0YXJ0ID0gaW5kZXhcbiAgICAgICwgbGluZVN0YXJ0Q29tbWVudCA9IGxpbmVTdGFydFxuICAgICAgLCBsaW5lQ29tbWVudCA9IGxpbmU7XG5cbiAgICBpZiAoJ1snID09PSBjaGFyYWN0ZXIpIHtcbiAgICAgIGNvbnRlbnQgPSByZWFkTG9uZ1N0cmluZyh0cnVlKTtcbiAgICAgIC8vIFRoaXMgd2Fzbid0IGEgbXVsdGlsaW5lIGNvbW1lbnQgYWZ0ZXIgYWxsLlxuICAgICAgaWYgKGZhbHNlID09PSBjb250ZW50KSBjb250ZW50ID0gY2hhcmFjdGVyO1xuICAgICAgZWxzZSBpc0xvbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBTY2FuIHVudGlsIG5leHQgbGluZSBhcyBsb25nIGFzIGl0J3Mgbm90IGEgbXVsdGlsaW5lIGNvbW1lbnQuXG4gICAgaWYgKCFpc0xvbmcpIHtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpIGJyZWFrO1xuICAgICAgICArK2luZGV4O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIGNvbnRlbnQgPSBpbnB1dC5zbGljZShjb21tZW50U3RhcnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jb21tZW50cykge1xuICAgICAgdmFyIG5vZGUgPSBhc3QuY29tbWVudChjb250ZW50LCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgICAvLyBgTWFya2VyYHMgZGVwZW5kIG9uIHRva2VucyBhdmFpbGFibGUgaW4gdGhlIHBhcnNlciBhbmQgYXMgY29tbWVudHMgYXJlXG4gICAgICAvLyBpbnRlcmNlcHRlZCBpbiB0aGUgbGV4ZXIgYWxsIGxvY2F0aW9uIGRhdGEgaXMgc2V0IG1hbnVhbGx5LlxuICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgIG5vZGUubG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogbGluZUNvbW1lbnQsIGNvbHVtbjogdG9rZW5TdGFydCAtIGxpbmVTdGFydENvbW1lbnQgfVxuICAgICAgICAgICwgZW5kOiB7IGxpbmU6IGxpbmUsIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgIG5vZGUucmFuZ2UgPSBbdG9rZW5TdGFydCwgaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub25DcmVhdGVOb2RlKSBvcHRpb25zLm9uQ3JlYXRlTm9kZShub2RlKTtcbiAgICAgIGNvbW1lbnRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCBhIG11bHRpbGluZSBzdHJpbmcgYnkgY2FsY3VsYXRpbmcgdGhlIGRlcHRoIG9mIGA9YCBjaGFyYWN0ZXJzIGFuZFxuICAvLyB0aGVuIGFwcGVuZGluZyB1bnRpbCBhbiBlcXVhbCBkZXB0aCBpcyBmb3VuZC5cblxuICBmdW5jdGlvbiByZWFkTG9uZ1N0cmluZyhpc0NvbW1lbnQpIHtcbiAgICB2YXIgbGV2ZWwgPSAwXG4gICAgICAsIGNvbnRlbnQgPSAnJ1xuICAgICAgLCB0ZXJtaW5hdG9yID0gZmFsc2VcbiAgICAgICwgY2hhcmFjdGVyLCBzdHJpbmdTdGFydCwgZmlyc3RMaW5lID0gbGluZTtcblxuICAgICsraW5kZXg7IC8vIFtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGVwdGggb2YgdGhlIGNvbW1lbnQuXG4gICAgd2hpbGUgKCc9JyA9PT0gaW5wdXQuY2hhckF0KGluZGV4ICsgbGV2ZWwpKSArK2xldmVsO1xuICAgIC8vIEV4aXQsIHRoaXMgaXMgbm90IGEgbG9uZyBzdHJpbmcgYWZ0ZXJhbGwuXG4gICAgaWYgKCdbJyAhPT0gaW5wdXQuY2hhckF0KGluZGV4ICsgbGV2ZWwpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpbmRleCArPSBsZXZlbCArIDE7XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIGEgbmV3bGluZSwgaWdub3JlIGl0IGFuZCBiZWdpbiBvbiBuZXh0IGxpbmUuXG4gICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSBjb25zdW1lRU9MKCk7XG5cbiAgICBzdHJpbmdTdGFydCA9IGluZGV4O1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgLy8gVG8ga2VlcCB0cmFjayBvZiBsaW5lIG51bWJlcnMgcnVuIHRoZSBgY29uc3VtZUVPTCgpYCB3aGljaCBpbmNyZW1lbnRzXG4gICAgICAvLyBpdHMgY291bnRlci5cbiAgICAgIHdoaWxlIChpc0xpbmVUZXJtaW5hdG9yKGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgY29uc3VtZUVPTCgpO1xuXG4gICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQXQoaW5kZXgrKyk7XG5cbiAgICAgIC8vIE9uY2UgdGhlIGRlbGltaXRlciBpcyBmb3VuZCwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBkZXB0aCBjb3VudCBhbmQgc2VlXG4gICAgICAvLyBpZiBpdCBtYXRjaGVzLlxuICAgICAgaWYgKCddJyA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgIHRlcm1pbmF0b3IgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsOyArK2kpIHtcbiAgICAgICAgICBpZiAoJz0nICE9PSBpbnB1dC5jaGFyQXQoaW5kZXggKyBpKSkgdGVybWluYXRvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnXScgIT09IGlucHV0LmNoYXJBdChpbmRleCArIGxldmVsKSkgdGVybWluYXRvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG11bHRpbGluZSBzdHJpbmcuIEdldCBvdXQgbm93LlxuICAgICAgaWYgKHRlcm1pbmF0b3IpIHtcbiAgICAgICAgY29udGVudCArPSBpbnB1dC5zbGljZShzdHJpbmdTdGFydCwgaW5kZXggLSAxKTtcbiAgICAgICAgaW5kZXggKz0gbGV2ZWwgKyAxO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZShudWxsLCBpc0NvbW1lbnQgP1xuICAgICAgICAgICAgICAgIGVycm9ycy51bmZpbmlzaGVkTG9uZ0NvbW1lbnQgOlxuICAgICAgICAgICAgICAgIGVycm9ycy51bmZpbmlzaGVkTG9uZ1N0cmluZyxcbiAgICAgICAgICBmaXJzdExpbmUsICc8ZW9mPicpO1xuICB9XG5cbiAgLy8gIyMgTGV4IGZ1bmN0aW9ucyBhbmQgaGVscGVycy5cblxuICAvLyBSZWFkIHRoZSBuZXh0IHRva2VuLlxuICAvL1xuICAvLyBUaGlzIGlzIGFjdHVhbGx5IGRvbmUgYnkgc2V0dGluZyB0aGUgY3VycmVudCB0b2tlbiB0byB0aGUgbG9va2FoZWFkIGFuZFxuICAvLyByZWFkaW5nIGluIHRoZSBuZXcgbG9va2FoZWFkIHRva2VuLlxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgIGxvb2thaGVhZCA9IGxleCgpO1xuICB9XG5cbiAgLy8gQ29uc3VtZSBhIHRva2VuIGlmIGl0cyB2YWx1ZSBtYXRjaGVzLiBPbmNlIGNvbnN1bWVkIG9yIG5vdCwgcmV0dXJuIHRoZVxuICAvLyBzdWNjZXNzIG9mIHRoZSBvcGVyYXRpb24uXG5cbiAgZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdG9rZW4udmFsdWUpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdmFsdWUgdG8gbWF0Y2guIElmIG5vdCwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdG9rZW4udmFsdWUpIG5leHQoKTtcbiAgICBlbHNlIHJhaXNlKHRva2VuLCBlcnJvcnMuZXhwZWN0ZWQsIHZhbHVlLCB0b2tlblZhbHVlKHRva2VuKSk7XG4gIH1cblxuICAvLyAjIyMgVmFsaWRhdGlvbiBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gOSA9PT0gY2hhckNvZGUgfHwgMzIgPT09IGNoYXJDb2RlIHx8IDB4QiA9PT0gY2hhckNvZGUgfHwgMHhDID09PSBjaGFyQ29kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gMTAgPT09IGNoYXJDb2RlIHx8IDEzID09PSBjaGFyQ29kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVjRGlnaXQoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTc7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykgfHwgKGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMikgfHwgKGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKTtcbiAgfVxuXG4gIC8vIEZyb20gW0x1YSA1LjJdKGh0dHA6Ly93d3cubHVhLm9yZy9tYW51YWwvNS4yL21hbnVhbC5odG1sIzguMSkgb253YXJkc1xuICAvLyBpZGVudGlmaWVycyBjYW5ub3QgdXNlICdsb2NhbGUtZGVwZW5kZW50JyBsZXR0ZXJzIChpLmUuIGRlcGVuZGVudCBvbiB0aGUgQyBsb2NhbGUpLlxuICAvLyBPbiB0aGUgb3RoZXIgaGFuZCwgTHVhSklUIGFsbG93cyBhcmJpdHJhcnkgb2N0ZXRzIOKJpSAxMjggaW4gaWRlbnRpZmllcnMuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2hhckNvZGUpIHtcbiAgICBpZiAoKGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDkwKSB8fCAoY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTIyKSB8fCA5NSA9PT0gY2hhckNvZGUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZmVhdHVyZXMuZXh0ZW5kZWRJZGVudGlmaWVycyAmJiBjaGFyQ29kZSA+PSAxMjgpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoYXJDb2RlKSB7XG4gICAgaWYgKChjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA5MCkgfHwgKGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEyMikgfHwgOTUgPT09IGNoYXJDb2RlIHx8IChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZmVhdHVyZXMuZXh0ZW5kZWRJZGVudGlmaWVycyAmJiBjaGFyQ29kZSA+PSAxMjgpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBbMy4xIExleGljYWwgQ29udmVudGlvbnNdKGh0dHA6Ly93d3cubHVhLm9yZy9tYW51YWwvNS4yL21hbnVhbC5odG1sIzMuMSlcbiAgLy9cbiAgLy8gYHRydWVgLCBgZmFsc2VgIGFuZCBgbmlsYCB3aWxsIG5vdCBiZSBjb25zaWRlcmVkIGtleXdvcmRzLCBidXQgbGl0ZXJhbHMuXG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuICdkbycgPT09IGlkIHx8ICdpZicgPT09IGlkIHx8ICdpbicgPT09IGlkIHx8ICdvcicgPT09IGlkO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gJ2FuZCcgPT09IGlkIHx8ICdlbmQnID09PSBpZCB8fCAnZm9yJyA9PT0gaWQgfHwgJ25vdCcgPT09IGlkO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBpZiAoJ2Vsc2UnID09PSBpZCB8fCAndGhlbicgPT09IGlkKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZmVhdHVyZXMubGFiZWxzICYmICFmZWF0dXJlcy5jb250ZXh0dWFsR290bylcbiAgICAgICAgICByZXR1cm4gKCdnb3RvJyA9PT0gaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiAnYnJlYWsnID09PSBpZCB8fCAnbG9jYWwnID09PSBpZCB8fCAndW50aWwnID09PSBpZCB8fCAnd2hpbGUnID09PSBpZDtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuICdlbHNlaWYnID09PSBpZCB8fCAncmVwZWF0JyA9PT0gaWQgfHwgJ3JldHVybicgPT09IGlkO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJyA9PT0gaWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5hcnkodG9rZW4pIHtcbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkgcmV0dXJuICcjLX4nLmluZGV4T2YodG9rZW4udmFsdWUpID49IDA7XG4gICAgaWYgKEtleXdvcmQgPT09IHRva2VuLnR5cGUpIHJldHVybiAnbm90JyA9PT0gdG9rZW4udmFsdWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHRva2VuIHN5bnRhY3RpY2FsbHkgY2xvc2VzIGEgYmxvY2suXG5cbiAgZnVuY3Rpb24gaXNCbG9ja0ZvbGxvdyh0b2tlbikge1xuICAgIGlmIChFT0YgPT09IHRva2VuLnR5cGUpIHJldHVybiB0cnVlO1xuICAgIGlmIChLZXl3b3JkICE9PSB0b2tlbi50eXBlKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgY2FzZSAnZWxzZSc6IGNhc2UgJ2Vsc2VpZic6XG4gICAgICBjYXNlICdlbmQnOiBjYXNlICd1bnRpbCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNjb3BlXG4gIC8vIC0tLS0tXG5cbiAgLy8gU3RvcmUgZWFjaCBibG9jayBzY29wZSBhcyBhIGFuIGFycmF5IG9mIGlkZW50aWZpZXIgbmFtZXMuIEVhY2ggc2NvcGUgaXNcbiAgLy8gc3RvcmVkIGluIGFuIEZJTE8tYXJyYXkuXG4gIHZhciBzY29wZXNcbiAgICAvLyBUaGUgY3VycmVudCBzY29wZSBpbmRleFxuICAgICwgc2NvcGVEZXB0aFxuICAgIC8vIEEgbGlzdCBvZiBhbGwgZ2xvYmFsIGlkZW50aWZpZXIgbm9kZXMuXG4gICAgLCBnbG9iYWxzO1xuXG4gIC8vIENyZWF0ZSBhIG5ldyBzY29wZSBpbmhlcml0aW5nIGFsbCBkZWNsYXJhdGlvbnMgZnJvbSB0aGUgcHJldmlvdXMgc2NvcGUuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNjb3BlKCkge1xuICAgIHZhciBzY29wZSA9IHNjb3Blc1tzY29wZURlcHRoKytdLnNsaWNlKCk7XG4gICAgc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgIGlmIChvcHRpb25zLm9uQ3JlYXRlU2NvcGUpIG9wdGlvbnMub25DcmVhdGVTY29wZSgpO1xuICB9XG5cbiAgLy8gRXhpdCBhbmQgcmVtb3ZlIHRoZSBjdXJyZW50IHNjb3BlLlxuICBmdW5jdGlvbiBkZXN0cm95U2NvcGUoKSB7XG4gICAgdmFyIHNjb3BlID0gc2NvcGVzLnBvcCgpO1xuICAgIC0tc2NvcGVEZXB0aDtcbiAgICBpZiAob3B0aW9ucy5vbkRlc3Ryb3lTY29wZSkgb3B0aW9ucy5vbkRlc3Ryb3lTY29wZSgpO1xuICB9XG5cbiAgLy8gQWRkIGlkZW50aWZpZXIgbmFtZSB0byB0aGUgY3VycmVudCBzY29wZSBpZiBpdCBkb2VzbnQgYWxyZWFkeSBleGlzdC5cbiAgZnVuY3Rpb24gc2NvcGVJZGVudGlmaWVyTmFtZShuYW1lKSB7XG4gICAgaWYgKG9wdGlvbnMub25Mb2NhbERlY2xhcmF0aW9uKSBvcHRpb25zLm9uTG9jYWxEZWNsYXJhdGlvbihuYW1lKTtcbiAgICBpZiAoLTEgIT09IGluZGV4T2Yoc2NvcGVzW3Njb3BlRGVwdGhdLCBuYW1lKSkgcmV0dXJuO1xuICAgIHNjb3Blc1tzY29wZURlcHRoXS5wdXNoKG5hbWUpO1xuICB9XG5cbiAgLy8gQWRkIGlkZW50aWZpZXIgdG8gdGhlIGN1cnJlbnQgc2NvcGVcbiAgZnVuY3Rpb24gc2NvcGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBzY29wZUlkZW50aWZpZXJOYW1lKG5vZGUubmFtZSk7XG4gICAgYXR0YWNoU2NvcGUobm9kZSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBBdHRhY2ggc2NvcGUgaW5mb3JtYXRpb24gdG8gbm9kZS4gSWYgdGhlIG5vZGUgaXMgZ2xvYmFsLCBzdG9yZSBpdCBpbiB0aGVcbiAgLy8gZ2xvYmFscyBhcnJheSBzbyB3ZSBjYW4gcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiB0byB0aGUgdXNlci5cbiAgZnVuY3Rpb24gYXR0YWNoU2NvcGUobm9kZSwgaXNMb2NhbCkge1xuICAgIGlmICghaXNMb2NhbCAmJiAtMSA9PT0gaW5kZXhPZk9iamVjdChnbG9iYWxzLCAnbmFtZScsIG5vZGUubmFtZSkpXG4gICAgICBnbG9iYWxzLnB1c2gobm9kZSk7XG5cbiAgICBub2RlLmlzTG9jYWwgPSBpc0xvY2FsO1xuICB9XG5cbiAgLy8gSXMgdGhlIGlkZW50aWZpZXIgbmFtZSBhdmFpbGFibGUgaW4gdGhpcyBzY29wZS5cbiAgZnVuY3Rpb24gc2NvcGVIYXNOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gKC0xICE9PSBpbmRleE9mKHNjb3Blc1tzY29wZURlcHRoXSwgbmFtZSkpO1xuICB9XG5cbiAgLy8gTG9jYXRpb24gdHJhY2tpbmdcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gTG9jYXRpb25zIGFyZSBzdG9yZWQgaW4gRklMTy1hcnJheSBhcyBhIGBNYXJrZXJgIG9iamVjdCBjb25zaXN0aW5nIG9mIGJvdGhcbiAgLy8gYGxvY2AgYW5kIGByYW5nZWAgZGF0YS4gT25jZSBhIGBNYXJrZXJgIGlzIHBvcHBlZCBvZmYgdGhlIGxpc3QgYW4gZW5kXG4gIC8vIGxvY2F0aW9uIGlzIGFkZGVkIGFuZCB0aGUgZGF0YSBpcyBhdHRhY2hlZCB0byBhIHN5bnRheCBub2RlLlxuXG4gIHZhciBsb2NhdGlvbnMgPSBbXVxuICAgICwgdHJhY2tMb2NhdGlvbnM7XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb25NYXJrZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXIodG9rZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gTWFya2VyKHRva2VuKSB7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICB0aGlzLmxvYyA9IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgbGluZTogdG9rZW4ubGluZVxuICAgICAgICAgICwgY29sdW1uOiB0b2tlbi5yYW5nZVswXSAtIHRva2VuLmxpbmVTdGFydFxuICAgICAgICB9XG4gICAgICAgICwgZW5kOiB7XG4gICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgICAgLCBjb2x1bW46IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKSB0aGlzLnJhbmdlID0gW3Rva2VuLnJhbmdlWzBdLCAwXTtcbiAgfVxuXG4gIC8vIENvbXBsZXRlIHRoZSBsb2NhdGlvbiBkYXRhIHN0b3JlZCBpbiB0aGUgYE1hcmtlcmAgYnkgYWRkaW5nIHRoZSBsb2NhdGlvblxuICAvLyBvZiB0aGUgKnByZXZpb3VzIHRva2VuKiBhcyBhbiBlbmQgbG9jYXRpb24uXG4gIE1hcmtlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHRoaXMubG9jLmVuZC5saW5lID0gcHJldmlvdXNUb2tlbi5sYXN0TGluZSB8fCBwcmV2aW91c1Rva2VuLmxpbmU7XG4gICAgICB0aGlzLmxvYy5lbmQuY29sdW1uID0gcHJldmlvdXNUb2tlbi5yYW5nZVsxXSAtIChwcmV2aW91c1Rva2VuLmxhc3RMaW5lU3RhcnQgfHwgcHJldmlvdXNUb2tlbi5saW5lU3RhcnQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgIHRoaXMucmFuZ2VbMV0gPSBwcmV2aW91c1Rva2VuLnJhbmdlWzFdO1xuICAgIH1cbiAgfTtcblxuICBNYXJrZXIucHJvdG90eXBlLmJsZXNzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAodGhpcy5sb2MpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvYztcbiAgICAgIG5vZGUubG9jID0ge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGxpbmU6IGxvYy5zdGFydC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogbG9jLnN0YXJ0LmNvbHVtblxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICBsaW5lOiBsb2MuZW5kLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBsb2MuZW5kLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5yYW5nZSkge1xuICAgICAgbm9kZS5yYW5nZSA9IFtcbiAgICAgICAgdGhpcy5yYW5nZVswXSxcbiAgICAgICAgdGhpcy5yYW5nZVsxXVxuICAgICAgXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGBNYXJrZXJgIGFuZCBhZGQgaXQgdG8gdGhlIEZJTE8tYXJyYXkuXG4gIGZ1bmN0aW9uIG1hcmtMb2NhdGlvbigpIHtcbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIGxvY2F0aW9ucy5wdXNoKGNyZWF0ZUxvY2F0aW9uTWFya2VyKCkpO1xuICB9XG5cbiAgLy8gUHVzaCBhbiBhcmJpdHJhcnkgYE1hcmtlcmAgb2JqZWN0IG9udG8gdGhlIEZJTE8tYXJyYXkuXG4gIGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihtYXJrZXIpIHtcbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIGxvY2F0aW9ucy5wdXNoKG1hcmtlcik7XG4gIH1cblxuICAvLyBDb250cm9sIGZsb3cgdHJhY2tpbmdcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEEgY29udGV4dCBvYmplY3QgdGhhdCB2YWxpZGF0ZXMgbG9vcCBicmVha3MgYW5kIGBnb3RvYC1iYXNlZCBjb250cm9sIGZsb3cuXG5cbiAgZnVuY3Rpb24gRnVsbEZsb3dDb250ZXh0KCkge1xuICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgdGhpcy5wZW5kaW5nR290b3MgPSBbXTtcbiAgfVxuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUuaXNJbkxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSB0aGlzLnNjb3Blcy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgLS0+IDApIHtcbiAgICAgIGlmICh0aGlzLnNjb3Blc1tpXS5pc0xvb3ApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5wdXNoU2NvcGUgPSBmdW5jdGlvbiAoaXNMb29wKSB7XG4gICAgdmFyIHNjb3BlID0ge1xuICAgICAgbGFiZWxzOiB7fSxcbiAgICAgIGxvY2FsczogW10sXG4gICAgICBkZWZlcnJlZEdvdG9zOiBbXSxcbiAgICAgIGlzTG9vcDogISFpc0xvb3BcbiAgICB9O1xuICAgIHRoaXMuc2NvcGVzLnB1c2goc2NvcGUpO1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUucG9wU2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdHb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHRoZUdvdG8gPSB0aGlzLnBlbmRpbmdHb3Rvc1tpXTtcbiAgICAgIGlmICh0aGVHb3RvLm1heERlcHRoID49IHRoaXMuc2NvcGVzLmxlbmd0aClcbiAgICAgICAgaWYgKC0tdGhlR290by5tYXhEZXB0aCA8PSAwKVxuICAgICAgICAgIHJhaXNlKHRoZUdvdG8udG9rZW4sIGVycm9ycy5sYWJlbE5vdFZpc2libGUsIHRoZUdvdG8udGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnNjb3Blcy5wb3AoKTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLmFkZEdvdG8gPSBmdW5jdGlvbiAodGFyZ2V0LCB0b2tlbikge1xuICAgIHZhciBsb2NhbENvdW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNjb3Blcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZXNbaV07XG4gICAgICBsb2NhbENvdW50cy5wdXNoKHNjb3BlLmxvY2Fscy5sZW5ndGgpO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY29wZS5sYWJlbHMsIHRhcmdldCkpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdHb3Rvcy5wdXNoKHtcbiAgICAgIG1heERlcHRoOiB0aGlzLnNjb3Blcy5sZW5ndGgsXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgIGxvY2FsQ291bnRzOiBsb2NhbENvdW50c1xuICAgIH0pO1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkTGFiZWwgPSBmdW5jdGlvbiAobmFtZSwgdG9rZW4pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY29wZS5sYWJlbHMsIG5hbWUpKSB7XG4gICAgICByYWlzZSh0b2tlbiwgZXJyb3JzLmxhYmVsQWxyZWFkeURlZmluZWQsIG5hbWUsIHNjb3BlLmxhYmVsc1tuYW1lXS5saW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5ld0dvdG9zID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nR290b3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHRoZUdvdG8gPSB0aGlzLnBlbmRpbmdHb3Rvc1tpXTtcblxuICAgICAgICBpZiAodGhlR290by5tYXhEZXB0aCA+PSB0aGlzLnNjb3Blcy5sZW5ndGggJiYgdGhlR290by50YXJnZXQgPT09IG5hbWUpIHtcbiAgICAgICAgICBpZiAodGhlR290by5sb2NhbENvdW50c1t0aGlzLnNjb3Blcy5sZW5ndGggLSAxXSA8IHNjb3BlLmxvY2Fscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNjb3BlLmRlZmVycmVkR290b3MucHVzaCh0aGVHb3RvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdHb3Rvcy5wdXNoKHRoZUdvdG8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlbmRpbmdHb3RvcyA9IG5ld0dvdG9zO1xuICAgIH1cblxuICAgIHNjb3BlLmxhYmVsc1tuYW1lXSA9IHtcbiAgICAgIGxvY2FsQ291bnQ6IHNjb3BlLmxvY2Fscy5sZW5ndGgsXG4gICAgICBsaW5lOiB0b2tlbi5saW5lXG4gICAgfTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLmFkZExvY2FsID0gZnVuY3Rpb24gKG5hbWUsIHRva2VuKSB7XG4gICAgdGhpcy5jdXJyZW50U2NvcGUoKS5sb2NhbHMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdG9rZW46IHRva2VuXG4gICAgfSk7XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5jdXJyZW50U2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVzW3RoaXMuc2NvcGVzLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUucmFpc2VEZWZlcnJlZEVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHZhciBiYWRzID0gc2NvcGUuZGVmZXJyZWRHb3RvcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0aGVHb3RvID0gYmFkc1tpXTtcbiAgICAgIHJhaXNlKHRoZUdvdG8udG9rZW4sIGVycm9ycy5nb3RvSnVtcEluTG9jYWxTY29wZSwgdGhlR290by50YXJnZXQsIHNjb3BlLmxvY2Fsc1t0aGVHb3RvLmxvY2FsQ291bnRzW3RoaXMuc2NvcGVzLmxlbmd0aCAtIDFdXS5uYW1lKTtcbiAgICB9XG4gICAgLy8gV291bGQgYmUgZGVhZCBjb2RlIGN1cnJlbnRseSwgYnV0IG1heSBiZSB1c2VmdWwgbGF0ZXJcbiAgICAvLyBpZiAoYmFkcy5sZW5ndGgpXG4gICAgLy8gICBzY29wZS5kZWZlcnJlZEdvdG9zID0gW107XG4gIH07XG5cbiAgLy8gU2ltcGxpZmllZCBjb250ZXh0IHRoYXQgb25seSBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGxvb3AgYnJlYWtzLlxuXG4gIGZ1bmN0aW9uIExvb3BGbG93Q29udGV4dCgpIHtcbiAgICB0aGlzLmxldmVsID0gMDtcbiAgICB0aGlzLmxvb3BMZXZlbHMgPSBbXTtcbiAgfVxuXG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUuaXNJbkxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5sb29wTGV2ZWxzLmxlbmd0aDtcbiAgfTtcblxuICBMb29wRmxvd0NvbnRleHQucHJvdG90eXBlLnB1c2hTY29wZSA9IGZ1bmN0aW9uIChpc0xvb3ApIHtcbiAgICArK3RoaXMubGV2ZWw7XG4gICAgaWYgKGlzTG9vcClcbiAgICAgIHRoaXMubG9vcExldmVscy5wdXNoKHRoaXMubGV2ZWwpO1xuICB9O1xuXG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUucG9wU2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxldmVscyA9IHRoaXMubG9vcExldmVscztcbiAgICB2YXIgbGV2bGVuID0gbGV2ZWxzLmxlbmd0aDtcbiAgICBpZiAobGV2bGVuKSB7XG4gICAgICBpZiAobGV2ZWxzW2xldmxlbiAtIDFdID09PSB0aGlzLmxldmVsKVxuICAgICAgICBsZXZlbHMucG9wKCk7XG4gICAgfVxuICAgIC0tdGhpcy5sZXZlbDtcbiAgfTtcblxuICBMb29wRmxvd0NvbnRleHQucHJvdG90eXBlLmFkZEdvdG8gPVxuICBMb29wRmxvd0NvbnRleHQucHJvdG90eXBlLmFkZExhYmVsID1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbicpOyB9O1xuXG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkTG9jYWwgPVxuICBMb29wRmxvd0NvbnRleHQucHJvdG90eXBlLnJhaXNlRGVmZXJyZWRFcnJvcnMgPVxuICBmdW5jdGlvbiAoKSB7fTtcblxuICBmdW5jdGlvbiBtYWtlRmxvd0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzLmxhYmVscyA/IG5ldyBGdWxsRmxvd0NvbnRleHQoKSA6IG5ldyBMb29wRmxvd0NvbnRleHQoKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBDaHVuayBpcyB0aGUgbWFpbiBwcm9ncmFtIG9iamVjdC4gU3ludGFjdGljYWxseSBpdCdzIHRoZSBzYW1lIGFzIGEgYmxvY2suXG4gIC8vXG4gIC8vICAgICBjaHVuayA6Oj0gYmxvY2tcblxuICBmdW5jdGlvbiBwYXJzZUNodW5rKCkge1xuICAgIG5leHQoKTtcbiAgICBtYXJrTG9jYXRpb24oKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICB2YXIgZmxvd0NvbnRleHQgPSBtYWtlRmxvd0NvbnRleHQoKTtcbiAgICBmbG93Q29udGV4dC5hbGxvd1ZhcmFyZyA9IHRydWU7XG4gICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKCk7XG4gICAgdmFyIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICBpZiAoRU9GICE9PSB0b2tlbi50eXBlKSB1bmV4cGVjdGVkKHRva2VuKTtcbiAgICAvLyBJZiB0aGUgYm9keSBpcyBlbXB0eSBubyBwcmV2aW91c1Rva2VuIGV4aXN0cyB3aGVuIGZpbmlzaE5vZGUgcnVucy5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMgJiYgIWJvZHkubGVuZ3RoKSBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmNodW5rKGJvZHkpKTtcbiAgfVxuXG4gIC8vIEEgYmxvY2sgY29udGFpbnMgYSBsaXN0IG9mIHN0YXRlbWVudHMgd2l0aCBhbiBvcHRpb25hbCByZXR1cm4gc3RhdGVtZW50XG4gIC8vIGFzIGl0cyBsYXN0IHN0YXRlbWVudC5cbiAgLy9cbiAgLy8gICAgIGJsb2NrIDo6PSB7c3RhdH0gW3JldHN0YXRdXG5cbiAgZnVuY3Rpb24gcGFyc2VCbG9jayhmbG93Q29udGV4dCkge1xuICAgIHZhciBibG9jayA9IFtdXG4gICAgICAsIHN0YXRlbWVudDtcblxuICAgIHdoaWxlICghaXNCbG9ja0ZvbGxvdyh0b2tlbikpIHtcbiAgICAgIC8vIFJldHVybiBoYXMgdG8gYmUgdGhlIGxhc3Qgc3RhdGVtZW50IGluIGEgYmxvY2suXG4gICAgICAvLyBMaWtld2lzZSAnYnJlYWsnIGluIEx1YSBvbGRlciB0aGFuIDUuMlxuICAgICAgaWYgKCdyZXR1cm4nID09PSB0b2tlbi52YWx1ZSB8fCAoIWZlYXR1cmVzLnJlbGF4ZWRCcmVhayAmJiAnYnJlYWsnID09PSB0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgYmxvY2sucHVzaChwYXJzZVN0YXRlbWVudChmbG93Q29udGV4dCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgIGNvbnN1bWUoJzsnKTtcbiAgICAgIC8vIFN0YXRlbWVudHMgYXJlIG9ubHkgYWRkZWQgaWYgdGhleSBhcmUgcmV0dXJuZWQsIHRoaXMgYWxsb3dzIHVzIHRvXG4gICAgICAvLyBpZ25vcmUgc29tZSBzdGF0ZW1lbnRzLCBzdWNoIGFzIEVtcHR5U3RhdGVtZW50LlxuICAgICAgaWYgKHN0YXRlbWVudCkgYmxvY2sucHVzaChzdGF0ZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIERvZXNuJ3QgcmVhbGx5IG5lZWQgYW4gYXN0IG5vZGVcbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHN0YXRlbWVudHMsIHNpbXBsZSBhbmQgY29tcG91bmQuXG4gIC8vXG4gIC8vICAgICBzdGF0ZW1lbnQgOjo9IGJyZWFrIHwgZ290byB8IGRvIHwgd2hpbGUgfCByZXBlYXQgfCByZXR1cm5cbiAgLy8gICAgICAgICAgfCBpZiB8IGZvciB8IGZ1bmN0aW9uIHwgbG9jYWwgfCBsYWJlbCB8IGFzc2lnbm1lbnRcbiAgLy8gICAgICAgICAgfCBmdW5jdGlvbmNhbGwgfCAnOydcblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIG1hcmtMb2NhdGlvbigpO1xuXG4gICAgaWYgKFB1bmN0dWF0b3IgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIGlmIChjb25zdW1lKCc6OicpKSByZXR1cm4gcGFyc2VMYWJlbFN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBhIGA7YCBpcyBlbmNvdW50ZWQsIHNpbXBseSBlYXQgaXQgd2l0aG91dCBzdG9yaW5nIGl0LlxuICAgIGlmIChmZWF0dXJlcy5lbXB0eVN0YXRlbWVudCkge1xuICAgICAgaWYgKGNvbnN1bWUoJzsnKSkge1xuICAgICAgICBpZiAodHJhY2tMb2NhdGlvbnMpIGxvY2F0aW9ucy5wb3AoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsb3dDb250ZXh0LnJhaXNlRGVmZXJyZWRFcnJvcnMoKTtcblxuICAgIGlmIChLZXl3b3JkID09PSB0b2tlbi50eXBlKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xvY2FsJzogICAgbmV4dCgpOyByZXR1cm4gcGFyc2VMb2NhbFN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2lmJzogICAgICAgbmV4dCgpOyByZXR1cm4gcGFyc2VJZlN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ3JldHVybic6ICAgbmV4dCgpOyByZXR1cm4gcGFyc2VSZXR1cm5TdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6IG5leHQoKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHBhcnNlRnVuY3Rpb25OYW1lKCk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuYW1lKTtcbiAgICAgICAgY2FzZSAnd2hpbGUnOiAgICBuZXh0KCk7IHJldHVybiBwYXJzZVdoaWxlU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAnZm9yJzogICAgICBuZXh0KCk7IHJldHVybiBwYXJzZUZvclN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ3JlcGVhdCc6ICAgbmV4dCgpOyByZXR1cm4gcGFyc2VSZXBlYXRTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdicmVhayc6ICAgIG5leHQoKTtcbiAgICAgICAgICBpZiAoIWZsb3dDb250ZXh0LmlzSW5Mb29wKCkpXG4gICAgICAgICAgICByYWlzZSh0b2tlbiwgZXJyb3JzLm5vTG9vcFRvQnJlYWssIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VCcmVha1N0YXRlbWVudCgpO1xuICAgICAgICBjYXNlICdkbyc6ICAgICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlRG9TdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdnb3RvJzogICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlR290b1N0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZlYXR1cmVzLmNvbnRleHR1YWxHb3RvICYmXG4gICAgICAgIHRva2VuLnR5cGUgPT09IElkZW50aWZpZXIgJiYgdG9rZW4udmFsdWUgPT09ICdnb3RvJyAmJlxuICAgICAgICBsb29rYWhlYWQudHlwZSA9PT0gSWRlbnRpZmllciAmJiBsb29rYWhlYWQudmFsdWUgIT09ICdnb3RvJykge1xuICAgICAgbmV4dCgpOyByZXR1cm4gcGFyc2VHb3RvU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBBc3NpZ25tZW50cyBtZW1vcml6ZXMgdGhlIGxvY2F0aW9uIGFuZCBwdXNoZXMgaXQgbWFudWFsbHkgZm9yIHdyYXBwZXIgbm9kZXMuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBsb2NhdGlvbnMucG9wKCk7XG5cbiAgICByZXR1cm4gcGFyc2VBc3NpZ25tZW50T3JDYWxsU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgfVxuXG4gIC8vICMjIFN0YXRlbWVudHNcblxuICAvLyAgICAgbGFiZWwgOjo9ICc6OicgTmFtZSAnOjonXG5cbiAgZnVuY3Rpb24gcGFyc2VMYWJlbFN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBuYW1lVG9rZW4gPSB0b2tlblxuICAgICAgLCBsYWJlbCA9IHBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIHtcbiAgICAgIHNjb3BlSWRlbnRpZmllck5hbWUoJzo6JyArIG5hbWVUb2tlbi52YWx1ZSArICc6OicpO1xuICAgICAgYXR0YWNoU2NvcGUobGFiZWwsIHRydWUpO1xuICAgIH1cblxuICAgIGV4cGVjdCgnOjonKTtcblxuICAgIGZsb3dDb250ZXh0LmFkZExhYmVsKG5hbWVUb2tlbi52YWx1ZSwgbmFtZVRva2VuKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QubGFiZWxTdGF0ZW1lbnQobGFiZWwpKTtcbiAgfVxuXG4gIC8vICAgICBicmVhayA6Oj0gJ2JyZWFrJ1xuXG4gIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmJyZWFrU3RhdGVtZW50KCkpO1xuICB9XG5cbiAgLy8gICAgIGdvdG8gOjo9ICdnb3RvJyBOYW1lXG5cbiAgZnVuY3Rpb24gcGFyc2VHb3RvU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIG5hbWUgPSB0b2tlbi52YWx1ZVxuICAgICAgLCBnb3RvVG9rZW4gPSBwcmV2aW91c1Rva2VuXG4gICAgICAsIGxhYmVsID0gcGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICBmbG93Q29udGV4dC5hZGRHb3RvKG5hbWUsIGdvdG9Ub2tlbik7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmdvdG9TdGF0ZW1lbnQobGFiZWwpKTtcbiAgfVxuXG4gIC8vICAgICBkbyA6Oj0gJ2RvJyBibG9jayAnZW5kJ1xuXG4gIGZ1bmN0aW9uIHBhcnNlRG9TdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUoKTtcbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgIGV4cGVjdCgnZW5kJyk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmRvU3RhdGVtZW50KGJvZHkpKTtcbiAgfVxuXG4gIC8vICAgICB3aGlsZSA6Oj0gJ3doaWxlJyBleHAgJ2RvJyBibG9jayAnZW5kJ1xuXG4gIGZ1bmN0aW9uIHBhcnNlV2hpbGVTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgY29uZGl0aW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgIGV4cGVjdCgnZG8nKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUodHJ1ZSk7XG4gICAgdmFyIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICBleHBlY3QoJ2VuZCcpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC53aGlsZVN0YXRlbWVudChjb25kaXRpb24sIGJvZHkpKTtcbiAgfVxuXG4gIC8vICAgICByZXBlYXQgOjo9ICdyZXBlYXQnIGJsb2NrICd1bnRpbCcgZXhwXG5cbiAgZnVuY3Rpb24gcGFyc2VSZXBlYXRTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUodHJ1ZSk7XG4gICAgdmFyIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICBleHBlY3QoJ3VudGlsJyk7XG4gICAgZmxvd0NvbnRleHQucmFpc2VEZWZlcnJlZEVycm9ycygpO1xuICAgIHZhciBjb25kaXRpb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LnJlcGVhdFN0YXRlbWVudChjb25kaXRpb24sIGJvZHkpKTtcbiAgfVxuXG4gIC8vICAgICByZXRzdGF0IDo6PSAncmV0dXJuJyBbZXhwIHsnLCcgZXhwfV0gWyc7J11cblxuICBmdW5jdGlvbiBwYXJzZVJldHVyblN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgaWYgKCdlbmQnICE9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgaWYgKG51bGwgIT0gZXhwcmVzc2lvbikgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgIHdoaWxlIChjb25zdW1lKCcsJykpIHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN1bWUoJzsnKTsgLy8gZ3JhbW1hciB0ZWxscyB1cyA7IGlzIG9wdGlvbmFsIGhlcmUuXG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5yZXR1cm5TdGF0ZW1lbnQoZXhwcmVzc2lvbnMpKTtcbiAgfVxuXG4gIC8vICAgICBpZiA6Oj0gJ2lmJyBleHAgJ3RoZW4nIGJsb2NrIHtlbGlmfSBbJ2Vsc2UnIGJsb2NrXSAnZW5kJ1xuICAvLyAgICAgZWxpZiA6Oj0gJ2Vsc2VpZicgZXhwICd0aGVuJyBibG9ja1xuXG4gIGZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgY2xhdXNlcyA9IFtdXG4gICAgICAsIGNvbmRpdGlvblxuICAgICAgLCBib2R5XG4gICAgICAsIG1hcmtlcjtcblxuICAgIC8vIElmQ2xhdXNlcyBiZWdpbiBhdCB0aGUgc2FtZSBsb2NhdGlvbiBhcyB0aGUgcGFyZW50IElmU3RhdGVtZW50LlxuICAgIC8vIEl0IGVuZHMgYXQgdGhlIHN0YXJ0IG9mIGBlbmRgLCBgZWxzZWAsIG9yIGBlbHNlaWZgLlxuICAgIGlmICh0cmFja0xvY2F0aW9ucykge1xuICAgICAgbWFya2VyID0gbG9jYXRpb25zW2xvY2F0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9ucy5wdXNoKG1hcmtlcik7XG4gICAgfVxuICAgIGNvbmRpdGlvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICBleHBlY3QoJ3RoZW4nKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUoKTtcbiAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgY2xhdXNlcy5wdXNoKGZpbmlzaE5vZGUoYXN0LmlmQ2xhdXNlKGNvbmRpdGlvbiwgYm9keSkpKTtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcbiAgICB3aGlsZSAoY29uc3VtZSgnZWxzZWlmJykpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgY29uZGl0aW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgZXhwZWN0KCd0aGVuJyk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgICAgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICAgIGNsYXVzZXMucHVzaChmaW5pc2hOb2RlKGFzdC5lbHNlaWZDbGF1c2UoY29uZGl0aW9uLCBib2R5KSkpO1xuICAgICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuICAgIH1cblxuICAgIGlmIChjb25zdW1lKCdlbHNlJykpIHtcbiAgICAgIC8vIEluY2x1ZGUgdGhlIGBlbHNlYCBpbiB0aGUgbG9jYXRpb24gb2YgRWxzZUNsYXVzZS5cbiAgICAgIGlmICh0cmFja0xvY2F0aW9ucykge1xuICAgICAgICBtYXJrZXIgPSBuZXcgTWFya2VyKHByZXZpb3VzVG9rZW4pO1xuICAgICAgICBsb2NhdGlvbnMucHVzaChtYXJrZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUoKTtcbiAgICAgIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgICBjbGF1c2VzLnB1c2goZmluaXNoTm9kZShhc3QuZWxzZUNsYXVzZShib2R5KSkpO1xuICAgIH1cblxuICAgIGV4cGVjdCgnZW5kJyk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmlmU3RhdGVtZW50KGNsYXVzZXMpKTtcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgZm9yIHN0YXRlbWVudHMsIGdlbmVyaWMgYW5kIG51bWVyaWMuXG4gIC8vXG4gIC8vICAgICBmb3IgOjo9IE5hbWUgJz0nIGV4cCAnLCcgZXhwIFsnLCcgZXhwXSAnZG8nIGJsb2NrICdlbmQnXG4gIC8vICAgICBmb3IgOjo9IG5hbWVsaXN0ICdpbicgZXhwbGlzdCAnZG8nIGJsb2NrICdlbmQnXG4gIC8vICAgICBuYW1lbGlzdCA6Oj0gTmFtZSB7JywnIE5hbWV9XG4gIC8vICAgICBleHBsaXN0IDo6PSBleHAgeycsJyBleHB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGb3JTdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgdmFyaWFibGUgPSBwYXJzZUlkZW50aWZpZXIoKVxuICAgICAgLCBib2R5O1xuXG4gICAgLy8gVGhlIHN0YXJ0LWlkZW50aWZpZXIgaXMgbG9jYWwuXG5cbiAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgY3JlYXRlU2NvcGUoKTtcbiAgICAgIHNjb3BlSWRlbnRpZmllcih2YXJpYWJsZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGZpcnN0IGV4cHJlc3Npb24gaXMgZm9sbG93ZWQgYnkgYSBgPWAgcHVuY3R1YXRvciwgdGhpcyBpcyBhXG4gICAgLy8gTnVtZXJpYyBGb3IgU3RhdGVtZW50LlxuICAgIGlmIChjb25zdW1lKCc9JykpIHtcbiAgICAgIC8vIFN0YXJ0IGV4cHJlc3Npb25cbiAgICAgIHZhciBzdGFydCA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgLy8gRW5kIGV4cHJlc3Npb25cbiAgICAgIHZhciBlbmQgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAvLyBPcHRpb25hbCBzdGVwIGV4cHJlc3Npb25cbiAgICAgIHZhciBzdGVwID0gY29uc3VtZSgnLCcpID8gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpIDogbnVsbDtcblxuICAgICAgZXhwZWN0KCdkbycpO1xuICAgICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKHRydWUpO1xuICAgICAgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICAgIGV4cGVjdCgnZW5kJyk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG5cbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5mb3JOdW1lcmljU3RhdGVtZW50KHZhcmlhYmxlLCBzdGFydCwgZW5kLCBzdGVwLCBib2R5KSk7XG4gICAgfVxuICAgIC8vIElmIG5vdCwgaXQncyBhIEdlbmVyaWMgRm9yIFN0YXRlbWVudFxuICAgIGVsc2Uge1xuICAgICAgLy8gVGhlIG5hbWVsaXN0IGNhbiBjb250YWluIG9uZSBvciBtb3JlIGlkZW50aWZpZXJzLlxuICAgICAgdmFyIHZhcmlhYmxlcyA9IFt2YXJpYWJsZV07XG4gICAgICB3aGlsZSAoY29uc3VtZSgnLCcpKSB7XG4gICAgICAgIHZhcmlhYmxlID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIC8vIEVhY2ggdmFyaWFibGUgaW4gdGhlIG5hbWVsaXN0IGlzIGxvY2FsbHkgc2NvcGVkLlxuICAgICAgICBpZiAob3B0aW9ucy5zY29wZSkgc2NvcGVJZGVudGlmaWVyKHZhcmlhYmxlKTtcbiAgICAgICAgdmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgICAgfVxuICAgICAgZXhwZWN0KCdpbicpO1xuICAgICAgdmFyIGl0ZXJhdG9ycyA9IFtdO1xuXG4gICAgICAvLyBPbmUgb3IgbW9yZSBleHByZXNzaW9ucyBpbiB0aGUgZXhwbGlzdC5cbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgIGl0ZXJhdG9ycy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgfSB3aGlsZSAoY29uc3VtZSgnLCcpKTtcblxuICAgICAgZXhwZWN0KCdkbycpO1xuICAgICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKHRydWUpO1xuICAgICAgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICAgIGV4cGVjdCgnZW5kJyk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG5cbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5mb3JHZW5lcmljU3RhdGVtZW50KHZhcmlhYmxlcywgaXRlcmF0b3JzLCBib2R5KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gTG9jYWwgc3RhdGVtZW50cyBjYW4gZWl0aGVyIGJlIHZhcmlhYmxlIGFzc2lnbm1lbnRzIG9yIGZ1bmN0aW9uXG4gIC8vIGRlZmluaXRpb25zLiBJZiBhIGZ1bmN0aW9uIGRlZmluaXRpb24gaXMgZm91bmQsIGl0IHdpbGwgYmUgZGVsZWdhdGVkIHRvXG4gIC8vIGBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKWAgd2l0aCB0aGUgaXNMb2NhbCBmbGFnLlxuICAvL1xuICAvLyBUaGlzIEFTVCBzdHJ1Y3R1cmUgbWlnaHQgY2hhbmdlIGludG8gYSBsb2NhbCBhc3NpZ25tZW50IHdpdGggYSBmdW5jdGlvblxuICAvLyBjaGlsZC5cbiAgLy9cbiAgLy8gICAgIGxvY2FsIDo6PSAnbG9jYWwnICdmdW5jdGlvbicgTmFtZSBmdW5jZGVjbFxuICAvLyAgICAgICAgfCAnbG9jYWwnIE5hbWUgeycsJyBOYW1lfSBbJz0nIGV4cCB7JywnIGV4cH1dXG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbFN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBuYW1lXG4gICAgICAsIGRlY2xUb2tlbiA9IHByZXZpb3VzVG9rZW47XG5cbiAgICBpZiAoSWRlbnRpZmllciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgdmFyIHZhcmlhYmxlcyA9IFtdXG4gICAgICAgICwgaW5pdCA9IFtdO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5hbWUgPSBwYXJzZUlkZW50aWZpZXIoKTtcblxuICAgICAgICB2YXJpYWJsZXMucHVzaChuYW1lKTtcbiAgICAgICAgZmxvd0NvbnRleHQuYWRkTG9jYWwobmFtZS5uYW1lLCBkZWNsVG9rZW4pO1xuICAgICAgfSB3aGlsZSAoY29uc3VtZSgnLCcpKTtcblxuICAgICAgaWYgKGNvbnN1bWUoJz0nKSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgaW5pdC5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICB9IHdoaWxlIChjb25zdW1lKCcsJykpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWNsYXJhdGlvbnMgZG9lc24ndCBleGlzdCBiZWZvcmUgdGhlIHN0YXRlbWVudCBoYXMgYmVlbiBldmFsdWF0ZWQuXG4gICAgICAvLyBUaGVyZWZvcmUgYXNzaWdubWVudHMgY2FuJ3QgdXNlIHRoZWlyIGRlY2xhcmF0b3IuIEFuZCB0aGUgaWRlbnRpZmllcnNcbiAgICAgIC8vIHNob3VsZG4ndCBiZSBhZGRlZCB0byB0aGUgc2NvcGUgdW50aWwgdGhlIHN0YXRlbWVudCBpcyBjb21wbGV0ZS5cbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFyaWFibGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIHNjb3BlSWRlbnRpZmllcih2YXJpYWJsZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5sb2NhbFN0YXRlbWVudCh2YXJpYWJsZXMsIGluaXQpKTtcbiAgICB9XG4gICAgaWYgKGNvbnN1bWUoJ2Z1bmN0aW9uJykpIHtcbiAgICAgIG5hbWUgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGZsb3dDb250ZXh0LmFkZExvY2FsKG5hbWUubmFtZSwgZGVjbFRva2VuKTtcblxuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgc2NvcGVJZGVudGlmaWVyKG5hbWUpO1xuICAgICAgICBjcmVhdGVTY29wZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBNZW1iZXJFeHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gbG9jYWwgZnVuY3Rpb24gc3RhdGVtZW50cy5cbiAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obmFtZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8bmFtZT4nLCB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gICAgIGFzc2lnbm1lbnQgOjo9IHZhcmxpc3QgJz0nIGV4cGxpc3RcbiAgLy8gICAgIHZhciA6Oj0gTmFtZSB8IHByZWZpeGV4cCAnWycgZXhwICddJyB8IHByZWZpeGV4cCAnLicgTmFtZVxuICAvLyAgICAgdmFybGlzdCA6Oj0gdmFyIHsnLCcgdmFyfVxuICAvLyAgICAgZXhwbGlzdCA6Oj0gZXhwIHsnLCcgZXhwfVxuICAvL1xuICAvLyAgICAgY2FsbCA6Oj0gY2FsbGV4cFxuICAvLyAgICAgY2FsbGV4cCA6Oj0gcHJlZml4ZXhwIGFyZ3MgfCBwcmVmaXhleHAgJzonIE5hbWUgYXJnc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudE9yQ2FsbFN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIHRva2VuIGZvciBiZXR0ZXIgZXJyb3IgbWVzc2FnZXMgaW4gY2FzZVxuICAgIC8vIG9mIGludmFsaWQgc3RhdGVtZW50XG4gICAgdmFyIHByZXZpb3VzID0gdG9rZW5cbiAgICAgICwgbWFya2VyLCBzdGFydE1hcmtlcjtcbiAgICB2YXIgbHZhbHVlLCBiYXNlLCBuYW1lO1xuXG4gICAgdmFyIHRhcmdldHMgPSBbXTtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgc3RhcnRNYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuXG4gICAgICBpZiAoSWRlbnRpZmllciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgICBuYW1lID0gdG9rZW4udmFsdWU7XG4gICAgICAgIGJhc2UgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgLy8gU2V0IHRoZSBwYXJlbnQgc2NvcGUuXG4gICAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBhdHRhY2hTY29wZShiYXNlLCBzY29wZUhhc05hbWUobmFtZSkpO1xuICAgICAgICBsdmFsdWUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICgnKCcgPT09IHRva2VuLnZhbHVlKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgYmFzZSA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgIGx2YWx1ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBib3RoOiBmb3IgKDs7KSB7XG4gICAgICAgIHZhciBuZXdCYXNlO1xuXG4gICAgICAgIHN3aXRjaCAoU3RyaW5nTGl0ZXJhbCA9PT0gdG9rZW4udHlwZSA/ICdcIicgOiB0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgbHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIGx2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWsgYm90aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2UgPSBwYXJzZVByZWZpeEV4cHJlc3Npb25QYXJ0KGJhc2UsIG1hcmtlciwgZmxvd0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRzLnB1c2goYmFzZSk7XG5cbiAgICAgIGlmICgnLCcgIT09IHRva2VuLnZhbHVlKVxuICAgICAgICBicmVhaztcblxuICAgICAgaWYgKCFsdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBuZXh0KCk7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDEgJiYgbHZhbHVlID09PSBudWxsKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5jYWxsU3RhdGVtZW50KHRhcmdldHNbMF0pKTtcbiAgICB9IGVsc2UgaWYgKCFsdmFsdWUpIHtcbiAgICAgIHJldHVybiB1bmV4cGVjdGVkKHRva2VuKTtcbiAgICB9XG5cbiAgICBleHBlY3QoJz0nKTtcblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGRvIHtcbiAgICAgIHZhbHVlcy5wdXNoKHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KSk7XG4gICAgfSB3aGlsZSAoY29uc3VtZSgnLCcpKTtcblxuICAgIHB1c2hMb2NhdGlvbihzdGFydE1hcmtlcik7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmFzc2lnbm1lbnRTdGF0ZW1lbnQodGFyZ2V0cywgdmFsdWVzKSk7XG4gIH1cblxuICAvLyAjIyMgTm9uLXN0YXRlbWVudHNcblxuICAvLyAgICAgSWRlbnRpZmllciA6Oj0gTmFtZVxuXG4gIGZ1bmN0aW9uIHBhcnNlSWRlbnRpZmllcigpIHtcbiAgICBtYXJrTG9jYXRpb24oKTtcbiAgICB2YXIgaWRlbnRpZmllciA9IHRva2VuLnZhbHVlO1xuICAgIGlmIChJZGVudGlmaWVyICE9PSB0b2tlbi50eXBlKSByYWlzZVVuZXhwZWN0ZWRUb2tlbignPG5hbWU+JywgdG9rZW4pO1xuICAgIG5leHQoKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuaWRlbnRpZmllcihpZGVudGlmaWVyKSk7XG4gIH1cblxuICAvLyBQYXJzZSB0aGUgZnVuY3Rpb25zIHBhcmFtZXRlcnMgYW5kIGJvZHkgYmxvY2suIFRoZSBuYW1lIHNob3VsZCBhbHJlYWR5XG4gIC8vIGhhdmUgYmVlbiBwYXJzZWQgYW5kIHBhc3NlZCB0byB0aGlzIGRlY2xhcmF0aW9uIGZ1bmN0aW9uLiBCeSBzZXBhcmF0aW5nXG4gIC8vIHRoaXMgd2UgYWxsb3cgZm9yIGFub255bW91cyBmdW5jdGlvbnMgaW4gZXhwcmVzc2lvbnMuXG4gIC8vXG4gIC8vIEZvciBsb2NhbCBmdW5jdGlvbnMgdGhlcmUncyBhIGJvb2xlYW4gcGFyYW1ldGVyIHdoaWNoIG5lZWRzIHRvIGJlIHNldFxuICAvLyB3aGVuIHBhcnNpbmcgdGhlIGRlY2xhcmF0aW9uLlxuICAvL1xuICAvLyAgICAgZnVuY2RlY2wgOjo9ICcoJyBbcGFybGlzdF0gJyknIGJsb2NrICdlbmQnXG4gIC8vICAgICBwYXJsaXN0IDo6PSBOYW1lIHsnLCcgTmFtZX0gfCBbJywnICcuLi4nXSB8ICcuLi4nXG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5hbWUsIGlzTG9jYWwpIHtcbiAgICB2YXIgZmxvd0NvbnRleHQgPSBtYWtlRmxvd0NvbnRleHQoKTtcbiAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUoKTtcblxuICAgIHZhciBwYXJhbWV0ZXJzID0gW107XG4gICAgZXhwZWN0KCcoJyk7XG5cbiAgICAvLyBUaGUgZGVjbGFyYXRpb24gaGFzIGFyZ3VtZW50c1xuICAgIGlmICghY29uc3VtZSgnKScpKSB7XG4gICAgICAvLyBBcmd1bWVudHMgYXJlIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgaWRlbnRpZmllcnMsIG9wdGlvbmFsbHkgZW5kaW5nXG4gICAgICAvLyB3aXRoIGEgdmFyYXJnLlxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKElkZW50aWZpZXIgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgLy8gRnVuY3Rpb24gcGFyYW1ldGVycyBhcmUgbG9jYWwuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIHNjb3BlSWRlbnRpZmllcihwYXJhbWV0ZXIpO1xuXG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHBhcmFtZXRlcik7XG5cbiAgICAgICAgICBpZiAoY29uc3VtZSgnLCcpKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBhcmd1bWVudHMgYXJlIGFsbG93ZWQgYWZ0ZXIgYSB2YXJhcmcuXG4gICAgICAgIGVsc2UgaWYgKFZhcmFyZ0xpdGVyYWwgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBmbG93Q29udGV4dC5hbGxvd1ZhcmFyZyA9IHRydWU7XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oZmxvd0NvbnRleHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYWlzZVVuZXhwZWN0ZWRUb2tlbignPG5hbWU+IG9yIFxcJy4uLlxcJycsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGV4cGVjdCgnZW5kJyk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuXG4gICAgaXNMb2NhbCA9IGlzTG9jYWwgfHwgZmFsc2U7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmZ1bmN0aW9uU3RhdGVtZW50KG5hbWUsIHBhcmFtZXRlcnMsIGlzTG9jYWwsIGJvZHkpKTtcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBmdW5jdGlvbiBuYW1lIGFzIGlkZW50aWZpZXJzIGFuZCBtZW1iZXIgZXhwcmVzc2lvbnMuXG4gIC8vXG4gIC8vICAgICBOYW1lIHsnLicgTmFtZX0gWyc6JyBOYW1lXVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25OYW1lKCkge1xuICAgIHZhciBiYXNlLCBuYW1lLCBtYXJrZXI7XG5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG4gICAgYmFzZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIHtcbiAgICAgIGF0dGFjaFNjb3BlKGJhc2UsIHNjb3BlSGFzTmFtZShiYXNlLm5hbWUpKTtcbiAgICAgIGNyZWF0ZVNjb3BlKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNvbnN1bWUoJy4nKSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICBuYW1lID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBiYXNlID0gZmluaXNoTm9kZShhc3QubWVtYmVyRXhwcmVzc2lvbihiYXNlLCAnLicsIG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoY29uc3VtZSgnOicpKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIG5hbWUgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGJhc2UgPSBmaW5pc2hOb2RlKGFzdC5tZW1iZXJFeHByZXNzaW9uKGJhc2UsICc6JywgbmFtZSkpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIHNjb3BlSWRlbnRpZmllck5hbWUoJ3NlbGYnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8vICAgICB0YWJsZWNvbnN0cnVjdG9yIDo6PSAneycgW2ZpZWxkbGlzdF0gJ30nXG4gIC8vICAgICBmaWVsZGxpc3QgOjo9IGZpZWxkIHtmaWVsZHNlcCBmaWVsZH0gZmllbGRzZXBcbiAgLy8gICAgIGZpZWxkIDo6PSAnWycgZXhwICddJyAnPScgZXhwIHwgTmFtZSA9ICdleHAnIHwgZXhwXG4gIC8vXG4gIC8vICAgICBmaWVsZHNlcCA6Oj0gJywnIHwgJzsnXG5cbiAgZnVuY3Rpb24gcGFyc2VUYWJsZUNvbnN0cnVjdG9yKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGZpZWxkcyA9IFtdXG4gICAgICAsIGtleSwgdmFsdWU7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbWFya0xvY2F0aW9uKCk7XG4gICAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSAmJiBjb25zdW1lKCdbJykpIHtcbiAgICAgICAga2V5ID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICBleHBlY3QoJ10nKTtcbiAgICAgICAgZXhwZWN0KCc9Jyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICBmaWVsZHMucHVzaChmaW5pc2hOb2RlKGFzdC50YWJsZUtleShrZXksIHZhbHVlKSkpO1xuICAgICAgfSBlbHNlIGlmIChJZGVudGlmaWVyID09PSB0b2tlbi50eXBlKSB7XG4gICAgICAgIGlmICgnPScgPT09IGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGtleSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICBmaWVsZHMucHVzaChmaW5pc2hOb2RlKGFzdC50YWJsZUtleVN0cmluZyhrZXksIHZhbHVlKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgIGZpZWxkcy5wdXNoKGZpbmlzaE5vZGUoYXN0LnRhYmxlVmFsdWUodmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChudWxsID09ICh2YWx1ZSA9IHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCkpKSB7XG4gICAgICAgICAgbG9jYXRpb25zLnBvcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcy5wdXNoKGZpbmlzaE5vZGUoYXN0LnRhYmxlVmFsdWUodmFsdWUpKSk7XG4gICAgICB9XG4gICAgICBpZiAoJyw7Jy5pbmRleE9mKHRva2VuLnZhbHVlKSA+PSAwKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZXhwZWN0KCd9Jyk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LnRhYmxlQ29uc3RydWN0b3JFeHByZXNzaW9uKGZpZWxkcykpO1xuICB9XG5cbiAgLy8gRXhwcmVzc2lvbiBwYXJzZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gRXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZCBhbmQgYWx3YXlzIHJldHVybiBhIHZhbHVlLiBJZiBub3RoaW5nIGlzXG4gIC8vIG1hdGNoZWQgbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAvL1xuICAvLyAgICAgZXhwIDo6PSAodW5vcCBleHAgfCBwcmltYXJ5IHwgcHJlZml4ZXhwICkgeyBiaW5vcCBleHAgfVxuICAvL1xuICAvLyAgICAgcHJpbWFyeSA6Oj0gbmlsIHwgZmFsc2UgfCB0cnVlIHwgTnVtYmVyIHwgU3RyaW5nIHwgJy4uLidcbiAgLy8gICAgICAgICAgfCBmdW5jdGlvbmRlZiB8IHRhYmxlY29uc3RydWN0b3JcbiAgLy9cbiAgLy8gICAgIHByZWZpeGV4cCA6Oj0gKE5hbWUgfCAnKCcgZXhwICcpJyApIHsgJ1snIGV4cCAnXSdcbiAgLy8gICAgICAgICAgfCAnLicgTmFtZSB8ICc6JyBOYW1lIGFyZ3MgfCBhcmdzIH1cbiAgLy9cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlU3ViRXhwcmVzc2lvbigwLCBmbG93Q29udGV4dCk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG4gIH1cblxuICAvLyBQYXJzZSBhbiBleHByZXNzaW9uIGV4cGVjdGluZyBpdCB0byBiZSB2YWxpZC5cblxuICBmdW5jdGlvbiBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCkge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICBpZiAobnVsbCA9PSBleHByZXNzaW9uKSByYWlzZVVuZXhwZWN0ZWRUb2tlbignPGV4cHJlc3Npb24+JywgdG9rZW4pO1xuICAgIGVsc2UgcmV0dXJuIGV4cHJlc3Npb247XG4gIH1cblxuXG4gIC8vIFJldHVybiB0aGUgcHJlY2VkZW5jZSBwcmlvcml0eSBvZiB0aGUgb3BlcmF0b3IuXG4gIC8vXG4gIC8vIEFzIHVuYXJ5IGAtYCBjYW4ndCBiZSBkaXN0aW5ndWlzaGVkIGZyb20gYmluYXJ5IGAtYCwgdW5hcnkgcHJlY2VkZW5jZVxuICAvLyBpc24ndCBkZXNjcmliZWQgaW4gdGhpcyB0YWJsZSBidXQgaW4gYHBhcnNlU3ViRXhwcmVzc2lvbigpYCBpdHNlbGYuXG4gIC8vXG4gIC8vIEFzIHRoaXMgZnVuY3Rpb24gZ2V0cyBoaXQgb24gZXZlcnkgZXhwcmVzc2lvbiBpdCdzIGJlZW4gb3B0aW1pemVkIGR1ZSB0b1xuICAvLyB0aGUgZXhwZW5zaXZlIENvbXBhcmVJQ1N0dWIgd2hpY2ggdG9vayB+OCUgb2YgdGhlIHBhcnNlIHRpbWUuXG5cbiAgZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZShvcGVyYXRvcikge1xuICAgIHZhciBjaGFyQ29kZSA9IG9wZXJhdG9yLmNoYXJDb2RlQXQoMClcbiAgICAgICwgbGVuZ3RoID0gb3BlcmF0b3IubGVuZ3RoO1xuXG4gICAgaWYgKDEgPT09IGxlbmd0aCkge1xuICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICBjYXNlIDk0OiByZXR1cm4gMTI7IC8vIF5cbiAgICAgICAgY2FzZSA0MjogY2FzZSA0NzogY2FzZSAzNzogcmV0dXJuIDEwOyAvLyAqIC8gJVxuICAgICAgICBjYXNlIDQzOiBjYXNlIDQ1OiByZXR1cm4gOTsgLy8gKyAtXG4gICAgICAgIGNhc2UgMzg6IHJldHVybiA2OyAvLyAmXG4gICAgICAgIGNhc2UgMTI2OiByZXR1cm4gNTsgLy8gflxuICAgICAgICBjYXNlIDEyNDogcmV0dXJuIDQ7IC8vIHxcbiAgICAgICAgY2FzZSA2MDogY2FzZSA2MjogcmV0dXJuIDM7IC8vIDwgPlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoMiA9PT0gbGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgIGNhc2UgNDc6IHJldHVybiAxMDsgLy8gLy9cbiAgICAgICAgY2FzZSA0NjogcmV0dXJuIDg7IC8vIC4uXG4gICAgICAgIGNhc2UgNjA6IGNhc2UgNjI6XG4gICAgICAgICAgICBpZignPDwnID09PSBvcGVyYXRvciB8fCAnPj4nID09PSBvcGVyYXRvcikgcmV0dXJuIDc7IC8vIDw8ID4+XG4gICAgICAgICAgICByZXR1cm4gMzsgLy8gPD0gPj1cbiAgICAgICAgY2FzZSA2MTogY2FzZSAxMjY6IHJldHVybiAzOyAvLyA9PSB+PVxuICAgICAgICBjYXNlIDExMTogcmV0dXJuIDE7IC8vIG9yXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICg5NyA9PT0gY2hhckNvZGUgJiYgJ2FuZCcgPT09IG9wZXJhdG9yKSByZXR1cm4gMjtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIEltcGxlbWVudCBhbiBvcGVyYXRvci1wcmVjZWRlbmNlIHBhcnNlciB0byBoYW5kbGUgYmluYXJ5IG9wZXJhdG9yXG4gIC8vIHByZWNlZGVuY2UuXG4gIC8vXG4gIC8vIFdlIHVzZSB0aGlzIGFsZ29yaXRobSBiZWNhdXNlIGl0J3MgY29tcGFjdCwgaXQncyBmYXN0IGFuZCBMdWEgY29yZSB1c2VzXG4gIC8vIHRoZSBzYW1lIHNvIHdlIGNhbiBiZSBzdXJlIG91ciBleHByZXNzaW9ucyBhcmUgcGFyc2VkIGluIHRoZSBzYW1lIG1hbm5lclxuICAvLyB3aXRob3V0IGV4Y2Vzc2l2ZSBhbW91bnRzIG9mIHRlc3RzLlxuICAvL1xuICAvLyAgICAgZXhwIDo6PSAodW5vcCBleHAgfCBwcmltYXJ5IHwgcHJlZml4ZXhwICkgeyBiaW5vcCBleHAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3ViRXhwcmVzc2lvbihtaW5QcmVjZWRlbmNlLCBmbG93Q29udGV4dCkge1xuICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnZhbHVlXG4gICAgLy8gVGhlIGxlZnQtaGFuZCBzaWRlIGluIGJpbmFyeSBvcGVyYXRpb25zLlxuICAgICAgLCBleHByZXNzaW9uLCBtYXJrZXI7XG5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAvLyBVbmFyeUV4cHJlc3Npb25cbiAgICBpZiAoaXNVbmFyeSh0b2tlbikpIHtcbiAgICAgIG1hcmtMb2NhdGlvbigpO1xuICAgICAgbmV4dCgpO1xuICAgICAgdmFyIGFyZ3VtZW50ID0gcGFyc2VTdWJFeHByZXNzaW9uKDEwLCBmbG93Q29udGV4dCk7XG4gICAgICBpZiAoYXJndW1lbnQgPT0gbnVsbCkgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxleHByZXNzaW9uPicsIHRva2VuKTtcbiAgICAgIGV4cHJlc3Npb24gPSBmaW5pc2hOb2RlKGFzdC51bmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50KSk7XG4gICAgfVxuICAgIGlmIChudWxsID09IGV4cHJlc3Npb24pIHtcbiAgICAgIC8vIFByaW1hcnlFeHByZXNzaW9uXG4gICAgICBleHByZXNzaW9uID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG5cbiAgICAgIC8vIFByZWZpeEV4cHJlc3Npb25cbiAgICAgIGlmIChudWxsID09IGV4cHJlc3Npb24pIHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlUHJlZml4RXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgbm90IGEgdmFsaWQgbGVmdCBoYW5kIGV4cHJlc3Npb24uXG4gICAgaWYgKG51bGwgPT0gZXhwcmVzc2lvbikgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcHJlY2VkZW5jZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgb3BlcmF0b3IgPSB0b2tlbi52YWx1ZTtcblxuICAgICAgcHJlY2VkZW5jZSA9IChQdW5jdHVhdG9yID09PSB0b2tlbi50eXBlIHx8IEtleXdvcmQgPT09IHRva2VuLnR5cGUpID9cbiAgICAgICAgYmluYXJ5UHJlY2VkZW5jZShvcGVyYXRvcikgOiAwO1xuXG4gICAgICBpZiAocHJlY2VkZW5jZSA9PT0gMCB8fCBwcmVjZWRlbmNlIDw9IG1pblByZWNlZGVuY2UpIGJyZWFrO1xuICAgICAgLy8gUmlnaHQtaGFuZCBwcmVjZWRlbmNlIG9wZXJhdG9yc1xuICAgICAgaWYgKCdeJyA9PT0gb3BlcmF0b3IgfHwgJy4uJyA9PT0gb3BlcmF0b3IpIC0tcHJlY2VkZW5jZTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHZhciByaWdodCA9IHBhcnNlU3ViRXhwcmVzc2lvbihwcmVjZWRlbmNlLCBmbG93Q29udGV4dCk7XG4gICAgICBpZiAobnVsbCA9PSByaWdodCkgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxleHByZXNzaW9uPicsIHRva2VuKTtcbiAgICAgIC8vIFB1c2ggaW4gdGhlIG1hcmtlciBjcmVhdGVkIGJlZm9yZSB0aGUgbG9vcCB0byB3cmFwIGl0cyBlbnRpcmV0eS5cbiAgICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnB1c2gobWFya2VyKTtcbiAgICAgIGV4cHJlc3Npb24gPSBmaW5pc2hOb2RlKGFzdC5iaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByZXNzaW9uLCByaWdodCkpO1xuXG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG5cbiAgLy8gICAgIHByZWZpeGV4cCA6Oj0gcHJlZml4IHtzdWZmaXh9XG4gIC8vICAgICBwcmVmaXggOjo9IE5hbWUgfCAnKCcgZXhwICcpJ1xuICAvLyAgICAgc3VmZml4IDo6PSAnWycgZXhwICddJyB8ICcuJyBOYW1lIHwgJzonIE5hbWUgYXJncyB8IGFyZ3NcbiAgLy9cbiAgLy8gICAgIGFyZ3MgOjo9ICcoJyBbZXhwbGlzdF0gJyknIHwgdGFibGVjb25zdHJ1Y3RvciB8IFN0cmluZ1xuXG4gIGZ1bmN0aW9uIHBhcnNlUHJlZml4RXhwcmVzc2lvblBhcnQoYmFzZSwgbWFya2VyLCBmbG93Q29udGV4dCkge1xuICAgIHZhciBleHByZXNzaW9uLCBpZGVudGlmaWVyO1xuXG4gICAgaWYgKFB1bmN0dWF0b3IgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgZXhwZWN0KCddJyk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmluZGV4RXhwcmVzc2lvbihiYXNlLCBleHByZXNzaW9uKSk7XG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBpZGVudGlmaWVyID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0Lm1lbWJlckV4cHJlc3Npb24oYmFzZSwgJy4nLCBpZGVudGlmaWVyKSk7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBpZGVudGlmaWVyID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgYmFzZSA9IGZpbmlzaE5vZGUoYXN0Lm1lbWJlckV4cHJlc3Npb24oYmFzZSwgJzonLCBpZGVudGlmaWVyKSk7XG4gICAgICAgICAgLy8gT25jZSBhIDogaXMgZm91bmQsIHRoaXMgaGFzIHRvIGJlIGEgQ2FsbEV4cHJlc3Npb24sIG90aGVyd2lzZVxuICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUNhbGxFeHByZXNzaW9uKGJhc2UsIGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAnKCc6IGNhc2UgJ3snOiAvLyBhcmdzXG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQ2FsbEV4cHJlc3Npb24oYmFzZSwgZmxvd0NvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoU3RyaW5nTGl0ZXJhbCA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICByZXR1cm4gcGFyc2VDYWxsRXhwcmVzc2lvbihiYXNlLCBmbG93Q29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByZWZpeEV4cHJlc3Npb24oZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgYmFzZSwgbmFtZSwgbWFya2VyO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuXG4gICAgLy8gVGhlIHByZWZpeFxuICAgIGlmIChJZGVudGlmaWVyID09PSB0b2tlbi50eXBlKSB7XG4gICAgICBuYW1lID0gdG9rZW4udmFsdWU7XG4gICAgICBiYXNlID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAvLyBTZXQgdGhlIHBhcmVudCBzY29wZS5cbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBhdHRhY2hTY29wZShiYXNlLCBzY29wZUhhc05hbWUobmFtZSkpO1xuICAgIH0gZWxzZSBpZiAoY29uc3VtZSgnKCcpKSB7XG4gICAgICBiYXNlID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgZXhwZWN0KCcpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRoZSBzdWZmaXhcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmV3QmFzZSA9IHBhcnNlUHJlZml4RXhwcmVzc2lvblBhcnQoYmFzZSwgbWFya2VyLCBmbG93Q29udGV4dCk7XG4gICAgICBpZiAobmV3QmFzZSA9PT0gbnVsbClcbiAgICAgICAgYnJlYWs7XG4gICAgICBiYXNlID0gbmV3QmFzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIC8vICAgICBhcmdzIDo6PSAnKCcgW2V4cGxpc3RdICcpJyB8IHRhYmxlY29uc3RydWN0b3IgfCBTdHJpbmdcblxuICBmdW5jdGlvbiBwYXJzZUNhbGxFeHByZXNzaW9uKGJhc2UsIGZsb3dDb250ZXh0KSB7XG4gICAgaWYgKFB1bmN0dWF0b3IgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgaWYgKCFmZWF0dXJlcy5lbXB0eVN0YXRlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRva2VuLmxpbmUgIT09IHByZXZpb3VzVG9rZW4ubGluZSlcbiAgICAgICAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmFtYmlndW91c1N5bnRheCwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgICAvLyBMaXN0IG9mIGV4cHJlc3Npb25zXG4gICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgIGlmIChudWxsICE9IGV4cHJlc3Npb24pIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgd2hpbGUgKGNvbnN1bWUoJywnKSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmNhbGxFeHByZXNzaW9uKGJhc2UsIGV4cHJlc3Npb25zKSk7XG5cbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgbWFya0xvY2F0aW9uKCk7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHZhciB0YWJsZSA9IHBhcnNlVGFibGVDb25zdHJ1Y3RvcihmbG93Q29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LnRhYmxlQ2FsbEV4cHJlc3Npb24oYmFzZSwgdGFibGUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFN0cmluZ0xpdGVyYWwgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5zdHJpbmdDYWxsRXhwcmVzc2lvbihiYXNlLCBwYXJzZVByaW1hcnlFeHByZXNzaW9uKGZsb3dDb250ZXh0KSkpO1xuICAgIH1cblxuICAgIHJhaXNlVW5leHBlY3RlZFRva2VuKCdmdW5jdGlvbiBhcmd1bWVudHMnLCB0b2tlbik7XG4gIH1cblxuICAvLyAgICAgcHJpbWFyeSA6Oj0gU3RyaW5nIHwgTnVtZXJpYyB8IG5pbCB8IHRydWUgfCBmYWxzZVxuICAvLyAgICAgICAgICB8IGZ1bmN0aW9uZGVmIHwgdGFibGVjb25zdHJ1Y3RvciB8ICcuLi4nXG5cbiAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihmbG93Q29udGV4dCkge1xuICAgIHZhciBsaXRlcmFscyA9IFN0cmluZ0xpdGVyYWwgfCBOdW1lcmljTGl0ZXJhbCB8IEJvb2xlYW5MaXRlcmFsIHwgTmlsTGl0ZXJhbCB8IFZhcmFyZ0xpdGVyYWxcbiAgICAgICwgdmFsdWUgPSB0b2tlbi52YWx1ZVxuICAgICAgLCB0eXBlID0gdG9rZW4udHlwZVxuICAgICAgLCBtYXJrZXI7XG5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gVmFyYXJnTGl0ZXJhbCAmJiAhZmxvd0NvbnRleHQuYWxsb3dWYXJhcmcpIHtcbiAgICAgIHJhaXNlKHRva2VuLCBlcnJvcnMuY2Fubm90VXNlVmFyYXJnLCB0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgJiBsaXRlcmFscykge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICB2YXIgcmF3ID0gaW5wdXQuc2xpY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5saXRlcmFsKHR5cGUsIHZhbHVlLCByYXcpKTtcbiAgICB9IGVsc2UgaWYgKEtleXdvcmQgPT09IHR5cGUgJiYgJ2Z1bmN0aW9uJyA9PT0gdmFsdWUpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgbmV4dCgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNyZWF0ZVNjb3BlKCk7XG4gICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG51bGwpO1xuICAgIH0gZWxzZSBpZiAoY29uc3VtZSgneycpKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIHJldHVybiBwYXJzZVRhYmxlQ29uc3RydWN0b3IoZmxvd0NvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlclxuICAvLyAtLS0tLS1cblxuICAvLyBFeHBvcnQgdGhlIG1haW4gcGFyc2VyLlxuICAvL1xuICAvLyAgIC0gYHdhaXRgIEhvbGQgcGFyc2luZyB1bnRpbCBlbmQoKSBpcyBjYWxsZWQuIERlZmF1bHRzIHRvIGZhbHNlXG4gIC8vICAgLSBgY29tbWVudHNgIFN0b3JlIGNvbW1lbnRzLiBEZWZhdWx0cyB0byB0cnVlLlxuICAvLyAgIC0gYHNjb3BlYCBUcmFjayBpZGVudGlmaWVyIHNjb3BlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgLy8gICAtIGBsb2NhdGlvbnNgIFN0b3JlIGxvY2F0aW9uIGluZm9ybWF0aW9uLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgLy8gICAtIGByYW5nZXNgIFN0b3JlIHRoZSBzdGFydCBhbmQgZW5kIGNoYXJhY3RlciBsb2NhdGlvbnMuIERlZmF1bHRzIHRvXG4gIC8vICAgICBmYWxzZS5cbiAgLy8gICAtIGBvbkNyZWF0ZU5vZGVgIENhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgc3ludGF4IG5vZGUgaXNcbiAgLy8gICAgIGNyZWF0ZWQuXG4gIC8vICAgLSBgb25DcmVhdGVTY29wZWAgQ2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBuZXcgc2NvcGUgaXNcbiAgLy8gICAgIGNyZWF0ZWQuXG4gIC8vICAgLSBgb25EZXN0cm95U2NvcGVgIENhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBjdXJyZW50IHNjb3BlXG4gIC8vICAgICBpcyBkZXN0cm95ZWQuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICB2YXIgcGFyc2VyID0gcmVxdWlyZSgnbHVhcGFyc2VyJyk7XG4gIC8vICAgICBwYXJzZXIucGFyc2UoJ2kgPSAwJyk7XG5cbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG4gIHZhciB2ZXJzaW9uRmVhdHVyZXMgPSB7XG4gICAgJzUuMSc6IHtcbiAgICB9LFxuICAgICc1LjInOiB7XG4gICAgICBsYWJlbHM6IHRydWUsXG4gICAgICBlbXB0eVN0YXRlbWVudDogdHJ1ZSxcbiAgICAgIGhleEVzY2FwZXM6IHRydWUsXG4gICAgICBza2lwV2hpdGVzcGFjZUVzY2FwZTogdHJ1ZSxcbiAgICAgIHN0cmljdEVzY2FwZXM6IHRydWUsXG4gICAgICByZWxheGVkQnJlYWs6IHRydWVcbiAgICB9LFxuICAgICc1LjMnOiB7XG4gICAgICBsYWJlbHM6IHRydWUsXG4gICAgICBlbXB0eVN0YXRlbWVudDogdHJ1ZSxcbiAgICAgIGhleEVzY2FwZXM6IHRydWUsXG4gICAgICBza2lwV2hpdGVzcGFjZUVzY2FwZTogdHJ1ZSxcbiAgICAgIHN0cmljdEVzY2FwZXM6IHRydWUsXG4gICAgICB1bmljb2RlRXNjYXBlczogdHJ1ZSxcbiAgICAgIGJpdHdpc2VPcGVyYXRvcnM6IHRydWUsXG4gICAgICBpbnRlZ2VyRGl2aXNpb246IHRydWUsXG4gICAgICByZWxheGVkQnJlYWs6IHRydWVcbiAgICB9LFxuICAgICdMdWFKSVQnOiB7XG4gICAgICAvLyBYWFg6IEx1YUpJVCBsYW5ndWFnZSBmZWF0dXJlcyBtYXkgZGVwZW5kIG9uIGNvbXBpbGF0aW9uIG9wdGlvbnM7IG1heSBuZWVkIHRvXG4gICAgICAvLyByZXRoaW5rIGhvdyB0byBoYW5kbGUgdGhpcy4gU3BlY2lmaWNhbGx5LCB0aGVyZSBpcyBhIExVQUpJVF9FTkFCTEVfTFVBNTJDT01QQVRcbiAgICAgIC8vIHRoYXQgcmVtb3ZlcyBjb250ZXh0dWFsIGdvdG8uIE1heWJlIGFkZCAnTHVhSklULTUuMmNvbXBhdCcgYXMgd2VsbD9cbiAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgIGNvbnRleHR1YWxHb3RvOiB0cnVlLFxuICAgICAgaGV4RXNjYXBlczogdHJ1ZSxcbiAgICAgIHNraXBXaGl0ZXNwYWNlRXNjYXBlOiB0cnVlLFxuICAgICAgc3RyaWN0RXNjYXBlczogdHJ1ZSxcbiAgICAgIHVuaWNvZGVFc2NhcGVzOiB0cnVlLFxuICAgICAgaW1hZ2luYXJ5TnVtYmVyczogdHJ1ZSxcbiAgICAgIGludGVnZXJTdWZmaXhlczogdHJ1ZVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZShfaW5wdXQsIF9vcHRpb25zKSB7XG4gICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgX29wdGlvbnMgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBfaW5wdXQpIHtcbiAgICAgIF9vcHRpb25zID0gX2lucHV0O1xuICAgICAgX2lucHV0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIV9vcHRpb25zKSBfb3B0aW9ucyA9IHt9O1xuXG4gICAgaW5wdXQgPSBfaW5wdXQgfHwgJyc7XG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIF9vcHRpb25zKTtcblxuICAgIC8vIFJld2luZCB0aGUgbGV4ZXJcbiAgICBpbmRleCA9IDA7XG4gICAgbGluZSA9IDE7XG4gICAgbGluZVN0YXJ0ID0gMDtcbiAgICBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgLy8gV2hlbiB0cmFja2luZyBpZGVudGlmaWVyIHNjb3BlLCBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgc2NvcGUuXG4gICAgc2NvcGVzID0gW1tdXTtcbiAgICBzY29wZURlcHRoID0gMDtcbiAgICBnbG9iYWxzID0gW107XG4gICAgbG9jYXRpb25zID0gW107XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2ZXJzaW9uRmVhdHVyZXMsIG9wdGlvbnMubHVhVmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzcHJpbnRmKFwiTHVhIHZlcnNpb24gJyUxJyBub3Qgc3VwcG9ydGVkXCIsIG9wdGlvbnMubHVhVmVyc2lvbikpO1xuICAgIH1cblxuICAgIGZlYXR1cmVzID0gYXNzaWduKHt9LCB2ZXJzaW9uRmVhdHVyZXNbb3B0aW9ucy5sdWFWZXJzaW9uXSk7XG4gICAgaWYgKG9wdGlvbnMuZXh0ZW5kZWRJZGVudGlmaWVycyAhPT0gdm9pZCAwKVxuICAgICAgZmVhdHVyZXMuZXh0ZW5kZWRJZGVudGlmaWVycyA9ICEhb3B0aW9ucy5leHRlbmRlZElkZW50aWZpZXJzO1xuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZW5jb2RpbmdNb2Rlcywgb3B0aW9ucy5lbmNvZGluZ01vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZihcIkVuY29kaW5nIG1vZGUgJyUxJyBub3Qgc3VwcG9ydGVkXCIsIG9wdGlvbnMuZW5jb2RpbmdNb2RlKSk7XG4gICAgfVxuXG4gICAgZW5jb2RpbmdNb2RlID0gZW5jb2RpbmdNb2Rlc1tvcHRpb25zLmVuY29kaW5nTW9kZV07XG5cbiAgICBpZiAob3B0aW9ucy5jb21tZW50cykgY29tbWVudHMgPSBbXTtcbiAgICBpZiAoIW9wdGlvbnMud2FpdCkgcmV0dXJuIGVuZCgpO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgLy8gV3JpdGUgdG8gdGhlIHNvdXJjZSBjb2RlIGJ1ZmZlciB3aXRob3V0IGJlZ2lubmluZyB0aGUgcGFyc2UuXG4gIGV4cG9ydHMud3JpdGUgPSB3cml0ZTtcblxuICBmdW5jdGlvbiB3cml0ZShfaW5wdXQpIHtcbiAgICBpbnB1dCArPSBTdHJpbmcoX2lucHV0KTtcbiAgICBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICAvLyBTZW5kIGFuIEVPRiBhbmQgYmVnaW4gcGFyc2luZy5cbiAgZXhwb3J0cy5lbmQgPSBlbmQ7XG5cbiAgZnVuY3Rpb24gZW5kKF9pbnB1dCkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIF9pbnB1dCkgd3JpdGUoX2lucHV0KTtcblxuICAgIC8vIElnbm9yZSBzaGViYW5ncy5cbiAgICBpZiAoaW5wdXQgJiYgaW5wdXQuc3Vic3RyKDAsIDIpID09PSAnIyEnKSBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL14uKi8sIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS5yZXBsYWNlKC8uL2csICcgJyk7XG4gICAgfSk7XG5cbiAgICBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdHJhY2tMb2NhdGlvbnMgPSBvcHRpb25zLmxvY2F0aW9ucyB8fCBvcHRpb25zLnJhbmdlcztcbiAgICAvLyBJbml0aWFsaXplIHdpdGggYSBsb29rYWhlYWQgdG9rZW4uXG4gICAgbG9va2FoZWFkID0gbGV4KCk7XG5cbiAgICB2YXIgY2h1bmsgPSBwYXJzZUNodW5rKCk7XG4gICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIGNodW5rLmNvbW1lbnRzID0gY29tbWVudHM7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGNodW5rLmdsb2JhbHMgPSBnbG9iYWxzO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGxvY2F0aW9ucy5sZW5ndGggPiAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhdGlvbiB0cmFja2luZyBmYWlsZWQuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcgaW4gbHVhcGFyc2UnKTtcblxuICAgIHJldHVybiBjaHVuaztcbiAgfVxuXG59KSk7XG4vKiB2aW06IHNldCBzdz0yIHRzPTIgZXQgdHc9NzkgOiAqL1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzcyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG51bWJlcklzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuXHRcdHJldHVybiAxIC8gYSA9PT0gMSAvIGI7XG5cdH1cblx0aWYgKGEgPT09IGIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAobnVtYmVySXNOYU4oYSkgJiYgbnVtYmVySXNOYU4oYikpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5Njg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDk4KTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzcyKTtcbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkzNyk7XG52YXIgc2hpbSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA4Nyk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE9iamVjdCk7XG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE5Mzc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjM3Mik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDg3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MzcpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1Nyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IGlzOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNjA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBrZXlzU2hpbTtcbmlmICghT2JqZWN0LmtleXMpIHtcblx0Ly8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBpc0FyZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2OCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcblx0dmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xuXHR2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcblx0dmFyIGRvbnRFbnVtcyA9IFtcblx0XHQndG9TdHJpbmcnLFxuXHRcdCd0b0xvY2FsZVN0cmluZycsXG5cdFx0J3ZhbHVlT2YnLFxuXHRcdCdoYXNPd25Qcm9wZXJ0eScsXG5cdFx0J2lzUHJvdG90eXBlT2YnLFxuXHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0J2NvbnN0cnVjdG9yJ1xuXHRdO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHRcdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcblx0fTtcblx0dmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0XHQkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcblx0XHQkY29uc29sZTogdHJ1ZSxcblx0XHQkZXh0ZXJuYWw6IHRydWUsXG5cdFx0JGZyYW1lOiB0cnVlLFxuXHRcdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdFx0JGZyYW1lczogdHJ1ZSxcblx0XHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdFx0JGlubmVyV2lkdGg6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG5cdFx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHRcdCRvdXRlcldpZHRoOiB0cnVlLFxuXHRcdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0XHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdFx0JHBhcmVudDogdHJ1ZSxcblx0XHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0XHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHRcdCRzY3JvbGxYOiB0cnVlLFxuXHRcdCRzY3JvbGxZOiB0cnVlLFxuXHRcdCRzZWxmOiB0cnVlLFxuXHRcdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdFx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHRcdCR3aW5kb3c6IHRydWVcblx0fTtcblx0dmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSgpKTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHRrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHRcdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHRcdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdFx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRcdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRcdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoZUtleXM7XG5cdH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MjI4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjgpO1xuXG52YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5cztcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IF9fd2VicGFja19yZXF1aXJlX18oODE2MCk7XG5cbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcblxua2V5c1NoaW0uc2hpbSA9IGZ1bmN0aW9uIHNoaW1PYmplY3RLZXlzKCkge1xuXHRpZiAoT2JqZWN0LmtleXMpIHtcblx0XHR2YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBTYWZhcmkgNS4wIGJ1Z1xuXHRcdFx0dmFyIGFyZ3MgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPT09IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0fSgxLCAyKSk7XG5cdFx0aWYgKCFrZXlzV29ya3NXaXRoQXJndW1lbnRzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG5cdFx0XHRcdGlmIChpc0FyZ3Mob2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMoc2xpY2UuY2FsbChvYmplY3QpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKG9iamVjdCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRPYmplY3Qua2V5cyA9IGtleXNTaGltO1xuXHR9XG5cdHJldHVybiBPYmplY3Qua2V5cyB8fCBrZXlzU2hpbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2ODpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHR2YXIgaXNBcmdzID0gc3RyID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcblx0aWYgKCFpc0FyZ3MpIHtcblx0XHRpc0FyZ3MgPSBzdHIgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHRcdHRvU3RyLmNhbGwodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0fVxuXHRyZXR1cm4gaXNBcmdzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkwNzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYxMDg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYpO1xudmFyIGhhc0Rlc2NyaXB0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjM5KSgpO1xudmFyIGdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMzYpO1xuXG52YXIgJFR5cGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2OCk7XG52YXIgJGZsb29yID0gR2V0SW50cmluc2ljKCclTWF0aC5mbG9vciUnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0RnVuY3Rpb25MZW5ndGgoZm4sIGxlbmd0aCkge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BmbmAgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0fVxuXHRpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoIDwgMCB8fCBsZW5ndGggPiAweEZGRkZGRkZGIHx8ICRmbG9vcihsZW5ndGgpICE9PSBsZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxlbmd0aGAgbXVzdCBiZSBhIHBvc2l0aXZlIDMyLWJpdCBpbnRlZ2VyJyk7XG5cdH1cblxuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiAhIWFyZ3VtZW50c1syXTtcblxuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdHZhciBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSB0cnVlO1xuXHRpZiAoJ2xlbmd0aCcgaW4gZm4gJiYgZ09QRCkge1xuXHRcdHZhciBkZXNjID0gZ09QRChmbiwgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoZGVzYyAmJiAhZGVzYy53cml0YWJsZSkge1xuXHRcdFx0ZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgfHwgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlIHx8ICFsb29zZSkge1xuXHRcdGlmIChoYXNEZXNjcmlwdG9ycykge1xuXHRcdFx0ZGVmaW5lKC8qKiBAdHlwZSB7UGFyYW1ldGVyczxkZWZpbmU+WzBdfSAqLyAoZm4pLCAnbGVuZ3RoJywgbGVuZ3RoLCB0cnVlLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVmaW5lKC8qKiBAdHlwZSB7UGFyYW1ldGVyczxkZWZpbmU+WzBdfSAqLyAoZm4pLCAnbGVuZ3RoJywgbGVuZ3RoKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZuO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjEyNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBCYXNlU2VydmljZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQmFzZVNlcnZpY2UpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUwMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzcwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNDEpO1xuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cblxuY2xhc3MgQmFzZVNlcnZpY2Uge1xuICAgIGFkZERvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRzW2RvY3VtZW50LnVyaV0gPSB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18vKiAuVGV4dERvY3VtZW50ICovIC5WLmNyZWF0ZShkb2N1bWVudC51cmksIGRvY3VtZW50Lmxhbmd1YWdlSWQsIGRvY3VtZW50LnZlcnNpb24sIGRvY3VtZW50LnRleHQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudCh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRzW3VyaV07XG4gICAgfVxuICAgIHJlbW92ZURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5hbWVEb2N1bWVudChkb2N1bWVudCwgbmV3RG9jdW1lbnRVcmkpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudHNbbmV3RG9jdW1lbnRVcmldID0gdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgdGhpcy5vcHRpb25zW25ld0RvY3VtZW50VXJpXSA9IHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldO1xuICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50KGRvY3VtZW50KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRWYWx1ZSh1cmkpIHtcbiAgICAgICAgdmFyIF90aGlzX2dldERvY3VtZW50O1xuICAgICAgICByZXR1cm4gKF90aGlzX2dldERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCh1cmkpKSA9PT0gbnVsbCB8fCBfdGhpc19nZXREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfZ2V0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGlkZW50aWZpZXIudXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYuY3JlYXRlKGRvY3VtZW50LnVyaSwgZG9jdW1lbnQubGFuZ3VhZ2VJZCwgZG9jdW1lbnQudmVyc2lvbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXSA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICB9XG4gICAgc2V0V29ya3NwYWNlKHdvcmtzcGFjZVVyaSkge1xuICAgICAgICB0aGlzLndvcmtzcGFjZVVyaSA9IHdvcmtzcGFjZVVyaTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhkb2N1bWVudFVyaSwgb3B0aW9ucywgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldID0gbWVyZ2UgPyAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5tZXJnZU9iamVjdHMgKi8gLnJMKShvcHRpb25zLCB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldKSA6IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbihkb2N1bWVudFVyaSwgb3B0aW9uTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXSAmJiB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXVtvcHRpb25OYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYudXBkYXRlKGRvY3VtZW50LCBkZWx0YXMsIGlkZW50aWZpZXIudmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZmluZERvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MoKSB7XG4gICAgICAgIHZhciBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSwgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvckNvZGVzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvckNvZGVzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb0lnbm9yZTogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNlbWFudGljVG9rZW5zKGRvY3VtZW50LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRDb2RlQWN0aW9ucyhkb2N1bWVudCwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgZXhlY3V0ZUNvbW1hbmQoY29tbWFuZCwgYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBzZW5kQXBwbGllZFJlc3VsdChyZXN1bHQsIGNhbGxiYWNrSWQpIHt9XG4gICAgY29uc3RydWN0b3IobW9kZSwgd29ya3NwYWNlVXJpKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VOYW1lXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJkb2N1bWVudHNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJnbG9iYWxPcHRpb25zXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VEYXRhXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIndvcmtzcGFjZVVyaVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY2xpZW50Q2FwYWJpbGl0aWVzXCIsIHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZERvY3VtZW50U3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHVibGlzaERpYWdub3N0aWNzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRJbmZvcm1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0YWdTdXBwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNldDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkRpYWdub3N0aWNUYWcuVW5uZWNlc3NhcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRGb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhaW50ZXh0J1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzeW5jaHJvbml6YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd2lsbFNhdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkaWRTYXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2lsbFNhdmVXYWl0VW50aWw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuaXBwZXRTdXBwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbkZvcm1hdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWludGV4dCdcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZWxlY3RTdXBwb3J0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0U3VwcG9ydDogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUhlbHA6IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlSW5mb3JtYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb25Gb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFpbnRleHQnXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUGFyYW1ldGVyU3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudEhpZ2hsaWdodDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZW1hbnRpY1Rva2Vuczoge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmVUb2tlblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ1Rva2VuU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbk1vZGlmaWVyczogW10sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF1Z21lbnRzU3ludGF4VG9rZW5zOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb2RlQWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICAgICAgZGlkQ2hhbmdlQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGVjdXRlQ29tbWFuZDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcHBseUVkaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdDoge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlSGFuZGxpbmc6IFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplc0xpbmVFbmRpbmdzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMud29ya3NwYWNlVXJpID0gd29ya3NwYWNlVXJpO1xuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzc3MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBUazogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJMOiAoKSA9PiAoLyogYmluZGluZyAqLyBtZXJnZU9iamVjdHMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydHMgbm90RW1wdHksIG1lcmdlUmFuZ2VzLCBjb252ZXJ0VG9VcmkgKi9cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIsIGV4Y2x1ZGVVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIGlmICghb2JqMSkgcmV0dXJuIG9iajI7XG4gICAgaWYgKCFvYmoyKSByZXR1cm4gb2JqMTtcbiAgICBpZiAoZXhjbHVkZVVuZGVmaW5lZCkge1xuICAgICAgICBvYmoxID0gZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyhvYmoxKTtcbiAgICAgICAgb2JqMiA9IGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqMik7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZE9iamVjdHMgPSB7XG4gICAgICAgIC4uLm9iajIsXG4gICAgICAgIC4uLm9iajFcbiAgICB9OyAvLyBHaXZlIHByaW9yaXR5IHRvIG9iajEgdmFsdWVzIGJ5IHNwcmVhZGluZyBvYmoyIGZpcnN0LCB0aGVuIG9iajFcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtZXJnZWRPYmplY3RzKSl7XG4gICAgICAgIGlmIChvYmoxW2tleV0gJiYgb2JqMltrZXldKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoxW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gb2JqMVtrZXldLmNvbmNhdChvYmoyW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iajJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBvYmoyW2tleV0uY29uY2F0KG9iajFba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmoxW2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoyW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gbWVyZ2VPYmplY3RzKG9iajFba2V5XSwgb2JqMltrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkT2JqZWN0cztcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqKSB7XG4gICAgY29uc3QgZmlsdGVyZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtfLCB2YWx1ZV0pPT52YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGZpbHRlcmVkRW50cmllcyk7XG59XG5mdW5jdGlvbiBub3RFbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy90YWtlbiB3aXRoIHNtYWxsIGNoYW5nZXMgZnJvbSBhY2UtY29kZVxuZnVuY3Rpb24gbWVyZ2VSYW5nZXMocmFuZ2VzKSB7XG4gICAgdmFyIGxpc3QgPSByYW5nZXM7XG4gICAgbGlzdCA9IGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlUG9pbnRzKGEuc3RhcnQsIGIuc3RhcnQpO1xuICAgIH0pO1xuICAgIHZhciBuZXh0ID0gbGlzdFswXSwgcmFuZ2U7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIG5leHQgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgY21wID0gY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuc3RhcnQpO1xuICAgICAgICBpZiAoY21wIDwgMCkgY29udGludWU7XG4gICAgICAgIGlmIChjbXAgPT0gMCAmJiAhcmFuZ2UuaXNFbXB0eSgpICYmICFuZXh0LmlzRW1wdHkoKSkgY29udGludWU7XG4gICAgICAgIGlmIChjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5lbmQpIDwgMCkge1xuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IG5leHQuZW5kLnJvdztcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBuZXh0LmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG5leHQgPSByYW5nZTtcbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVQb2ludHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyAtIHAyLnJvdyB8fCBwMS5jb2x1bW4gLSBwMi5jb2x1bW47XG59XG5mdW5jdGlvbiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5KHZhbHVlLCByZWdleHBBcnJheSkge1xuICAgIGlmICghcmVnZXhwQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcmVnZXhwQXJyYXkubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAocmVnZXhwQXJyYXlbaV0udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1VyaShmaWxlUGF0aCkge1xuICAgIC8vYWxyZWFkeSBVUklcbiAgICBpZiAoZmlsZVBhdGguc3RhcnRzV2l0aChcImZpbGU6Ly8vXCIpKSB7XG4gICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIFVSSS5maWxlKGZpbGVQYXRoKS50b1N0cmluZygpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjcyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mzg3KTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjI1KTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MzApO1xudmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk0Myk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG4vLyBTdG9yZSBhIGNvcHkgb2YgU2hhcmVkQXJyYXlCdWZmZXIgaW4gY2FzZSBpdCdzIGRlbGV0ZWQgZWxzZXdoZXJlXG52YXIgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IFNoYXJlZEFycmF5QnVmZmVyIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODI3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zbGljZSgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMxKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTI3Mik7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYxNSk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MjA4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMTA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMxMik7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcyKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzIpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMzEyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcyKTtcbmNsYXNzIE1lc3NhZ2VCdWZmZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuYXNjaWlEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICAgIH1cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXI7XG4gICAgfVxuICAgIGZyb21TdHJpbmcodmFsdWUsIF9lbmNvZGluZykge1xuICAgICAgICByZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc2NpaURlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc05hdGl2ZShidWZmZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NOYXRpdmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH1cbn1cbk1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBhcGlfMS5SQUwpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgYXBpXzEuUkFMLmluc3RhbGwoX3JpbCk7XG4gICAgfVxuICAgIFJJTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJJTCB8fCAoUklMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUklMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjcyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvdGhlbmFibGUuZC50c1wiIC8+XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5Ub3VjaCA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuUkFMID0gdm9pZCAwO1xuZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk1lc3NhZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNlRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2Rlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuRXJyb3JDb2RlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzOyB9IH0pKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTA5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZE1hcFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxpbmtlZE1hcDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMUlVDYWNoZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxSVUNhY2hlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvdWNoXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuVG91Y2g7IH0gfSkpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODQ0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3Bvc2FibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZTsgfSB9KSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkV2ZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtaXR0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FbWl0dGVyOyB9IH0pKTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuU291cmNlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KSk7XG5jb25zdCBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDg5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVJlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5NZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5BYnN0cmFjdE1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlV3JpdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5NZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VCdWZmZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTgwNSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VCdWZmZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlQnVmZmVyXzEuQWJzdHJhY3RNZXNzYWdlQnVmZmVyOyB9IH0pKTtcbmNvbnN0IGNvbm5lY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDA1NCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25PcHRpb25zXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25PcHRpb25zOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxMb2dnZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTnVsbExvZ2dlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc1Rva2VuXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlByb2dyZXNzVG9rZW47IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlByb2dyZXNzVHlwZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZVZhbHVlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZVZhbHVlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZUZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZUZvcm1hdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXRUcmFjZU5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5TZXRUcmFjZU5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dUcmFjZU5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Mb2dUcmFjZU5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uRXJyb3JzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25FcnJvcnM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25FcnJvcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk1lc3NhZ2VTdHJhdGVneTsgfSB9KSk7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5leHBvcnRzLlJBTCA9IHJhbF8xLmRlZmF1bHQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5NTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmVcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXG4gICAgICAgICAgICB8fCAoSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpICYmICEhY2FuZGlkYXRlLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDU0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNjIpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMDkpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xudmFyIENhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoQ2FuY2VsTm90aWZpY2F0aW9uKSB7XG4gICAgQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2NhbmNlbFJlcXVlc3QnKTtcbn0pKENhbmNlbE5vdGlmaWNhdGlvbiB8fCAoQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBQcm9ncmVzc1Rva2VuO1xuKGZ1bmN0aW9uIChQcm9ncmVzc1Rva2VuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgUHJvZ3Jlc3NUb2tlbi5pcyA9IGlzO1xufSkoUHJvZ3Jlc3NUb2tlbiA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiB8fCAoZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0ge30pKTtcbnZhciBQcm9ncmVzc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoUHJvZ3Jlc3NOb3RpZmljYXRpb24pIHtcbiAgICBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9wcm9ncmVzcycpO1xufSkoUHJvZ3Jlc3NOb3RpZmljYXRpb24gfHwgKFByb2dyZXNzTm90aWZpY2F0aW9uID0ge30pKTtcbmNsYXNzIFByb2dyZXNzVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBQcm9ncmVzc1R5cGU7XG52YXIgU3RhclJlcXVlc3RIYW5kbGVyO1xuKGZ1bmN0aW9uIChTdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXMuZnVuYyh2YWx1ZSk7XG4gICAgfVxuICAgIFN0YXJSZXF1ZXN0SGFuZGxlci5pcyA9IGlzO1xufSkoU3RhclJlcXVlc3RIYW5kbGVyIHx8IChTdGFyUmVxdWVzdEhhbmRsZXIgPSB7fSkpO1xuZXhwb3J0cy5OdWxsTG9nZ2VyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6ICgpID0+IHsgfSxcbiAgICB3YXJuOiAoKSA9PiB7IH0sXG4gICAgaW5mbzogKCkgPT4geyB9LFxuICAgIGxvZzogKCkgPT4geyB9XG59KTtcbnZhciBUcmFjZTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBUcmFjZVtUcmFjZVtcIk9mZlwiXSA9IDBdID0gXCJPZmZcIjtcbiAgICBUcmFjZVtUcmFjZVtcIk1lc3NhZ2VzXCJdID0gMV0gPSBcIk1lc3NhZ2VzXCI7XG4gICAgVHJhY2VbVHJhY2VbXCJDb21wYWN0XCJdID0gMl0gPSBcIkNvbXBhY3RcIjtcbiAgICBUcmFjZVtUcmFjZVtcIlZlcmJvc2VcIl0gPSAzXSA9IFwiVmVyYm9zZVwiO1xufSkoVHJhY2UgPSBleHBvcnRzLlRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0ge30pKTtcbnZhciBUcmFjZVZhbHVlcztcbihmdW5jdGlvbiAoVHJhY2VWYWx1ZXMpIHtcbiAgICAvKipcbiAgICAgKiBUdXJuIHRyYWNpbmcgb2ZmLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLk9mZiA9ICdvZmYnO1xuICAgIC8qKlxuICAgICAqIFRyYWNlIG1lc3NhZ2VzIG9ubHkuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuTWVzc2FnZXMgPSAnbWVzc2FnZXMnO1xuICAgIC8qKlxuICAgICAqIENvbXBhY3QgbWVzc2FnZSB0cmFjaW5nLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLkNvbXBhY3QgPSAnY29tcGFjdCc7XG4gICAgLyoqXG4gICAgICogVmVyYm9zZSBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuVmVyYm9zZSA9ICd2ZXJib3NlJztcbn0pKFRyYWNlVmFsdWVzID0gZXhwb3J0cy5UcmFjZVZhbHVlcyB8fCAoZXhwb3J0cy5UcmFjZVZhbHVlcyA9IHt9KSk7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk1lc3NhZ2VzO1xuICAgICAgICAgICAgY2FzZSAnY29tcGFjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgICAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuVmVyYm9zZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk9mZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk1lc3NhZ2VzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnY29tcGFjdCc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJib3NlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLnRvU3RyaW5nID0gdG9TdHJpbmc7XG59KShUcmFjZSA9IGV4cG9ydHMuVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlRm9ybWF0O1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIFRyYWNlRm9ybWF0W1wiVGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIFRyYWNlRm9ybWF0W1wiSlNPTlwiXSA9IFwianNvblwiO1xufSkoVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2VGb3JtYXQpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LkpTT047XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZUZvcm1hdC5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbn0pKFRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZUZvcm1hdCB8fCAoZXhwb3J0cy5UcmFjZUZvcm1hdCA9IHt9KSk7XG52YXIgU2V0VHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFNldFRyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvc2V0VHJhY2UnKTtcbn0pKFNldFRyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgTG9nVHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKExvZ1RyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvbG9nVHJhY2UnKTtcbn0pKExvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbkVycm9ycztcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkVycm9ycykge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJDbG9zZWRcIl0gPSAxXSA9IFwiQ2xvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkRpc3Bvc2VkXCJdID0gMl0gPSBcIkRpc3Bvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBpbiBsaXN0ZW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJBbHJlYWR5TGlzdGVuaW5nXCJdID0gM10gPSBcIkFscmVhZHlMaXN0ZW5pbmdcIjtcbn0pKENvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgfHwgKGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyA9IHt9KSk7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gQ29ubmVjdGlvbkVycm9yO1xudmFyIENvbm5lY3Rpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2FuY2VsVW5kaXNwYXRjaGVkKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDb25uZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmtpbmQgPT09ICdpZCcpICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKSAmJiAoY2FuZGlkYXRlLmRpc3Bvc2UgPT09IHVuZGVmaW5lZCB8fCBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSk7XG4gICAgfVxuICAgIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlcXVlc3QnICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKSAmJiAoY2FuZGlkYXRlLmRpc3Bvc2UgPT09IHVuZGVmaW5lZCB8fCBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSk7XG4gICAgfVxuICAgIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoXykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSkgfHwgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXModmFsdWUpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgc2VuZENhbmNlbGxhdGlvbihjb25uLCBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm4uc2VuZE5vdGlmaWNhdGlvbihDYW5jZWxOb3RpZmljYXRpb24udHlwZSwgeyBpZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cChfKSB7IH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5zZW5kQ2FuY2VsbGF0aW9uKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jbGVhbnVwKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICByZWNlaXZlcjogQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5NZXNzYWdlLFxuICAgICAgICBzZW5kZXI6IENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2VcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5yZWNlaXZlcikgJiYgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnNlbmRlcik7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIE1lc3NhZ2VTdHJhdGVneTtcbihmdW5jdGlvbiAoTWVzc2FnZVN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuaGFuZGxlTWVzc2FnZSk7XG4gICAgfVxuICAgIE1lc3NhZ2VTdHJhdGVneS5pcyA9IGlzO1xufSkoTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgfHwgKGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0ge30pKTtcbnZhciBDb25uZWN0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLmNhbmNlbGxhdGlvblN0cmF0ZWd5KSB8fCBDb25uZWN0aW9uU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLmNvbm5lY3Rpb25TdHJhdGVneSkgfHwgTWVzc2FnZVN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5tZXNzYWdlU3RyYXRlZ3kpKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvbk9wdGlvbnMuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25PcHRpb25zID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IHt9KSk7XG52YXIgQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTmV3XCJdID0gMV0gPSBcIk5ld1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJMaXN0ZW5pbmdcIl0gPSAyXSA9IFwiTGlzdGVuaW5nXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkNsb3NlZFwiXSA9IDNdID0gXCJDbG9zZWRcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiRGlzcG9zZWRcIl0gPSA0XSA9IFwiRGlzcG9zZWRcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKG1lc3NhZ2VSZWFkZXIsIG1lc3NhZ2VXcml0ZXIsIF9sb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBfbG9nZ2VyICE9PSB1bmRlZmluZWQgPyBfbG9nZ2VyIDogZXhwb3J0cy5OdWxsTG9nZ2VyO1xuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgbGV0IG5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgdW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGNvbnN0IHZlcnNpb24gPSAnMi4wJztcbiAgICBsZXQgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvZ3Jlc3NIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdGltZXI7XG4gICAgbGV0IG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICBsZXQgcmVzcG9uc2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgIGxldCByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgIGxldCB0cmFjZSA9IFRyYWNlLk9mZjtcbiAgICBsZXQgdHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdC5UZXh0O1xuICAgIGxldCB0cmFjZXI7XG4gICAgbGV0IHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLk5ldztcbiAgICBjb25zdCBlcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBkaXNwb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNhbmNlbGxhdGlvblN0cmF0ZWd5KSA/IG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kgOiBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2VuZCByZXF1ZXN0cyB3aXRoIGlkIG51bGwgc2luY2UgdGhlIHJlc3BvbnNlIGNhbid0IGJlIGNvcnJlbGF0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdyZXEtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy11bmtub3duLScgKyAoKyt1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLScgKyBpZC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCkge1xuICAgICAgICByZXR1cm4gJ25vdC0nICsgKCsrbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE1lc3NhZ2VUb1F1ZXVlKHF1ZXVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KG1lc3NhZ2UuaWQpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbFVuZGlzcGF0Y2hlZChfbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpc3RlbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VIYW5kbGVyKCkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5OZXcgfHwgc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZDtcbiAgICAgICAgICAgIGNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gaXMgZGlzcG9zZWQgZG9uJ3Qgc2VudCBjbG9zZSBldmVudHMuXG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoW2Vycm9yLCB1bmRlZmluZWQsIHVuZGVmaW5lZF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUVycm9ySGFuZGxlcihkYXRhKSB7XG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKGRhdGEpO1xuICAgIH1cbiAgICBtZXNzYWdlUmVhZGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlUmVhZGVyLm9uRXJyb3IocmVhZEVycm9ySGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkVycm9yKHdyaXRlRXJyb3JIYW5kbGVyKTtcbiAgICBmdW5jdGlvbiB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAodGltZXIgfHwgbWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHByb2Nlc3NNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAobWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyYXRlZ3kgPSBvcHRpb25zPy5tZXNzYWdlU3RyYXRlZ3k7XG4gICAgICAgICAgICBpZiAoTWVzc2FnZVN0cmF0ZWd5LmlzKG1lc3NhZ2VTdHJhdGVneSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlU3RyYXRlZ3kuaGFuZGxlTWVzc2FnZShtZXNzYWdlLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2sgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWNlaXZlZCBhIGNhbmNlbGxhdGlvbiBtZXNzYWdlLiBDaGVjayBpZiB0aGUgbWVzc2FnZSBpcyBzdGlsbCBpbiB0aGUgcXVldWVcbiAgICAgICAgICAgIC8vIGFuZCBjYW5jZWwgaXQgaWYgYWxsb3dlZCB0byBkbyBzby5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkgJiYgbWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0NhbmNlbCA9IG1lc3NhZ2VRdWV1ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdCh0b0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBvcHRpb25zPy5jb25uZWN0aW9uU3RyYXRlZ3k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKHN0cmF0ZWd5ICYmIHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCkgPyBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwsIGNhbmNlbFVuZGlzcGF0Y2hlZCkgOiBjYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLmVycm9yICE9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UucmVzdWx0ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZShjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5pZCA9IHRvQ2FuY2VsLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UocmVzcG9uc2UsIG1lc3NhZ2UubWV0aG9kLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUocmVzcG9uc2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmb3IgY2FuY2VsZWQgbWVzc2FnZSBmYWlsZWQuYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gcmVxdWVzdFRva2Vucy5nZXQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGlzIGFscmVhZHkgcnVubmluZy4gQ2FuY2VsIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25Ub2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgY2FuY2VsIGJ1dCBzdGlsbCBxdWV1ZSB0aGUgbWVzc2FnZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCBzdGF0ZSBpbiBwcm9jZXNzIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5hZGQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZE1lc3NhZ2VUb1F1ZXVlKG1lc3NhZ2VRdWV1ZSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gd2UgcmV0dXJuIGhlcmUgc2lsZW50bHkgc2luY2Ugd2UgZmlyZWQgYW4gZXZlbnQgd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5KHJlc3VsdE9yRXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdE9yRXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVzdWx0T3JFcnJvci50b0pzb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzdWx0ID0gcmVzdWx0T3JFcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJlc3VsdE9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5RXJyb3IoZXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci50b0pzb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlTdWNjZXNzKHJlc3VsdCwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBKU09OIFJQQyBkZWZpbmVzIHRoYXQgYSByZXNwb25zZSBtdXN0IGVpdGhlciBoYXZlIGEgcmVzdWx0IG9yIGFuIGVycm9yXG4gICAgICAgICAgICAvLyBTbyB3ZSBjYW4ndCB0cmVhdCB1bmRlZmluZWQgYXMgYSB2YWxpZCByZXNwb25zZSByZXN1bHQuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2VSZWNlaXZlZFJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVxdWVzdEhhbmRsZXJzLmdldChyZXF1ZXN0TWVzc2FnZS5tZXRob2QpO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgbGV0IHJlcXVlc3RIYW5kbGVyO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0SGFuZGxlciB8fCBzdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuS2V5ID0gcmVxdWVzdE1lc3NhZ2UuaWQgPz8gU3RyaW5nKERhdGUubm93KCkpOyAvL1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uU291cmNlID0gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyKVxuICAgICAgICAgICAgICAgID8gY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UodG9rZW5LZXkpXG4gICAgICAgICAgICAgICAgOiBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwgJiYga25vd25DYW5jZWxlZFJlcXVlc3RzLmhhcyhyZXF1ZXN0TWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Tb3VyY2UuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLnNldCh0b2tlbktleSwgY2FuY2VsbGF0aW9uU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdE1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKC4uLnJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gc3RhclJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgcmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseVN1Y2Nlc3MoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHRPckVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseShyZXN1bHRPckVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQsIGBVbmhhbmRsZWQgbWV0aG9kICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFNlZSBoYW5kbGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQ6IEVycm9yIGlzOiBcXG4ke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZS5lcnJvciwgdW5kZWZpbmVkLCA0KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgcmVzcG9uc2UgbWVzc2FnZSB3aXRob3V0IGlkLiBObyBmdXJ0aGVyIGVycm9yIGluZm9ybWF0aW9uIHByb3ZpZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVzcG9uc2VNZXNzYWdlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZU1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgaGFwcGVuLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZXNwb25zZSBoYW5kbGVyICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB1bmV4cGVjdGVkbHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbm90aWZpY2F0aW9uSGFuZGxlcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDYW5jZWxOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICBrbm93bkNhbmNlbGVkUmVxdWVzdHMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm90aWZpY2F0aW9uSGFuZGxlcnMuZ2V0KG1lc3NhZ2UubWV0aG9kKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciA9IGVsZW1lbnQuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyIHx8IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gMCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgIT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBKU09OLVJQQyBsaWJyYXJpZXMgdGhhdCBzZW5kIHByb2dyZXNzIG1lc3NhZ2UgYXMgcG9zaXRpb25hbCBwYXJhbXMgYWx0aG91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBhcyBuYW1lZC4gU28gY29udmVydCB0aGVtIGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBtZXNzYWdlLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZS5tZXRob2QgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMiAmJiBQcm9ncmVzc1Rva2VuLmlzKHBhcmFtc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKHsgdG9rZW46IHBhcmFtc1swXSwgdmFsdWU6IHBhcmFtc1sxXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgcG9zaXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gbWVzc2FnZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCAke3BhcmFtcy5sZW5ndGh9IGFyZ3VtZW50c2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFyTm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiBoYW5kbGVyICcke21lc3NhZ2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmZpcmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignUmVjZWl2ZWQgZW1wdHkgbWVzc2FnZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2Ugd2hpY2ggaXMgbmVpdGhlciBhIHJlc3BvbnNlIG5vciBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlOlxcbiR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSwgbnVsbCwgNCl9YCk7XG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciB3ZSBmaW5kIGFuIGlkIHRvIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoSXMuc3RyaW5nKHJlc3BvbnNlTWVzc2FnZS5pZCkgfHwgSXMubnVtYmVyKHJlc3BvbnNlTWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3BvbnNlTWVzc2FnZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IHJlc3BvbnNlUHJvbWlzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnJlamVjdChuZXcgRXJyb3IoJ1RoZSByZWNlaXZlZCByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdCBub3IgYW4gZXJyb3IgcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVRyYWNlKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHJhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCA0KTtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuQ29tcGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVzcG9uc2UgJyR7bWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuIFByb2Nlc3NpbmcgcmVxdWVzdCB0b29rICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2AsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVxdWVzdCAnJHttZXNzYWdlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXF1ZXN0JywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIgfHwgbWVzc2FnZS5tZXRob2QgPT09IExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkUmVzcG9uc2UobWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG1lc3NhZ2UuZXJyb3IgPyBgIFJlcXVlc3QgZmFpbGVkOiAke21lc3NhZ2UuZXJyb3IubWVzc2FnZX0gKCR7bWVzc2FnZS5lcnJvci5jb2RlfSkuYCA6ICcnO1xuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJyBpbiAke0RhdGUubm93KCkgLSByZXNwb25zZVByb21pc2UudGltZXJTdGFydH1tcy4ke2Vycm9yfWAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJHttZXNzYWdlLmlkfSB3aXRob3V0IGFjdGl2ZSByZXNwb25zZSBwcm9taXNlLmAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ0xTUE1lc3NhZ2UodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRyYWNlciB8fCB0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHNwTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlzTFNQTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRyYWNlci5sb2cobHNwTWVzc2FnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCkge1xuICAgICAgICBpZiAoaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkNsb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5EaXNwb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgZGlzcG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkxpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKGlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5BbHJlYWR5TGlzdGVuaW5nLCAnQ29ubmVjdGlvbiBpcyBhbHJlYWR5IGxpc3RlbmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZOb3RMaXN0ZW5pbmcoKSB7XG4gICAgICAgIGlmICghaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGxpc3RlbigpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuZGVmaW5lZFRvTnVsbChwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc05hbWVkUGFyYW0ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtICE9PSB1bmRlZmluZWQgJiYgcGFyYW0gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocGFyYW0pICYmIHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbSkge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtZXRlclN0cnVjdHVyZXMpIHtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG86XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZFRvTnVsbChwYXJhbSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZTpcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHBhcmFtIGlzIG5vdCBhbiBvYmplY3QgbGl0ZXJhbC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgc3RydWN0dXJlICR7cGFyYW1ldGVyU3RydWN0dXJlcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHR5cGUubnVtYmVyT2ZQYXJhbXM7XG4gICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZVNpbmdsZVBhcmFtKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcywgcGFyYW1zWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoICYmIGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZFRvTnVsbChwYXJhbXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPCBudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyYW1zLmxlbmd0aDsgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgIHNlbmROb3RpZmljYXRpb246ICh0eXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlUGFyYW1zO1xuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyU3RydWN0dXJlcyA9IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuaXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbUVuZCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gcGFyYW1FbmQgLSBwYXJhbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIGFyZ3NbcGFyYW1TdGFydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgJHtudW1iZXJPZlBhcmFtc30gcGFyYW1ldGVycyBmb3IgJ2J5IE5hbWUnIG5vdGlmaWNhdGlvbiBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3RpZmljYXRpb25NZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VXcml0ZXIud3JpdGUobm90aWZpY2F0aW9uTWVzc2FnZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiBmYWlsZWQuYCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob3RpZmljYXRpb246ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUsIHsgdHlwZTogdW5kZWZpbmVkLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLnNldCh0eXBlLm1ldGhvZCwgeyB0eXBlLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NIYW5kbGVycy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmVzcyBoYW5kbGVyIGZvciB0b2tlbiAke3Rva2VufSBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuc2V0KHRva2VuLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXJzLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGF3YWl0IGJ1dCBzaW1wbGUgcmV0dXJuIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IGhhdmUgYW5vdGhlclxuICAgICAgICAgICAgLy8gYXN5bmMgc2NoZWR1bGluZy4gT3RoZXJ3aXNlIG9uZSBzZW5kIGNvdWxkIG92ZXJ0YWtlIGFub3RoZXIgc2VuZC5cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSwgeyB0b2tlbiwgdmFsdWUgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVW5oYW5kbGVkUHJvZ3Jlc3M6IHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlci5ldmVudCxcbiAgICAgICAgc2VuZFJlcXVlc3Q6ICh0eXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZk5vdExpc3RlbmluZygpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlUGFyYW1zO1xuICAgICAgICAgICAgbGV0IHRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuLmlzKGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtRW5kID0gcGFyYW1FbmQgLSAxO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gcGFyYW1FbmQgLSBwYXJhbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIGFyZ3NbcGFyYW1TdGFydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgJHtudW1iZXJPZlBhcmFtc30gcGFyYW1ldGVycyBmb3IgJ2J5IE5hbWUnIHJlcXVlc3QgcGFyYW1ldGVyIHN0cnVjdHVyZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBhcmdzLnNsaWNlKHBhcmFtU3RhcnQsIHBhcmFtRW5kKS5tYXAodmFsdWUgPT4gdW5kZWZpbmVkVG9OdWxsKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuLmlzKHBhcmFtc1tudW1iZXJPZlBhcmFtc10pID8gcGFyYW1zW251bWJlck9mUGFyYW1zXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2VxdWVuY2VOdW1iZXIrKztcbiAgICAgICAgICAgIGxldCBkaXNwb3NhYmxlO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZSA9IHRva2VuLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5zZW5kQ2FuY2VsbGF0aW9uKGNvbm5lY3Rpb24sIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVjZWl2ZWQgbm8gcHJvbWlzZSBmcm9tIGNhbmNlbGxhdGlvbiBzdHJhdGVneSB3aGVuIGNhbmNlbGxpbmcgaWQgJHtpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTZW5kaW5nIGNhbmNlbGxhdGlvbiBtZXNzYWdlcyBmb3IgaWQgJHtpZH0gZmFpbGVkYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWplY3RXaXRoQ2xlYW51cCA9IChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB7IG1ldGhvZDogbWV0aG9kLCB0aW1lclN0YXJ0OiBEYXRlLm5vdygpLCByZXNvbHZlOiByZXNvbHZlV2l0aENsZWFudXAsIHJlamVjdDogcmVqZWN0V2l0aENsZWFudXAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBtZXNzYWdlV3JpdGVyLndyaXRlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5zZXQoaWQsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVxdWVzdCBmYWlsZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRpbmcgdGhlIG1lc3NhZ2UgZmFpbGVkLiBTbyB3ZSBuZWVkIHRvIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciwgZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biByZWFzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblJlcXVlc3Q6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoU3RhclJlcXVlc3RIYW5kbGVyLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLnNldCh0eXBlLCB7IGhhbmRsZXI6IGhhbmRsZXIsIHR5cGU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1BlbmRpbmdSZXNwb25zZTogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZXMuc2l6ZSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNlOiBhc3luYyAoX3ZhbHVlLCBfdHJhY2VyLCBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGxldCBfc2VuZE5vdGlmaWNhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IF90cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICBpZiAoc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuYm9vbGVhbihzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zZW5kTm90aWZpY2F0aW9uID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMuc2VuZE5vdGlmaWNhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RyYWNlRm9ybWF0ID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zLnRyYWNlRm9ybWF0IHx8IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UgPSBfdmFsdWU7XG4gICAgICAgICAgICB0cmFjZUZvcm1hdCA9IF90cmFjZUZvcm1hdDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gX3RyYWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfc2VuZE5vdGlmaWNhdGlvbiAmJiAhaXNDbG9zZWQoKSAmJiAhaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKFNldFRyYWNlTm90aWZpY2F0aW9uLnR5cGUsIHsgdmFsdWU6IFRyYWNlLnRvU3RyaW5nKF92YWx1ZSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGVycm9yRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25DbG9zZTogY2xvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvblVuaGFuZGxlZE5vdGlmaWNhdGlvbjogdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25EaXNwb3NlOiBkaXNwb3NlRW1pdHRlci5ldmVudCxcbiAgICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XG4gICAgICAgICAgICBkaXNwb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkLCAnUGVuZGluZyByZXNwb25zZSByZWplY3RlZCBzaW5jZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHJlc3BvbnNlUHJvbWlzZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmVxdWVzdFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlV3JpdGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlUmVhZGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHRocm93SWZMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZztcbiAgICAgICAgICAgIG1lc3NhZ2VSZWFkZXIubGlzdGVuKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zcGVjdDogKCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLmNvbnNvbGUubG9nKCdpbnNwZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZSA9IHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0O1xuICAgICAgICB0cmFjZXIubG9nKHBhcmFtcy5tZXNzYWdlLCB2ZXJib3NlID8gcGFyYW1zLnZlcmJvc2UgOiB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcHJvZ3Jlc3NIYW5kbGVycy5nZXQocGFyYW1zLnRva2VuKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyYW1zLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlci5maXJlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn1cbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODg0NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSB2b2lkIDA7XG52YXIgRGlzcG9zYWJsZTtcbihmdW5jdGlvbiAoRGlzcG9zYWJsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmdW5jKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpc3Bvc2FibGUuY3JlYXRlID0gY3JlYXRlO1xufSkoRGlzcG9zYWJsZSA9IGV4cG9ydHMuRGlzcG9zYWJsZSB8fCAoZXhwb3J0cy5EaXNwb3NhYmxlID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjQ3OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50ID0gZXhwb3J0cy5FdmVudCB8fCAoZXhwb3J0cy5FdmVudCA9IHt9KSk7XG5jbGFzcyBDYWxsYmFja0xpc3Qge1xuICAgIGFkZChjYWxsYmFjaywgY29udGV4dCA9IG51bGwsIGJ1Y2tldCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVja2V0KSkge1xuICAgICAgICAgICAgYnVja2V0LnB1c2goeyBkaXNwb3NlOiAoKSA9PiB0aGlzLnJlbW92ZShjYWxsYmFjaywgY29udGV4dCkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrc1tpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dHNbaV0gPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgJiBjb250ZXh0IG1hdGNoID0+IHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBhZGRpbmcgYSBsaXN0ZW5lciB3aXRoIGEgY29udGV4dCwgeW91IHNob3VsZCByZW1vdmUgaXQgd2l0aCB0aGUgc2FtZSBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBbXSwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzLnNsaWNlKDApLCBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzLnNsaWNlKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGNhbGxiYWNrc1tpXS5hcHBseShjb250ZXh0c1tpXSwgYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLmNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9jYWxsYmFja3MgfHwgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jb250ZXh0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihfb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgcHVibGljIHRvIGFsbG93IHRvIHN1YnNjcmliZVxuICAgICAqIHRvIGV2ZW50cyBmcm9tIHRoaXMgRW1pdHRlclxuICAgICAqL1xuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnQgPSAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBDYWxsYmFja0xpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmFkZChsaXN0ZW5lciwgdGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwb3NhYmxlIGlzIGRpc3Bvc2VkIGFmdGVyIGVtaXR0ZXIgaXMgZGlzcG9zZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnJlbW92ZShsaXN0ZW5lciwgdGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3Bvc2UgPSBFbWl0dGVyLl9ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcG9zYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBrZXB0IHByaXZhdGUgdG8gZmlyZSBhbiBldmVudCB0b1xuICAgICAqIHN1YnNjcmliZXJzXG4gICAgICovXG4gICAgZmlyZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuaW52b2tlLmNhbGwodGhpcy5fY2FsbGJhY2tzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG5FbWl0dGVyLl9ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NjE4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZWxlbSA9PiBzdHJpbmcoZWxlbSkpO1xufVxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMTA5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTFJVQ2FjaGUgPSBleHBvcnRzLkxpbmtlZE1hcCA9IGV4cG9ydHMuVG91Y2ggPSB2b2lkIDA7XG52YXIgVG91Y2g7XG4oZnVuY3Rpb24gKFRvdWNoKSB7XG4gICAgVG91Y2guTm9uZSA9IDA7XG4gICAgVG91Y2guRmlyc3QgPSAxO1xuICAgIFRvdWNoLkFzT2xkID0gVG91Y2guRmlyc3Q7XG4gICAgVG91Y2guTGFzdCA9IDI7XG4gICAgVG91Y2guQXNOZXcgPSBUb3VjaC5MYXN0O1xufSkoVG91Y2ggPSBleHBvcnRzLlRvdWNoIHx8IChleHBvcnRzLlRvdWNoID0ge30pKTtcbmNsYXNzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXNbX2FdID0gJ0xpbmtlZE1hcCc7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWQ/LnZhbHVlO1xuICAgIH1cbiAgICBnZXQgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhaWw/LnZhbHVlO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guTm9uZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUsIHRvdWNoID0gVG91Y2guTm9uZSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b3VjaCAhPT0gVG91Y2guTm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHsga2V5LCB2YWx1ZSwgbmV4dDogdW5kZWZpbmVkLCBwcmV2aW91czogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBzd2l0Y2ggKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5Ob25lOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkZpcnN0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1GaXJzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5MYXN0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlbW92ZShrZXkpO1xuICAgIH1cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoaXRlbS5rZXkpO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpc0FyZykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uYmluZCh0aGlzQXJnKShjdXJyZW50LnZhbHVlLCBjdXJyZW50LmtleSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja2ZuKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQudmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogW2N1cnJlbnQua2V5LCBjdXJyZW50LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgWyhfYSA9IFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgdHJpbU9sZChuZXdTaXplKSB7XG4gICAgICAgIGlmIChuZXdTaXplID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnRTaXplID4gbmV3U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShjdXJyZW50LmtleSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgY3VycmVudFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IGN1cnJlbnRTaXplO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBhZGRJdGVtRmlyc3QoaXRlbSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBhZGRJdGVtTGFzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCAmJiBpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW5lZCBpZiBzaXplID09PSAxIHdoaWNoIGlzIGhhbmRsZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGNhc2UgYWJvdmUuXG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8ICFwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHRvdWNoKGl0ZW0sIHRvdWNoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRvdWNoICE9PSBUb3VjaC5GaXJzdCAmJiB0b3VjaCAhPT0gVG91Y2guTGFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggPT09IFRvdWNoLkZpcnN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW1cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCBoZWFkIGJ1dCBpcyB0YWlsXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZSBhdCBoZWFkXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSBUb3VjaC5MYXN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW0uXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIC8vIG5leHQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCB0YWlsIGJ1dCBpcyBoZWFkXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGlua2VkTWFwID0gTGlua2VkTWFwO1xuY2xhc3MgTFJVQ2FjaGUgZXh0ZW5kcyBMaW5rZWRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxpbWl0LCByYXRpbyA9IDEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCByYXRpbyksIDEpO1xuICAgIH1cbiAgICBnZXQgbGltaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW1pdDtcbiAgICB9XG4gICAgc2V0IGxpbWl0KGxpbWl0KSB7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldCByYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhdGlvO1xuICAgIH1cbiAgICBzZXQgcmF0aW8ocmF0aW8pIHtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCByYXRpbyksIDEpO1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgIH1cbiAgICBnZXQoa2V5LCB0b3VjaCA9IFRvdWNoLkFzTmV3KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCB0b3VjaCk7XG4gICAgfVxuICAgIHBlZWsoa2V5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCBUb3VjaC5Ob25lKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUsIFRvdWNoLkxhc3QpO1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2hlY2tUcmltKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID4gdGhpcy5fbGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpbU9sZChNYXRoLnJvdW5kKHRoaXMuX2xpbWl0ICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgwNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IENSID0gMTM7XG5jb25zdCBMRiA9IDEwO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgdGhpcy5fY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIGFwcGVuZChjaHVuaykge1xuICAgICAgICBjb25zdCB0b0FwcGVuZCA9IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyB0aGlzLmZyb21TdHJpbmcoY2h1bmssIHRoaXMuX2VuY29kaW5nKSA6IGNodW5rO1xuICAgICAgICB0aGlzLl9jaHVua3MucHVzaCh0b0FwcGVuZCk7XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoICs9IHRvQXBwZW5kLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRyeVJlYWRIZWFkZXJzKGxvd2VyQ2FzZUtleXMgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtCeXRlc1JlYWQgPSAwO1xuICAgICAgICByb3c6IHdoaWxlIChjaHVua0luZGV4IDwgdGhpcy5fY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29sdW1uOiB3aGlsZSAob2Zmc2V0IDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVua1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExGOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua0J5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY2h1bmtJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVmZmVyIGNvbnRhaW5zIHRoZSB0d28gQ1JMRiBhdCB0aGUgZW5kLiBTbyB3ZSB3aWxsXG4gICAgICAgIC8vIGhhdmUgdHdvIGVtcHR5IGxpbmVzIGFmdGVyIHRoZSBzcGxpdCBhdCB0aGUgZW5kIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3JlYWQoY2h1bmtCeXRlc1JlYWQgKyBvZmZzZXQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnRvU3RyaW5nKGJ1ZmZlciwgJ2FzY2lpJykuc3BsaXQoQ1JMRik7XG4gICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaGVhZGVyLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgaGVhZGVyIG11c3Qgc2VwYXJhdGUga2V5IGFuZCB2YWx1ZSB1c2luZyA6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBoZWFkZXIuc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQobG93ZXJDYXNlS2V5cyA/IGtleS50b0xvd2VyQ2FzZSgpIDoga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5UmVhZEJvZHkobGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b3RhbExlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChsZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsTGVuZ3RoO1xuICAgIH1cbiAgICBfcmVhZChieXRlQ291bnQpIHtcbiAgICAgICAgaWYgKGJ5dGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZUNvdW50ID4gdGhpcy5fdG90YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlYWQgc28gbWFueSBieXRlcyFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2h1bmtzWzBdLmJ5dGVMZW5ndGggPT09IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gc3VwZXIgZmFzdCBwYXRoLCBwcmVjaXNlbHkgZmlyc3QgY2h1bmsgbXVzdCBiZSByZXR1cm5lZFxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbMF07XG4gICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzTmF0aXZlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2h1bmtzWzBdLmJ5dGVMZW5ndGggPiBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIGZhc3QgcGF0aCwgdGhlIHJlYWRpbmcgaXMgZW50aXJlbHkgd2l0aGluIHRoZSBmaXJzdCBjaHVua1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbMF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFzTmF0aXZlKGNodW5rLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtzWzBdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvY05hdGl2ZShieXRlQ291bnQpO1xuICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGNodW5rSW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoYnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBzdXJ2aXZlXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtQYXJ0ID0gY2h1bmsuc2xpY2UoMCwgYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rUGFydCwgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rc1tjaHVua0luZGV4XSA9IGNodW5rLnNsaWNlKGJ5dGVDb3VudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNodW5rIHdpbGwgYmUgZW50aXJlbHkgcmVhZFxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHJlc3VsdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgLT0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gQWJzdHJhY3RNZXNzYWdlQnVmZmVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NTY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDE4KTtcbnZhciBNZXNzYWdlUmVhZGVyO1xuKGZ1bmN0aW9uIChNZXNzYWdlUmVhZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmxpc3RlbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uQ2xvc2UpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uUGFydGlhbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlUmVhZGVyLmlzID0gaXM7XG59KShNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyIHx8IChleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKHRoaXMuYXNFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0IG9uUGFydGlhbE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZVBhcnRpYWxNZXNzYWdlKGluZm8pIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZmlyZShpbmZvKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgUmVhZGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gQWJzdHJhY3RNZXNzYWdlUmVhZGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGxldCBjaGFyc2V0O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgY29udGVudERlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnREZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGVEZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zID8/ICd1dGYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCc7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXIgPSBvcHRpb25zLmNvbnRlbnREZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoY29udGVudERlY29kZXIubmFtZSwgY29udGVudERlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50RGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZURlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmRlY29kZXI7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFyc2V0LCBjb250ZW50RGVjb2RlciwgY29udGVudERlY29kZXJzLCBjb250ZW50VHlwZURlY29kZXIsIGNvbnRlbnRUeXBlRGVjb2RlcnMgfTtcbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5tZXNzYWdlQnVmZmVyLmNyZWF0ZSh0aGlzLm9wdGlvbnMuY2hhcnNldCk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IDEwMDAwO1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICB9XG4gICAgc2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQ7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZGFibGUub25EYXRhKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuYnVmZmVyLnRyeVJlYWRIZWFkZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKCdIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcignQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQm9keSh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvKiogV2UgaGF2ZW4ndCByZWNlaXZlZCB0aGUgZnVsbCBtZXNzYWdlIHlldC4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgY29udmVydCBvbmUgcmVjZWl2ZWQgbWVzc2FnZSBhZnRlciB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyLiBPdGhlcndpc2UgaXQgY291bGQgaGFwcGVuIHRoYXQgYSBkZWNvZGluZyBvZiBhIHNlY29uZFxuICAgICAgICAgICAgLy8gc21hbGxlciBtZXNzYWdlIGZpbmlzaGVkIGJlZm9yZSB0aGUgZGVjb2Rpbmcgb2YgYSBmaXJzdCBsYXJnZXJcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgYW5kIHRoZW4gd2Ugd291bGQgZGVsaXZlciB0aGUgc2Vjb25kIG1lc3NhZ2UgZmlyc3QuXG4gICAgICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2Rlci5kZWNvZGUoYm9keSlcbiAgICAgICAgICAgICAgICAgICAgOiBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyLmRlY29kZShieXRlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMubWVzc2FnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTAzNjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDE4KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbmNvbnN0IENvbnRlbnRMZW5ndGggPSAnQ29udGVudC1MZW5ndGg6ICc7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG52YXIgTWVzc2FnZVdyaXRlcjtcbihmdW5jdGlvbiAoTWVzc2FnZVdyaXRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJlxuICAgICAgICAgICAgSXMuZnVuYyhjYW5kaWRhdGUub25FcnJvcikgJiYgSXMuZnVuYyhjYW5kaWRhdGUud3JpdGUpO1xuICAgIH1cbiAgICBNZXNzYWdlV3JpdGVyLmlzID0gaXM7XG59KShNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5NZXNzYWdlV3JpdGVyIHx8IChleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGNvdW50KSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUoW3RoaXMuYXNFcnJvcihlcnJvciksIG1lc3NhZ2UsIGNvdW50XSk7XG4gICAgfVxuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBhc0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBXcml0ZXIgcmVjZWl2ZWQgZXJyb3IuIFJlYXNvbjogJHtJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBBYnN0cmFjdE1lc3NhZ2VXcml0ZXI7XG52YXIgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucztcbihmdW5jdGlvbiAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMgPz8gJ3V0Zi04JywgY29udGVudFR5cGVFbmNvZGVyOiAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcnNldDogb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCcsIGNvbnRlbnRFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRFbmNvZGVyLCBjb250ZW50VHlwZUVuY29kZXI6IG9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyID8/ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5lbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0YWJsZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IDA7XG4gICAgICAgIHRoaXMud3JpdGVTZW1hcGhvcmUgPSBuZXcgc2VtYXBob3JlXzEuU2VtYXBob3JlKDEpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uRXJyb3IoKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uQ2xvc2UoKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XG4gICAgfVxuICAgIGFzeW5jIHdyaXRlKG1zZykge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVNlbWFwaG9yZS5sb2NrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyLmVuY29kZShtc2csIHRoaXMub3B0aW9ucykudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RW5jb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIuZW5jb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChDb250ZW50TGVuZ3RoLCBidWZmZXIuYnl0ZUxlbmd0aC50b1N0cmluZygpLCBDUkxGKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ1JMRik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9Xcml0ZShtc2csIGhlYWRlcnMsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRvV3JpdGUobXNnLCBoZWFkZXJzLCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRhYmxlLndyaXRlKGhlYWRlcnMuam9pbignJyksICdhc2NpaScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGFibGUud3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbXNnKSB7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCsrO1xuICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvciwgbXNnLCB0aGlzLmVycm9yQ291bnQpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzE2Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5NZXNzYWdlID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5SZXNwb25zZUVycm9yID0gZXhwb3J0cy5FcnJvckNvZGVzID0gdm9pZCAwO1xuY29uc3QgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuLyoqXG4gKiBQcmVkZWZpbmVkIGVycm9yIGNvZGVzLlxuICovXG52YXIgRXJyb3JDb2RlcztcbihmdW5jdGlvbiAoRXJyb3JDb2Rlcykge1xuICAgIC8vIERlZmluZWQgYnkgSlNPTiBSUENcbiAgICBFcnJvckNvZGVzLlBhcnNlRXJyb3IgPSAtMzI3MDA7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUmVxdWVzdCA9IC0zMjYwMDtcbiAgICBFcnJvckNvZGVzLk1ldGhvZE5vdEZvdW5kID0gLTMyNjAxO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFBhcmFtcyA9IC0zMjYwMjtcbiAgICBFcnJvckNvZGVzLkludGVybmFsRXJyb3IgPSAtMzI2MDM7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgc3RhcnQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuIE5vIGFwcGxpY2F0aW9uIGVycm9yIGNvZGVzIHNob3VsZFxuICAgICAqIGJlIGRlZmluZWQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCByYW5nZS4gRm9yIGJhY2t3YXJkc1xuICAgICAqIGNvbXBhdGliaWxpdHkgdGhlIGBTZXJ2ZXJOb3RJbml0aWFsaXplZGAgYW5kIHRoZSBgVW5rbm93bkVycm9yQ29kZWBcbiAgICAgKiBhcmUgbGVmdCBpbiB0aGUgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCA9IC0zMjA5OTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiB3cml0ZSBhIG1lc3NhZ2UgdG8gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gcmVhZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVJlYWRFcnJvciA9IC0zMjA5ODtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQgb3IgbG9zdCBhbmQgYWxsIHBlbmRpbmcgcmVzcG9uc2VzIGdvdFxuICAgICAqIHJlamVjdGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQgPSAtMzIwOTc7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgaW5hY3RpdmUgYW5kIGEgdXNlIG9mIGl0IGZhaWxlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLkNvbm5lY3Rpb25JbmFjdGl2ZSA9IC0zMjA5NjtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHNlcnZlciByZWNlaXZlZCBhIG5vdGlmaWNhdGlvbiBvclxuICAgICAqIHJlcXVlc3QgYmVmb3JlIHRoZSBzZXJ2ZXIgaGFzIHJlY2VpdmVkIHRoZSBgaW5pdGlhbGl6ZWAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlNlcnZlck5vdEluaXRpYWxpemVkID0gLTMyMDAyO1xuICAgIEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZSA9IC0zMjAwMTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzIwMDA7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JFbmQgPSAtMzIwMDA7XG59KShFcnJvckNvZGVzID0gZXhwb3J0cy5FcnJvckNvZGVzIHx8IChleHBvcnRzLkVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBBbiBlcnJvciBvYmplY3QgcmV0dXJuIGluIGEgcmVzcG9uc2UgaW4gY2FzZSBhIHJlcXVlc3RcbiAqIGhhcyBmYWlsZWQuXG4gKi9cbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gaXMubnVtYmVyKGNvZGUpID8gY29kZSA6IEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJlc3BvbnNlRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IFJlc3BvbnNlRXJyb3I7XG5jbGFzcyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byB8fCB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUgfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQ7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcztcbi8qKlxuICogVGhlIHBhcmFtZXRlciBzdHJ1Y3R1cmUgaXMgYXV0b21hdGljYWxseSBpbmZlcnJlZCBvbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnNcbiAqIGFuZCB0aGUgcGFyYW1ldGVyIHR5cGUgaW4gY2FzZSBvZiBhIHNpbmdsZSBwYXJhbS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2F1dG8nKTtcbi8qKlxuICogRm9yY2VzIGBieVBvc2l0aW9uYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgaGF2ZSBhIHNpbmdsZVxuICogcGFyYW1ldGVyIHdoaWNoIGhhcyBhIGxpdGVyYWwgdHlwZS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5UG9zaXRpb24nKTtcbi8qKlxuICogRm9yY2VzIGBieU5hbWVgIHBhcmFtZXRlciBzdHJ1Y3R1cmUuIFRoaXMgaXMgb25seSB1c2VmdWwgd2hlbiBoYXZpbmcgYSBzaW5nbGVcbiAqIHBhcmFtZXRlci4gVGhlIGxpYnJhcnkgd2lsbCByZXBvcnQgZXJyb3JzIGlmIHVzZWQgd2l0aCBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5TmFtZScpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIE1lc3NhZ2VUeXBlLlxuICovXG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbXMgPSBudW1iZXJPZlBhcmFtcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmU7XG4vKipcbiAqIENsYXNzZXMgdG8gdHlwZSByZXF1ZXN0IHJlc3BvbnNlIHBhaXJzXG4gKi9cbmNsYXNzIFJlcXVlc3RUeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBSZXF1ZXN0VHlwZTA7XG5jbGFzcyBSZXF1ZXN0VHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlID0gUmVxdWVzdFR5cGU7XG5jbGFzcyBSZXF1ZXN0VHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBSZXF1ZXN0VHlwZTE7XG5jbGFzcyBSZXF1ZXN0VHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gUmVxdWVzdFR5cGUyO1xuY2xhc3MgUmVxdWVzdFR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMyA9IFJlcXVlc3RUeXBlMztcbmNsYXNzIFJlcXVlc3RUeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBSZXF1ZXN0VHlwZTQ7XG5jbGFzcyBSZXF1ZXN0VHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gUmVxdWVzdFR5cGU1O1xuY2xhc3MgUmVxdWVzdFR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNiA9IFJlcXVlc3RUeXBlNjtcbmNsYXNzIFJlcXVlc3RUeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBSZXF1ZXN0VHlwZTc7XG5jbGFzcyBSZXF1ZXN0VHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gUmVxdWVzdFR5cGU4O1xuY2xhc3MgUmVxdWVzdFR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOSA9IFJlcXVlc3RUeXBlOTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gTm90aWZpY2F0aW9uVHlwZTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gTm90aWZpY2F0aW9uVHlwZTE7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IE5vdGlmaWNhdGlvblR5cGUyO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBOb3RpZmljYXRpb25UeXBlMztcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU0IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gTm90aWZpY2F0aW9uVHlwZTQ7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IE5vdGlmaWNhdGlvblR5cGU1O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDYpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBOb3RpZmljYXRpb25UeXBlNjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU3IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gTm90aWZpY2F0aW9uVHlwZTc7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IE5vdGlmaWNhdGlvblR5cGU4O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBOb3RpZmljYXRpb25UeXBlOTtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXF1ZXN0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkpO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzUmVxdWVzdCA9IGlzUmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiBtZXNzYWdlLmlkID09PSB2b2lkIDA7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNOb3RpZmljYXRpb24gPSBpc05vdGlmaWNhdGlvbjtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLnJlc3VsdCAhPT0gdm9pZCAwIHx8ICEhY2FuZGlkYXRlLmVycm9yKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkgfHwgY2FuZGlkYXRlLmlkID09PSBudWxsKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1Jlc3BvbnNlID0gaXNSZXNwb25zZTtcbn0pKE1lc3NhZ2UgPSBleHBvcnRzLk1lc3NhZ2UgfHwgKGV4cG9ydHMuTWVzc2FnZSA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwOTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmxldCBfcmFsO1xuZnVuY3Rpb24gUkFMKCkge1xuICAgIGlmIChfcmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIGluc3RhbGxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gX3JhbDtcbn1cbihmdW5jdGlvbiAoUkFMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbChyYWwpIHtcbiAgICAgICAgaWYgKHJhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bnRpbWUgYWJzdHJhY3Rpb24gbGF5ZXIgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBfcmFsID0gcmFsO1xuICAgIH1cbiAgICBSQUwuaW5zdGFsbCA9IGluc3RhbGw7XG59KShSQUwgfHwgKFJBTCA9IHt9KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJBTDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbWFwaG9yZSA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNsYXNzIFNlbWFwaG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2FwYWNpdHkgPSAxKSB7XG4gICAgICAgIGlmIChjYXBhY2l0eSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLl93YWl0aW5nID0gW107XG4gICAgfVxuICAgIGxvY2sodGh1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmcucHVzaCh7IHRodW5rLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfVxuICAgIHJ1bk5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YWl0aW5nLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9hY3RpdmUgPT09IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuZG9SdW5OZXh0KCkpO1xuICAgIH1cbiAgICBkb1J1bk5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YWl0aW5nLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9hY3RpdmUgPT09IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuX3dhaXRpbmcuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlKys7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgPiB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUbyBtYW55IHRodW5rcyBhY3RpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dC50aHVuaygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIG5leHQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICBuZXh0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNlbWFwaG9yZSA9IFNlbWFwaG9yZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ4OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSB2b2lkIDA7XG5jb25zdCBjYW5jZWxsYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjk1Nyk7XG52YXIgQ2FuY2VsbGF0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0YXRlKSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWUgPSAwO1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCA9IDE7XG59KShDYW5jZWxsYXRpb25TdGF0ZSB8fCAoQ2FuY2VsbGF0aW9uU3RhdGUgPSB7fSkpO1xuY2xhc3MgU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBkYXRhWzBdID0gQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWU7XG4gICAgICAgIHRoaXMuYnVmZmVycy5zZXQocmVxdWVzdC5pZCwgYnVmZmVyKTtcbiAgICAgICAgcmVxdWVzdC4kY2FuY2VsbGF0aW9uRGF0YSA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgc2VuZENhbmNlbGxhdGlvbihfY29ubiwgaWQpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzLmdldChpZCk7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBBdG9taWNzLnN0b3JlKGRhdGEsIDAsIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCk7XG4gICAgfVxuICAgIGNsZWFudXAoaWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7XG5jbGFzcyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuZGF0YSwgMCkgPT09IENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbmNlbGxhdGlvbiBvdmVyIFNoYXJlZEFycmF5QnVmZmVyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxsYXRpb24gZXZlbnRzYCk7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbihidWZmZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3JlcXVlc3QnO1xuICAgIH1cbiAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShidWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTAxOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBicm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMDgpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTIwOCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMzE0NyksIGV4cG9ydHMpO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIGJyb3dzZXJfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzE0Nzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IGV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTExMCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNzcxNyksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oODQzMSksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMTgxNSksIGV4cG9ydHMpO1xudmFyIGNvbm5lY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb247IH0gfSkpO1xudmFyIExTUEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKExTUEVycm9yQ29kZXMpIHtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIExTUCByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICpcbiAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIExTUEVycm9yQ29kZXMubHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzI4OTk7XG4gICAgLyoqXG4gICAgICogQSByZXF1ZXN0IGZhaWxlZCBidXQgaXQgd2FzIHN5bnRhY3RpY2FsbHkgY29ycmVjdCwgZS5nIHRoZVxuICAgICAqIG1ldGhvZCBuYW1lIHdhcyBrbm93biBhbmQgdGhlIHBhcmFtZXRlcnMgd2VyZSB2YWxpZC4gVGhlIGVycm9yXG4gICAgICogbWVzc2FnZSBzaG91bGQgY29udGFpbiBodW1hbiByZWFkYWJsZSBpbmZvcm1hdGlvbiBhYm91dCB3aHlcbiAgICAgKiB0aGUgcmVxdWVzdCBmYWlsZWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5SZXF1ZXN0RmFpbGVkID0gLTMyODAzO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgY2FuY2VsbGVkIHRoZSByZXF1ZXN0LiBUaGlzIGVycm9yIGNvZGUgc2hvdWxkXG4gICAgICogb25seSBiZSB1c2VkIGZvciByZXF1ZXN0cyB0aGF0IGV4cGxpY2l0bHkgc3VwcG9ydCBiZWluZ1xuICAgICAqIHNlcnZlciBjYW5jZWxsYWJsZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlNlcnZlckNhbmNlbGxlZCA9IC0zMjgwMjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGRldGVjdGVkIHRoYXQgdGhlIGNvbnRlbnQgb2YgYSBkb2N1bWVudCBnb3RcbiAgICAgKiBtb2RpZmllZCBvdXRzaWRlIG5vcm1hbCBjb25kaXRpb25zLiBBIHNlcnZlciBzaG91bGRcbiAgICAgKiBOT1Qgc2VuZCB0aGlzIGVycm9yIGNvZGUgaWYgaXQgZGV0ZWN0cyBhIGNvbnRlbnQgY2hhbmdlXG4gICAgICogaW4gaXQgdW5wcm9jZXNzZWQgbWVzc2FnZXMuIFRoZSByZXN1bHQgZXZlbiBjb21wdXRlZFxuICAgICAqIG9uIGFuIG9sZGVyIHN0YXRlIG1pZ2h0IHN0aWxsIGJlIHVzZWZ1bCBmb3IgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgY2xpZW50IGRlY2lkZXMgdGhhdCBhIHJlc3VsdCBpcyBub3Qgb2YgYW55IHVzZSBhbnltb3JlXG4gICAgICogdGhlIGNsaWVudCBzaG91bGQgY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuQ29udGVudE1vZGlmaWVkID0gLTMyODAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgaGFzIGNhbmNlbGVkIGEgcmVxdWVzdCBhbmQgYSBzZXJ2ZXIgYXMgZGV0ZWN0ZWRcbiAgICAgKiB0aGUgY2FuY2VsLlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdENhbmNlbGxlZCA9IC0zMjgwMDtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjgwMDtcbn0pKExTUEVycm9yQ29kZXMgPSBleHBvcnRzLkxTUEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI5MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbihpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodnNjb2RlX2pzb25ycGNfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgdnNjb2RlX2pzb25ycGNfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikoaW5wdXQsIG91dHB1dCwgbG9nZ2VyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDMxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZTAgPSBleHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcbnZhciBNZXNzYWdlRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChNZXNzYWdlRGlyZWN0aW9uKSB7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcImNsaWVudFRvU2VydmVyXCJdID0gXCJjbGllbnRUb1NlcnZlclwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJzZXJ2ZXJUb0NsaWVudFwiXSA9IFwic2VydmVyVG9DbGllbnRcIjtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wiYm90aFwiXSA9IFwiYm90aFwiO1xufSkoTWVzc2FnZURpcmVjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiB8fCAoZXhwb3J0cy5NZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbmNsYXNzIFJlZ2lzdHJhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBSZWdpc3RyYXRpb25UeXBlO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZTAgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IFByb3RvY29sUmVxdWVzdFR5cGUwO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IFByb3RvY29sUmVxdWVzdFR5cGU7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMDtcbmNsYXNzIFByb3RvY29sTm90aWZpY2F0aW9uVHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgdnNjb2RlX2pzb25ycGNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2MDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXN1bHQgYSBgQ2FsbEhpZXJhcmNoeUl0ZW1gIGluIGEgZG9jdW1lbnQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAqIENhbiBiZSB1c2VkIGFzIGFuIGlucHV0IHRvIGFuIGluY29taW5nIG9yIG91dGdvaW5nIGNhbGwgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZUNhbGxIaWVyYXJjaHknO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBpbmNvbWluZyBjYWxscyBmb3IgYSBnaXZlbiBgQ2FsbEhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCA9ICdjYWxsSGllcmFyY2h5L2luY29taW5nQ2FsbHMnO1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBvdXRnb2luZyBjYWxscyBmb3IgYSBnaXZlbiBgQ2FsbEhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCA9ICdjYWxsSGllcmFyY2h5L291dGdvaW5nQ2FsbHMnO1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3NDc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgY29sb3Igc3ltYm9scyBmb3VuZCBpbiBhIGdpdmVuIHRleHQgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudENvbG9yUGFyYW1zfSB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb24gQ29sb3JJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudENvbG9yUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRDb2xvclJlcXVlc3QpIHtcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50Q29sb3InO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50Q29sb3JSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IGFsbCBwcmVzZW50YXRpb24gZm9yIGEgY29sb3IuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb2xvclByZXNlbnRhdGlvblBhcmFtc30gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBDb2xvckluZm9ybWF0aW9uIENvbG9ySW5mb3JtYXRpb25bXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvblJlcXVlc3QpIHtcbiAgICBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2xvclByZXNlbnRhdGlvbic7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzYzOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8tLS0tIEdldCBDb25maWd1cmF0aW9uIHJlcXVlc3QgLS0tLVxuLyoqXG4gKiBUaGUgJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gZmV0Y2ggYSBjZXJ0YWluXG4gKiBjb25maWd1cmF0aW9uIHNldHRpbmcuXG4gKlxuICogVGhpcyBwdWxsIG1vZGVsIHJlcGxhY2VzIHRoZSBvbGQgcHVzaCBtb2RlbCB3ZXJlIHRoZSBjbGllbnQgc2lnbmFsZWQgY29uZmlndXJhdGlvbiBjaGFuZ2UgdmlhIGFuXG4gKiBldmVudC4gSWYgdGhlIHNlcnZlciBzdGlsbCBuZWVkcyB0byByZWFjdCB0byBjb25maWd1cmF0aW9uIGNoYW5nZXMgKHNpbmNlIHRoZSBzZXJ2ZXIgY2FjaGVzIHRoZVxuICogcmVzdWx0IG9mIGB3b3Jrc3BhY2UvY29uZmlndXJhdGlvbmAgcmVxdWVzdHMpIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlZ2lzdGVyIGZvciBhbiBlbXB0eSBjb25maWd1cmF0aW9uXG4gKiBjaGFuZ2UgZXZlbnQgYW5kIGVtcHR5IHRoZSBjYWNoZSBpZiBzdWNoIGFuIGV2ZW50IGlzIHJlY2VpdmVkLlxuICovXG52YXIgQ29uZmlndXJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbmZpZ3VyYXRpb25SZXF1ZXN0KSB7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJztcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb25maWd1cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlY2xhcmF0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVjbGFyYXRpb25MaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIHN1Y2guXG4gKi9cbnZhciBEZWNsYXJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKERlY2xhcmF0aW9uUmVxdWVzdCkge1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RlY2xhcmF0aW9uJztcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRGVjbGFyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShEZWNsYXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDk0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTExMCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUucmV0cmlnZ2VyUmVxdWVzdCk7XG4gICAgfVxuICAgIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhLmlzID0gaXM7XG59KShEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgfHwgKGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgZGlhZ25vc3RpYyByZXBvcnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgZGlhZ25vc3RpYyByZXBvcnQgd2l0aCBhIGZ1bGxcbiAgICAgKiBzZXQgb2YgcHJvYmxlbXMuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5GdWxsID0gJ2Z1bGwnO1xuICAgIC8qKlxuICAgICAqIEEgcmVwb3J0IGluZGljYXRpbmcgdGhhdCB0aGUgbGFzdFxuICAgICAqIHJldHVybmVkIHJlcG9ydCBpcyBzdGlsbCBhY2N1cmF0ZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kLlVuY2hhbmdlZCA9ICd1bmNoYW5nZWQnO1xufSkoRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCB8fCAoZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVxdWVzdCBkZWZpbml0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlhZ25vc3RpYyc7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXRob2QpO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QucGFydGlhbFJlc3VsdCA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xufSkoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIHdvcmtzcGFjZSBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2RpYWdub3N0aWMnO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyByZWZyZXNoIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCkge1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2RpYWdub3N0aWMvcmVmcmVzaGA7XG4gICAgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3ODE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcGF0dGVybiBraW5kIGRlc2NyaWJpbmcgaWYgYSBnbG9iIHBhdHRlcm4gbWF0Y2hlcyBhIGZpbGUgYSBmb2xkZXIgb3JcbiAqIGJvdGguXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kO1xuKGZ1bmN0aW9uIChGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiBtYXRjaGVzIGEgZmlsZSBvbmx5LlxuICAgICAqL1xuICAgIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZC5maWxlID0gJ2ZpbGUnO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIG1hdGNoZXMgYSBmb2xkZXIgb25seS5cbiAgICAgKi9cbiAgICBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQuZm9sZGVyID0gJ2ZvbGRlcic7XG59KShGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCB8fCAoZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBjcmVhdGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGNyZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY3JlYXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIHJldHVybiBhIGBXb3Jrc3BhY2VFZGl0YCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gd29ya3NwYWNlIGJlZm9yZSB0aGVcbiAqIGZpbGVzIGFyZSBjcmVhdGVkLiBIZW5jZSB0aGUgYFdvcmtzcGFjZUVkaXRgIGNhbiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGUgZmlsZVxuICogdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxDcmVhdGVGaWxlcyc7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCBjcmVhdGUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSBjcmVhdGVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDcmVhdGVGaWxlcyc7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCByZW5hbWUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIHJlbmFtZWQgYXMgbG9uZyBhcyB0aGUgcmVuYW1lIGlzIHRyaWdnZXJlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QpIHtcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd2lsbFJlbmFtZUZpbGVzJztcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIHJlbmFtZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIHJlbmFtZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZFJlbmFtZUZpbGVzJztcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIGRlbGV0ZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogZGVsZXRlZCBhcyBsb25nIGFzIHRoZSBkZWxldGlvbiBpcyB0cmlnZ2VyZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZERlbGV0ZUZpbGVzJztcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgZGVsZXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgZGVsZXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFdpbGxEZWxldGVGaWxlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QpIHtcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd2lsbERlbGV0ZUZpbGVzJztcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBmb2xkaW5nIHJhbmdlcyBpbiBhIGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlUGFyYW1zfSwgdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBGb2xkaW5nUmFuZ2VMaXN0fSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VSZXF1ZXN0KSB7XG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2ZvbGRpbmdSYW5nZSc7XG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoRm9sZGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW1wbGVtZW50YXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGFcbiAqIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIEltcGxlbWVudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoSW1wbGVtZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvaW1wbGVtZW50YXRpb24nO1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShJbXBsZW1lbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKEltcGxlbWVudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5sYXkgaGludHMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGF5SGludHNQYXJhbXN9LCB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIElubGF5SGludCBJbmxheUhpbnRbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVxdWVzdCkge1xuICAgIElubGF5SGludFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxheUhpbnQnO1xuICAgIElubGF5SGludFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxheUhpbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgYW4gaW5sYXkgaGludC5cbiAqIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0sIHRoZSByZXNwb25zZSBpc1xuICogb2YgdHlwZSB7QGxpbmsgSW5sYXlIaW50fSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnaW5sYXlIaW50L3Jlc29sdmUnO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGF5SGludFJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvaW5sYXlIaW50L3JlZnJlc2hgO1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGluZSB2YWx1ZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGluZVZhbHVlUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVWYWx1ZSBJbmxpbmVWYWx1ZVtdfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZVZhbHVlJztcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lVmFsdWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0KSB7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2lubGluZVZhbHVlL3JlZnJlc2hgO1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODE1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IGV4cG9ydHMuRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kID0gZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLldhdGNoS2luZCA9IGV4cG9ydHMuUmVsYXRpdmVQYXR0ZXJuID0gZXhwb3J0cy5GaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRTYXZlUmVhc29uID0gZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudFN5bmNLaW5kID0gZXhwb3J0cy5UZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSBleHBvcnRzLkluaXRpYWxpemVFcnJvckNvZGVzID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSBleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSBleHBvcnRzLlBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5GYWlsdXJlSGFuZGxpbmdLaW5kID0gZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBleHBvcnRzLlVucmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB2b2lkIDA7XG5leHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJLaW5kID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgPSBleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgPSBleHBvcnRzLkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QgPSB2b2lkIDA7XG5leHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0gZXhwb3J0cy5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzcxNyk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mjg3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcGxlbWVudGF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEuSW1wbGVtZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyNjQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZURlZmluaXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfdHlwZURlZmluaXRpb25fMS5UeXBlRGVmaW5pdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NjApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya3NwYWNlRm9sZGVyc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF93b3Jrc3BhY2VGb2xkZXJfMS5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jb25maWd1cmF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MzkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29uZmlndXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb25maWd1cmF0aW9uXzEuQ29uZmlndXJhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzQ3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50Q29sb3JSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xLkRvY3VtZW50Q29sb3JSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Db2xvclByZXNlbnRhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMDMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRm9sZGluZ1JhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xLkZvbGRpbmdSYW5nZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZGVjbGFyYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTU4MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kZWNsYXJhdGlvbl8xLkRlY2xhcmF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbGVjdGlvblJhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Byb2dyZXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNjYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MDIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbkZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuVG9rZW5Gb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Nob3dEb2N1bWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzMzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNob3dEb2N1bWVudFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zaG93RG9jdW1lbnRfMS5TaG93RG9jdW1lbnRSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQ5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3ODEpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Njg0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzgzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgTm90ZWJvb2tEb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0RvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0RvY3VtZW50RmlsdGVyO1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubm90ZWJvb2tUeXBlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKSk7XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudEZpbHRlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5ub3RlYm9vaykgfHwgTm90ZWJvb2tEb2N1bWVudEZpbHRlci5pcyhjYW5kaWRhdGUubm90ZWJvb2spKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sYW5ndWFnZSA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvcmVnaXN0ZXJDYXBhYmlsaXR5YCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gcmVnaXN0ZXIgYSBuZXcgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBSZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZWdpc3RyYXRpb25SZXF1ZXN0KSB7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvdW5yZWdpc3RlckNhcGFiaWxpdHlgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgVW5yZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChVbnJlZ2lzdHJhdGlvblJlcXVlc3QpIHtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5VbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuUmVzb3VyY2VPcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IHt9KSk7XG52YXIgRmFpbHVyZUhhbmRsaW5nS2luZDtcbihmdW5jdGlvbiAoRmFpbHVyZUhhbmRsaW5nS2luZCkge1xuICAgIC8qKlxuICAgICAqIEFwcGx5aW5nIHRoZSB3b3Jrc3BhY2UgY2hhbmdlIGlzIHNpbXBseSBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgY2hhbmdlcyBwcm92aWRlZFxuICAgICAqIGZhaWxzLiBBbGwgb3BlcmF0aW9ucyBleGVjdXRlZCBiZWZvcmUgdGhlIGZhaWxpbmcgb3BlcmF0aW9uIHN0YXkgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5BYm9ydCA9ICdhYm9ydCc7XG4gICAgLyoqXG4gICAgICogQWxsIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkIHRyYW5zYWN0aW9uYWwuIFRoYXQgbWVhbnMgdGhleSBlaXRoZXIgYWxsXG4gICAgICogc3VjY2VlZCBvciBubyBjaGFuZ2VzIGF0IGFsbCBhcmUgYXBwbGllZCB0byB0aGUgd29ya3NwYWNlLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVHJhbnNhY3Rpb25hbCA9ICd0cmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgd29ya3NwYWNlIGVkaXQgY29udGFpbnMgb25seSB0ZXh0dWFsIGZpbGUgY2hhbmdlcyB0aGV5IGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLlxuICAgICAqIElmIHJlc291cmNlIGNoYW5nZXMgKGNyZWF0ZSwgcmVuYW1lIG9yIGRlbGV0ZSBmaWxlKSBhcmUgcGFydCBvZiB0aGUgY2hhbmdlIHRoZSBmYWlsdXJlXG4gICAgICogaGFuZGxpbmcgc3RyYXRlZ3kgaXMgYWJvcnQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5UZXh0T25seVRyYW5zYWN0aW9uYWwgPSAndGV4dE9ubHlUcmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRyaWVzIHRvIHVuZG8gdGhlIG9wZXJhdGlvbnMgYWxyZWFkeSBleGVjdXRlZC4gQnV0IHRoZXJlIGlzIG5vXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhpcyBpcyBzdWNjZWVkaW5nLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVW5kbyA9ICd1bmRvJztcbn0pKEZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgfHwgKGV4cG9ydHMuRmFpbHVyZUhhbmRsaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcG9zaXRpb24gZW5jb2Rpbmcga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgUG9zaXRpb25FbmNvZGluZ0tpbmQ7XG4oZnVuY3Rpb24gKFBvc2l0aW9uRW5jb2RpbmdLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTggY29kZSB1bml0cyAoZS5nLiBieXRlcykuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGOCA9ICd1dGYtOCc7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTE2IGNvZGUgdW5pdHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFuZCBtdXN0IGFsd2F5cyBiZSBzdXBwb3J0ZWRcbiAgICAgKiBieSBzZXJ2ZXJzXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMTYgPSAndXRmLTE2JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMzIgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGU6IHRoZXNlIGFyZSB0aGUgc2FtZSBhcyBVbmljb2RlIGNvZGVwb2ludHMsXG4gICAgICogc28gdGhpcyBgUG9zaXRpb25FbmNvZGluZ0tpbmRgIG1heSBhbHNvIGJlIHVzZWQgZm9yIGFuXG4gICAgICogZW5jb2RpbmctYWdub3N0aWMgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyIG9mZnNldHMuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMzIgPSAndXRmLTMyJztcbn0pKFBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCB8fCAoZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IgPT09IG51bGwgfHwgRG9jdW1lbnRTZWxlY3Rvci5pcyhjYW5kaWRhdGUuZG9jdW1lbnRTZWxlY3RvcikpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgV29ya0RvbmVQcm9ncmVzc09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc09wdGlvbnM7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcykpO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucy5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGhhc1dvcmtEb25lUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcyk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmhhc1dvcmtEb25lUHJvZ3Jlc3MgPSBoYXNXb3JrRG9uZVByb2dyZXNzO1xufSkoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCB8fCAoZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEtub3duIGVycm9yIGNvZGVzIGZvciBhbiBgSW5pdGlhbGl6ZUVycm9yQ29kZXNgO1xuICovXG52YXIgSW5pdGlhbGl6ZUVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHByb3RvY29sIHZlcnNpb24gcHJvdmlkZWQgYnkgdGhlIGNsaWVudCBjYW4ndCBiZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGluaXRpYWxpemUgZXJyb3IgZ290IHJlcGxhY2VkIGJ5IGNsaWVudCBjYXBhYmlsaXRpZXMuIFRoZXJlIGlzXG4gICAgICogbm8gdmVyc2lvbiBoYW5kc2hha2UgaW4gdmVyc2lvbiAzLjB4XG4gICAgICovXG4gICAgSW5pdGlhbGl6ZUVycm9yQ29kZXMudW5rbm93blByb3RvY29sVmVyc2lvbiA9IDE7XG59KShJbml0aWFsaXplRXJyb3JDb2RlcyA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgaW5pdGlhbGl6ZWQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZVxuICogc2VydmVyIGFmdGVyIHRoZSBjbGllbnQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgYW5kIHRoZSBzZXJ2ZXJcbiAqIGlzIGFsbG93ZWQgdG8gc2VuZCByZXF1ZXN0cyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudC5cbiAqL1xudmFyIEluaXRpYWxpemVkTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplZE5vdGlmaWNhdGlvbikge1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCA9ICdpbml0aWFsaXplZCc7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCB8fCAoZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIEV4aXQgTm90aWZpY2F0aW9uIC0tLS1cbi8qKlxuICogVGhlIGV4aXQgZXZlbnQgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0b1xuICogYXNrIHRoZSBzZXJ2ZXIgdG8gZXhpdCBpdHMgcHJvY2Vzcy5cbiAqL1xudmFyIEV4aXROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEV4aXROb3RpZmljYXRpb24pIHtcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdleGl0JztcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMChFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShFeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIHdoZW4gdGhlIGNsaWVudCdzIGNvbmZpZ3VyYXRpb24gaGFzIGNoYW5nZWQuIFRoZSBub3RpZmljYXRpb24gY29udGFpbnNcbiAqIHRoZSBjaGFuZ2VkIGNvbmZpZ3VyYXRpb24gYXMgZGVmaW5lZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbikge1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VDb25maWd1cmF0aW9uJztcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2hvdyBhIG1lc3NhZ2VcbiAqIGFuZCBhIHNldCBvZiBvcHRpb25zIGFjdGlvbnMgdG8gdGhlIHVzZXIuXG4gKi9cbnZhciBTaG93TWVzc2FnZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dNZXNzYWdlUmVxdWVzdCkge1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3Nob3dNZXNzYWdlUmVxdWVzdCc7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGxvZyBtZXNzYWdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBsb2cgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UuXG4gKi9cbnZhciBMb2dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dNZXNzYWdlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd2luZG93L2xvZ01lc3NhZ2UnO1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBob3cgdGhlIGhvc3QgKGVkaXRvcikgc2hvdWxkIHN5bmNcbiAqIGRvY3VtZW50IGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAqL1xudmFyIFRleHREb2N1bWVudFN5bmNLaW5kO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTeW5jS2luZCkge1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBzaG91bGQgbm90IGJlIHN5bmNlZCBhdCBhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSA9IDA7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgYWx3YXlzIHNlbmRpbmcgdGhlIGZ1bGwgY29udGVudFxuICAgICAqIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsID0gMTtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgYXJlIHN5bmNlZCBieSBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnQgb24gb3Blbi5cbiAgICAgKiBBZnRlciB0aGF0IG9ubHkgaW5jcmVtZW50YWwgdXBkYXRlcyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgICogc2VuZC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCA9IDI7XG59KShUZXh0RG9jdW1lbnRTeW5jS2luZCA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgb3BlbiBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIG5ld2x5IG9wZW5lZCB0ZXh0IGRvY3VtZW50cy4gVGhlIGRvY3VtZW50J3MgdHJ1dGggaXMgbm93IG1hbmFnZWQgYnkgdGhlIGNsaWVudFxuICogYW5kIHRoZSBzZXJ2ZXIgbXVzdCBub3QgdHJ5IHRvIHJlYWQgdGhlIGRvY3VtZW50J3MgdHJ1dGggdXNpbmcgdGhlIGRvY3VtZW50J3NcbiAqIHVyaS4gT3BlbiBpbiB0aGlzIHNlbnNlIG1lYW5zIGl0IGlzIG1hbmFnZWQgYnkgdGhlIGNsaWVudC4gSXQgZG9lc24ndCBuZWNlc3NhcmlseVxuICogbWVhbiB0aGF0IGl0cyBjb250ZW50IGlzIHByZXNlbnRlZCBpbiBhbiBlZGl0b3IuIEFuIG9wZW4gbm90aWZpY2F0aW9uIG11c3Qgbm90XG4gKiBiZSBzZW50IG1vcmUgdGhhbiBvbmNlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGNsb3NlIG5vdGlmaWNhdGlvbiBzZW5kIGJlZm9yZS5cbiAqIFRoaXMgbWVhbnMgb3BlbiBhbmQgY2xvc2Ugbm90aWZpY2F0aW9uIG11c3QgYmUgYmFsYW5jZWQgYW5kIHRoZSBtYXggb3BlbiBjb3VudFxuICogaXMgb25lLlxuICovXG52YXIgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIGNoYW5nZXMgdG8gYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNsb3NlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBkb2N1bWVudCBnb3QgY2xvc2VkIGluIHRoZSBjbGllbnQuIFRoZSBkb2N1bWVudCdzIHRydXRoIG5vdyBleGlzdHMgd2hlcmVcbiAqIHRoZSBkb2N1bWVudCdzIHVyaSBwb2ludHMgdG8gKGUuZy4gaWYgdGhlIGRvY3VtZW50J3MgdXJpIGlzIGEgZmlsZSB1cmkgdGhlXG4gKiB0cnV0aCBub3cgZXhpc3RzIG9uIGRpc2spLiBBcyB3aXRoIHRoZSBvcGVuIG5vdGlmaWNhdGlvbiB0aGUgY2xvc2Ugbm90aWZpY2F0aW9uXG4gKiBpcyBhYm91dCBtYW5hZ2luZyB0aGUgZG9jdW1lbnQncyBjb250ZW50LiBSZWNlaXZpbmcgYSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBkb2N1bWVudCB3YXMgb3BlbiBpbiBhbiBlZGl0b3IgYmVmb3JlLiBBIGNsb3NlXG4gKiBub3RpZmljYXRpb24gcmVxdWlyZXMgYSBwcmV2aW91cyBvcGVuIG5vdGlmaWNhdGlvbiB0byBiZSBzZW50LlxuICovXG52YXIgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyByZWFzb25zIHdoeSBhIHRleHQgZG9jdW1lbnQgaXMgc2F2ZWQuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTYXZlUmVhc29uO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTYXZlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgdHJpZ2dlcmVkLCBlLmcuIGJ5IHRoZSB1c2VyIHByZXNzaW5nIHNhdmUsIGJ5IHN0YXJ0aW5nIGRlYnVnZ2luZyxcbiAgICAgKiBvciBieSBhbiBBUEkgY2FsbC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLk1hbnVhbCA9IDE7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGFmdGVyIGEgZGVsYXkuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5BZnRlckRlbGF5ID0gMjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBlZGl0b3IgbG9zdCBmb2N1cy5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLkZvY3VzT3V0ID0gMztcbn0pKFRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgd2lsbCBzYXZlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZVxuICogdGhlIGRvY3VtZW50IGlzIGFjdHVhbGx5IHNhdmVkLlxuICovXG52YXIgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC93aWxsU2F2ZSc7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3YXRjaGVkIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBjbGllbnQgZGV0ZWN0cyBjaGFuZ2VzIHRvIGZpbGUgd2F0Y2hlZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXYXRjaGVkRmlsZXMnO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGZpbGUgZXZlbnQgdHlwZVxuICovXG52YXIgRmlsZUNoYW5nZVR5cGU7XG4oZnVuY3Rpb24gKEZpbGVDaGFuZ2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNyZWF0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNoYW5nZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ2hhbmdlZCA9IDI7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGRlbGV0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuRGVsZXRlZCA9IDM7XG59KShGaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgfHwgKGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLlJlbGF0aXZlUGF0dGVybiB8fCAoZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSB7fSkpO1xudmFyIFdhdGNoS2luZDtcbihmdW5jdGlvbiAoV2F0Y2hLaW5kKSB7XG4gICAgLyoqXG4gICAgICogSW50ZXJlc3RlZCBpbiBjcmVhdGUgZXZlbnRzLlxuICAgICAqL1xuICAgIFdhdGNoS2luZC5DcmVhdGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY2hhbmdlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5DaGFuZ2UgPSAyO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gZGVsZXRlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5EZWxldGUgPSA0O1xufSkoV2F0Y2hLaW5kID0gZXhwb3J0cy5XYXRjaEtpbmQgfHwgKGV4cG9ydHMuV2F0Y2hLaW5kID0ge30pKTtcbi8qKlxuICogRGlhZ25vc3RpY3Mgbm90aWZpY2F0aW9uIGFyZSBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNpZ25hbFxuICogcmVzdWx0cyBvZiB2YWxpZGF0aW9uIHJ1bnMuXG4gKi9cbnZhciBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbikge1xuICAgIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3B1Ymxpc2hEaWFnbm9zdGljcyc7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlcXVlc3QgY29tcGxldGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbSBDb21wbGV0aW9uSXRlbVtdfSBvciB7QGxpbmsgQ29tcGxldGlvbkxpc3R9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBUaGUgcmVxdWVzdCBjYW4gZGVsYXkgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZGV0YWlsIGBkZXRhaWxgfVxuICogYW5kIHtAbGluayBDb21wbGV0aW9uSXRlbS5kb2N1bWVudGF0aW9uIGBkb2N1bWVudGF0aW9uYH0gcHJvcGVydGllcyB0byB0aGUgYGNvbXBsZXRpb25JdGVtL3Jlc29sdmVgXG4gKiByZXF1ZXN0LiBIb3dldmVyLCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgc29ydGluZyBhbmQgZmlsdGVyaW5nLCBsaWtlIGBzb3J0VGV4dGAsXG4gKiBgZmlsdGVyVGV4dGAsIGBpbnNlcnRUZXh0YCwgYW5kIGB0ZXh0RWRpdGAsIG11c3Qgbm90IGJlIGNoYW5nZWQgZHVyaW5nIHJlc29sdmUuXG4gKi9cbnZhciBDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvbXBsZXRpb24nO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvbXBsZXRpb24gaXRlbS5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvbXBsZXRpb25JdGVtL3Jlc29sdmUnO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCB8fCAoZXhwb3J0cy5Ib3ZlclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBzaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIGludm9rZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIgb3IgYnkgYSBjb21tYW5kLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5JbnZva2VkID0gMTtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIgPSAyO1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIGN1cnNvciBtb3Zpbmcgb3IgYnkgdGhlIGRvY3VtZW50IGNvbnRlbnQgY2hhbmdpbmcuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkNvbnRlbnRDaGFuZ2UgPSAzO1xufSkoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTaWduYXR1cmVIZWxwUmVxdWVzdDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFJlcXVlc3QpIHtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NpZ25hdHVyZUhlbHAnO1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2lnbmF0dXJlSGVscFJlcXVlc3QubWV0aG9kKTtcbn0pKFNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlc1xuICogdG8gc3VjaC5cbiAqL1xudmFyIERlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVmaW5pdGlvbic7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhIHtAbGluayBEb2N1bWVudEhpZ2hsaWdodH0gZm9yIGEgZ2l2ZW5cbiAqIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlcXVlc3QgcmVzcG9uc2UgaXMgb2YgdHlwZSBbRG9jdW1lbnRIaWdobGlnaHRbXV1cbiAqICgjRG9jdW1lbnRIaWdobGlnaHQpIG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QpIHtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudEhpZ2hsaWdodCc7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgYW5kIHJhbmdlLlxuICovXG52YXIgQ29kZUFjdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25SZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2RlQWN0aW9uJztcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBjb2RlIGFjdGlvbi5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29kZUFjdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdjb2RlQWN0aW9uL3Jlc29sdmUnO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHJhbmdlIGluc2lkZSB0aGUgd29ya3NwYWNlXG4gKiBzeW1ib2wncyBsb2NhdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlU3ltYm9sL3Jlc29sdmUnO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGNvZGUgbGVucyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQuXG4gKi9cbnZhciBDb2RlTGVuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVMZW5zUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvZGVMZW5zJztcbiAgICBDb2RlTGVuc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZWZyZXNoIGFsbCBjb2RlIGFjdGlvbnNcbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2NvZGVMZW5zL3JlZnJlc2hgO1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBkb2N1bWVudCBsaW5rc1xuICovXG52YXIgRG9jdW1lbnRMaW5rUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudExpbmsnO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRvIGZvcm1hdCBhIHdob2xlIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gdG8gZm9ybWF0IGEgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcmFuZ2VGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IGEgZG9jdW1lbnQgb24gdHlwZS5cbiAqL1xudmFyIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvb25UeXBlRm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBSZW5hbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQncyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHNlbGVjdCB0aGUgaWRlbnRpZmllclxuICAgICAqIGFjY29yZGluZyB0aGUgdG8gbGFuZ3VhZ2UncyBzeW50YXggcnVsZS5cbiAgICAgKi9cbiAgICBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvci5JZGVudGlmaWVyID0gMTtcbn0pKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciB8fCAoZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRlc3QgYW5kIHBlcmZvcm0gdGhlIHNldHVwIG5lY2Vzc2FyeSBmb3IgYSByZW5hbWUuXG4gKlxuICogQHNpbmNlIDMuMTYgLSBzdXBwb3J0IGZvciBkZWZhdWx0IGJlaGF2aW9yXG4gKi9cbnZhciBQcmVwYXJlUmVuYW1lUmVxdWVzdDtcbihmdW5jdGlvbiAoUHJlcGFyZVJlbmFtZVJlcXVlc3QpIHtcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3ByZXBhcmVSZW5hbWUnO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kKTtcbn0pKFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCBzZW5kIGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGV4ZWN1dGUgYSBjb21tYW5kLiBUaGUgcmVxdWVzdCBtaWdodCByZXR1cm5cbiAqIGEgd29ya3NwYWNlIGVkaXQgd2hpY2ggdGhlIGNsaWVudCB3aWxsIGFwcGx5IHRvIHRoZSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBFeGVjdXRlQ29tbWFuZFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCkge1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2V4ZWN1dGVDb21tYW5kJztcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCk7XG59KShFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjI0OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgY2FuIGJlIGVkaXRlZCB0b2dldGhlci5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0KSB7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2xpbmtlZEVkaXRpbmdSYW5nZSc7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY4NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlcktpbmQgPSBleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBNb25pa2VyIHVuaXF1ZW5lc3MgbGV2ZWwgdG8gZGVmaW5lIHNjb3BlIG9mIHRoZSBtb25pa2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFVuaXF1ZW5lc3NMZXZlbDtcbihmdW5jdGlvbiAoVW5pcXVlbmVzc0xldmVsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgb25seSB1bmlxdWUgaW5zaWRlIGEgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuZG9jdW1lbnQgPSAnZG9jdW1lbnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgYSBwcm9qZWN0IGZvciB3aGljaCBhIGR1bXAgZ290IGNyZWF0ZWRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwucHJvamVjdCA9ICdwcm9qZWN0JztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBncm91cCB0byB3aGljaCBhIHByb2plY3QgYmVsb25nc1xuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5ncm91cCA9ICdncm91cCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSB0aGUgbW9uaWtlciBzY2hlbWUuXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLnNjaGVtZSA9ICdzY2hlbWUnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIGdsb2JhbGx5IHVuaXF1ZVxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5nbG9iYWwgPSAnZ2xvYmFsJztcbn0pKFVuaXF1ZW5lc3NMZXZlbCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsIHx8IChleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBtb25pa2VyIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTW9uaWtlcktpbmQ7XG4oZnVuY3Rpb24gKE1vbmlrZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50IGEgc3ltYm9sIHRoYXQgaXMgaW1wb3J0ZWQgaW50byBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kaW1wb3J0ID0gJ2ltcG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGV4cG9ydGVkIGZyb20gYSBwcm9qZWN0XG4gICAgICovXG4gICAgTW9uaWtlcktpbmQuJGV4cG9ydCA9ICdleHBvcnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIHJlcHJlc2VudHMgYSBzeW1ib2wgdGhhdCBpcyBsb2NhbCB0byBhIHByb2plY3QgKGUuZy4gYSBsb2NhbFxuICAgICAqIHZhcmlhYmxlIG9mIGEgZnVuY3Rpb24sIGEgY2xhc3Mgbm90IHZpc2libGUgb3V0c2lkZSB0aGUgcHJvamVjdCwgLi4uKVxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLmxvY2FsID0gJ2xvY2FsJztcbn0pKE1vbmlrZXJLaW5kID0gZXhwb3J0cy5Nb25pa2VyS2luZCB8fCAoZXhwb3J0cy5Nb25pa2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBnZXQgdGhlIG1vbmlrZXIgb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLlxuICogVGhlIHJlcXVlc3QgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfS5cbiAqIFRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBNb25pa2VyIE1vbmlrZXJbXX0gb3IgYG51bGxgLlxuICovXG52YXIgTW9uaWtlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKE1vbmlrZXJSZXF1ZXN0KSB7XG4gICAgTW9uaWtlclJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9tb25pa2VyJztcbiAgICBNb25pa2VyUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIE1vbmlrZXJSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKE1vbmlrZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShNb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgfHwgKGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzkyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0gZXhwb3J0cy5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzcxNyk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSBub3RlYm9vayBjZWxsIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tDZWxsS2luZDtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsS2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgbWFya3VwLWNlbGwgaXMgZm9ybWF0dGVkIHNvdXJjZSB0aGF0IGlzIHVzZWQgZm9yIGRpc3BsYXkuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5NYXJrdXAgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgY29kZS1jZWxsIGlzIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIE5vdGVib29rQ2VsbEtpbmQuQ29kZSA9IDI7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxIHx8IHZhbHVlID09PSAyO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxLaW5kLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxLaW5kID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxLaW5kIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB7fSkpO1xudmFyIEV4ZWN1dGlvblN1bW1hcnk7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZXhlY3V0aW9uT3JkZXIsIHN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBleGVjdXRpb25PcmRlciB9O1xuICAgICAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSB8fCBzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5leGVjdXRpb25PcmRlcikgJiYgKGNhbmRpZGF0ZS5zdWNjZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuc3VjY2VzcykpO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmUuZXhlY3V0aW9uT3JkZXIgPT09IG90aGVyLmV4ZWN1dGlvbk9yZGVyICYmIG9uZS5zdWNjZXNzID09PSBvdGhlci5zdWNjZXNzO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyA9IGVxdWFscztcbn0pKEV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IHt9KSk7XG52YXIgTm90ZWJvb2tDZWxsO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGwpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoa2luZCwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZCwgZG9jdW1lbnQgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBOb3RlYm9va0NlbGxLaW5kLmlzKGNhbmRpZGF0ZS5raW5kKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5Eb2N1bWVudFVyaS5pcyhjYW5kaWRhdGUuZG9jdW1lbnQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLm1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUubWV0YWRhdGEpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZGlmZihvbmUsIHR3bykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChvbmUuZG9jdW1lbnQgIT09IHR3by5kb2N1bWVudCkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lLmtpbmQgIT09IHR3by5raW5kKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZS5leGVjdXRpb25TdW1tYXJ5ICE9PSB0d28uZXhlY3V0aW9uU3VtbWFyeSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZXhlY3V0aW9uU3VtbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob25lLm1ldGFkYXRhICE9PSB1bmRlZmluZWQgfHwgdHdvLm1ldGFkYXRhICE9PSB1bmRlZmluZWQpICYmICFlcXVhbHNNZXRhZGF0YShvbmUubWV0YWRhdGEsIHR3by5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ21ldGFkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvbmUuZXhlY3V0aW9uU3VtbWFyeSAhPT0gdW5kZWZpbmVkIHx8IHR3by5leGVjdXRpb25TdW1tYXJ5ICE9PSB1bmRlZmluZWQpICYmICFFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyhvbmUuZXhlY3V0aW9uU3VtbWFyeSwgdHdvLmV4ZWN1dGlvblN1bW1hcnkpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdleGVjdXRpb25TdW1tYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmRpZmYgPSBkaWZmO1xuICAgIGZ1bmN0aW9uIGVxdWFsc01ldGFkYXRhKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbmVBcnJheSA9IEFycmF5LmlzQXJyYXkob25lKTtcbiAgICAgICAgY29uc3Qgb3RoZXJBcnJheSA9IEFycmF5LmlzQXJyYXkob3RoZXIpO1xuICAgICAgICBpZiAob25lQXJyYXkgIT09IG90aGVyQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lQXJyYXkgJiYgb3RoZXJBcnJheSkge1xuICAgICAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5vYmplY3RMaXRlcmFsKG9uZSkgJiYgSXMub2JqZWN0TGl0ZXJhbChvdGhlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZUtleXMgPSBPYmplY3Qua2V5cyhvbmUpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob3RoZXIpO1xuICAgICAgICAgICAgaWYgKG9uZUtleXMubGVuZ3RoICE9PSBvdGhlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IG9uZUtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbcHJvcF0sIG90aGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pKE5vdGVib29rQ2VsbCA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbCA9IHt9KSk7XG52YXIgTm90ZWJvb2tEb2N1bWVudDtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBub3RlYm9va1R5cGUsIHZlcnNpb24sIGNlbGxzIH07XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5pbnRlZ2VyLmlzKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jZWxscywgTm90ZWJvb2tDZWxsLmlzKTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5pcyA9IGlzO1xufSkoTm90ZWJvb2tEb2N1bWVudCA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudCB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9zeW5jJztcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBvcGVucy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBOb3RlYm9va0NlbGxBcnJheUNoYW5nZTtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS51aW50ZWdlci5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5kZWxldGVDb3VudCkgJiYgKGNhbmRpZGF0ZS5jZWxscyA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnQsIGRlbGV0ZUNvdW50LCBjZWxscykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHN0YXJ0LCBkZWxldGVDb3VudCB9O1xuICAgICAgICBpZiAoY2VsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNlbGxzID0gY2VsbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuY3JlYXRlID0gY3JlYXRlO1xufSkoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0ge30pKTtcbnZhciBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGRvY3VtZW50IGlzIHNhdmVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBjbG9zZXMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkQ2xvc2UnO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE2Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG52YXIgV29ya0RvbmVQcm9ncmVzcztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzcykge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3MudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gV29ya0RvbmVQcm9ncmVzcy50eXBlO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzLmlzID0gaXM7XG59KShXb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGluaXRpYXRlIHByb2dyZXNzXG4gKiByZXBvcnRpbmcgZnJvbSB0aGUgc2VydmVyLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0KSB7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZSc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGB3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWxgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBjYW5jZWwgYSBwcm9ncmVzc1xuICogaW5pdGlhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZS5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWwnO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBzZWxlY3Rpb24gcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU2VsZWN0aW9uUmFuZ2UgU2VsZWN0aW9uUmFuZ2VbXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZVJlcXVlc3QpIHtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZWxlY3Rpb25SYW5nZSc7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA2Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ub2tlbkZvcm1hdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8tLS0tLS0tICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnIC0tLS0tXG52YXIgVG9rZW5Gb3JtYXQ7XG4oZnVuY3Rpb24gKFRva2VuRm9ybWF0KSB7XG4gICAgVG9rZW5Gb3JtYXQuUmVsYXRpdmUgPSAncmVsYXRpdmUnO1xufSkoVG9rZW5Gb3JtYXQgPSBleHBvcnRzLlRva2VuRm9ybWF0IHx8IChleHBvcnRzLlRva2VuRm9ybWF0ID0ge30pKTtcbnZhciBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc1JlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0IHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvZnVsbC9kZWx0YSc7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXRob2QpO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0LnJlZ2lzdHJhdGlvbk1ldGhvZCA9IFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL3JhbmdlJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2Uvc2VtYW50aWNUb2tlbnMvcmVmcmVzaGA7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzMzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gc2hvdyBhIGRvY3VtZW50LiBUaGlzIHJlcXVlc3QgbWlnaHQgb3BlbiBhblxuICogZXh0ZXJuYWwgcHJvZ3JhbSBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHRoZSBVUkkgdG8gb3Blbi5cbiAqIEZvciBleGFtcGxlIGEgcmVxdWVzdCB0byBvcGVuIGBodHRwczovL2NvZGUudmlzdWFsc3R1ZGlvLmNvbS9gXG4gKiB3aWxsIHZlcnkgbGlrZWx5IG9wZW4gdGhlIFVSSSBpbiBhIFdFQiBicm93c2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiovXG52YXIgU2hvd0RvY3VtZW50UmVxdWVzdDtcbihmdW5jdGlvbiAoU2hvd0RvY3VtZW50UmVxdWVzdCkge1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93RG9jdW1lbnQnO1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dEb2N1bWVudFJlcXVlc3QgPSBleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyNjQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgdHlwZSBkZWZpbml0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhXG4gKiBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBUeXBlRGVmaW5pdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3R5cGVEZWZpbml0aW9uJztcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDYyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgVHlwZUZveCwgTWljcm9zb2Z0IGFuZCBvdGhlcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc3VsdCBhIGBUeXBlSGllcmFyY2h5SXRlbWAgaW4gYSBkb2N1bWVudCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICogQ2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgdG8gYSBzdWJ0eXBlcyBvciBzdXBlcnR5cGVzIHR5cGUgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZVR5cGVIaWVyYXJjaHknO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdXBlcnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VwZXJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHN1YnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCkge1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VidHlwZXMnO1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4NjA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogVGhlIGB3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVyc2AgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCB0aGUgb3BlbiB3b3Jrc3BhY2UgZm9sZGVycy5cbiAqL1xudmFyIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCkge1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVycyc7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd29ya3NwYWNlL2RpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gdGhlIHdvcmtzcGFjZVxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyc7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLm9iamVjdExpdGVyYWwgPSBleHBvcnRzLnR5cGVkQXJyYXkgPSBleHBvcnRzLnN0cmluZ0FycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZWxlbSA9PiBzdHJpbmcoZWxlbSkpO1xufVxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xuZnVuY3Rpb24gdHlwZWRBcnJheSh2YWx1ZSwgY2hlY2spIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xufVxuZXhwb3J0cy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbmZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcbiAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAvLyBkb2Vzbid0IHVzZSBjbGFzc2VzIHdlIGlnbm9yZSB0aGlzIGZvciBub3cuIElmIHdlIGRvIHdlIG5lZWQgdG8gYWRkIHNvbWV0aGluZ1xuICAgIC8vIGxpa2UgdGhpczogYE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkpID09PSBudWxsYFxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzcxNzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0ZWRUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGVkVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDaGFuZ2VBbm5vdGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25Db250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvblRyaWdnZXJLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZURlc2NyaXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlRGVzY3JpcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlTGVuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUxlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvckluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JQcmVzZW50YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9yUHJlc2VudGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tbWFuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tbWFuZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1UYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ3JlYXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ3JlYXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERlbGV0ZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIERlbGV0ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWNTZXZlcml0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1NldmVyaXR5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1RhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1RhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0OiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRIaWdobGlnaHRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRMaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudExpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFVyaTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRVcmkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBFT0w6ICgpID0+ICgvKiBiaW5kaW5nICovIEVPTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvbGRpbmdSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvcm1hdHRpbmdPcHRpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb3JtYXR0aW5nT3B0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEhvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBIb3ZlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50S2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludExhYmVsUGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50TGFiZWxQYXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVDb250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUNvbnRleHQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZVRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVmFyaWFibGVMb29rdXApLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRSZXBsYWNlRWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0UmVwbGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0Rm9ybWF0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRUZXh0Rm9ybWF0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5zZXJ0VGV4dE1vZGU6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRNb2RlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb25MaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBMb2NhdGlvbkxpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrZWRTdHJpbmc6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmtlZFN0cmluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cENvbnRlbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cENvbnRlbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrdXBLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBNYXJrdXBLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQYXJhbWV0ZXJJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUGFyYW1ldGVySW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQb3NpdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUG9zaXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSZW5hbWVGaWxlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSZW5hbWVGaWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VsZWN0aW9uUmFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbGVjdGlvblJhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbk1vZGlmaWVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNlbWFudGljVG9rZW5UeXBlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlblR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbWFudGljVG9rZW5zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2lnbmF0dXJlSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFNpZ25hdHVyZUluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFN5bWJvbEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN5bWJvbFRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRFZGl0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEl0ZW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVUkk6ICgpID0+ICgvKiBiaW5kaW5nICovIFVSSSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VDaGFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUNoYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VGb2xkZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUZvbGRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZVN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlU3ltYm9sKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW50ZWdlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50ZWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyB1aW50ZWdlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRG9jdW1lbnRVcmk7XG4oZnVuY3Rpb24gKERvY3VtZW50VXJpKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xudmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xudmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG52YXIgdWludGVnZXI7XG4oZnVuY3Rpb24gKHVpbnRlZ2VyKSB7XG4gICAgdWludGVnZXIuTUlOX1ZBTFVFID0gMDtcbiAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHVpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIHVpbnRlZ2VyLmlzID0gaXM7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3RlcjogY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFBvc2l0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgUG9zaXRpb24uaXMgPSBpcztcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBSYW5nZTtcbihmdW5jdGlvbiAoUmFuZ2UpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob25lLCB0d28sIHRocmVlLCBmb3VyKSB7XG4gICAgICAgIGlmIChJcy51aW50ZWdlcihvbmUpICYmIElzLnVpbnRlZ2VyKHR3bykgJiYgSXMudWludGVnZXIodGhyZWUpICYmIElzLnVpbnRlZ2VyKGZvdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogUG9zaXRpb24uY3JlYXRlKG9uZSwgdHdvKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUodGhyZWUsIGZvdXIpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUG9zaXRpb24uaXMob25lKSAmJiBQb3NpdGlvbi5pcyh0d28pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogb25lLCBlbmQ6IHR3byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzW1wiLmNvbmNhdChvbmUsIFwiLCBcIikuY29uY2F0KHR3bywgXCIsIFwiKS5jb25jYXQodGhyZWUsIFwiLCBcIikuY29uY2F0KGZvdXIsIFwiXVwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnN0YXJ0KSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuZW5kKTtcbiAgICB9XG4gICAgUmFuZ2UuaXMgPSBpcztcbn0pKFJhbmdlIHx8IChSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBMb2NhdGlvbjtcbihmdW5jdGlvbiAoTG9jYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb24gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBsb2NhdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIGxvY2F0aW9uJ3MgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9O1xuICAgIH1cbiAgICBMb2NhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS51cmkpKTtcbiAgICB9XG4gICAgTG9jYXRpb24uaXMgPSBpcztcbn0pKExvY2F0aW9uIHx8IChMb2NhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbkxpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTG9jYXRpb25MaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uTGluaztcbihmdW5jdGlvbiAoTG9jYXRpb25MaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIExvY2F0aW9uTGluayBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB0YXJnZXRVcmkgVGhlIGRlZmluaXRpb24ncyB1cmkuXG4gICAgICogQHBhcmFtIHRhcmdldFJhbmdlIFRoZSBmdWxsIHJhbmdlIG9mIHRoZSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXRTZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGRlZmluaXRpb24gYXQgdGhlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luU2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBiZWluZyBkZWZpbmVkIGluIHRoZSBvcmlnaW5hdGluZyBzb3VyY2UgZmlsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHRhcmdldFVyaTogdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZTogdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlOiB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2U6IG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQ6IHJlZCxcbiAgICAgICAgICAgIGdyZWVuOiBncmVlbixcbiAgICAgICAgICAgIGJsdWU6IGJsdWUsXG4gICAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9yfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5yZWQsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuZ3JlZW4sIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYmx1ZSwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5hbHBoYSwgMCwgMSk7XG4gICAgfVxuICAgIENvbG9yLmlzID0gaXM7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3JJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9ySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKENvbG9ySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIENvbG9yLmlzKGNhbmRpZGF0ZS5jb2xvcik7XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKENvbG9ySW5mb3JtYXRpb24gfHwgKENvbG9ySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb247XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQ6IHRleHRFZGl0LFxuICAgICAgICAgICAgYWRkaXRpb25hbFRleHRFZGl0czogYWRkaXRpb25hbFRleHRFZGl0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKENvbG9yUHJlc2VudGF0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZUtpbmQ7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZUtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGNvbW1lbnRcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgPSAnY29tbWVudCc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYW4gaW1wb3J0IG9yIGluY2x1ZGVcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHMgPSAnaW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSByZWdpb24gKGUuZy4gYCNyZWdpb25gKVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uID0gJ3JlZ2lvbic7XG59KShGb2xkaW5nUmFuZ2VLaW5kIHx8IChGb2xkaW5nUmFuZ2VLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGZvbGRpbmcgcmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9sZGluZ1JhbmdlfSBsaXRlcmFscy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kLCBjb2xsYXBzZWRUZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29sbGFwc2VkVGV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2xsYXBzZWRUZXh0ID0gY29sbGFwc2VkVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRm9sZGluZ1JhbmdlfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzID0gaXM7XG59KShEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIHx8IChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMncyBzZXZlcml0eS5cbiAqL1xudmFyIERpYWdub3N0aWNTZXZlcml0eTtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1NldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSB3YXJuaW5nLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nID0gMjtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbiA9IDM7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIGhpbnQuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQgPSA0O1xufSkoRGlhZ25vc3RpY1NldmVyaXR5IHx8IChEaWFnbm9zdGljU2V2ZXJpdHkgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyB0YWdzLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIERpYWdub3N0aWNUYWc7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNUYWcpIHtcbiAgICAvKipcbiAgICAgKiBVbnVzZWQgb3IgdW5uZWNlc3NhcnkgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgZmFkZWQgb3V0IGluc3RlYWQgb2YgaGF2aW5nXG4gICAgICogYW4gZXJyb3Igc3F1aWdnbGUuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5Vbm5lY2Vzc2FyeSA9IDE7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBvciBvYnNvbGV0ZSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXJlZCBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIHN0cmlrZSB0aHJvdWdoLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuRGVwcmVjYXRlZCA9IDI7XG59KShEaWFnbm9zdGljVGFnIHx8IChEaWFnbm9zdGljVGFnID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVEZXNjcmlwdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBkZXNjcmlwdGlvbnMgZm9yIGRpYWdub3N0aWMgY29kZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZURlc2NyaXB0aW9uO1xuKGZ1bmN0aW9uIChDb2RlRGVzY3JpcHRpb24pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpYztcbihmdW5jdGlvbiAoRGlhZ25vc3RpYykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpYyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHNvdXJjZSwgcmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSwgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlLCBjb21tYW5kOiBjb21tYW5kIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29tbWFuZC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb21tYW5kfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG52YXIgVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlcGxhY2UgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaXMgPSBpcztcbn0pKFRleHRFZGl0IHx8IChUZXh0RWRpdCA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbjtcbihmdW5jdGlvbiAoQ2hhbmdlQW5ub3RhdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgbmVlZHNDb25maXJtYXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IGxhYmVsOiBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSAmJlxuICAgICAgICAgICAgKElzLmJvb2xlYW4oY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uKSB8fCBjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24gPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb24gfHwgKENoYW5nZUFubm90YXRpb24gPSB7fSkpO1xudmFyIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgfHwgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyID0ge30pKTtcbnZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJywgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmRlbCA9IGRlbDtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgVGV4dERvY3VtZW50RWRpdDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRleHREb2N1bWVudEVkaXRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRleHREb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dERvY3VtZW50OiB0ZXh0RG9jdW1lbnQsIGVkaXRzOiBlZGl0cyB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhjYW5kaWRhdGUudGV4dERvY3VtZW50KVxuICAgICAgICAgICAgJiYgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZWRpdHMpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRFZGl0IHx8IChUZXh0RG9jdW1lbnRFZGl0ID0ge30pKTtcbnZhciBDcmVhdGVGaWxlO1xuKGZ1bmN0aW9uIChDcmVhdGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2NyZWF0ZScsXG4gICAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdjcmVhdGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmlzID0gaXM7XG59KShDcmVhdGVGaWxlIHx8IChDcmVhdGVGaWxlID0ge30pKTtcbnZhciBSZW5hbWVGaWxlO1xuKGZ1bmN0aW9uIChSZW5hbWVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAncmVuYW1lJyxcbiAgICAgICAgICAgIG9sZFVyaTogb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpOiBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xudmFyIERlbGV0ZUZpbGU7XG4oZnVuY3Rpb24gKERlbGV0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2RlbGV0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuaXMgPSBpcztcbn0pKERlbGV0ZUZpbGUgfHwgKERlbGV0ZUZpbGUgPSB7fSkpO1xudmFyIFdvcmtzcGFjZUVkaXQ7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUVkaXQpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcy5ldmVyeShmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUZpbGUuaXMoY2hhbmdlKSB8fCBSZW5hbWVGaWxlLmlzKGNoYW5nZSkgfHwgRGVsZXRlRmlsZS5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUVkaXQuaXMgPSBpcztcbn0pKFdvcmtzcGFjZUVkaXQgfHwgKFdvcmtzcGFjZUVkaXQgPSB7fSkpO1xudmFyIFRleHRFZGl0Q2hhbmdlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMsIGNoYW5nZUFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cztcbiAgICAgICAgdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyA9IGNoYW5nZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5kZWwocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWRpdCkge1xuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdHM7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVkaXRzLnNwbGljZSgwLCB0aGlzLmVkaXRzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFzc2VydENoYW5nZUFubm90YXRpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZXh0IGVkaXQgY2hhbmdlIGlzIG5vdCBjb25maWd1cmVkIHRvIG1hbmFnZSBjaGFuZ2UgYW5ub3RhdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dEVkaXRDaGFuZ2VJbXBsO1xufSgpKTtcbi8qKlxuICogQSBoZWxwZXIgY2xhc3NcbiAqL1xudmFyIENoYW5nZUFubm90YXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5nZUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLm1hbmFnZSA9IGZ1bmN0aW9uIChpZE9yQW5ub3RhdGlvbiwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZCBcIi5jb25jYXQoaWQsIFwiIGlzIGFscmVhZHkgaW4gdXNlLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbmdlQW5ub3RhdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBXb3Jrc3BhY2VDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHdvcmtzcGFjZUVkaXQ7XG4gICAgICAgICAgICBpZiAod29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucyh3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCBfdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1tjaGFuZ2UudGV4dERvY3VtZW50LnVyaV0gPSB0ZXh0RWRpdENoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod29ya3NwYWNlRWRpdC5jaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLCBcImVkaXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgV29ya3NwYWNlRWRpdH0gbGl0ZXJhbFxuICAgICAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmdldFRleHRFZGl0Q2hhbmdlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudCA9IHsgdXJpOiBrZXkudXJpLCB2ZXJzaW9uOiBrZXkudmVyc2lvbiB9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBlZGl0czogZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmluaXREb2N1bWVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5pbml0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5yZW5hbWVGaWxlID0gZnVuY3Rpb24gKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmRlbGV0ZUZpbGUgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXb3Jrc3BhY2VDaGFuZ2U7XG59KCkpO1xuXG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmkgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4vKipcbiAqIFRoZSBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQsIHZlcnNpb246IHZlcnNpb24sIHRleHQ6IHRleHQgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEl0ZW0gfHwgKFRleHREb2N1bWVudEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGNvbnRlbnQgdHlwZSB0aGF0IGEgY2xpZW50IHN1cHBvcnRzIGluIHZhcmlvdXNcbiAqIHJlc3VsdCBsaXRlcmFscyBsaWtlIGBIb3ZlcmAsIGBQYXJhbWV0ZXJJbmZvYCBvciBgQ29tcGxldGlvbkl0ZW1gLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgYE1hcmt1cEtpbmRzYCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYCRgLiBUaGlzIGtpbmRzXG4gKiBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlLlxuICovXG52YXIgTWFya3VwS2luZDtcbihmdW5jdGlvbiAoTWFya3VwS2luZCkge1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQgaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLlBsYWluVGV4dCA9ICdwbGFpbnRleHQnO1xuICAgIC8qKlxuICAgICAqIE1hcmtkb3duIGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5NYXJrZG93biA9ICdtYXJrZG93bic7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIHtAbGluayBNYXJrdXBLaW5kfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbnZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xuICAgIH1cbiAgICBNYXJrdXBDb250ZW50LmlzID0gaXM7XG59KShNYXJrdXBDb250ZW50IHx8IChNYXJrdXBDb250ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGtpbmQgb2YgYSBjb21wbGV0aW9uIGVudHJ5LlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgd2hldGhlciB0aGUgaW5zZXJ0IHRleHQgaW4gYSBjb21wbGV0aW9uIGl0ZW0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAqL1xudmFyIEluc2VydFRleHRGb3JtYXQ7XG4oZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICpcbiAgICAgKiBBIHNuaXBwZXQgY2FuIGRlZmluZSB0YWIgc3RvcHMgYW5kIHBsYWNlaG9sZGVycyB3aXRoIGAkMWAsIGAkMmBcbiAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxuICAgICAqIHRoYXQgaXMgdHlwaW5nIGluIG9uZSB3aWxsIHVwZGF0ZSBvdGhlcnMgdG9vLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9sYW5ndWFnZS1zZXJ2ZXItcHJvdG9jb2wvc3BlY2lmaWNhdGlvbnMvc3BlY2lmaWNhdGlvbi1jdXJyZW50LyNzbmlwcGV0X3N5bnRheFxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG59KShJbnNlcnRUZXh0Rm9ybWF0IHx8IChJbnNlcnRUZXh0Rm9ybWF0ID0ge30pKTtcbi8qKlxuICogQ29tcGxldGlvbiBpdGVtIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIGNvbXBsZXRpb25cbiAqIGl0ZW0uXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1UYWc7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgY29tcGxldGlvbiBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgQ29tcGxldGlvbkl0ZW1UYWcuRGVwcmVjYXRlZCA9IDE7XG59KShDb21wbGV0aW9uSXRlbVRhZyB8fCAoQ29tcGxldGlvbkl0ZW1UYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5zZXJ0UmVwbGFjZUVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggaW5zZXJ0IC8gcmVwbGFjZSBlZGl0cy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbihmdW5jdGlvbiAoSW5zZXJ0UmVwbGFjZUVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogbmV3VGV4dCwgaW5zZXJ0OiBpbnNlcnQsIHJlcGxhY2U6IHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuaW5zZXJ0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmVwbGFjZSk7XG4gICAgfVxuICAgIEluc2VydFJlcGxhY2VFZGl0LmlzID0gaXM7XG59KShJbnNlcnRSZXBsYWNlRWRpdCB8fCAoSW5zZXJ0UmVwbGFjZUVkaXQgPSB7fSkpO1xuLyoqXG4gKiBIb3cgd2hpdGVzcGFjZSBhbmQgaW5kZW50YXRpb24gaXMgaGFuZGxlZCBkdXJpbmcgY29tcGxldGlvblxuICogaXRlbSBpbnNlcnRpb24uXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbnZhciBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xufSkoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgfHwgKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW07XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29tcGxldGlvbiBpdGVtIGFuZCBzZWVkIGl0IHdpdGggYSBsYWJlbC5cbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGNvbXBsZXRpb24gaXRlbSdzIGxhYmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7IGxhYmVsOiBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbnZhciBDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBsZXRpb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cbiAgICAgKiBAcGFyYW0gaXNJbmNvbXBsZXRlIFRoZSBsaXN0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG52YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuaXMgPSBpcztcbn0pKE1hcmtlZFN0cmluZyB8fCAoTWFya2VkU3RyaW5nID0ge30pKTtcbnZhciBIb3ZlcjtcbihmdW5jdGlvbiAoSG92ZXIpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBIb3Zlcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxuICAgICAgICAgICAgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY29udGVudHMsIE1hcmtlZFN0cmluZy5pcykpICYmICh2YWx1ZS5yYW5nZSA9PT0gdW5kZWZpbmVkIHx8IFJhbmdlLmlzKHZhbHVlLnJhbmdlKSk7XG4gICAgfVxuICAgIEhvdmVyLmlzID0gaXM7XG59KShIb3ZlciB8fCAoSG92ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUGFyYW1ldGVySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbDogbGFiZWwsIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGRvY3VtZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU2lnbmF0dXJlSW5mb3JtYXRpb24gfHwgKFNpZ25hdHVyZUluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuUmVhZCA9IDI7XG4gICAgLyoqXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuV3JpdGUgPSAzO1xufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEb2N1bWVudEhpZ2hsaWdodCBuYW1lc3BhY2UgdG8gcHJvdmlkZSBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERvY3VtZW50SGlnaGxpZ2h0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRoZSBoaWdobGlnaHQgYXBwbGllcyB0by5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUgaGlnaGxpZ2h0IGtpbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudEhpZ2hsaWdodC5jcmVhdGUgPSBjcmVhdGU7XG59KShEb2N1bWVudEhpZ2hsaWdodCB8fCAoRG9jdW1lbnRIaWdobGlnaHQgPSB7fSkpO1xuLyoqXG4gKiBBIHN5bWJvbCBraW5kLlxuICovXG52YXIgU3ltYm9sS2luZDtcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XG4gICAgU3ltYm9sS2luZC5Nb2R1bGUgPSAyO1xuICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xuICAgIFN5bWJvbEtpbmQuQ2xhc3MgPSA1O1xuICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcbiAgICBTeW1ib2xLaW5kLkZpZWxkID0gODtcbiAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcbiAgICBTeW1ib2xLaW5kLkludGVyZmFjZSA9IDExO1xuICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XG4gICAgU3ltYm9sS2luZC5Db25zdGFudCA9IDE0O1xuICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcbiAgICBTeW1ib2xLaW5kLkJvb2xlYW4gPSAxNztcbiAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcbiAgICBTeW1ib2xLaW5kLktleSA9IDIwO1xuICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xuICAgIFN5bWJvbEtpbmQuU3RydWN0ID0gMjM7XG4gICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcbiAgICBTeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBTeW1ib2wgdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgc3ltYm9sLlxuICpcbiAqIEBzaW5jZSAzLjE2XG4gKi9cbnZhciBTeW1ib2xUYWc7XG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHN5bWJvbCBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgU3ltYm9sVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoU3ltYm9sVGFnIHx8IChTeW1ib2xUYWcgPSB7fSkpO1xudmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLlxuICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wgY29udGFpbmluZyB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGFpbmVyTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFN5bWJvbEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFN5bWJvbEluZm9ybWF0aW9uIHx8IChTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XG52YXIgV29ya3NwYWNlU3ltYm9sO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgQSBXb3Jrc3BhY2VTeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geyBuYW1lOiBuYW1lLCBraW5kOiBraW5kLCBsb2NhdGlvbjogeyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH0gfVxuICAgICAgICAgICAgOiB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpIH0gfTtcbiAgICB9XG4gICAgV29ya3NwYWNlU3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFdvcmtzcGFjZVN5bWJvbCB8fCAoV29ya3NwYWNlU3ltYm9sID0ge30pKTtcbnZhciBEb2N1bWVudFN5bWJvbDtcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRTeW1ib2x9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5raW5kKSAmJlxuICAgICAgICAgICAgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuc2VsZWN0aW9uUmFuZ2UpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGVwcmVjYXRlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmRlcHJlY2F0ZWQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmNoaWxkcmVuKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUudGFncyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLnRhZ3MpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuaXMgPSBpcztcbn0pKERvY3VtZW50U3ltYm9sIHx8IChEb2N1bWVudFN5bWJvbCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgY29kZSBhY3Rpb24ga2luZHNcbiAqL1xudmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSByZWFzb24gd2h5IGNvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyIG9yIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gY3VycmVudCBzZWxlY3Rpb24gaW4gYSBmaWxlIGNoYW5nZXMsIGJ1dCBjYW5cbiAgICAgKiBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIGZpbGUgY29udGVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAyO1xufSkoQ29kZUFjdGlvblRyaWdnZXJLaW5kIHx8IChDb2RlQWN0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUFjdGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25Db250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlQWN0aW9uQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShkaWFnbm9zdGljcywgb25seSwgdHJpZ2dlcktpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgZGlhZ25vc3RpY3M6IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbnZhciBDb2RlQWN0aW9uO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHRpdGxlOiB0aXRsZSB9O1xuICAgICAgICB2YXIgY2hlY2tLaW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBraW5kT3JDb21tYW5kT3JFZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hlY2tLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZC5pcyhraW5kT3JDb21tYW5kT3JFZGl0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVkaXQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja0tpbmQgJiYga2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRpYWdub3N0aWNzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuaXNQcmVmZXJyZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHVuZGVmaW5lZCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uaXMgPSBpcztcbn0pKENvZGVBY3Rpb24gfHwgKENvZGVBY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUxlbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUxlbnN9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUxlbnM7XG4oZnVuY3Rpb24gKENvZGVMZW5zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlTGVucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlTGVucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlTGVuc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgQ29kZUxlbnMuaXMgPSBpcztcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBGb3JtYXR0aW5nT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb3JtYXR0aW5nT3B0aW9ucztcbihmdW5jdGlvbiAoRm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvcm1hdHRpbmdPcHRpb25zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhYlNpemUsIGluc2VydFNwYWNlcykge1xuICAgICAgICByZXR1cm4geyB0YWJTaXplOiB0YWJTaXplLCBpbnNlcnRTcGFjZXM6IGluc2VydFNwYWNlcyB9O1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBEb2N1bWVudExpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRMaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50TGluaztcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEb2N1bWVudExpbmsgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHRhcmdldDogdGFyZ2V0LCBkYXRhOiBkYXRhIH07XG4gICAgfVxuICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudExpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XG4gICAgfVxuICAgIERvY3VtZW50TGluay5pcyA9IGlzO1xufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2VsZWN0aW9uUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byB3b3JrIHdpdGhcbiAqIFNlbGVjdGlvblJhbmdlIGxpdGVyYWxzLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2U7XG4oZnVuY3Rpb24gKFNlbGVjdGlvblJhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTZWxlY3Rpb25SYW5nZVxuICAgICAqIEBwYXJhbSByYW5nZSB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHBhcmVudCBhbiBvcHRpb25hbCBwYXJlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBwYXJlbnQ6IHBhcmVudCB9O1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKGNhbmRpZGF0ZS5wYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBTZWxlY3Rpb25SYW5nZS5pcyhjYW5kaWRhdGUucGFyZW50KSk7XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmlzID0gaXM7XG59KShTZWxlY3Rpb25SYW5nZSB8fCAoU2VsZWN0aW9uUmFuZ2UgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIHR5cGVzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlblR5cGVzO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuVHlwZXMpIHtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJuYW1lc3BhY2VcIl0gPSBcIm5hbWVzcGFjZVwiO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBnZW5lcmljIHR5cGUuIEFjdHMgYXMgYSBmYWxsYmFjayBmb3IgdHlwZXMgd2hpY2ggY2FuJ3QgYmUgbWFwcGVkIHRvXG4gICAgICogYSBzcGVjaWZpYyB0eXBlIGxpa2UgY2xhc3Mgb3IgZW51bS5cbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlXCJdID0gXCJ0eXBlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY2xhc3NcIl0gPSBcImNsYXNzXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZW51bVwiXSA9IFwiZW51bVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImludGVyZmFjZVwiXSA9IFwiaW50ZXJmYWNlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RydWN0XCJdID0gXCJzdHJ1Y3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlUGFyYW1ldGVyXCJdID0gXCJ0eXBlUGFyYW1ldGVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wicGFyYW1ldGVyXCJdID0gXCJwYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ2YXJpYWJsZVwiXSA9IFwidmFyaWFibGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwcm9wZXJ0eVwiXSA9IFwicHJvcGVydHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtTWVtYmVyXCJdID0gXCJlbnVtTWVtYmVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZnVuY3Rpb25cIl0gPSBcImZ1bmN0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWV0aG9kXCJdID0gXCJtZXRob2RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtYWNyb1wiXSA9IFwibWFjcm9cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJrZXl3b3JkXCJdID0gXCJrZXl3b3JkXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibW9kaWZpZXJcIl0gPSBcIm1vZGlmaWVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY29tbWVudFwiXSA9IFwiY29tbWVudFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJyZWdleHBcIl0gPSBcInJlZ2V4cFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm9wZXJhdG9yXCJdID0gXCJvcGVyYXRvclwiO1xuICAgIC8qKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJkZWNvcmF0b3JcIl0gPSBcImRlY29yYXRvclwiO1xufSkoU2VtYW50aWNUb2tlblR5cGVzIHx8IChTZW1hbnRpY1Rva2VuVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIG1vZGlmaWVycy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5Nb2RpZmllcnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5Nb2RpZmllcnMpIHtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVjbGFyYXRpb25cIl0gPSBcImRlY2xhcmF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmluaXRpb25cIl0gPSBcImRlZmluaXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInN0YXRpY1wiXSA9IFwic3RhdGljXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlcHJlY2F0ZWRcIl0gPSBcImRlcHJlY2F0ZWRcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFzeW5jXCJdID0gXCJhc3luY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJtb2RpZmljYXRpb25cIl0gPSBcIm1vZGlmaWNhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmF1bHRMaWJyYXJ5XCJdID0gXCJkZWZhdWx0TGlicmFyeVwiO1xufSkoU2VtYW50aWNUb2tlbk1vZGlmaWVycyB8fCAoU2VtYW50aWNUb2tlbk1vZGlmaWVycyA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLnJlc3VsdElkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5kYXRhKSAmJiAoY2FuZGlkYXRlLmRhdGEubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBjYW5kaWRhdGUuZGF0YVswXSA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBTZW1hbnRpY1Rva2Vucy5pcyA9IGlzO1xufSkoU2VtYW50aWNUb2tlbnMgfHwgKFNlbWFudGljVG9rZW5zID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVRleHRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVUZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0ZXh0OiB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVRleHQgfHwgKElubGluZVZhbHVlVGV4dCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVmFyaWFibGVMb29rdXBzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVmFyaWFibGVMb29rdXApIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgdmFyaWFibGVOYW1lOiB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXA6IGNhc2VTZW5zaXRpdmVMb29rdXAgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuY2FzZVNlbnNpdGl2ZUxvb2t1cClcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSkgfHwgY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCB8fCAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmV4cHJlc3Npb24pIHx8IGNhbmRpZGF0ZS5leHByZXNzaW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gfHwgKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlQ29udGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVDb250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IGZyYW1lSWQ6IGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbjogc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXModmFsdWUuc3RvcHBlZExvY2F0aW9uKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUNvbnRleHQgfHwgKElubGluZVZhbHVlQ29udGV4dCA9IHt9KSk7XG4vKipcbiAqIElubGF5IGhpbnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50S2luZDtcbihmdW5jdGlvbiAoSW5sYXlIaW50S2luZCkge1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBmb3IgYSB0eXBlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5UeXBlID0gMTtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgaXMgZm9yIGEgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuUGFyYW1ldGVyID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIElubGF5SGludEtpbmQuaXMgPSBpcztcbn0pKElubGF5SGludEtpbmQgfHwgKElubGF5SGludEtpbmQgPSB7fSkpO1xudmFyIElubGF5SGludExhYmVsUGFydDtcbihmdW5jdGlvbiAoSW5sYXlIaW50TGFiZWxQYXJ0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbnZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcG9zaXRpb246IHBvc2l0aW9uLCBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5wb3NpdGlvbilcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5sYWJlbCwgSW5sYXlIaW50TGFiZWxQYXJ0LmlzKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElubGF5SGludEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHVuZGVmaW5lZCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUudGV4dEVkaXRzLCBUZXh0RWRpdC5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudG9vbHRpcCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudG9vbHRpcCkgfHwgTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUudG9vbHRpcCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdMZWZ0ID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUucGFkZGluZ0xlZnQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQpKTtcbiAgICB9XG4gICAgSW5sYXlIaW50LmlzID0gaXM7XG59KShJbmxheUhpbnQgfHwgKElubGF5SGludCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUZvbGRlci5pcyA9IGlzO1xufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xudmFyIEVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSVRleHREb2N1bWVudCBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIHVyaSBhbmQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElUZXh0RG9jdW1lbnR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmxhbmd1YWdlSWQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lQ291bnQpXG4gICAgICAgICAgICAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5nZXRUZXh0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5wb3NpdGlvbkF0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vZmZzZXRBdCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHNvcnRlZEVkaXRzW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mZnNldCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgZS5uZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG4gICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIC8vIHNvcnRlZFxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICAgICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgICAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB2YXIgbGVmdElkeCA9IDA7XG4gICAgICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQsIHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGV2ZW50LnRleHQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5vZmZzZXRBdCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICB2YXIgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxpbmVDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgSXM7XG4oZnVuY3Rpb24gKElzKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3MzA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDUpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODM0KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODE4KTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoYXJyLnNsaWNlKTtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZCA9ICRzbGljZSh0eXBlZEFycmF5LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG52YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCBuYW1lKSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2V0dGVyKHZhbHVlKTtcblx0XHRcdFx0Zm91bmQgPSAkc2xpY2UobmFtZSwgMSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDgzNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlKHN0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmUsIC4uLmFkZGVkTGluZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhdm9pZCB0b28gbWFueSBhcmd1bWVudHMgZm9yIHNwbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH1cbiAgICBwb3NpdGlvbkF0KG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH1cbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmNoYXJhY3RlciA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldCkge1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gbGluZU9mZnNldCAmJiBpc0VPTCh0aGlzLl9jb250ZW50LmNoYXJDb2RlQXQob2Zmc2V0IC0gMSkpKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgbGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5jcmVtZW50YWwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfVxufVxudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIGluaXRpYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBUZXh0RG9jdW1lbnQgYnkgbW9kaWZ5aW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgY2hhbmdlcyB2ZXJzaW9uIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dERvY3VtZW50LiBOb3RlOiBUaGF0J3MgdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShkb2N1bWVudCwgY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBGdWxsVGV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC51cGRhdGUoY2hhbmdlcywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHREb2N1bWVudC51cGRhdGU6IGRvY3VtZW50IG11c3QgYmUgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERvY3VtZW50LnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cy5tYXAoZ2V0V2VsbGZvcm1lZEVkaXQpLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygc29ydGVkRWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPCBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ID4gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cmluZyhsYXN0TW9kaWZpZWRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5uZXdUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2goZS5uZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHRleHQuc3Vic3RyKGxhc3RNb2RpZmllZE9mZnNldCkpO1xuICAgICAgICByZXR1cm4gc3BhbnMuam9pbignJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbmZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgLy8gc29ydGVkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICBsZXQgbGVmdElkeCA9IDA7XG4gICAgbGV0IHJpZ2h0SWR4ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgfVxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaXNFT0woY2gpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0T2Zmc2V0ICsgaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0VPTChjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IGNoYXIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZFJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKHRleHRFZGl0LnJhbmdlKTtcbiAgICBpZiAocmFuZ2UgIT09IHRleHRFZGl0LnJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IG5ld1RleHQ6IHRleHRFZGl0Lm5ld1RleHQsIHJhbmdlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0RWRpdDtcbn1cblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG4vKioqKioqLyBcdFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGUpO1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdFx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG4vKioqKioqLyBcdFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8qKioqKiovIFx0XHRcdH0gY2F0Y2ggKGUpIHtcbi8qKioqKiovIFx0XHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH0pKCk7XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0bW9kdWxlLnBhdGhzID0gW107XG4vKioqKioqLyBcdFx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gbW9kdWxlO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbigoKSA9PiB7XG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBMdWFTZXJ2aWNlOiAoKSA9PiAoLyogYmluZGluZyAqLyBMdWFTZXJ2aWNlKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc2VydmljZXMvYmFzZS1zZXJ2aWNlLnRzXG52YXIgYmFzZV9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTI1KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2x1YXBhcnNlL2x1YXBhcnNlLmpzXG52YXIgbHVhcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9saWIvYnJvd3Nlci9tYWluLmpzXG52YXIgbWFpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTUwMSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzLnRzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NzApO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FjZS9yYW5nZS1zaW5nbGV0b24udHNcbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmNsYXNzIEFjZVJhbmdlIHtcbiAgICBzdGF0aWMgZ2V0Q29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICAgIGlmICghQWNlUmFuZ2UuX2luc3RhbmNlICYmIGVkaXRvcikge1xuICAgICAgICAgICAgQWNlUmFuZ2UuX2luc3RhbmNlID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkuY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFjZVJhbmdlLl9pbnN0YW5jZTtcbiAgICB9XG59XG5fZGVmaW5lX3Byb3BlcnR5KEFjZVJhbmdlLCBcIl9pbnN0YW5jZVwiLCB2b2lkIDApO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdHlwZS1jb252ZXJ0ZXJzL2NvbW1vbi1jb252ZXJ0ZXJzLnRzXG5cblxuXG52YXIgY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyO1xuKGZ1bmN0aW9uKENvbW1vbkNvbnZlcnRlcikge1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmdlcyhjb21wbGV0aW9ucykge1xuICAgICAgICByZXR1cm4gY29tcGxldGlvbnMgJiYgY29tcGxldGlvbnMubWFwKChlbCk9PntcbiAgICAgICAgICAgIGlmIChlbFtcInJhbmdlXCJdKSB7XG4gICAgICAgICAgICAgICAgZWxbXCJyYW5nZVwiXSA9IHRvUmFuZ2UoZWxbXCJyYW5nZVwiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIubm9ybWFsaXplUmFuZ2VzID0gbm9ybWFsaXplUmFuZ2VzO1xuICAgIGZ1bmN0aW9uIGNsZWFuSHRtbChodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoLzxhXFxzLywgXCI8YSB0YXJnZXQ9J19ibGFuaycgXCIpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIuY2xlYW5IdG1sID0gY2xlYW5IdG1sO1xuICAgIGZ1bmN0aW9uIHRvUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKCFyYW5nZSB8fCAhcmFuZ2Uuc3RhcnQgfHwgIXJhbmdlLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBSYW5nZSA9IEFjZVJhbmdlLmdldENvbnN0cnVjdG9yKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgfVxuICAgIENvbW1vbkNvbnZlcnRlci50b1JhbmdlID0gdG9SYW5nZTtcbiAgICBmdW5jdGlvbiBjb252ZXJ0S2luZChraW5kKSB7XG4gICAgICAgIHN3aXRjaChraW5kKXtcbiAgICAgICAgICAgIGNhc2UgXCJwcmltaXRpdmVUeXBlXCI6XG4gICAgICAgICAgICBjYXNlIFwia2V5d29yZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkO1xuICAgICAgICAgICAgY2FzZSBcInZhcmlhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwibG9jYWxWYXJpYWJsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYXJpYWJsZTtcbiAgICAgICAgICAgIGNhc2UgXCJtZW1iZXJWYXJpYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm1lbWJlckdldEFjY2Vzc29yXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyU2V0QWNjZXNzb3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuRmllbGQ7XG4gICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJtZW1iZXJGdW5jdGlvblwiOlxuICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdFNpZ25hdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImNhbGxTaWduYXR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbmRleFNpZ25hdHVyZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5GdW5jdGlvbjtcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkVudW07XG4gICAgICAgICAgICBjYXNlIFwibW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZTtcbiAgICAgICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5DbGFzcztcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmZhY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlO1xuICAgICAgICAgICAgY2FzZSBcIndhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuRmlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk7XG4gICAgfVxuICAgIENvbW1vbkNvbnZlcnRlci5jb252ZXJ0S2luZCA9IGNvbnZlcnRLaW5kO1xuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVCeUVycm9yTWVzc2FnZShkaWFnbm9zdGljcywgZXJyb3JNZXNzYWdlc1RvSWdub3JlLCBmaWVsZE5hbWUgPSBcIm1lc3NhZ2VcIikge1xuICAgICAgICBpZiAoIWVycm9yTWVzc2FnZXNUb0lnbm9yZSkgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3MuZmlsdGVyKChlbCk9PiEoMCx1dGlscy8qIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkgKi8uVGspKGVsW2ZpZWxkTmFtZV0sIGVycm9yTWVzc2FnZXNUb0lnbm9yZSkpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIuZXhjbHVkZUJ5RXJyb3JNZXNzYWdlID0gZXhjbHVkZUJ5RXJyb3JNZXNzYWdlO1xufSkoY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyIHx8IChjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXIgPSB7fSkpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdHlwZS1jb252ZXJ0ZXJzL2xzcC9sc3AtY29udmVydGVycy50c1xuXG5cblxuXG5mdW5jdGlvbiBmcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgbGluZTogcmFuZ2Uuc3RhcnQucm93LFxuICAgICAgICAgICAgY2hhcmFjdGVyOiByYW5nZS5zdGFydC5jb2x1bW5cbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBsaW5lOiByYW5nZS5lbmQucm93LFxuICAgICAgICAgICAgY2hhcmFjdGVyOiByYW5nZS5lbmQuY29sdW1uXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmFuZ2VGcm9tUG9zaXRpb25zKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvUmFuZ2UocmFuZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgcm93OiByYW5nZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiByYW5nZS5zdGFydC5jaGFyYWN0ZXJcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICByb3c6IHJhbmdlLmVuZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiByYW5nZS5lbmQuY2hhcmFjdGVyXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbVBvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogcG9pbnQucm93LFxuICAgICAgICBjaGFyYWN0ZXI6IHBvaW50LmNvbHVtblxuICAgIH07XG59XG5mdW5jdGlvbiB0b1BvaW50KHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm93OiBwb3NpdGlvbi5saW5lLFxuICAgICAgICBjb2x1bW46IHBvc2l0aW9uLmNoYXJhY3RlclxuICAgIH07XG59XG5mdW5jdGlvbiB0b0Fubm90YXRpb25zKGRpYWdub3N0aWNzKSB7XG4gICAgdmFyIF9kaWFnbm9zdGljcztcbiAgICByZXR1cm4gKF9kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzKSA9PT0gbnVsbCB8fCBfZGlhZ25vc3RpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kaWFnbm9zdGljcy5tYXAoKGVsKT0+e1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93OiBlbC5yYW5nZS5zdGFydC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBlbC5yYW5nZS5zdGFydC5jaGFyYWN0ZXIsXG4gICAgICAgICAgICB0ZXh0OiBlbC5tZXNzYWdlLFxuICAgICAgICAgICAgdHlwZTogZWwuc2V2ZXJpdHkgPT09IDEgPyBcImVycm9yXCIgOiBlbC5zZXZlcml0eSA9PT0gMiA/IFwid2FybmluZ1wiIDogXCJpbmZvXCIsXG4gICAgICAgICAgICBjb2RlOiBlbC5jb2RlXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmcm9tQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpIHtcbiAgICB2YXIgX2Fubm90YXRpb25zO1xuICAgIHJldHVybiAoX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMpID09PSBudWxsIHx8IF9hbm5vdGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fubm90YXRpb25zLm1hcCgoZWwpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVsLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyOiBlbC5jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBlbC5yb3csXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogZWwuY29sdW1uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVsLnRleHQsXG4gICAgICAgICAgICBzZXZlcml0eTogZWwudHlwZSA9PT0gXCJlcnJvclwiID8gMSA6IGVsLnR5cGUgPT09IFwid2FybmluZ1wiID8gMiA6IDMsXG4gICAgICAgICAgICBjb2RlOiBlbFtcImNvZGVcIl1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvQ29tcGxldGlvbihpdGVtKSB7XG4gICAgdmFyIF9pdGVtX3RleHRFZGl0LCBfaXRlbV9jb21tYW5kO1xuICAgIGxldCBpdGVtS2luZCA9IGl0ZW0ua2luZDtcbiAgICBsZXQga2luZCA9IGl0ZW1LaW5kID8gT2JqZWN0LmtleXMoQ29tcGxldGlvbkl0ZW1LaW5kKVtPYmplY3QudmFsdWVzKENvbXBsZXRpb25JdGVtS2luZCkuaW5kZXhPZihpdGVtS2luZCldIDogdW5kZWZpbmVkO1xuICAgIHZhciBfaXRlbV90ZXh0RWRpdF9uZXdUZXh0LCBfcmVmO1xuICAgIGxldCB0ZXh0ID0gKF9yZWYgPSAoX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCA9IChfaXRlbV90ZXh0RWRpdCA9IGl0ZW0udGV4dEVkaXQpID09PSBudWxsIHx8IF9pdGVtX3RleHRFZGl0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaXRlbV90ZXh0RWRpdC5uZXdUZXh0KSAhPT0gbnVsbCAmJiBfaXRlbV90ZXh0RWRpdF9uZXdUZXh0ICE9PSB2b2lkIDAgPyBfaXRlbV90ZXh0RWRpdF9uZXdUZXh0IDogaXRlbS5pbnNlcnRUZXh0KSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogaXRlbS5sYWJlbDtcbiAgICBsZXQgZmlsdGVyVGV4dDtcbiAgICAvLyBmaWx0ZXJpbmcgd291bGQgaGFwcGVuIG9uIGFjZSBlZGl0b3Igc2lkZVxuICAgIC8vVE9ETzogaWYgZmlsdGVyaW5nIGFuZCBzb3J0aW5nIGFyZSBvbiBzZXJ2ZXIgc2lkZSwgd2Ugc2hvdWxkIGRpc2FibGUgRmlsdGVyZWRMaXN0IGluIGFjZSBjb21wbGV0ZXJcbiAgICBpZiAoaXRlbS5maWx0ZXJUZXh0KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0V29yZE1hdGNoID0gaXRlbS5maWx0ZXJUZXh0Lm1hdGNoKC9cXHcrLyk7XG4gICAgICAgIGNvbnN0IGZpcnN0V29yZCA9IGZpcnN0V29yZE1hdGNoID8gZmlyc3RXb3JkTWF0Y2hbMF0gOiBudWxsO1xuICAgICAgICBpZiAoZmlyc3RXb3JkKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkUmVnZXggPSBuZXcgUmVnRXhwKGBcXFxcYiR7Zmlyc3RXb3JkfVxcXFxiYCwgJ2knKTtcbiAgICAgICAgICAgIGlmICghd29yZFJlZ2V4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gYCR7aXRlbS5maWx0ZXJUZXh0fSAke3RleHR9YDtcbiAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0ID0gaXRlbS5maWx0ZXJUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0ZXh0LmluY2x1ZGVzKGl0ZW0uZmlsdGVyVGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gYCR7aXRlbS5maWx0ZXJUZXh0fSAke3RleHR9YDtcbiAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0ID0gaXRlbS5maWx0ZXJUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb21tYW5kID0gKChfaXRlbV9jb21tYW5kID0gaXRlbS5jb21tYW5kKSA9PT0gbnVsbCB8fCBfaXRlbV9jb21tYW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaXRlbV9jb21tYW5kLmNvbW1hbmQpID09IFwiZWRpdG9yLmFjdGlvbi50cmlnZ2VyU3VnZ2VzdFwiID8gXCJzdGFydEF1dG9jb21wbGV0ZVwiIDogdW5kZWZpbmVkO1xuICAgIGxldCByYW5nZSA9IGl0ZW0udGV4dEVkaXQgPyBnZXRUZXh0RWRpdFJhbmdlKGl0ZW0udGV4dEVkaXQsIGZpbHRlclRleHQpIDogdW5kZWZpbmVkO1xuICAgIGxldCBjb21wbGV0aW9uID0ge1xuICAgICAgICBtZXRhOiBraW5kLFxuICAgICAgICBjYXB0aW9uOiBpdGVtLmxhYmVsLFxuICAgICAgICBzY29yZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBjb21wbGV0aW9uW1wiY29tbWFuZFwiXSA9IGNvbW1hbmQ7XG4gICAgY29tcGxldGlvbltcInJhbmdlXCJdID0gcmFuZ2U7XG4gICAgY29tcGxldGlvbltcIml0ZW1cIl0gPSBpdGVtO1xuICAgIGlmIChpdGVtLmluc2VydFRleHRGb3JtYXQgPT0gSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0KSB7XG4gICAgICAgIGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0aW9uW1widmFsdWVcIl0gPSB0ZXh0ICE9PSBudWxsICYmIHRleHQgIT09IHZvaWQgMCA/IHRleHQgOiBcIlwiO1xuICAgIH1cbiAgICBjb21wbGV0aW9uW1wiZG9jdW1lbnRhdGlvblwiXSA9IGl0ZW0uZG9jdW1lbnRhdGlvbjsgLy9UT0RPOiB0aGlzIGlzIHdvcmthcm91bmQgZm9yIHNlcnZpY2VzIHdpdGggaW5zdGFudCBjb21wbGV0aW9uXG4gICAgY29tcGxldGlvbltcInBvc2l0aW9uXCJdID0gaXRlbVtcInBvc2l0aW9uXCJdO1xuICAgIGNvbXBsZXRpb25bXCJzZXJ2aWNlXCJdID0gaXRlbVtcInNlcnZpY2VcIl07IC8vVE9ETzogc2luY2Ugd2UgaGF2ZSBtdWx0aXBsZSBzZXJ2ZXJzLCB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgIC8vIHNlcnZlciB0byB1c2UgZm9yIHJlc29sdmluZ1xuICAgIHJldHVybiBjb21wbGV0aW9uO1xufVxuZnVuY3Rpb24gdG9Db21wbGV0aW9ucyhjb21wbGV0aW9ucykge1xuICAgIGlmIChjb21wbGV0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBjb21iaW5lZENvbXBsZXRpb25zID0gY29tcGxldGlvbnMubWFwKChlbCk9PntcbiAgICAgICAgICAgIGlmICghZWwuY29tcGxldGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWxsQ29tcGxldGlvbnM7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbC5jb21wbGV0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBhbGxDb21wbGV0aW9ucyA9IGVsLmNvbXBsZXRpb25zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGxDb21wbGV0aW9ucyA9IGVsLmNvbXBsZXRpb25zLml0ZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsbENvbXBsZXRpb25zLm1hcCgoaXRlbSk9PntcbiAgICAgICAgICAgICAgICBpdGVtW1wic2VydmljZVwiXSA9IGVsLnNlcnZpY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZmxhdCgpO1xuICAgICAgICByZXR1cm4gY29tYmluZWRDb21wbGV0aW9ucy5tYXAoKGl0ZW0pPT50b0NvbXBsZXRpb24oaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiB0b1Jlc29sdmVkQ29tcGxldGlvbihjb21wbGV0aW9uLCBpdGVtKSB7XG4gICAgY29tcGxldGlvbltcImRvY01hcmtkb3duXCJdID0gZnJvbU1hcmt1cENvbnRlbnQoaXRlbS5kb2N1bWVudGF0aW9uKTtcbiAgICByZXR1cm4gY29tcGxldGlvbjtcbn1cbmZ1bmN0aW9uIHRvQ29tcGxldGlvbkl0ZW0oY29tcGxldGlvbikge1xuICAgIGxldCBjb21tYW5kO1xuICAgIGlmIChjb21wbGV0aW9uW1wiY29tbWFuZFwiXSkge1xuICAgICAgICBjb21tYW5kID0ge1xuICAgICAgICAgICAgdGl0bGU6IFwidHJpZ2dlclN1Z2dlc3RcIixcbiAgICAgICAgICAgIGNvbW1hbmQ6IGNvbXBsZXRpb25bXCJjb21tYW5kXCJdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBfY29tcGxldGlvbl9jYXB0aW9uO1xuICAgIGxldCBjb21wbGV0aW9uSXRlbSA9IHtcbiAgICAgICAgbGFiZWw6IChfY29tcGxldGlvbl9jYXB0aW9uID0gY29tcGxldGlvbi5jYXB0aW9uKSAhPT0gbnVsbCAmJiBfY29tcGxldGlvbl9jYXB0aW9uICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9jYXB0aW9uIDogXCJcIixcbiAgICAgICAga2luZDogQ29tbW9uQ29udmVydGVyLmNvbnZlcnRLaW5kKGNvbXBsZXRpb24ubWV0YSksXG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGluc2VydFRleHRGb3JtYXQ6IGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdID8gSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0IDogSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQsXG4gICAgICAgIGRvY3VtZW50YXRpb246IGNvbXBsZXRpb25bXCJkb2N1bWVudGF0aW9uXCJdXG4gICAgfTtcbiAgICBpZiAoY29tcGxldGlvbltcInJhbmdlXCJdKSB7XG4gICAgICAgIHZhciBfY29tcGxldGlvbl9zbmlwcGV0O1xuICAgICAgICBjb21wbGV0aW9uSXRlbS50ZXh0RWRpdCA9IHtcbiAgICAgICAgICAgIHJhbmdlOiBmcm9tUmFuZ2UoY29tcGxldGlvbltcInJhbmdlXCJdKSxcbiAgICAgICAgICAgIG5ld1RleHQ6IChfY29tcGxldGlvbl9zbmlwcGV0ID0gY29tcGxldGlvbltcInNuaXBwZXRcIl0pICE9PSBudWxsICYmIF9jb21wbGV0aW9uX3NuaXBwZXQgIT09IHZvaWQgMCA/IF9jb21wbGV0aW9uX3NuaXBwZXQgOiBjb21wbGV0aW9uW1widmFsdWVcIl1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbXBsZXRpb25fc25pcHBldDE7XG4gICAgICAgIGNvbXBsZXRpb25JdGVtLmluc2VydFRleHQgPSAoX2NvbXBsZXRpb25fc25pcHBldDEgPSBjb21wbGV0aW9uW1wic25pcHBldFwiXSkgIT09IG51bGwgJiYgX2NvbXBsZXRpb25fc25pcHBldDEgIT09IHZvaWQgMCA/IF9jb21wbGV0aW9uX3NuaXBwZXQxIDogY29tcGxldGlvbltcInZhbHVlXCJdO1xuICAgIH1cbiAgICBjb21wbGV0aW9uSXRlbVtcImZpbGVOYW1lXCJdID0gY29tcGxldGlvbltcImZpbGVOYW1lXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wicG9zaXRpb25cIl0gPSBjb21wbGV0aW9uW1wicG9zaXRpb25cIl07XG4gICAgY29tcGxldGlvbkl0ZW1bXCJpdGVtXCJdID0gY29tcGxldGlvbltcIml0ZW1cIl07XG4gICAgY29tcGxldGlvbkl0ZW1bXCJzZXJ2aWNlXCJdID0gY29tcGxldGlvbltcInNlcnZpY2VcIl07IC8vVE9ETzpcbiAgICByZXR1cm4gY29tcGxldGlvbkl0ZW07XG59XG5mdW5jdGlvbiBnZXRUZXh0RWRpdFJhbmdlKHRleHRFZGl0LCBmaWx0ZXJUZXh0KSB7XG4gICAgY29uc3QgZmlsdGVyTGVuZ3RoID0gZmlsdGVyVGV4dCA/IGZpbHRlclRleHQubGVuZ3RoIDogMDtcbiAgICBpZiAoXCJpbnNlcnRcIiBpbiB0ZXh0RWRpdCAmJiBcInJlcGxhY2VcIiBpbiB0ZXh0RWRpdCkge1xuICAgICAgICBsZXQgbWVyZ2VkUmFuZ2VzID0gbWVyZ2VSYW5nZXMoW1xuICAgICAgICAgICAgdG9SYW5nZSh0ZXh0RWRpdC5pbnNlcnQpLFxuICAgICAgICAgICAgdG9SYW5nZSh0ZXh0RWRpdC5yZXBsYWNlKVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZFJhbmdlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0RWRpdC5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLT0gZmlsdGVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gdG9SYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9Ub29sdGlwKGhvdmVyKSB7XG4gICAgdmFyIF9ob3Zlcl9maW5kO1xuICAgIGlmICghaG92ZXIpIHJldHVybjtcbiAgICBsZXQgY29udGVudCA9IGhvdmVyLm1hcCgoZWwpPT57XG4gICAgICAgIGlmICghZWwgfHwgIWVsLmNvbnRlbnRzKSByZXR1cm47XG4gICAgICAgIGlmIChNYXJrdXBDb250ZW50LmlzKGVsLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21NYXJrdXBDb250ZW50KGVsLmNvbnRlbnRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXJrZWRTdHJpbmcuaXMoZWwuY29udGVudHMpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsLmNvbnRlbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiYGBgXCIgKyBlbC5jb250ZW50cy52YWx1ZSArIFwiYGBgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBlbC5jb250ZW50cy5tYXAoKGVsKT0+e1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXGBcXGBcXGAke2VsLnZhbHVlfVxcYFxcYFxcYGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzLmpvaW4oXCJcXG5cXG5cIik7XG4gICAgICAgIH1cbiAgICB9KS5maWx0ZXIobm90RW1wdHkpO1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIC8vVE9ETzogaXQgY291bGQgYmUgbWVyZ2VkIHdpdGhpbiBhbGwgcmFuZ2VzIGluIGZ1dHVyZVxuICAgIGxldCBsc3BSYW5nZSA9IChfaG92ZXJfZmluZCA9IGhvdmVyLmZpbmQoKGVsKT0+e1xuICAgICAgICB2YXIgX2VsO1xuICAgICAgICByZXR1cm4gKF9lbCA9IGVsKSA9PT0gbnVsbCB8fCBfZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbC5yYW5nZTtcbiAgICB9KSkgPT09IG51bGwgfHwgX2hvdmVyX2ZpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ob3Zlcl9maW5kLnJhbmdlO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAobHNwUmFuZ2UpIHJhbmdlID0gdG9SYW5nZShsc3BSYW5nZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrZG93blwiLFxuICAgICAgICAgICAgdGV4dDogY29udGVudC5qb2luKFwiXFxuXFxuXCIpXG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlOiByYW5nZVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tU2lnbmF0dXJlSGVscChzaWduYXR1cmVIZWxwKSB7XG4gICAgaWYgKCFzaWduYXR1cmVIZWxwKSByZXR1cm47XG4gICAgbGV0IGNvbnRlbnQgPSBzaWduYXR1cmVIZWxwLm1hcCgoZWwpPT57XG4gICAgICAgIHZhciBfZWwsIF9lbDE7XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgbGV0IHNpZ25hdHVyZUluZGV4ID0gKChfZWwgPSBlbCkgPT09IG51bGwgfHwgX2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWwuYWN0aXZlU2lnbmF0dXJlKSB8fCAwO1xuICAgICAgICBsZXQgYWN0aXZlU2lnbmF0dXJlID0gZWwuc2lnbmF0dXJlc1tzaWduYXR1cmVJbmRleF07XG4gICAgICAgIGlmICghYWN0aXZlU2lnbmF0dXJlKSByZXR1cm47XG4gICAgICAgIGxldCBhY3RpdmVQYXJhbSA9IChfZWwxID0gZWwpID09PSBudWxsIHx8IF9lbDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbDEuYWN0aXZlUGFyYW1ldGVyO1xuICAgICAgICBsZXQgY29udGVudHMgPSBhY3RpdmVTaWduYXR1cmUubGFiZWw7XG4gICAgICAgIGlmIChhY3RpdmVQYXJhbSAhPSB1bmRlZmluZWQgJiYgYWN0aXZlU2lnbmF0dXJlLnBhcmFtZXRlcnMgJiYgYWN0aXZlU2lnbmF0dXJlLnBhcmFtZXRlcnNbYWN0aXZlUGFyYW1dKSB7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVyc1thY3RpdmVQYXJhbV0ubGFiZWw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnJlcGxhY2UocGFyYW0sIGAqKiR7cGFyYW19KipgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlU2lnbmF0dXJlLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChNYXJrdXBDb250ZW50LmlzKGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50cyArIFwiXFxuXFxuXCIgKyBmcm9tTWFya3VwQ29udGVudChhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzICs9IFwiXFxuXFxuXCIgKyBhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgICAgIH1cbiAgICB9KS5maWx0ZXIobm90RW1wdHkpO1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibWFya2Rvd25cIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQuam9pbihcIlxcblxcblwiKVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21NYXJrdXBDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoIWNvbnRlbnQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbUFjZURlbHRhKGRlbHRhLCBlb2wpIHtcbiAgICBjb25zdCB0ZXh0ID0gZGVsdGEubGluZXMubGVuZ3RoID4gMSA/IGRlbHRhLmxpbmVzLmpvaW4oZW9sKSA6IGRlbHRhLmxpbmVzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlOiBkZWx0YS5hY3Rpb24gPT09IFwiaW5zZXJ0XCIgPyByYW5nZUZyb21Qb3NpdGlvbnMoZnJvbVBvaW50KGRlbHRhLnN0YXJ0KSwgZnJvbVBvaW50KGRlbHRhLnN0YXJ0KSkgOiByYW5nZUZyb21Qb3NpdGlvbnMoZnJvbVBvaW50KGRlbHRhLnN0YXJ0KSwgZnJvbVBvaW50KGRlbHRhLmVuZCkpLFxuICAgICAgICB0ZXh0OiBkZWx0YS5hY3Rpb24gPT09IFwiaW5zZXJ0XCIgPyB0ZXh0IDogXCJcIlxuICAgIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJEaWFnbm9zdGljcyhkaWFnbm9zdGljcywgZmlsdGVyRXJyb3JzKSB7XG4gICAgcmV0dXJuIGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlci5leGNsdWRlQnlFcnJvck1lc3NhZ2UoZGlhZ25vc3RpY3MsIGZpbHRlckVycm9ycy5lcnJvck1lc3NhZ2VzVG9JZ25vcmUpLm1hcCgoZWwpPT57XG4gICAgICAgIGlmICgoMCx1dGlscy8qIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkgKi8uVGspKGVsLm1lc3NhZ2UsIGZpbHRlckVycm9ycy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZykpIHtcbiAgICAgICAgICAgIGVsLnNldmVyaXR5ID0gbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgfSBlbHNlIGlmICgoMCx1dGlscy8qIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkgKi8uVGspKGVsLm1lc3NhZ2UsIGZpbHRlckVycm9ycy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykpIHtcbiAgICAgICAgICAgIGVsLnNldmVyaXR5ID0gbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZnJvbURvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudEhpZ2hsaWdodHMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRIaWdobGlnaHRzLm1hcChmdW5jdGlvbihlbCkge1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gZWwua2luZCA9PSAyID8gXCJsYW5ndWFnZV9oaWdobGlnaHRfcmVhZFwiIDogZWwua2luZCA9PSAzID8gXCJsYW5ndWFnZV9oaWdobGlnaHRfd3JpdGVcIiA6IFwibGFuZ3VhZ2VfaGlnaGxpZ2h0X3RleHRcIjtcbiAgICAgICAgcmV0dXJuIHRvTWFya2VyR3JvdXBJdGVtKENvbW1vbkNvbnZlcnRlci50b1JhbmdlKHRvUmFuZ2UoZWwucmFuZ2UpKSwgY2xhc3NOYW1lKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvTWFya2VyR3JvdXBJdGVtKHJhbmdlLCBjbGFzc05hbWUsIHRvb2x0aXBUZXh0KSB7XG4gICAgbGV0IG1hcmtlckdyb3VwSXRlbSA9IHtcbiAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH07XG4gICAgaWYgKHRvb2x0aXBUZXh0KSB7XG4gICAgICAgIG1hcmtlckdyb3VwSXRlbVtcInRvb2x0aXBUZXh0XCJdID0gdG9vbHRpcFRleHQ7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJHcm91cEl0ZW07XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZXJ2aWNlcy9sdWEvbHVhLXNlcnZpY2UudHNcbmZ1bmN0aW9uIGx1YV9zZXJ2aWNlX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cblxuY2xhc3MgTHVhU2VydmljZSBleHRlbmRzIGJhc2Vfc2VydmljZS5CYXNlU2VydmljZSB7XG4gICAgYXN5bmMgZG9WYWxpZGF0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0RG9jdW1lbnRWYWx1ZShkb2N1bWVudC51cmkpO1xuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gW107XG4gICAgICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuJHNlcnZpY2UucGFyc2UodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHRoaXMuJHNlcnZpY2UuU3ludGF4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubGluZSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyOiBlLmNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubGluZSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyOiBlLmNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5OiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlckRpYWdub3N0aWNzKGVycm9ycywgdGhpcy5vcHRpb25zVG9GaWx0ZXJEaWFnbm9zdGljcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1vZGUpe1xuICAgICAgICBzdXBlcihtb2RlKTtcbiAgICAgICAgbHVhX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiJHNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICAgICAgbHVhX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZUNhcGFiaWxpdGllc1wiLCB7XG4gICAgICAgICAgICBkaWFnbm9zdGljUHJvdmlkZXI6IHtcbiAgICAgICAgICAgICAgICBpbnRlckZpbGVEZXBlbmRlbmNpZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRGlhZ25vc3RpY3M6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJHNlcnZpY2UgPSBsdWFwYXJzZTtcbiAgICB9XG59XG5cbn0pKCk7XG5cbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJhIiwiaSIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwicHJvY2VzcyIsImNvbnNvbGUiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfcmVxdWlyZSIsIl9yZXF1aXJlJGNvZGVzIiwiY29kZXMiLCJFUlJfQU1CSUdVT1VTX0FSR1VNRU5UIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfSU5WQUxJRF9BUkdfVkFMVUUiLCJFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUiLCJFUlJfTUlTU0lOR19BUkdTIiwiQXNzZXJ0aW9uRXJyb3IiLCJfcmVxdWlyZTIiLCJpbnNwZWN0IiwiX3JlcXVpcmUkdHlwZXMiLCJ0eXBlcyIsImlzUHJvbWlzZSIsImlzUmVnRXhwIiwib2JqZWN0QXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwib2JqZWN0SXMiLCJpcyIsImVycm9yQ2FjaGUiLCJNYXAiLCJpc0RlZXBFcXVhbCIsImlzRGVlcFN0cmljdEVxdWFsIiwicGFyc2VFeHByZXNzaW9uQXQiLCJmaW5kTm9kZUFyb3VuZCIsImRlY29kZXIiLCJsYXp5TG9hZENvbXBhcmlzb24iLCJjb21wYXJpc29uIiwiZXNjYXBlU2VxdWVuY2VzUmVnRXhwIiwibWV0YSIsImVzY2FwZUZuIiwic3RyIiwiY2hhckNvZGVBdCIsIndhcm5lZCIsImFzc2VydCIsIm9rIiwiTk9fRVhDRVBUSU9OX1NFTlRJTkVMIiwiaW5uZXJGYWlsIiwibWVzc2FnZSIsIkVycm9yIiwiZmFpbCIsImFjdHVhbCIsImV4cGVjdGVkIiwib3BlcmF0b3IiLCJzdGFja1N0YXJ0Rm4iLCJhcmdzTGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaW50ZXJuYWxNZXNzYWdlIiwidW5kZWZpbmVkIiwid2FybiIsImVtaXRXYXJuaW5nIiwiYmluZCIsImVyckFyZ3MiLCJlcnIiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiaW5uZXJPayIsImZuIiwiYXJnTGVuIiwidmFsdWUiLCJfbGVuIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImFwcGx5IiwiY29uY2F0IiwiZXF1YWwiLCJub3RFcXVhbCIsImRlZXBFcXVhbCIsIm5vdERlZXBFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsIm5vdERlZXBTdHJpY3RFcXVhbCIsInN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJDb21wYXJpc29uIiwia2V5cyIsIl90aGlzIiwiZm9yRWFjaCIsImtleSIsInRlc3QiLCJjb21wYXJlRXhjZXB0aW9uS2V5IiwiYiIsIm5hbWUiLCJleHBlY3RlZEV4Y2VwdGlvbiIsIm1zZyIsInB1c2giLCJpc1Byb3RvdHlwZU9mIiwiY2FsbCIsImdldEFjdHVhbCIsImUiLCJjaGVja0lzUHJvbWlzZSIsInRoZW4iLCJjYXRjaCIsIndhaXRGb3JBY3R1YWwiLCJwcm9taXNlRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdFByb21pc2UiLCJleHBlY3RzRXJyb3IiLCJlcnJvciIsImRldGFpbHMiLCJmblR5cGUiLCJleHBlY3RzTm9FcnJvciIsInRocm93cyIsIl9sZW4yIiwiX2tleTIiLCJyZWplY3RzIiwiX2xlbjMiLCJfa2V5MyIsInJlc3VsdCIsImRvZXNOb3RUaHJvdyIsIl9sZW40IiwiX2tleTQiLCJkb2VzTm90UmVqZWN0IiwiX2xlbjUiLCJfa2V5NSIsImlmRXJyb3IiLCJuZXdFcnIiLCJvcmlnU3RhY2siLCJzdGFjayIsInRtcDIiLCJzcGxpdCIsInNoaWZ0IiwidG1wMSIsInBvcyIsImluZGV4T2YiLCJzbGljZSIsImpvaW4iLCJzdHJpY3QiLCJfbGVuNiIsIl9rZXk2IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsInNvdXJjZSIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX2RlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwiX3dyYXBOYXRpdmVTdXBlciIsIkNsYXNzIiwiX2NhY2hlIiwiX2lzTmF0aXZlRnVuY3Rpb24iLCJoYXMiLCJnZXQiLCJzZXQiLCJXcmFwcGVyIiwiX2NvbnN0cnVjdCIsIl9nZXRQcm90b3R5cGVPZiIsImlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJEYXRlIiwidG9TdHJpbmciLCJQYXJlbnQiLCJGdW5jdGlvbiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJnZXRQcm90b3R5cGVPZiIsImVuZHNXaXRoIiwic2VhcmNoIiwidGhpc19sZW4iLCJzdWJzdHJpbmciLCJyZXBlYXQiLCJjb3VudCIsIk1hdGgiLCJmbG9vciIsIm1heENvdW50IiwibG9nIiwiYmx1ZSIsImdyZWVuIiwicmVkIiwid2hpdGUiLCJrUmVhZGFibGVPcGVyYXRvciIsInN0cmljdEVxdWFsT2JqZWN0Iiwibm90U3RyaWN0RXF1YWxPYmplY3QiLCJub3RJZGVudGljYWwiLCJrTWF4U2hvcnRMZW5ndGgiLCJjb3B5RXJyb3IiLCJpbnNwZWN0VmFsdWUiLCJ2YWwiLCJjb21wYWN0IiwiY3VzdG9tSW5zcGVjdCIsImRlcHRoIiwibWF4QXJyYXlMZW5ndGgiLCJJbmZpbml0eSIsInNob3dIaWRkZW4iLCJicmVha0xlbmd0aCIsInNob3dQcm94eSIsInNvcnRlZCIsImdldHRlcnMiLCJjcmVhdGVFcnJEaWZmIiwib3RoZXIiLCJyZXMiLCJsYXN0UG9zIiwiZW5kIiwic2tpcHBlZCIsImFjdHVhbEluc3BlY3RlZCIsImFjdHVhbExpbmVzIiwiZXhwZWN0ZWRMaW5lcyIsImluZGljYXRvciIsImlucHV0TGVuZ3RoIiwibWF4TGVuZ3RoIiwic3RkZXJyIiwiaXNUVFkiLCJjb2x1bW5zIiwicG9wIiwibWF4TGluZXMiLCJtYXgiLCJfYWN0dWFsTGluZXMiLCJwcmludGVkTGluZXMiLCJza2lwcGVkTXNnIiwiY3VyIiwiZXhwZWN0ZWRMaW5lIiwiYWN0dWFsTGluZSIsImRpdmVyZ2luZ0xpbmVzIiwiX0Vycm9yIiwib3B0aW9ucyIsImxpbWl0Iiwic3RhY2tUcmFjZUxpbWl0IiwiU3RyaW5nIiwiZ2V0Q29sb3JEZXB0aCIsImJhc2UiLCJfcmVzIiwia25vd25PcGVyYXRvcnMiLCJjb2RlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjdXN0b20iLCJyZWN1cnNlVGltZXMiLCJjdHgiLCJ1dGlsIiwiY3JlYXRlRXJyb3JUeXBlIiwiQmFzZSIsImdldE1lc3NhZ2UiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJOb2RlRXJyb3IiLCJfQmFzZSIsIm9uZU9mIiwidGhpbmciLCJpc0FycmF5IiwibGVuIiwibWFwIiwic3RhcnRzV2l0aCIsInN1YnN0ciIsImluY2x1ZGVzIiwic3RhcnQiLCJkZXRlcm1pbmVyIiwicmVwbGFjZSIsInR5cGUiLCJyZWFzb24iLCJpbnNwZWN0ZWQiLCJSYW5nZUVycm9yIiwiaW5wdXQiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9ub25JdGVyYWJsZVJlc3QiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwicmVnZXhGbGFnc1N1cHBvcnRlZCIsImZsYWdzIiwiYXJyYXlGcm9tU2V0IiwiYXJyYXkiLCJhcnJheUZyb21NYXAiLCJvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJudW1iZXJJc05hTiIsIk51bWJlciIsImlzTmFOIiwidW5jdXJyeVRoaXMiLCJmIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm9iamVjdFRvU3RyaW5nIiwiaXNBbnlBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiaXNEYXRlIiwiaXNNYXAiLCJpc1NldCIsImlzTmF0aXZlRXJyb3IiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNOb25JbmRleCIsInBvdyIsImdldE93bk5vbkluZGV4UHJvcGVydGllcyIsImNvbXBhcmUiLCJ4IiwieSIsIm1pbiIsIk9OTFlfRU5VTUVSQUJMRSIsImtTdHJpY3QiLCJrTG9vc2UiLCJrTm9JdGVyYXRvciIsImtJc0FycmF5Iiwia0lzU2V0Iiwia0lzTWFwIiwiYXJlU2ltaWxhclJlZ0V4cHMiLCJSZWdFeHAiLCJhcmVTaW1pbGFyRmxvYXRBcnJheXMiLCJieXRlTGVuZ3RoIiwib2Zmc2V0IiwiYXJlU2ltaWxhclR5cGVkQXJyYXlzIiwiVWludDhBcnJheSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJhcmVFcXVhbEFycmF5QnVmZmVycyIsImJ1ZjEiLCJidWYyIiwiaXNFcXVhbEJveGVkUHJpbWl0aXZlIiwidmFsMSIsInZhbDIiLCJ2YWx1ZU9mIiwiQm9vbGVhbiIsIkJpZ0ludCIsImlubmVyRGVlcEVxdWFsIiwibWVtb3MiLCJ2YWwxVGFnIiwidmFsMlRhZyIsImtleXMxIiwia2V5czIiLCJrZXlDaGVjayIsImdldFRpbWUiLCJfa2V5cyIsIl9rZXlzMiIsInNpemUiLCJnZXRFbnVtZXJhYmxlcyIsImsiLCJpdGVyYXRpb25UeXBlIiwiYUtleXMiLCJiS2V5cyIsInN5bWJvbEtleXNBIiwic3ltYm9sS2V5c0IiLCJfc3ltYm9sS2V5c0IiLCJwb3NpdGlvbiIsInZhbDJNZW1vQSIsInZhbDJNZW1vQiIsImFyZUVxIiwib2JqRXF1aXYiLCJkZWxldGUiLCJzZXRIYXNFcXVhbEVsZW1lbnQiLCJtZW1vIiwic2V0VmFsdWVzIiwiZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzIiwicHJpbSIsInNldE1pZ2h0SGF2ZUxvb3NlUHJpbSIsImFsdFZhbHVlIiwibWFwTWlnaHRIYXZlTG9vc2VQcmltIiwiaXRlbSIsImN1ckIiLCJzZXRFcXVpdiIsImFWYWx1ZXMiLCJTZXQiLCJhZGQiLCJiVmFsdWVzIiwiX3ZhbCIsIm1hcEhhc0VxdWFsRW50cnkiLCJrZXkxIiwiaXRlbTEiLCJrZXkyIiwibWFwRXF1aXYiLCJhRW50cmllcyIsIl9hRW50cmllcyRpIiwiaXRlbTIiLCJiRW50cmllcyIsIl9pMiIsIl9iRW50cmllcyRfaSIsImtleXNBIiwiR2V0SW50cmluc2ljIiwiY2FsbEJpbmQiLCIkaW5kZXhPZiIsImNhbGxCb3VuZEludHJpbnNpYyIsImFsbG93TWlzc2luZyIsImludHJpbnNpYyIsInNldEZ1bmN0aW9uTGVuZ3RoIiwiJFR5cGVFcnJvciIsIiRhcHBseSIsIiRjYWxsIiwiJHJlZmxlY3RBcHBseSIsIiRkZWZpbmVQcm9wZXJ0eSIsIiRtYXgiLCJvcmlnaW5hbEZ1bmN0aW9uIiwiZnVuYyIsImFwcGx5QmluZCIsIm5vdyIsInRpbWVzIiwiZyIsIndpbmRvdyIsImZ1bmN0aW9ucyIsImluZm8iLCJ0aW1lIiwidGltZUVuZCIsInRyYWNlIiwiZGlyIiwiY29uc29sZUFzc2VydCIsInR1cGxlIiwibGFiZWwiLCJkdXJhdGlvbiIsImZvcm1hdCIsIm9iamVjdCIsImV4cHJlc3Npb24iLCIkU3ludGF4RXJyb3IiLCJnb3BkIiwiZGVmaW5lRGF0YVByb3BlcnR5IiwicHJvcGVydHkiLCJub25FbnVtZXJhYmxlIiwibm9uV3JpdGFibGUiLCJub25Db25maWd1cmFibGUiLCJsb29zZSIsImRlc2MiLCJoYXNTeW1ib2xzIiwidG9TdHIiLCJvcmlnRGVmaW5lUHJvcGVydHkiLCJpc0Z1bmN0aW9uIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9ycyIsInN1cHBvcnRzRGVzY3JpcHRvcnMiLCJwcmVkaWNhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJlZGljYXRlcyIsIkV2YWxFcnJvciIsIlN5bnRheEVycm9yIiwiVVJJRXJyb3IiLCJmaXJzdFNvdXJjZSIsInRvIiwibmV4dFNvdXJjZSIsImtleXNBcnJheSIsIm5leHRJbmRleCIsIm5leHRLZXkiLCJwb2x5ZmlsbCIsImlzQ2FsbGFibGUiLCJmb3JFYWNoQXJyYXkiLCJyZWNlaXZlciIsImZvckVhY2hTdHJpbmciLCJzdHJpbmciLCJjaGFyQXQiLCJmb3JFYWNoT2JqZWN0IiwibGlzdCIsInRoaXNBcmciLCJFUlJPUl9NRVNTQUdFIiwiZnVuY1R5cGUiLCJjb25jYXR0eSIsImoiLCJzbGljeSIsImFyckxpa2UiLCJqb2lueSIsImpvaW5lciIsInRoYXQiLCJib3VuZCIsImJpbmRlciIsImJvdW5kTGVuZ3RoIiwiYm91bmRBcmdzIiwiRW1wdHkiLCJpbXBsZW1lbnRhdGlvbiIsIiRFcnJvciIsIiRFdmFsRXJyb3IiLCIkUmFuZ2VFcnJvciIsIiRSZWZlcmVuY2VFcnJvciIsIiRVUklFcnJvciIsIiRGdW5jdGlvbiIsImdldEV2YWxsZWRDb25zdHJ1Y3RvciIsImV4cHJlc3Npb25TeW50YXgiLCIkZ09QRCIsInRocm93VHlwZUVycm9yIiwiVGhyb3dUeXBlRXJyb3IiLCJjYWxsZWUiLCJjYWxsZWVUaHJvd3MiLCJnT1BEdGhyb3dzIiwiaGFzUHJvdG8iLCJnZXRQcm90byIsIm5lZWRzRXZhbCIsIlR5cGVkQXJyYXkiLCJJTlRSSU5TSUNTIiwiQWdncmVnYXRlRXJyb3IiLCJBcnJheUJ1ZmZlciIsIkF0b21pY3MiLCJCaWdJbnQ2NEFycmF5IiwiQmlnVWludDY0QXJyYXkiLCJEYXRhVmlldyIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsImV2YWwiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiaXNGaW5pdGUiLCJKU09OIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJXZWFrTWFwIiwiV2Vha1JlZiIsIldlYWtTZXQiLCJlcnJvclByb3RvIiwiZG9FdmFsIiwiZ2VuIiwiTEVHQUNZX0FMSUFTRVMiLCJoYXNPd24iLCIkY29uY2F0IiwiJHNwbGljZUFwcGx5Iiwic3BsaWNlIiwiJHJlcGxhY2UiLCIkc3RyU2xpY2UiLCIkZXhlYyIsImV4ZWMiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwic3RyaW5nVG9QYXRoIiwiZmlyc3QiLCJsYXN0IiwibWF0Y2giLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImdldEJhc2VJbnRyaW5zaWMiLCJpbnRyaW5zaWNOYW1lIiwiYWxpYXMiLCJwYXJ0cyIsImludHJpbnNpY0Jhc2VOYW1lIiwiaW50cmluc2ljUmVhbE5hbWUiLCJza2lwRnVydGhlckNhY2hpbmciLCJpc093biIsInBhcnQiLCJoYXNBcnJheUxlbmd0aERlZmluZUJ1ZyIsImZvbyIsIiRPYmplY3QiLCJvcmlnU3ltYm9sIiwiaGFzU3ltYm9sU2hhbSIsImhhc05hdGl2ZVN5bWJvbHMiLCJzeW1PYmoiLCJzeW1WYWwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic3ltcyIsImhhc1RvU3RyaW5nVGFnU2hhbXMiLCJ0b1N0cmluZ1RhZyIsIiRoYXNPd24iLCJpbmhlcml0cyIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJUZW1wQ3RvciIsImhhc1RvU3RyaW5nVGFnIiwiY2FsbEJvdW5kIiwiJHRvU3RyaW5nIiwiaXNTdGFuZGFyZEFyZ3VtZW50cyIsImlzQXJndW1lbnRzIiwiaXNMZWdhY3lBcmd1bWVudHMiLCJzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzIiwiZm5Ub1N0ciIsInJlZmxlY3RBcHBseSIsImJhZEFycmF5TGlrZSIsImlzQ2FsbGFibGVNYXJrZXIiLCJfIiwiY29uc3RydWN0b3JSZWdleCIsImlzRVM2Q2xhc3NGbiIsImlzRVM2Q2xhc3NGdW5jdGlvbiIsImZuU3RyIiwidHJ5RnVuY3Rpb25PYmplY3QiLCJ0cnlGdW5jdGlvblRvU3RyIiwib2JqZWN0Q2xhc3MiLCJmbkNsYXNzIiwiZ2VuQ2xhc3MiLCJkZGFDbGFzcyIsImRkYUNsYXNzMiIsImRkYUNsYXNzMyIsImlzSUU2OCIsImlzRERBIiwiaXNEb2N1bWVudERvdEFsbCIsImRvY3VtZW50IiwiYWxsIiwic3RyQ2xhc3MiLCJpc0ZuUmVnZXgiLCJnZXRHZW5lcmF0b3JGdW5jIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuZXJhdG9yRnVuYyIsImdldFBvbHlmaWxsIiwic2hpbSIsIk5hTiIsInNoaW1OdW1iZXJJc05hTiIsInRlc3RJc05hTiIsIndoaWNoVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsIm5tZCIsIl9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyIsIl9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18iLCJfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyIsIm9iamVjdFR5cGVzIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwibW9kdWxlRXhwb3J0cyIsImdsb2JhbCIsInZlcnNpb24iLCJmZWF0dXJlcyIsImVuY29kaW5nTW9kZSIsImRlZmF1bHRPcHRpb25zIiwid2FpdCIsImNvbW1lbnRzIiwic2NvcGUiLCJsb2NhdGlvbnMiLCJyYW5nZXMiLCJvbkNyZWF0ZU5vZGUiLCJvbkNyZWF0ZVNjb3BlIiwib25EZXN0cm95U2NvcGUiLCJvbkxvY2FsRGVjbGFyYXRpb24iLCJsdWFWZXJzaW9uIiwiZW5jb2RlVVRGOCIsImNvZGVwb2ludCIsImhpZ2hNYXNrIiwiZnJvbUNoYXJDb2RlIiwidG9IZXgiLCJudW0iLCJkaWdpdHMiLCJjaGVja0NoYXJzIiwicngiLCJzIiwibSIsInJhaXNlIiwiZXJyb3JzIiwiaW52YWxpZENvZGVVbml0IiwidG9VcHBlckNhc2UiLCJlbmNvZGluZ01vZGVzIiwiZml4dXAiLCJlbmNvZGVCeXRlIiwiZGlzY2FyZFN0cmluZ3MiLCJFT0YiLCJTdHJpbmdMaXRlcmFsIiwiS2V5d29yZCIsIklkZW50aWZpZXIiLCJOdW1lcmljTGl0ZXJhbCIsIlB1bmN0dWF0b3IiLCJCb29sZWFuTGl0ZXJhbCIsIk5pbExpdGVyYWwiLCJWYXJhcmdMaXRlcmFsIiwidG9rZW5UeXBlcyIsInVuZXhwZWN0ZWQiLCJ1bmV4cGVjdGVkRU9GIiwiZXhwZWN0ZWRUb2tlbiIsInVuZmluaXNoZWRTdHJpbmciLCJtYWxmb3JtZWROdW1iZXIiLCJkZWNpbWFsRXNjYXBlVG9vTGFyZ2UiLCJpbnZhbGlkRXNjYXBlIiwiaGV4YWRlY2ltYWxEaWdpdEV4cGVjdGVkIiwiYnJhY2VFeHBlY3RlZCIsInRvb0xhcmdlQ29kZXBvaW50IiwidW5maW5pc2hlZExvbmdTdHJpbmciLCJ1bmZpbmlzaGVkTG9uZ0NvbW1lbnQiLCJhbWJpZ3VvdXNTeW50YXgiLCJub0xvb3BUb0JyZWFrIiwibGFiZWxBbHJlYWR5RGVmaW5lZCIsImxhYmVsTm90VmlzaWJsZSIsImdvdG9KdW1wSW5Mb2NhbFNjb3BlIiwiY2Fubm90VXNlVmFyYXJnIiwiYXN0IiwibGFiZWxTdGF0ZW1lbnQiLCJicmVha1N0YXRlbWVudCIsImdvdG9TdGF0ZW1lbnQiLCJyZXR1cm5TdGF0ZW1lbnQiLCJpZlN0YXRlbWVudCIsImNsYXVzZXMiLCJpZkNsYXVzZSIsImNvbmRpdGlvbiIsImJvZHkiLCJlbHNlaWZDbGF1c2UiLCJlbHNlQ2xhdXNlIiwid2hpbGVTdGF0ZW1lbnQiLCJkb1N0YXRlbWVudCIsInJlcGVhdFN0YXRlbWVudCIsImxvY2FsU3RhdGVtZW50IiwidmFyaWFibGVzIiwiaW5pdCIsImFzc2lnbm1lbnRTdGF0ZW1lbnQiLCJjYWxsU3RhdGVtZW50IiwiZnVuY3Rpb25TdGF0ZW1lbnQiLCJpZGVudGlmaWVyIiwicGFyYW1ldGVycyIsImlzTG9jYWwiLCJmb3JOdW1lcmljU3RhdGVtZW50IiwidmFyaWFibGUiLCJzdGVwIiwiZm9yR2VuZXJpY1N0YXRlbWVudCIsIml0ZXJhdG9ycyIsImNodW5rIiwibGl0ZXJhbCIsInJhdyIsInRhYmxlS2V5IiwidGFibGVLZXlTdHJpbmciLCJ0YWJsZVZhbHVlIiwidGFibGVDb25zdHJ1Y3RvckV4cHJlc3Npb24iLCJmaWVsZHMiLCJiaW5hcnlFeHByZXNzaW9uIiwibGVmdCIsInJpZ2h0IiwidW5hcnlFeHByZXNzaW9uIiwiYXJndW1lbnQiLCJtZW1iZXJFeHByZXNzaW9uIiwiaW5kZXhlciIsImluZGV4RXhwcmVzc2lvbiIsImluZGV4IiwiY2FsbEV4cHJlc3Npb24iLCJ0YWJsZUNhbGxFeHByZXNzaW9uIiwic3RyaW5nQ2FsbEV4cHJlc3Npb24iLCJjb21tZW50IiwiZmluaXNoTm9kZSIsIm5vZGUiLCJ0cmFja0xvY2F0aW9ucyIsImxvY2F0aW9uIiwiY29tcGxldGUiLCJibGVzcyIsImVsZW1lbnQiLCJpbmRleE9mT2JqZWN0Iiwic3ByaW50ZiIsImRlc3QiLCJzcmMiLCJwcm9wIiwiZml4dXBFcnJvciIsImxpbmUiLCJjb2x1bW4iLCJ0b2tlbiIsImNvbCIsImxpbmVTdGFydCIsInJhbmdlIiwidG9rZW5WYWx1ZSIsInJhaXNlVW5leHBlY3RlZFRva2VuIiwiZm91bmQiLCJuZWFyIiwibG9va2FoZWFkIiwicHJldmlvdXNUb2tlbiIsInRva2VuU3RhcnQiLCJsZXgiLCJza2lwV2hpdGVTcGFjZSIsInNjYW5Db21tZW50IiwiY2hhckNvZGUiLCJpc0lkZW50aWZpZXJTdGFydCIsInNjYW5JZGVudGlmaWVyT3JLZXl3b3JkIiwic2NhblN0cmluZ0xpdGVyYWwiLCJzY2FuTnVtZXJpY0xpdGVyYWwiLCJpc0RlY0RpZ2l0Iiwic2NhblZhcmFyZ0xpdGVyYWwiLCJzY2FuUHVuY3R1YXRvciIsImJpdHdpc2VPcGVyYXRvcnMiLCJsYWJlbHMiLCJzY2FuTG9uZ1N0cmluZ0xpdGVyYWwiLCJpbnRlZ2VyRGl2aXNpb24iLCJjb25zdW1lRU9MIiwicGVla0NoYXJDb2RlIiwiaXNMaW5lVGVybWluYXRvciIsImlzV2hpdGVTcGFjZSIsImlzSWRlbnRpZmllclBhcnQiLCJpc0tleXdvcmQiLCJkZWxpbWl0ZXIiLCJiZWdpbkxpbmUiLCJiZWdpbkxpbmVTdGFydCIsInN0cmluZ1N0YXJ0IiwiYmVmb3JlRXNjYXBlIiwiZXNjYXBlVmFsdWUiLCJyZWFkRXNjYXBlU2VxdWVuY2UiLCJsYXN0TGluZSIsImxhc3RMaW5lU3RhcnQiLCJyZWFkTG9uZ1N0cmluZyIsImNoYXJhY3RlciIsInJlYWRIZXhMaXRlcmFsIiwicmVhZERlY0xpdGVyYWwiLCJmb3VuZEltYWdpbmFyeVVuaXQiLCJyZWFkSW1hZ2luYXJ5VW5pdFN1ZmZpeCIsImZvdW5kSW50NjRTdWZmaXgiLCJyZWFkSW50NjRTdWZmaXgiLCJoYXNGcmFjdGlvblBhcnQiLCJpbWFnaW5hcnlOdW1iZXJzIiwiaW50ZWdlclN1ZmZpeGVzIiwiZnJhY3Rpb24iLCJiaW5hcnlFeHBvbmVudCIsImJpbmFyeVNpZ24iLCJkaWdpdCIsImZyYWN0aW9uU3RhcnQiLCJleHBvbmVudFN0YXJ0IiwiZGlnaXRTdGFydCIsImlzSGV4RGlnaXQiLCJmb3VuZEZyYWN0aW9uIiwiZm91bmRCaW5hcnlFeHBvbmVudCIsImZvdW5kRXhwb25lbnQiLCJyZWFkVW5pY29kZUVzY2FwZVNlcXVlbmNlIiwic2VxdWVuY2VTdGFydCIsImVzY1N0YXJ0IiwiZnJhZyIsImRkZCIsInNraXBXaGl0ZXNwYWNlRXNjYXBlIiwiaGV4RXNjYXBlcyIsInVuaWNvZGVFc2NhcGVzIiwic3RyaWN0RXNjYXBlcyIsImNvbnRlbnQiLCJpc0xvbmciLCJjb21tZW50U3RhcnQiLCJsaW5lU3RhcnRDb21tZW50IiwibGluZUNvbW1lbnQiLCJsb2MiLCJpc0NvbW1lbnQiLCJsZXZlbCIsInRlcm1pbmF0b3IiLCJmaXJzdExpbmUiLCJjb25zdW1lIiwiZXhwZWN0IiwiZXh0ZW5kZWRJZGVudGlmaWVycyIsImlkIiwiY29udGV4dHVhbEdvdG8iLCJpc1VuYXJ5IiwiaXNCbG9ja0ZvbGxvdyIsInNjb3BlcyIsInNjb3BlRGVwdGgiLCJnbG9iYWxzIiwiY3JlYXRlU2NvcGUiLCJkZXN0cm95U2NvcGUiLCJzY29wZUlkZW50aWZpZXJOYW1lIiwic2NvcGVJZGVudGlmaWVyIiwiYXR0YWNoU2NvcGUiLCJzY29wZUhhc05hbWUiLCJjcmVhdGVMb2NhdGlvbk1hcmtlciIsIk1hcmtlciIsIm1hcmtMb2NhdGlvbiIsInB1c2hMb2NhdGlvbiIsIm1hcmtlciIsIkZ1bGxGbG93Q29udGV4dCIsInBlbmRpbmdHb3RvcyIsImlzSW5Mb29wIiwiaXNMb29wIiwicHVzaFNjb3BlIiwibG9jYWxzIiwiZGVmZXJyZWRHb3RvcyIsInBvcFNjb3BlIiwidGhlR290byIsIm1heERlcHRoIiwiYWRkR290byIsImxvY2FsQ291bnRzIiwiYWRkTGFiZWwiLCJjdXJyZW50U2NvcGUiLCJuZXdHb3RvcyIsImxvY2FsQ291bnQiLCJhZGRMb2NhbCIsInJhaXNlRGVmZXJyZWRFcnJvcnMiLCJiYWRzIiwiTG9vcEZsb3dDb250ZXh0IiwibG9vcExldmVscyIsImxldmVscyIsImxldmxlbiIsIm1ha2VGbG93Q29udGV4dCIsInBhcnNlQ2h1bmsiLCJmbG93Q29udGV4dCIsImFsbG93VmFyYXJnIiwicGFyc2VCbG9jayIsImJsb2NrIiwic3RhdGVtZW50IiwicmVsYXhlZEJyZWFrIiwicGFyc2VTdGF0ZW1lbnQiLCJwYXJzZUxhYmVsU3RhdGVtZW50IiwiZW1wdHlTdGF0ZW1lbnQiLCJwYXJzZUxvY2FsU3RhdGVtZW50IiwicGFyc2VJZlN0YXRlbWVudCIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwicGFyc2VGdW5jdGlvbk5hbWUiLCJwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24iLCJwYXJzZVdoaWxlU3RhdGVtZW50IiwicGFyc2VGb3JTdGF0ZW1lbnQiLCJwYXJzZVJlcGVhdFN0YXRlbWVudCIsInBhcnNlQnJlYWtTdGF0ZW1lbnQiLCJwYXJzZURvU3RhdGVtZW50IiwicGFyc2VHb3RvU3RhdGVtZW50IiwicGFyc2VBc3NpZ25tZW50T3JDYWxsU3RhdGVtZW50IiwibmFtZVRva2VuIiwicGFyc2VJZGVudGlmaWVyIiwiZ290b1Rva2VuIiwicGFyc2VFeHBlY3RlZEV4cHJlc3Npb24iLCJleHByZXNzaW9ucyIsInBhcnNlRXhwcmVzc2lvbiIsImRlY2xUb2tlbiIsImwiLCJwcmV2aW91cyIsInN0YXJ0TWFya2VyIiwibHZhbHVlIiwidGFyZ2V0cyIsImJvdGgiLCJuZXdCYXNlIiwicGFyc2VQcmVmaXhFeHByZXNzaW9uUGFydCIsInZhbHVlcyIsInBhcmFtZXRlciIsInBhcnNlUHJpbWFyeUV4cHJlc3Npb24iLCJwYXJzZVRhYmxlQ29uc3RydWN0b3IiLCJwYXJzZVN1YkV4cHJlc3Npb24iLCJiaW5hcnlQcmVjZWRlbmNlIiwibWluUHJlY2VkZW5jZSIsInBhcnNlUHJlZml4RXhwcmVzc2lvbiIsInByZWNlZGVuY2UiLCJwYXJzZUNhbGxFeHByZXNzaW9uIiwidGFibGUiLCJsaXRlcmFscyIsInBhcnNlIiwidmVyc2lvbkZlYXR1cmVzIiwiX2lucHV0IiwiX29wdGlvbnMiLCJ3cml0ZSIsInNoaW1PYmplY3RJcyIsInRlc3RPYmplY3RJcyIsImtleXNTaGltIiwiaXNBcmdzIiwiaXNFbnVtZXJhYmxlIiwiaGFzRG9udEVudW1CdWciLCJoYXNQcm90b0VudW1CdWciLCJkb250RW51bXMiLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSIsImV4Y2x1ZGVkS2V5cyIsIiRhcHBsaWNhdGlvbkNhY2hlIiwiJGNvbnNvbGUiLCIkZXh0ZXJuYWwiLCIkZnJhbWUiLCIkZnJhbWVFbGVtZW50IiwiJGZyYW1lcyIsIiRpbm5lckhlaWdodCIsIiRpbm5lcldpZHRoIiwiJG9ubW96ZnVsbHNjcmVlbmNoYW5nZSIsIiRvbm1vemZ1bGxzY3JlZW5lcnJvciIsIiRvdXRlckhlaWdodCIsIiRvdXRlcldpZHRoIiwiJHBhZ2VYT2Zmc2V0IiwiJHBhZ2VZT2Zmc2V0IiwiJHBhcmVudCIsIiRzY3JvbGxMZWZ0IiwiJHNjcm9sbFRvcCIsIiRzY3JvbGxYIiwiJHNjcm9sbFkiLCIkc2VsZiIsIiR3ZWJraXRJbmRleGVkREIiLCIkd2Via2l0U3RvcmFnZUluZm8iLCIkd2luZG93IiwiaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnIiwiZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5IiwiaXNPYmplY3QiLCJpc1N0cmluZyIsInRoZUtleXMiLCJza2lwUHJvdG8iLCJza2lwQ29uc3RydWN0b3IiLCJvcmlnS2V5cyIsIm9yaWdpbmFsS2V5cyIsInNoaW1PYmplY3RLZXlzIiwia2V5c1dvcmtzV2l0aEFyZ3VtZW50cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIm5leHRUaWNrIiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsImhhc0Rlc2NyaXB0b3JzIiwiZ09QRCIsIiRmbG9vciIsImZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUiLCJmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUiLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJkIiwiQmFzZVNlcnZpY2UiLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJuIiwiX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJfZGVmaW5lX3Byb3BlcnR5IiwiYWRkRG9jdW1lbnQiLCJkb2N1bWVudHMiLCJ1cmkiLCJWIiwibGFuZ3VhZ2VJZCIsInRleHQiLCJnZXREb2N1bWVudCIsInJlbW92ZURvY3VtZW50IiwicmVuYW1lRG9jdW1lbnQiLCJuZXdEb2N1bWVudFVyaSIsImdldERvY3VtZW50VmFsdWUiLCJfdGhpc19nZXREb2N1bWVudCIsImdldFRleHQiLCJzZXRWYWx1ZSIsInNldEdsb2JhbE9wdGlvbnMiLCJnbG9iYWxPcHRpb25zIiwic2V0V29ya3NwYWNlIiwid29ya3NwYWNlVXJpIiwic2V0T3B0aW9ucyIsImRvY3VtZW50VXJpIiwibWVyZ2UiLCJyTCIsImdldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJhcHBseURlbHRhcyIsImRlbHRhcyIsInVwZGF0ZSIsImRvQ29tcGxldGUiLCJkb0hvdmVyIiwiZG9SZXNvbHZlIiwiZG9WYWxpZGF0aW9uIiwicHJvdmlkZVNpZ25hdHVyZUhlbHAiLCJmaW5kRG9jdW1lbnRIaWdobGlnaHRzIiwib3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MiLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmciLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUiLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyIsImVycm9yQ29kZXNUb0lnbm9yZSIsImVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIiwiZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8iLCJlcnJvck1lc3NhZ2VzVG9JZ25vcmUiLCJlcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyIsImVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvIiwiZ2V0U2VtYW50aWNUb2tlbnMiLCJkaXNwb3NlIiwiY2xvc2VDb25uZWN0aW9uIiwiZ2V0Q29kZUFjdGlvbnMiLCJjb250ZXh0IiwiZXhlY3V0ZUNvbW1hbmQiLCJjb21tYW5kIiwic2VuZEFwcGxpZWRSZXN1bHQiLCJjYWxsYmFja0lkIiwibW9kZSIsInRleHREb2N1bWVudCIsImRpYWdub3N0aWMiLCJkeW5hbWljUmVnaXN0cmF0aW9uIiwicmVsYXRlZERvY3VtZW50U3VwcG9ydCIsInB1Ymxpc2hEaWFnbm9zdGljcyIsInJlbGF0ZWRJbmZvcm1hdGlvbiIsInZlcnNpb25TdXBwb3J0IiwidGFnU3VwcG9ydCIsInZhbHVlU2V0IiwiRGlhZ25vc3RpY1RhZyIsIlVubmVjZXNzYXJ5IiwiRGVwcmVjYXRlZCIsImhvdmVyIiwiY29udGVudEZvcm1hdCIsInN5bmNocm9uaXphdGlvbiIsIndpbGxTYXZlIiwiZGlkU2F2ZSIsIndpbGxTYXZlV2FpdFVudGlsIiwiZm9ybWF0dGluZyIsImNvbXBsZXRpb24iLCJjb21wbGV0aW9uSXRlbSIsInNuaXBwZXRTdXBwb3J0IiwiY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQiLCJkb2N1bWVudGF0aW9uRm9ybWF0IiwiZGVwcmVjYXRlZFN1cHBvcnQiLCJwcmVzZWxlY3RTdXBwb3J0IiwiY29udGV4dFN1cHBvcnQiLCJzaWduYXR1cmVIZWxwIiwic2lnbmF0dXJlSW5mb3JtYXRpb24iLCJhY3RpdmVQYXJhbWV0ZXJTdXBwb3J0IiwiZG9jdW1lbnRIaWdobGlnaHQiLCJzZW1hbnRpY1Rva2VucyIsIm11bHRpbGluZVRva2VuU3VwcG9ydCIsIm92ZXJsYXBwaW5nVG9rZW5TdXBwb3J0IiwidG9rZW5Nb2RpZmllcnMiLCJmb3JtYXRzIiwicmVxdWVzdHMiLCJmdWxsIiwiZGVsdGEiLCJhdWdtZW50c1N5bnRheFRva2VucyIsImNvZGVBY3Rpb24iLCJ3b3Jrc3BhY2UiLCJkaWRDaGFuZ2VDb25maWd1cmF0aW9uIiwiYXBwbHlFZGl0Iiwid29ya3NwYWNlRWRpdCIsImZhaWx1cmVIYW5kbGluZyIsIm5vcm1hbGl6ZXNMaW5lRW5kaW5ncyIsImRvY3VtZW50Q2hhbmdlcyIsIlRrIiwiY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSIsIm1lcmdlT2JqZWN0cyIsIm9iajEiLCJvYmoyIiwiZXhjbHVkZVVuZGVmaW5lZCIsImV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMiLCJtZXJnZWRPYmplY3RzIiwiZmlsdGVyZWRFbnRyaWVzIiwiZW50cmllcyIsImZyb21FbnRyaWVzIiwibm90RW1wdHkiLCJtZXJnZVJhbmdlcyIsInNvcnQiLCJjb21wYXJlUG9pbnRzIiwiY21wIiwiaXNFbXB0eSIsInJvdyIsInAxIiwicDIiLCJyZWdleHBBcnJheSIsImNvbnZlcnRUb1VyaSIsImZpbGVQYXRoIiwiVVJJIiwiZmlsZSIsImlzQnVmZmVyIiwiYXJnIiwiY29weSIsImZpbGwiLCJyZWFkVUludDgiLCJpc0FyZ3VtZW50c09iamVjdCIsIkJpZ0ludFN1cHBvcnRlZCIsIlN5bWJvbFN1cHBvcnRlZCIsIk9iamVjdFRvU3RyaW5nIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xlYW5WYWx1ZSIsImJpZ0ludFZhbHVlIiwic3ltYm9sVmFsdWUiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwicHJvdG90eXBlVmFsdWVPZiIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc01hcFRvU3RyaW5nIiwid29ya2luZyIsImlzU2V0VG9TdHJpbmciLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsIlNoYXJlZEFycmF5QnVmZmVyQ29weSIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwibWV0aG9kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZm9ybWF0UmVnRXhwIiwib2JqZWN0cyIsInN0cmluZ2lmeSIsImlzTnVsbCIsImRlcHJlY2F0ZSIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0VudlJlZ2V4IiwiTk9ERV9ERUJVRyIsImRlYnVnRW52IiwiZGVidWdsb2ciLCJwaWQiLCJvcHRzIiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImNvbG9ycyIsImlzQm9vbGVhbiIsIl9leHRlbmQiLCJpc1VuZGVmaW5lZCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsInN0eWxlcyIsInN0eWxlVHlwZSIsInN0eWxlIiwiYXJyYXlUb0hhc2giLCJoYXNoIiwiaWR4IiwicmV0IiwicHJpbWl0aXZlIiwiZm9ybWF0UHJpbWl0aXZlIiwidmlzaWJsZUtleXMiLCJpc0Vycm9yIiwiZm9ybWF0RXJyb3IiLCJicmFjZXMiLCJ0b1VUQ1N0cmluZyIsIm91dHB1dCIsImZvcm1hdEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsImlzTnVtYmVyIiwibnVtTGluZXNFc3QiLCJyZWR1Y2UiLCJwcmV2IiwiYXIiLCJpc051bGxPclVuZGVmaW5lZCIsImlzU3ltYm9sIiwicmUiLCJpc1ByaW1pdGl2ZSIsInBhZCIsIm1vbnRocyIsInRpbWVzdGFtcCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJvcmlnaW4iLCJrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wiLCJwcm9taXNpZnkiLCJvcmlnaW5hbCIsInByb21pc2VSZXNvbHZlIiwicHJvbWlzZVJlamVjdCIsInByb21pc2UiLCJyZWplY3QiLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJjYiIsIm5ld1JlYXNvbiIsImNhbGxiYWNraWZ5IiwiY2FsbGJhY2tpZmllZCIsIm1heWJlQ2IiLCJyZWoiLCJfX2NyZWF0ZUJpbmRpbmciLCJrMiIsIl9fZXNNb2R1bGUiLCJfX2V4cG9ydFN0YXIiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIkJyb3dzZXJNZXNzYWdlV3JpdGVyIiwiQnJvd3Nlck1lc3NhZ2VSZWFkZXIiLCJyaWxfMSIsImRlZmF1bHQiLCJpbnN0YWxsIiwiYXBpXzEiLCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXIiLCJsaXN0ZW4iLCJjYWxsYmFjayIsIl9vbkRhdGEiLCJldmVudCIsInBvcnQiLCJFbWl0dGVyIiwiX21lc3NhZ2VMaXN0ZW5lciIsImZpcmUiLCJkYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVFcnJvciIsIm9ubWVzc2FnZSIsIkFic3RyYWN0TWVzc2FnZVdyaXRlciIsInBvc3RNZXNzYWdlIiwiaGFuZGxlRXJyb3IiLCJlcnJvckNvdW50IiwicmVhZGVyIiwid3JpdGVyIiwibG9nZ2VyIiwiTnVsbExvZ2dlciIsIkNvbm5lY3Rpb25TdHJhdGVneSIsImNvbm5lY3Rpb25TdHJhdGVneSIsIk1lc3NhZ2VCdWZmZXIiLCJBYnN0cmFjdE1lc3NhZ2VCdWZmZXIiLCJlbXB0eUJ1ZmZlciIsImZyb21TdHJpbmciLCJfZW5jb2RpbmciLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImVuY29kaW5nIiwiYXNjaWlEZWNvZGVyIiwiZGVjb2RlIiwiVGV4dERlY29kZXIiLCJhc05hdGl2ZSIsImFsbG9jTmF0aXZlIiwiUmVhZGFibGVTdHJlYW1XcmFwcGVyIiwib25DbG9zZSIsImxpc3RlbmVyIiwic29ja2V0IiwiRGlzcG9zYWJsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbkVycm9yIiwib25FbmQiLCJvbkRhdGEiLCJibG9iIiwiYXJyYXlCdWZmZXIiLCJSQUwiLCJXcml0YWJsZVN0cmVhbVdyYXBwZXIiLCJzZW5kIiwiY2xvc2UiLCJfdGV4dEVuY29kZXIiLCJfcmlsIiwiZnJlZXplIiwibWVzc2FnZUJ1ZmZlciIsImFwcGxpY2F0aW9uSnNvbiIsImVuY29kZXIiLCJjaGFyc2V0Iiwic3RyZWFtIiwiYXNSZWFkYWJsZVN0cmVhbSIsImFzV3JpdGFibGVTdHJlYW0iLCJ0aW1lciIsIm1zIiwiaGFuZGxlIiwic2V0SW1tZWRpYXRlIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiUklMIiwiUHJvZ3Jlc3NUeXBlIiwiUHJvZ3Jlc3NUb2tlbiIsIkNvbm5lY3Rpb25PcHRpb25zIiwiV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciIsIk1lc3NhZ2VXcml0ZXIiLCJSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIiLCJNZXNzYWdlUmVhZGVyIiwiU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IiwiU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblRva2VuIiwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJFdmVudCIsIkxSVUNhY2hlIiwiVG91Y2giLCJMaW5rZWRNYXAiLCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzIiwiTm90aWZpY2F0aW9uVHlwZTkiLCJOb3RpZmljYXRpb25UeXBlOCIsIk5vdGlmaWNhdGlvblR5cGU3IiwiTm90aWZpY2F0aW9uVHlwZTYiLCJOb3RpZmljYXRpb25UeXBlNSIsIk5vdGlmaWNhdGlvblR5cGU0IiwiTm90aWZpY2F0aW9uVHlwZTMiLCJOb3RpZmljYXRpb25UeXBlMiIsIk5vdGlmaWNhdGlvblR5cGUxIiwiTm90aWZpY2F0aW9uVHlwZTAiLCJOb3RpZmljYXRpb25UeXBlIiwiRXJyb3JDb2RlcyIsIlJlc3BvbnNlRXJyb3IiLCJSZXF1ZXN0VHlwZTkiLCJSZXF1ZXN0VHlwZTgiLCJSZXF1ZXN0VHlwZTciLCJSZXF1ZXN0VHlwZTYiLCJSZXF1ZXN0VHlwZTUiLCJSZXF1ZXN0VHlwZTQiLCJSZXF1ZXN0VHlwZTMiLCJSZXF1ZXN0VHlwZTIiLCJSZXF1ZXN0VHlwZTEiLCJSZXF1ZXN0VHlwZTAiLCJSZXF1ZXN0VHlwZSIsIk1lc3NhZ2UiLCJNZXNzYWdlU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TdHJhdGVneSIsIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSIsIkNvbm5lY3Rpb25FcnJvciIsIkNvbm5lY3Rpb25FcnJvcnMiLCJMb2dUcmFjZU5vdGlmaWNhdGlvbiIsIlNldFRyYWNlTm90aWZpY2F0aW9uIiwiVHJhY2VGb3JtYXQiLCJUcmFjZVZhbHVlcyIsIlRyYWNlIiwibWVzc2FnZXNfMSIsImxpbmtlZE1hcF8xIiwiZGlzcG9zYWJsZV8xIiwiZXZlbnRzXzEiLCJjYW5jZWxsYXRpb25fMSIsInNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEiLCJtZXNzYWdlUmVhZGVyXzEiLCJtZXNzYWdlV3JpdGVyXzEiLCJtZXNzYWdlQnVmZmVyXzEiLCJjb25uZWN0aW9uXzEiLCJyYWxfMSIsIklzIiwiTm9uZSIsImlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwib25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJDYW5jZWxsZWQiLCJjYW5kaWRhdGUiLCJib29sZWFuIiwic2hvcnRjdXRFdmVudCIsIk11dGFibGVUb2tlbiIsImNhbmNlbCIsIl9pc0NhbmNlbGxlZCIsIl9lbWl0dGVyIiwiX3Rva2VuIiwiUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDYW5jZWxOb3RpZmljYXRpb24iLCJQcm9ncmVzc05vdGlmaWNhdGlvbiIsIlN0YXJSZXF1ZXN0SGFuZGxlciIsIk9mZiIsIk1lc3NhZ2VzIiwiQ29tcGFjdCIsIlZlcmJvc2UiLCJ0b0xvd2VyQ2FzZSIsIlRleHQiLCJjYW5jZWxVbmRpc3BhdGNoZWQiLCJraW5kIiwiY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJzZW5kQ2FuY2VsbGF0aW9uIiwiY29ubiIsInNlbmROb3RpZmljYXRpb24iLCJjbGVhbnVwIiwic2VuZGVyIiwiaGFuZGxlTWVzc2FnZSIsImNhbmNlbGxhdGlvblN0cmF0ZWd5IiwibWVzc2FnZVN0cmF0ZWd5IiwiQ29ubmVjdGlvblN0YXRlIiwibWVzc2FnZVJlYWRlciIsIm1lc3NhZ2VXcml0ZXIiLCJfbG9nZ2VyIiwic2VxdWVuY2VOdW1iZXIiLCJub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlciIsInVua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyIiwic3RhclJlcXVlc3RIYW5kbGVyIiwicmVxdWVzdEhhbmRsZXJzIiwic3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIiLCJub3RpZmljYXRpb25IYW5kbGVycyIsInByb2dyZXNzSGFuZGxlcnMiLCJtZXNzYWdlUXVldWUiLCJyZXNwb25zZVByb21pc2VzIiwia25vd25DYW5jZWxlZFJlcXVlc3RzIiwicmVxdWVzdFRva2VucyIsInRyYWNlRm9ybWF0IiwidHJhY2VyIiwic3RhdGUiLCJOZXciLCJlcnJvckVtaXR0ZXIiLCJjbG9zZUVtaXR0ZXIiLCJ1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyIiwidW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyIiwiZGlzcG9zZUVtaXR0ZXIiLCJjcmVhdGVSZXF1ZXN0UXVldWVLZXkiLCJjcmVhdGVSZXNwb25zZVF1ZXVlS2V5IiwiY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkiLCJhZGRNZXNzYWdlVG9RdWV1ZSIsImlzUmVxdWVzdCIsImlzUmVzcG9uc2UiLCJfbWVzc2FnZSIsImlzTGlzdGVuaW5nIiwiTGlzdGVuaW5nIiwiaXNDbG9zZWQiLCJDbG9zZWQiLCJpc0Rpc3Bvc2VkIiwiRGlzcG9zZWQiLCJjbG9zZUhhbmRsZXIiLCJyZWFkRXJyb3JIYW5kbGVyIiwid3JpdGVFcnJvckhhbmRsZXIiLCJ0cmlnZ2VyTWVzc2FnZVF1ZXVlIiwicHJvY2Vzc01lc3NhZ2VRdWV1ZSIsImhhbmRsZVJlcXVlc3QiLCJpc05vdGlmaWNhdGlvbiIsImhhbmRsZU5vdGlmaWNhdGlvbiIsImhhbmRsZVJlc3BvbnNlIiwiaGFuZGxlSW52YWxpZE1lc3NhZ2UiLCJjYW5jZWxJZCIsInBhcmFtcyIsInRvQ2FuY2VsIiwic3RyYXRlZ3kiLCJyZXNwb25zZSIsInRyYWNlU2VuZGluZ1Jlc3BvbnNlIiwiY2FuY2VsbGF0aW9uVG9rZW4iLCJ0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uIiwicmVxdWVzdE1lc3NhZ2UiLCJyZXBseSIsInJlc3VsdE9yRXJyb3IiLCJzdGFydFRpbWUiLCJqc29ucnBjIiwidG9Kc29uIiwicmVwbHlFcnJvciIsInJlcGx5U3VjY2VzcyIsInRyYWNlUmVjZWl2ZWRSZXF1ZXN0IiwicmVxdWVzdEhhbmRsZXIiLCJoYW5kbGVyIiwidG9rZW5LZXkiLCJjYW5jZWxsYXRpb25Tb3VyY2UiLCJoYW5kbGVyUmVzdWx0IiwibnVtYmVyT2ZQYXJhbXMiLCJJbnZhbGlkUGFyYW1zIiwicGFyYW1ldGVyU3RydWN0dXJlcyIsImJ5TmFtZSIsImJ5UG9zaXRpb24iLCJJbnRlcm5hbEVycm9yIiwiTWV0aG9kTm90Rm91bmQiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZXNwb25zZVByb21pc2UiLCJ0cmFjZVJlY2VpdmVkUmVzcG9uc2UiLCJub3RpZmljYXRpb25IYW5kbGVyIiwicmVzcG9uc2VIYW5kbGVyIiwic3RyaW5naWZ5VHJhY2UiLCJ0cmFjZVNlbmRpbmdSZXF1ZXN0IiwibG9nTFNQTWVzc2FnZSIsInRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbiIsInRpbWVyU3RhcnQiLCJsc3BNZXNzYWdlIiwiaXNMU1BNZXNzYWdlIiwidGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQiLCJ0aHJvd0lmTGlzdGVuaW5nIiwiQWxyZWFkeUxpc3RlbmluZyIsInRocm93SWZOb3RMaXN0ZW5pbmciLCJ1bmRlZmluZWRUb051bGwiLCJwYXJhbSIsIm51bGxUb1VuZGVmaW5lZCIsImlzTmFtZWRQYXJhbSIsImNvbXB1dGVTaW5nbGVQYXJhbSIsImF1dG8iLCJjb21wdXRlTWVzc2FnZVBhcmFtcyIsImNvbm5lY3Rpb24iLCJtZXNzYWdlUGFyYW1zIiwicGFyYW1TdGFydCIsInBhcmFtRW5kIiwibm90aWZpY2F0aW9uTWVzc2FnZSIsIm9uTm90aWZpY2F0aW9uIiwib25Qcm9ncmVzcyIsIl90eXBlIiwic2VuZFByb2dyZXNzIiwib25VbmhhbmRsZWRQcm9ncmVzcyIsInNlbmRSZXF1ZXN0IiwiZGlzcG9zYWJsZSIsImVuYWJsZUNhbmNlbGxhdGlvbiIsInJlc29sdmVXaXRoQ2xlYW51cCIsInIiLCJyZWplY3RXaXRoQ2xlYW51cCIsIk1lc3NhZ2VXcml0ZUVycm9yIiwib25SZXF1ZXN0IiwiaGFzUGVuZGluZ1Jlc3BvbnNlIiwiX3ZhbHVlIiwiX3RyYWNlciIsInNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyIsIl9zZW5kTm90aWZpY2F0aW9uIiwiX3RyYWNlRm9ybWF0Iiwib25VbmhhbmRsZWROb3RpZmljYXRpb24iLCJvbkRpc3Bvc2UiLCJQZW5kaW5nUmVzcG9uc2VSZWplY3RlZCIsInZlcmJvc2UiLCJfZGlzcG9zYWJsZSIsIkNhbGxiYWNrTGlzdCIsImJ1Y2tldCIsIl9jYWxsYmFja3MiLCJfY29udGV4dHMiLCJyZW1vdmUiLCJmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQiLCJpbnZva2UiLCJjYWxsYmFja3MiLCJjb250ZXh0cyIsIl9ldmVudCIsInRoaXNBcmdzIiwiZGlzcG9zYWJsZXMiLCJvbkZpcnN0TGlzdGVuZXJBZGQiLCJfbm9vcCIsIm9uTGFzdExpc3RlbmVyUmVtb3ZlIiwic3RyaW5nQXJyYXkiLCJldmVyeSIsImVsZW0iLCJfYSIsIkZpcnN0IiwiQXNPbGQiLCJMYXN0IiwiQXNOZXciLCJjbGVhciIsIl9tYXAiLCJfaGVhZCIsIl90YWlsIiwiX3NpemUiLCJfc3RhdGUiLCJ0b3VjaCIsImFkZEl0ZW1MYXN0IiwiYWRkSXRlbUZpcnN0IiwicmVtb3ZlSXRlbSIsImNhbGxiYWNrZm4iLCJjdXJyZW50IiwidHJpbU9sZCIsIm5ld1NpemUiLCJjdXJyZW50U2l6ZSIsInRvSlNPTiIsImZyb21KU09OIiwiX2xpbWl0IiwiY2hlY2tUcmltIiwicmF0aW8iLCJfcmF0aW8iLCJwZWVrIiwicm91bmQiLCJDUiIsIkxGIiwiQ1JMRiIsImFwcGVuZCIsInRvQXBwZW5kIiwiX2NodW5rcyIsIl90b3RhbExlbmd0aCIsInRyeVJlYWRIZWFkZXJzIiwibG93ZXJDYXNlS2V5cyIsImNodW5rSW5kZXgiLCJjaHVua0J5dGVzUmVhZCIsIl9yZWFkIiwiaGVhZGVycyIsImhlYWRlciIsInRyaW0iLCJ0cnlSZWFkQm9keSIsIm51bWJlck9mQnl0ZXMiLCJieXRlQ291bnQiLCJyZXN1bHRPZmZzZXQiLCJjaHVua1BhcnQiLCJzZW1hcGhvcmVfMSIsIm9uUGFydGlhbE1lc3NhZ2UiLCJhc0Vycm9yIiwiZmlyZUNsb3NlIiwicGFydGlhbE1lc3NhZ2VFbWl0dGVyIiwiZmlyZVBhcnRpYWxNZXNzYWdlIiwiUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyIsImZyb21PcHRpb25zIiwiY29udGVudERlY29kZXIiLCJjb250ZW50RGVjb2RlcnMiLCJjb250ZW50VHlwZURlY29kZXIiLCJjb250ZW50VHlwZURlY29kZXJzIiwicGFydGlhbE1lc3NhZ2VUaW1lb3V0IiwiX3BhcnRpYWxNZXNzYWdlVGltZW91dCIsIm5leHRNZXNzYWdlTGVuZ3RoIiwibWVzc2FnZVRva2VuIiwicGFydGlhbE1lc3NhZ2VUaW1lciIsInJlYWRhYmxlIiwiY29udGVudExlbmd0aCIsInNldFBhcnRpYWxNZXNzYWdlVGltZXIiLCJjbGVhclBhcnRpYWxNZXNzYWdlVGltZXIiLCJyZWFkU2VtYXBob3JlIiwibG9jayIsImJ5dGVzIiwid2FpdGluZ1RpbWUiLCJTZW1hcGhvcmUiLCJDb250ZW50TGVuZ3RoIiwiUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyIsImNvbnRlbnRUeXBlRW5jb2RlciIsImNvbnRlbnRFbmNvZGVyIiwid3JpdGVTZW1hcGhvcmUiLCJwYXlsb2FkIiwiZG9Xcml0ZSIsIkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSIsIlBhcnNlRXJyb3IiLCJJbnZhbGlkUmVxdWVzdCIsImpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsInNlcnZlckVycm9yU3RhcnQiLCJNZXNzYWdlUmVhZEVycm9yIiwiQ29ubmVjdGlvbkluYWN0aXZlIiwiU2VydmVyTm90SW5pdGlhbGl6ZWQiLCJVbmtub3duRXJyb3JDb2RlIiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCIsInNlcnZlckVycm9yRW5kIiwiX3BhcmFtZXRlclN0cnVjdHVyZXMiLCJfcmFsIiwicmFsIiwidGh1bmsiLCJfd2FpdGluZyIsInJ1bk5leHQiLCJhY3RpdmUiLCJfYWN0aXZlIiwiX2NhcGFjaXR5IiwiZG9SdW5OZXh0IiwiY2FwYWNpdHkiLCJDYW5jZWxsYXRpb25TdGF0ZSIsIkNvbnRpbnVlIiwicmVxdWVzdCIsImJ1ZmZlcnMiLCIkY2FuY2VsbGF0aW9uRGF0YSIsIl9jb25uIiwic3RvcmUiLCJTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIiwibG9hZCIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24iLCJicm93c2VyXzEiLCJMU1BFcnJvckNvZGVzIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQiLCJSZXF1ZXN0RmFpbGVkIiwiU2VydmVyQ2FuY2VsbGVkIiwiQ29udGVudE1vZGlmaWVkIiwiUmVxdWVzdENhbmNlbGxlZCIsImxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCIsInZzY29kZV9qc29ucnBjXzEiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZSIsIlByb3RvY29sUmVxdWVzdFR5cGUwIiwiUmVnaXN0cmF0aW9uVHlwZSIsIk1lc3NhZ2VEaXJlY3Rpb24iLCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJtZXNzYWdlRGlyZWN0aW9uIiwiY2xpZW50VG9TZXJ2ZXIiLCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3QiLCJEb2N1bWVudENvbG9yUmVxdWVzdCIsIkNvbmZpZ3VyYXRpb25SZXF1ZXN0Iiwic2VydmVyVG9DbGllbnQiLCJEZWNsYXJhdGlvblJlcXVlc3QiLCJfX25vRHluYW1pY0ltcG9ydCIsIkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCIsIldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCIsIkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQiLCJEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSIsInJldHJpZ2dlclJlcXVlc3QiLCJGdWxsIiwiVW5jaGFuZ2VkIiwicGFydGlhbFJlc3VsdCIsIldpbGxEZWxldGVGaWxlc1JlcXVlc3QiLCJEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiIsIkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCIsIkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCIsIkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCIsImZvbGRlciIsIkZvbGRpbmdSYW5nZVJlcXVlc3QiLCJJbXBsZW1lbnRhdGlvblJlcXVlc3QiLCJJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCIsIklubGF5SGludFJlc29sdmVSZXF1ZXN0IiwiSW5sYXlIaW50UmVxdWVzdCIsIklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0IiwiQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IiwiQ29kZUFjdGlvblJlcXVlc3QiLCJEb2N1bWVudFN5bWJvbFJlcXVlc3QiLCJEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QiLCJSZWZlcmVuY2VzUmVxdWVzdCIsIkRlZmluaXRpb25SZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFJlcXVlc3QiLCJTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQiLCJIb3ZlclJlcXVlc3QiLCJDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QiLCJDb21wbGV0aW9uUmVxdWVzdCIsIkNvbXBsZXRpb25UcmlnZ2VyS2luZCIsIlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiIsIldhdGNoS2luZCIsIlJlbGF0aXZlUGF0dGVybiIsIkZpbGVDaGFuZ2VUeXBlIiwiRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IiwiV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTYXZlUmVhc29uIiwiRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IiwiRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudFN5bmNLaW5kIiwiVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24iLCJMb2dNZXNzYWdlTm90aWZpY2F0aW9uIiwiU2hvd01lc3NhZ2VSZXF1ZXN0IiwiU2hvd01lc3NhZ2VOb3RpZmljYXRpb24iLCJNZXNzYWdlVHlwZSIsIkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24iLCJFeGl0Tm90aWZpY2F0aW9uIiwiU2h1dGRvd25SZXF1ZXN0IiwiSW5pdGlhbGl6ZWROb3RpZmljYXRpb24iLCJJbml0aWFsaXplRXJyb3JDb2RlcyIsIkluaXRpYWxpemVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzc09wdGlvbnMiLCJUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIiwiU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyIsIlBvc2l0aW9uRW5jb2RpbmdLaW5kIiwiRmFpbHVyZUhhbmRsaW5nS2luZCIsIlJlc291cmNlT3BlcmF0aW9uS2luZCIsIlVucmVnaXN0cmF0aW9uUmVxdWVzdCIsIlJlZ2lzdHJhdGlvblJlcXVlc3QiLCJEb2N1bWVudFNlbGVjdG9yIiwiTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyIiwiTm90ZWJvb2tEb2N1bWVudEZpbHRlciIsIlRleHREb2N1bWVudEZpbHRlciIsIlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QiLCJUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJNb25pa2VyUmVxdWVzdCIsIk1vbmlrZXJLaW5kIiwiVW5pcXVlbmVzc0xldmVsIiwiTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCIsIlNob3dEb2N1bWVudFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUiLCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVxdWVzdCIsIlRva2VuRm9ybWF0IiwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiIsIldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzcyIsIlNlbGVjdGlvblJhbmdlUmVxdWVzdCIsIkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24iLCJXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCIsIlR5cGVEZWZpbml0aW9uUmVxdWVzdCIsIkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QiLCJFeGVjdXRlQ29tbWFuZFJlcXVlc3QiLCJQcmVwYXJlUmVuYW1lUmVxdWVzdCIsIlJlbmFtZVJlcXVlc3QiLCJQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciIsIkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QiLCJEb2N1bWVudExpbmtSZXF1ZXN0IiwiQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCIsIkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QiLCJDb2RlTGVuc1JlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCIsIkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIiwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUiLCJOb3RlYm9va0RvY3VtZW50IiwiTm90ZWJvb2tDZWxsIiwiRXhlY3V0aW9uU3VtbWFyeSIsIk5vdGVib29rQ2VsbEtpbmQiLCJUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QiLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSIsInByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEiLCJwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xIiwicHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEiLCJwcm90b2NvbF9jb25maWd1cmF0aW9uXzEiLCJwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEiLCJwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMSIsInByb3RvY29sX2RlY2xhcmF0aW9uXzEiLCJwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xIiwicHJvdG9jb2xfcHJvZ3Jlc3NfMSIsInByb3RvY29sX2NhbGxIaWVyYXJjaHlfMSIsInByb3RvY29sX3NlbWFudGljVG9rZW5zXzEiLCJwcm90b2NvbF9zaG93RG9jdW1lbnRfMSIsInByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xIiwicHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMSIsInByb3RvY29sX21vbmlrZXJfMSIsInByb3RvY29sX3R5cGVIaWVyYXJjaHlfMSIsInByb3RvY29sX2lubGluZVZhbHVlXzEiLCJwcm90b2NvbF9pbmxheUhpbnRfMSIsInByb3RvY29sX2RpYWdub3N0aWNfMSIsInByb3RvY29sX25vdGVib29rXzEiLCJsYW5ndWFnZSIsInNjaGVtZSIsInBhdHRlcm4iLCJvYmplY3RMaXRlcmFsIiwibm90ZWJvb2tUeXBlIiwibm90ZWJvb2siLCJDcmVhdGUiLCJSZW5hbWUiLCJEZWxldGUiLCJBYm9ydCIsIlRyYW5zYWN0aW9uYWwiLCJUZXh0T25seVRyYW5zYWN0aW9uYWwiLCJVbmRvIiwiVVRGOCIsIlVURjE2IiwiVVRGMzIiLCJoYXNJZCIsImRvY3VtZW50U2VsZWN0b3IiLCJ3b3JrRG9uZVByb2dyZXNzIiwiaGFzV29ya0RvbmVQcm9ncmVzcyIsInVua25vd25Qcm90b2NvbFZlcnNpb24iLCJXYXJuaW5nIiwiSW5mbyIsIkxvZyIsIkluY3JlbWVudGFsIiwiaXNJbmNyZW1lbnRhbCIsInJhbmdlTGVuZ3RoIiwiaXNGdWxsIiwiTWFudWFsIiwiQWZ0ZXJEZWxheSIsIkZvY3VzT3V0IiwiQ3JlYXRlZCIsIkNoYW5nZWQiLCJEZWxldGVkIiwiYmFzZVVyaSIsIldvcmtzcGFjZUZvbGRlciIsIkNoYW5nZSIsIkludm9rZWQiLCJUcmlnZ2VyQ2hhcmFjdGVyIiwiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyIsIkNvbnRlbnRDaGFuZ2UiLCJwcm9qZWN0IiwiZ3JvdXAiLCIkaW1wb3J0IiwiJGV4cG9ydCIsImxvY2FsIiwiTWFya3VwIiwiQ29kZSIsImV4ZWN1dGlvbk9yZGVyIiwic3VjY2VzcyIsInVpbnRlZ2VyIiwiZXF1YWxzIiwib25lIiwiRG9jdW1lbnRVcmkiLCJtZXRhZGF0YSIsImRpZmYiLCJ0d28iLCJleGVjdXRpb25TdW1tYXJ5IiwiZXF1YWxzTWV0YWRhdGEiLCJvbmVBcnJheSIsIm90aGVyQXJyYXkiLCJvbmVLZXlzIiwib3RoZXJLZXlzIiwiY2VsbHMiLCJpbnRlZ2VyIiwidHlwZWRBcnJheSIsInJlZ2lzdHJhdGlvbk1ldGhvZCIsImRlbGV0ZUNvdW50IiwiUmVsYXRpdmUiLCJjaGVjayIsIkFubm90YXRlZFRleHRFZGl0IiwiQ2hhbmdlQW5ub3RhdGlvbiIsIkNoYW5nZUFubm90YXRpb25JZGVudGlmaWVyIiwiQ29kZUFjdGlvbiIsIkNvZGVBY3Rpb25Db250ZXh0IiwiQ29kZUFjdGlvbktpbmQiLCJDb2RlQWN0aW9uVHJpZ2dlcktpbmQiLCJDb2RlRGVzY3JpcHRpb24iLCJDb2RlTGVucyIsIkNvbG9yIiwiQ29sb3JJbmZvcm1hdGlvbiIsIkNvbG9yUHJlc2VudGF0aW9uIiwiQ29tbWFuZCIsIkNvbXBsZXRpb25JdGVtIiwiQ29tcGxldGlvbkl0ZW1LaW5kIiwiQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMiLCJDb21wbGV0aW9uSXRlbVRhZyIsIkNvbXBsZXRpb25MaXN0IiwiQ3JlYXRlRmlsZSIsIkRlbGV0ZUZpbGUiLCJEaWFnbm9zdGljIiwiRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiIsIkRpYWdub3N0aWNTZXZlcml0eSIsIkRvY3VtZW50SGlnaGxpZ2h0IiwiRG9jdW1lbnRIaWdobGlnaHRLaW5kIiwiRG9jdW1lbnRMaW5rIiwiRG9jdW1lbnRTeW1ib2wiLCJFT0wiLCJGb2xkaW5nUmFuZ2UiLCJGb2xkaW5nUmFuZ2VLaW5kIiwiRm9ybWF0dGluZ09wdGlvbnMiLCJIb3ZlciIsIklubGF5SGludCIsIklubGF5SGludEtpbmQiLCJJbmxheUhpbnRMYWJlbFBhcnQiLCJJbmxpbmVWYWx1ZUNvbnRleHQiLCJJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiIsIklubGluZVZhbHVlVGV4dCIsIklubGluZVZhbHVlVmFyaWFibGVMb29rdXAiLCJJbnNlcnRSZXBsYWNlRWRpdCIsIkluc2VydFRleHRGb3JtYXQiLCJJbnNlcnRUZXh0TW9kZSIsIkxvY2F0aW9uIiwiTG9jYXRpb25MaW5rIiwiTWFya2VkU3RyaW5nIiwiTWFya3VwQ29udGVudCIsIk1hcmt1cEtpbmQiLCJPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJQYXJhbWV0ZXJJbmZvcm1hdGlvbiIsIlBvc2l0aW9uIiwiUmFuZ2UiLCJSZW5hbWVGaWxlIiwiU2VsZWN0aW9uUmFuZ2UiLCJTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIiwiU2VtYW50aWNUb2tlblR5cGVzIiwiU2VtYW50aWNUb2tlbnMiLCJTaWduYXR1cmVJbmZvcm1hdGlvbiIsIlN5bWJvbEluZm9ybWF0aW9uIiwiU3ltYm9sS2luZCIsIlN5bWJvbFRhZyIsIlRleHREb2N1bWVudCIsIlRleHREb2N1bWVudEVkaXQiLCJUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiVGV4dERvY3VtZW50SXRlbSIsIlRleHRFZGl0IiwiVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciIsIldvcmtzcGFjZUNoYW5nZSIsIldvcmtzcGFjZUVkaXQiLCJXb3Jrc3BhY2VTeW1ib2wiLCJNSU5fVkFMVUUiLCJNQVhfVkFMVUUiLCJ0aHJlZSIsImZvdXIiLCJ0YXJnZXRVcmkiLCJ0YXJnZXRSYW5nZSIsInRhcmdldFNlbGVjdGlvblJhbmdlIiwib3JpZ2luU2VsZWN0aW9uUmFuZ2UiLCJhbHBoYSIsIm51bWJlclJhbmdlIiwiY29sb3IiLCJ0ZXh0RWRpdCIsImFkZGl0aW9uYWxUZXh0RWRpdHMiLCJDb21tZW50IiwiSW1wb3J0cyIsIlJlZ2lvbiIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJzdGFydENoYXJhY3RlciIsImVuZENoYXJhY3RlciIsImNvbGxhcHNlZFRleHQiLCJkZWZpbmVkIiwiSW5mb3JtYXRpb24iLCJIaW50IiwiaHJlZiIsInNldmVyaXR5IiwiY29kZURlc2NyaXB0aW9uIiwibmV3VGV4dCIsImluc2VydCIsImRlbCIsIm5lZWRzQ29uZmlybWF0aW9uIiwiZGVzY3JpcHRpb24iLCJhbm5vdGF0aW9uIiwiYW5ub3RhdGlvbklkIiwiZWRpdHMiLCJvdmVyd3JpdGUiLCJpZ25vcmVJZkV4aXN0cyIsIm9sZFVyaSIsIm5ld1VyaSIsInJlY3Vyc2l2ZSIsImlnbm9yZUlmTm90RXhpc3RzIiwiY2hhbmdlcyIsImNoYW5nZSIsIlRleHRFZGl0Q2hhbmdlSW1wbCIsImNoYW5nZUFubm90YXRpb25zIiwiZWRpdCIsImFzc2VydENoYW5nZUFubm90YXRpb25zIiwibWFuYWdlIiwiQ2hhbmdlQW5ub3RhdGlvbnMiLCJhbm5vdGF0aW9ucyIsIl9hbm5vdGF0aW9ucyIsIl9jb3VudGVyIiwiaWRPckFubm90YXRpb24iLCJuZXh0SWQiLCJfdGV4dEVkaXRDaGFuZ2VzIiwiX3dvcmtzcGFjZUVkaXQiLCJfY2hhbmdlQW5ub3RhdGlvbnMiLCJ0ZXh0RWRpdENoYW5nZSIsImluaXREb2N1bWVudENoYW5nZXMiLCJnZXRUZXh0RWRpdENoYW5nZSIsInRleHREb2N1bWVudEVkaXQiLCJpbml0Q2hhbmdlcyIsImNyZWF0ZUZpbGUiLCJvcHRpb25zT3JBbm5vdGF0aW9uIiwib3BlcmF0aW9uIiwicmVuYW1lRmlsZSIsImRlbGV0ZUZpbGUiLCJQbGFpblRleHQiLCJNYXJrZG93biIsIk1ldGhvZCIsIkZpZWxkIiwiVmFyaWFibGUiLCJJbnRlcmZhY2UiLCJNb2R1bGUiLCJQcm9wZXJ0eSIsIlVuaXQiLCJWYWx1ZSIsIkVudW0iLCJTbmlwcGV0IiwiRmlsZSIsIlJlZmVyZW5jZSIsIkZvbGRlciIsIkVudW1NZW1iZXIiLCJDb25zdGFudCIsIlN0cnVjdCIsIk9wZXJhdG9yIiwiVHlwZVBhcmFtZXRlciIsImFzSXMiLCJhZGp1c3RJbmRlbnRhdGlvbiIsImRldGFpbCIsIml0ZW1zIiwiaXNJbmNvbXBsZXRlIiwiZnJvbVBsYWluVGV4dCIsInBsYWluVGV4dCIsImNvbnRlbnRzIiwiZG9jdW1lbnRhdGlvbiIsIlJlYWQiLCJXcml0ZSIsIk5hbWVzcGFjZSIsIlBhY2thZ2UiLCJLZXkiLCJOdWxsIiwiY29udGFpbmVyTmFtZSIsInNlbGVjdGlvblJhbmdlIiwiY2hpbGRyZW4iLCJ0YWdzIiwiUXVpY2tGaXgiLCJSZWZhY3RvciIsIlJlZmFjdG9yRXh0cmFjdCIsIlJlZmFjdG9ySW5saW5lIiwiUmVmYWN0b3JSZXdyaXRlIiwiU291cmNlIiwiU291cmNlT3JnYW5pemVJbXBvcnRzIiwiU291cmNlRml4QWxsIiwiQXV0b21hdGljIiwiZGlhZ25vc3RpY3MiLCJvbmx5IiwidHJpZ2dlcktpbmQiLCJraW5kT3JDb21tYW5kT3JFZGl0IiwiY2hlY2tLaW5kIiwiaXNQcmVmZXJyZWQiLCJ0YWJTaXplIiwiaW5zZXJ0U3BhY2VzIiwicGFyZW50IiwicmVzdWx0SWQiLCJ2YXJpYWJsZU5hbWUiLCJjYXNlU2Vuc2l0aXZlTG9va3VwIiwiZnJhbWVJZCIsInN0b3BwZWRMb2NhdGlvbiIsIlR5cGUiLCJQYXJhbWV0ZXIiLCJ0b29sdGlwIiwidGV4dEVkaXRzIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJGdWxsVGV4dERvY3VtZW50IiwibGluZUNvdW50IiwicG9zaXRpb25BdCIsIm9mZnNldEF0IiwiYXBwbHlFZGl0cyIsInNvcnRlZEVkaXRzIiwibWVyZ2VTb3J0IiwibGFzdE1vZGlmaWVkT2Zmc2V0Iiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJsZWZ0SWR4IiwicmlnaHRJZHgiLCJfdXJpIiwiX2xhbmd1YWdlSWQiLCJfdmVyc2lvbiIsIl9jb250ZW50IiwiX2xpbmVPZmZzZXRzIiwiZ2V0TGluZU9mZnNldHMiLCJsaW5lT2Zmc2V0cyIsImlzTGluZVN0YXJ0IiwiY2giLCJsb3ciLCJoaWdoIiwibWlkIiwibGluZU9mZnNldCIsIm5leHRMaW5lT2Zmc2V0IiwiYXZhaWxhYmxlVHlwZWRBcnJheXMiLCJnbG9iYWxUaGlzIiwidHlwZWRBcnJheXMiLCIkc2xpY2UiLCJjYWNoZSIsInByb3RvIiwic3VwZXJQcm90byIsInRyeVR5cGVkQXJyYXlzIiwidHJ5QWxsVHlwZWRBcnJheXMiLCJnZXR0ZXIiLCJ0cnlTbGljZXMiLCJ0cnlBbGxTbGljZXMiLCJ0YWciLCJwb3NzaWJsZU5hbWVzIiwib3V0IiwiX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18iLCJnZXRXZWxsZm9ybWVkUmFuZ2UiLCJhZGRlZExpbmVPZmZzZXRzIiwiY29tcHV0ZUxpbmVPZmZzZXRzIiwiZW5zdXJlQmVmb3JlRU9MIiwiaXNFT0wiLCJnZXRXZWxsZm9ybWVkRWRpdCIsInNwYW5zIiwiaXNBdExpbmVTdGFydCIsInRleHRPZmZzZXQiLCJjaGFyIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJsb2FkZWQiLCJkZWZpbml0aW9uIiwicGF0aHMiLCJMdWFTZXJ2aWNlIiwiYmFzZV9zZXJ2aWNlIiwibHVhcGFyc2UiLCJtYWluIiwidXRpbHMiLCJBY2VSYW5nZSIsImdldENvbnN0cnVjdG9yIiwiZWRpdG9yIiwiX2luc3RhbmNlIiwiZ2V0U2VsZWN0aW9uUmFuZ2UiLCJjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXIiLCJDb21tb25Db252ZXJ0ZXIiLCJub3JtYWxpemVSYW5nZXMiLCJjb21wbGV0aW9ucyIsImVsIiwidG9SYW5nZSIsImNsZWFuSHRtbCIsImh0bWwiLCJmcm9tUG9pbnRzIiwiY29udmVydEtpbmQiLCJleGNsdWRlQnlFcnJvck1lc3NhZ2UiLCJmaWVsZE5hbWUiLCJmcm9tUmFuZ2UiLCJyYW5nZUZyb21Qb3NpdGlvbnMiLCJmcm9tUG9pbnQiLCJwb2ludCIsInRvUG9pbnQiLCJ0b0Fubm90YXRpb25zIiwiX2RpYWdub3N0aWNzIiwiZnJvbUFubm90YXRpb25zIiwidG9Db21wbGV0aW9uIiwiX2l0ZW1fdGV4dEVkaXQiLCJfaXRlbV9jb21tYW5kIiwiaXRlbUtpbmQiLCJfaXRlbV90ZXh0RWRpdF9uZXdUZXh0IiwiX3JlZiIsImluc2VydFRleHQiLCJmaWx0ZXJUZXh0IiwiZmlyc3RXb3JkTWF0Y2giLCJmaXJzdFdvcmQiLCJ3b3JkUmVnZXgiLCJnZXRUZXh0RWRpdFJhbmdlIiwiY2FwdGlvbiIsInNjb3JlIiwiaW5zZXJ0VGV4dEZvcm1hdCIsInRvQ29tcGxldGlvbnMiLCJjb21iaW5lZENvbXBsZXRpb25zIiwiYWxsQ29tcGxldGlvbnMiLCJzZXJ2aWNlIiwiZmxhdCIsInRvUmVzb2x2ZWRDb21wbGV0aW9uIiwiZnJvbU1hcmt1cENvbnRlbnQiLCJ0b0NvbXBsZXRpb25JdGVtIiwiX2NvbXBsZXRpb25fY2FwdGlvbiIsIl9jb21wbGV0aW9uX3NuaXBwZXQiLCJfY29tcGxldGlvbl9zbmlwcGV0MSIsImZpbHRlckxlbmd0aCIsIm1lcmdlZFJhbmdlcyIsInRvVG9vbHRpcCIsIl9ob3Zlcl9maW5kIiwibHNwUmFuZ2UiLCJmaW5kIiwiX2VsIiwiZnJvbVNpZ25hdHVyZUhlbHAiLCJfZWwxIiwic2lnbmF0dXJlSW5kZXgiLCJhY3RpdmVTaWduYXR1cmUiLCJzaWduYXR1cmVzIiwiYWN0aXZlUGFyYW0iLCJhY3RpdmVQYXJhbWV0ZXIiLCJmcm9tQWNlRGVsdGEiLCJlb2wiLCJsaW5lcyIsImFjdGlvbiIsImZpbHRlckRpYWdub3N0aWNzIiwiZmlsdGVyRXJyb3JzIiwiZnJvbURvY3VtZW50SGlnaGxpZ2h0cyIsImRvY3VtZW50SGlnaGxpZ2h0cyIsImNsYXNzTmFtZSIsInRvTWFya2VyR3JvdXBJdGVtIiwidG9vbHRpcFRleHQiLCJtYXJrZXJHcm91cEl0ZW0iLCJsdWFfc2VydmljZV9kZWZpbmVfcHJvcGVydHkiLCIkc2VydmljZSIsImRpYWdub3N0aWNQcm92aWRlciIsImludGVyRmlsZURlcGVuZGVuY2llcyIsIndvcmtzcGFjZURpYWdub3N0aWNzIl0sInNvdXJjZVJvb3QiOiIifQ==