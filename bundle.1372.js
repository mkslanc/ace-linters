(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[1372],{

/***/ 21372:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 6093: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_511__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_511__(9907);
                /* provided dependency */ var console = __nested_webpack_require_511__(4364);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_511__(1342), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_511__(9801);
                var _require2 = __nested_webpack_require_511__(6827), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_511__(6827).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_511__(3046).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_511__(5968);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_511__(5656);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 9801: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_31729__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_31729__(9907);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_31729__(6827), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_31729__(1342), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 1342: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65318__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65318__(6093);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65318__(6827);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65318__(6093);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 5656: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76379__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76379__(5968);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76379__(7838);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76379__(6827).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 9818: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_107933__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_107933__(528);
                var callBind = __nested_webpack_require_107933__(8498);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 8498: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108660__)=>{
                "use strict";
                var bind = __nested_webpack_require_108660__(9138);
                var GetIntrinsic = __nested_webpack_require_108660__(528);
                var setFunctionLength = __nested_webpack_require_108660__(6108);
                var $TypeError = __nested_webpack_require_108660__(3468);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $defineProperty = __nested_webpack_require_108660__(4940);
                var $max = GetIntrinsic('%Math.max%');
                module1.exports = function callBind(originalFunction) {
                    if (typeof originalFunction !== 'function') {
                        throw new $TypeError('a function is required');
                    }
                    var func = $reflectApply(bind, $call, arguments);
                    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 4364: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110259__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110259__(6827);
                var assert = __nested_webpack_require_110259__(6093);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110259__.g !== "undefined" && __nested_webpack_require_110259__.g.console) {
                    console = __nested_webpack_require_110259__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 686: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_113941__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_113941__(4940);
                var $SyntaxError = __nested_webpack_require_113941__(5731);
                var $TypeError = __nested_webpack_require_113941__(3468);
                var gopd = __nested_webpack_require_113941__(9336);
                /** @type {import('.')} */ module1.exports = function defineDataProperty(obj, property, value) {
                    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
                        throw new $TypeError('`obj` must be an object or a function`');
                    }
                    if (typeof property !== 'string' && typeof property !== 'symbol') {
                        throw new $TypeError('`property` must be a string or a symbol`');
                    }
                    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
                        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
                        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
                        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
                        throw new $TypeError('`loose`, if provided, must be a boolean');
                    }
                    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                    var nonWritable = arguments.length > 4 ? arguments[4] : null;
                    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                    var loose = arguments.length > 6 ? arguments[6] : false;
                    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
                    if ($defineProperty) {
                        $defineProperty(obj, property, {
                            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                            value: value,
                            writable: nonWritable === null && desc ? desc.writable : !nonWritable
                        });
                    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
                        obj[property] = value; // eslint-disable-line no-param-reassign
                    } else {
                        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
                    }
                };
            /***/ },
            /***/ 1857: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_117229__)=>{
                "use strict";
                var keys = __nested_webpack_require_117229__(9228);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var defineDataProperty = __nested_webpack_require_117229__(686);
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var supportsDescriptors = __nested_webpack_require_117229__(7239)();
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        defineDataProperty(object, name, value, true);
                    } else {
                        defineDataProperty(object, name, value);
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4940: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_119306__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_119306__(528);
                /** @type {import('.')} */ var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = false;
                    }
                }
                module1.exports = $defineProperty;
            /***/ },
            /***/ 6729: /***/ (module1)=>{
                "use strict";
                /** @type {import('./eval')} */ module1.exports = EvalError;
            /***/ },
            /***/ 9838: /***/ (module1)=>{
                "use strict";
                /** @type {import('.')} */ module1.exports = Error;
            /***/ },
            /***/ 1155: /***/ (module1)=>{
                "use strict";
                /** @type {import('./range')} */ module1.exports = RangeError;
            /***/ },
            /***/ 4943: /***/ (module1)=>{
                "use strict";
                /** @type {import('./ref')} */ module1.exports = ReferenceError;
            /***/ },
            /***/ 5731: /***/ (module1)=>{
                "use strict";
                /** @type {import('./syntax')} */ module1.exports = SyntaxError;
            /***/ },
            /***/ 3468: /***/ (module1)=>{
                "use strict";
                /** @type {import('./type')} */ module1.exports = TypeError;
            /***/ },
            /***/ 2140: /***/ (module1)=>{
                "use strict";
                /** @type {import('./uri')} */ module1.exports = URIError;
            /***/ },
            /***/ 3046: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 705: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123152__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_123152__(9617);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 8794: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var toStr = Object.prototype.toString;
                var max = Math.max;
                var funcType = '[object Function]';
                var concatty = function concatty(a, b) {
                    var arr = [];
                    for(var i = 0; i < a.length; i += 1){
                        arr[i] = a[i];
                    }
                    for(var j = 0; j < b.length; j += 1){
                        arr[j + a.length] = b[j];
                    }
                    return arr;
                };
                var slicy = function slicy(arrLike, offset) {
                    var arr = [];
                    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
                        arr[j] = arrLike[i];
                    }
                    return arr;
                };
                var joiny = function(arr, joiner) {
                    var str = '';
                    for(var i = 0; i < arr.length; i += 1){
                        str += arr[i];
                        if (i + 1 < arr.length) {
                            str += joiner;
                        }
                    }
                    return str;
                };
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, concatty(args, arguments));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        }
                        return target.apply(that, concatty(args, arguments));
                    };
                    var boundLength = max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs[i] = '$' + i;
                    }
                    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 9138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_128871__)=>{
                "use strict";
                var implementation = __nested_webpack_require_128871__(8794);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 528: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129152__)=>{
                "use strict";
                var undefined1;
                var $Error = __nested_webpack_require_129152__(9838);
                var $EvalError = __nested_webpack_require_129152__(6729);
                var $RangeError = __nested_webpack_require_129152__(1155);
                var $ReferenceError = __nested_webpack_require_129152__(4943);
                var $SyntaxError = __nested_webpack_require_129152__(5731);
                var $TypeError = __nested_webpack_require_129152__(3468);
                var $URIError = __nested_webpack_require_129152__(2140);
                var $Function = Function;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_129152__(3558)();
                var hasProto = __nested_webpack_require_129152__(6869)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    __proto__: null,
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': $Error,
                    '%eval%': eval,
                    '%EvalError%': $EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': $RangeError,
                    '%ReferenceError%': $ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': $URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    __proto__: null,
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_129152__(9138);
                var hasOwn = __nested_webpack_require_129152__(8554);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 9336: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153030__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_153030__(528);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 7239: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153620__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_153620__(4940);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    return !!$defineProperty;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!$defineProperty) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 6869: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 3558: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155182__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_155182__(2908);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 2908: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 1913: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_158941__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_158941__(2908);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 8554: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159293__)=>{
                "use strict";
                var call = Function.prototype.call;
                var $hasOwn = Object.prototype.hasOwnProperty;
                var bind = __nested_webpack_require_159293__(9138);
                /** @type {import('.')} */ module1.exports = bind.call(call, $hasOwn);
            /***/ },
            /***/ 5615: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 5387: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_161080__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_161080__(1913)();
                var callBound = __nested_webpack_require_161080__(9818);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9617: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 2625: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168140__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_168140__(1913)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 8006: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 7838: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170109__)=>{
                "use strict";
                var callBind = __nested_webpack_require_170109__(8498);
                var define1 = __nested_webpack_require_170109__(1857);
                var implementation = __nested_webpack_require_170109__(8006);
                var getPolyfill = __nested_webpack_require_170109__(1591);
                var shim = __nested_webpack_require_170109__(1641);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1591: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170908__)=>{
                "use strict";
                var implementation = __nested_webpack_require_170908__(8006);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 1641: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171384__)=>{
                "use strict";
                var define1 = __nested_webpack_require_171384__(1857);
                var getPolyfill = __nested_webpack_require_171384__(1591);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5943: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_172152__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_172152__(2730);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 98: /***/ function(module1, exports1, __nested_webpack_require_172485__) {
                /* module decorator */ module1 = __nested_webpack_require_172485__.nmd(module1);
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /* global exports:true, module:true, require:true, define:true, global:true */ 
                (function(root, name, factory) {
                    'use strict';
                    // Used to determine if values are of the language type `Object`
                    var objectTypes = {
                        'function': true,
                        'object': true
                    }, freeExports = objectTypes[typeof exports1] && exports1 && !exports1.nodeType && exports1, freeModule = objectTypes["object"] && module1 && !module1.nodeType && module1, freeGlobal = freeExports && freeModule && typeof __nested_webpack_require_172485__.g === 'object' && __nested_webpack_require_172485__.g, moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                    /* istanbul ignore else */ if (freeGlobal && (freeGlobal.global === freeGlobal || /* istanbul ignore next */ freeGlobal.window === freeGlobal || /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {
                        root = freeGlobal;
                    }
                    // Some AMD build optimizers, like r.js, check for specific condition
                    // patterns like the following:
                    /* istanbul ignore if */ if (true) {
                        // defined as an anonymous module.
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                            exports1
                        ], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports1, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        // In case the source has been processed and wrapped in a define module use
                        // the supplied `exports` object.
                        if (freeExports && moduleExports) factory(freeModule.exports);
                    } else /* istanbul ignore else */ {}
                })(this, 'luaparse', function(exports1) {
                    'use strict';
                    exports1.version = "0.3.1";
                    var input, options, length, features, encodingMode;
                    // Options can be set either globally on the parser object through
                    // defaultOptions, or during the parse call.
                    var defaultOptions = exports1.defaultOptions = {
                        // Explicitly tell the parser when the input ends.
                        wait: false,
                        comments: true,
                        scope: false,
                        locations: false,
                        ranges: false,
                        onCreateNode: null,
                        onCreateScope: null,
                        onDestroyScope: null,
                        onLocalDeclaration: null,
                        luaVersion: '5.1',
                        encodingMode: 'none'
                    };
                    function encodeUTF8(codepoint, highMask) {
                        highMask = highMask || 0;
                        if (codepoint < 0x80) {
                            return String.fromCharCode(codepoint);
                        } else if (codepoint < 0x800) {
                            return String.fromCharCode(highMask | 0xc0 | codepoint >> 6, highMask | 0x80 | codepoint & 0x3f);
                        } else if (codepoint < 0x10000) {
                            return String.fromCharCode(highMask | 0xe0 | codepoint >> 12, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else /* istanbul ignore else */ if (codepoint < 0x110000) {
                            return String.fromCharCode(highMask | 0xf0 | codepoint >> 18, highMask | 0x80 | codepoint >> 12 & 0x3f, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);
                        } else {
                            // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993
                            return null;
                        }
                    }
                    function toHex(num, digits) {
                        var result = num.toString(16);
                        while(result.length < digits)result = '0' + result;
                        return result;
                    }
                    function checkChars(rx) {
                        return function(s) {
                            var m = rx.exec(s);
                            if (!m) return s;
                            raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());
                        };
                    }
                    var encodingModes = {
                        // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding
                        // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;
                        // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks
                        'pseudo-latin1': {
                            fixup: checkChars(/[^\x00-\xff]/),
                            encodeByte: function(value) {
                                if (value === null) return '';
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function(codepoint) {
                                return encodeUTF8(codepoint);
                            }
                        },
                        // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding
                        'x-user-defined': {
                            fixup: checkChars(/[^\x00-\x7f\uf780-\uf7ff]/),
                            encodeByte: function(value) {
                                if (value === null) return '';
                                if (value >= 0x80) return String.fromCharCode(value | 0xf700);
                                return String.fromCharCode(value);
                            },
                            encodeUTF8: function(codepoint) {
                                return encodeUTF8(codepoint, 0xf700);
                            }
                        },
                        // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is
                        'none': {
                            discardStrings: true,
                            fixup: function(s) {
                                return s;
                            },
                            encodeByte: function(value) {
                                return '';
                            },
                            encodeUTF8: function(codepoint) {
                                return '';
                            }
                        }
                    };
                    // The available tokens expressed as enum flags so they can be checked with
                    // bitwise operations.
                    var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8, NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64, NilLiteral = 128, VarargLiteral = 256;
                    exports1.tokenTypes = {
                        EOF: EOF,
                        StringLiteral: StringLiteral,
                        Keyword: Keyword,
                        Identifier: Identifier,
                        NumericLiteral: NumericLiteral,
                        Punctuator: Punctuator,
                        BooleanLiteral: BooleanLiteral,
                        NilLiteral: NilLiteral,
                        VarargLiteral: VarargLiteral
                    };
                    // As this parser is a bit different from luas own, the error messages
                    // will be different in some situations.
                    var errors = exports1.errors = {
                        unexpected: 'unexpected %1 \'%2\' near \'%3\'',
                        unexpectedEOF: 'unexpected symbol near \'<eof>\'',
                        expected: '\'%1\' expected near \'%2\'',
                        expectedToken: '%1 expected near \'%2\'',
                        unfinishedString: 'unfinished string near \'%1\'',
                        malformedNumber: 'malformed number near \'%1\'',
                        decimalEscapeTooLarge: 'decimal escape too large near \'%1\'',
                        invalidEscape: 'invalid escape sequence near \'%1\'',
                        hexadecimalDigitExpected: 'hexadecimal digit expected near \'%1\'',
                        braceExpected: 'missing \'%1\' near \'%2\'',
                        tooLargeCodepoint: 'UTF-8 value too large near \'%1\'',
                        unfinishedLongString: 'unfinished long string (starting at line %1) near \'%2\'',
                        unfinishedLongComment: 'unfinished long comment (starting at line %1) near \'%2\'',
                        ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \'%1\'',
                        noLoopToBreak: 'no loop to break near \'%1\'',
                        labelAlreadyDefined: 'label \'%1\' already defined on line %2',
                        labelNotVisible: 'no visible label \'%1\' for <goto>',
                        gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \'%2\'',
                        cannotUseVararg: 'cannot use \'...\' outside a vararg function near \'%1\'',
                        invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'
                    };
                    // ### Abstract Syntax Tree
                    //
                    // The default AST structure is inspired by the Mozilla Parser API but can
                    // easily be customized by overriding these functions.
                    var ast = exports1.ast = {
                        labelStatement: function(label) {
                            return {
                                type: 'LabelStatement',
                                label: label
                            };
                        },
                        breakStatement: function() {
                            return {
                                type: 'BreakStatement'
                            };
                        },
                        gotoStatement: function(label) {
                            return {
                                type: 'GotoStatement',
                                label: label
                            };
                        },
                        returnStatement: function(args) {
                            return {
                                type: 'ReturnStatement',
                                'arguments': args
                            };
                        },
                        ifStatement: function(clauses) {
                            return {
                                type: 'IfStatement',
                                clauses: clauses
                            };
                        },
                        ifClause: function(condition, body) {
                            return {
                                type: 'IfClause',
                                condition: condition,
                                body: body
                            };
                        },
                        elseifClause: function(condition, body) {
                            return {
                                type: 'ElseifClause',
                                condition: condition,
                                body: body
                            };
                        },
                        elseClause: function(body) {
                            return {
                                type: 'ElseClause',
                                body: body
                            };
                        },
                        whileStatement: function(condition, body) {
                            return {
                                type: 'WhileStatement',
                                condition: condition,
                                body: body
                            };
                        },
                        doStatement: function(body) {
                            return {
                                type: 'DoStatement',
                                body: body
                            };
                        },
                        repeatStatement: function(condition, body) {
                            return {
                                type: 'RepeatStatement',
                                condition: condition,
                                body: body
                            };
                        },
                        localStatement: function(variables, init) {
                            return {
                                type: 'LocalStatement',
                                variables: variables,
                                init: init
                            };
                        },
                        assignmentStatement: function(variables, init) {
                            return {
                                type: 'AssignmentStatement',
                                variables: variables,
                                init: init
                            };
                        },
                        callStatement: function(expression) {
                            return {
                                type: 'CallStatement',
                                expression: expression
                            };
                        },
                        functionStatement: function(identifier, parameters, isLocal, body) {
                            return {
                                type: 'FunctionDeclaration',
                                identifier: identifier,
                                isLocal: isLocal,
                                parameters: parameters,
                                body: body
                            };
                        },
                        forNumericStatement: function(variable, start, end, step, body) {
                            return {
                                type: 'ForNumericStatement',
                                variable: variable,
                                start: start,
                                end: end,
                                step: step,
                                body: body
                            };
                        },
                        forGenericStatement: function(variables, iterators, body) {
                            return {
                                type: 'ForGenericStatement',
                                variables: variables,
                                iterators: iterators,
                                body: body
                            };
                        },
                        chunk: function(body) {
                            return {
                                type: 'Chunk',
                                body: body
                            };
                        },
                        identifier: function(name) {
                            return {
                                type: 'Identifier',
                                name: name
                            };
                        },
                        literal: function(type, value, raw) {
                            type = type === StringLiteral ? 'StringLiteral' : type === NumericLiteral ? 'NumericLiteral' : type === BooleanLiteral ? 'BooleanLiteral' : type === NilLiteral ? 'NilLiteral' : 'VarargLiteral';
                            return {
                                type: type,
                                value: value,
                                raw: raw
                            };
                        },
                        tableKey: function(key, value) {
                            return {
                                type: 'TableKey',
                                key: key,
                                value: value
                            };
                        },
                        tableKeyString: function(key, value) {
                            return {
                                type: 'TableKeyString',
                                key: key,
                                value: value
                            };
                        },
                        tableValue: function(value) {
                            return {
                                type: 'TableValue',
                                value: value
                            };
                        },
                        tableConstructorExpression: function(fields) {
                            return {
                                type: 'TableConstructorExpression',
                                fields: fields
                            };
                        },
                        binaryExpression: function(operator, left, right) {
                            var type = 'and' === operator || 'or' === operator ? 'LogicalExpression' : 'BinaryExpression';
                            return {
                                type: type,
                                operator: operator,
                                left: left,
                                right: right
                            };
                        },
                        unaryExpression: function(operator, argument) {
                            return {
                                type: 'UnaryExpression',
                                operator: operator,
                                argument: argument
                            };
                        },
                        memberExpression: function(base, indexer, identifier) {
                            return {
                                type: 'MemberExpression',
                                indexer: indexer,
                                identifier: identifier,
                                base: base
                            };
                        },
                        indexExpression: function(base, index) {
                            return {
                                type: 'IndexExpression',
                                base: base,
                                index: index
                            };
                        },
                        callExpression: function(base, args) {
                            return {
                                type: 'CallExpression',
                                base: base,
                                'arguments': args
                            };
                        },
                        tableCallExpression: function(base, args) {
                            return {
                                type: 'TableCallExpression',
                                base: base,
                                'arguments': args
                            };
                        },
                        stringCallExpression: function(base, argument) {
                            return {
                                type: 'StringCallExpression',
                                base: base,
                                argument: argument
                            };
                        },
                        comment: function(value, raw) {
                            return {
                                type: 'Comment',
                                value: value,
                                raw: raw
                            };
                        }
                    };
                    // Wrap up the node object.
                    function finishNode(node) {
                        // Pop a `Marker` off the location-array and attach its location data.
                        if (trackLocations) {
                            var location = locations.pop();
                            location.complete();
                            location.bless(node);
                        }
                        if (options.onCreateNode) options.onCreateNode(node);
                        return node;
                    }
                    // Helpers
                    // -------
                    var slice = Array.prototype.slice, toString = Object.prototype.toString;
                    var indexOf = /* istanbul ignore next */ function(array, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i] === element) return i;
                        }
                        return -1;
                    };
                    /* istanbul ignore else */ if (Array.prototype.indexOf) indexOf = function(array, element) {
                        return array.indexOf(element);
                    };
                    // Iterate through an array of objects and return the index of an object
                    // with a matching property.
                    function indexOfObject(array, property, element) {
                        for(var i = 0, length = array.length; i < length; ++i){
                            if (array[i][property] === element) return i;
                        }
                        return -1;
                    }
                    // A sprintf implementation using %index (beginning at 1) to input
                    // arguments in the format string.
                    //
                    // Example:
                    //
                    //     // Unexpected function in token
                    //     sprintf('Unexpected %2 in %1.', 'token', 'function');
                    function sprintf(format) {
                        var args = slice.call(arguments, 1);
                        format = format.replace(/%(\d)/g, function(match, index) {
                            return '' + args[index - 1] || /* istanbul ignore next */ '';
                        });
                        return format;
                    }
                    // Polyfill for `Object.assign`.
                    var assign = /* istanbul ignore next */ function(dest) {
                        var args = slice.call(arguments, 1), src, prop;
                        for(var i = 0, length = args.length; i < length; ++i){
                            src = args[i];
                            for(prop in src)/* istanbul ignore else */ if (Object.prototype.hasOwnProperty.call(src, prop)) {
                                dest[prop] = src[prop];
                            }
                        }
                        return dest;
                    };
                    /* istanbul ignore else */ if (Object.assign) assign = Object.assign;
                    // ### Error functions
                    exports1.SyntaxError = SyntaxError;
                    // XXX: Eliminate this function and change the error type to be different from SyntaxError.
                    // This will unfortunately be a breaking change, because some downstream users depend
                    // on the error thrown being an instance of SyntaxError. For example, the Ace editor:
                    // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>
                    function fixupError(e) {
                        /* istanbul ignore if */ if (!Object.create) return e;
                        return Object.create(e, {
                            'line': {
                                'writable': true,
                                value: e.line
                            },
                            'index': {
                                'writable': true,
                                value: e.index
                            },
                            'column': {
                                'writable': true,
                                value: e.column
                            }
                        });
                    }
                    // #### Raise an exception.
                    //
                    // Raise an exception by passing a token, a string format and its paramters.
                    //
                    // The passed tokens location will automatically be added to the error
                    // message if it exists, if not it will default to the lexers current
                    // position.
                    //
                    // Example:
                    //
                    //     // [1:0] expected [ near (
                    //     raise(token, "expected %1 near %2", '[', token.value);
                    function raise(token) {
                        var message = sprintf.apply(null, slice.call(arguments, 1)), error, col;
                        if (token === null || typeof token.line === 'undefined') {
                            col = index - lineStart + 1;
                            error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));
                            error.index = index;
                            error.line = line;
                            error.column = col;
                        } else {
                            col = token.range[0] - token.lineStart;
                            error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));
                            error.line = token.line;
                            error.index = token.range[0];
                            error.column = col;
                        }
                        throw error;
                    }
                    function tokenValue(token) {
                        var raw = input.slice(token.range[0], token.range[1]);
                        if (raw) return raw;
                        return token.value;
                    }
                    // #### Raise an unexpected token error.
                    //
                    // Example:
                    //
                    //     // expected <name> near '0'
                    //     raiseUnexpectedToken('<name>', token);
                    function raiseUnexpectedToken(type, token) {
                        raise(token, errors.expectedToken, type, tokenValue(token));
                    }
                    // #### Raise a general unexpected error
                    //
                    // Usage should pass either a token object or a symbol string which was
                    // expected. We can also specify a nearby token such as <eof>, this will
                    // default to the currently active token.
                    //
                    // Example:
                    //
                    //     // Unexpected symbol 'end' near '<eof>'
                    //     unexpected(token);
                    //
                    // If there's no token in the buffer it means we have reached <eof>.
                    function unexpected(found) {
                        var near = tokenValue(lookahead);
                        if ('undefined' !== typeof found.type) {
                            var type;
                            switch(found.type){
                                case StringLiteral:
                                    type = 'string';
                                    break;
                                case Keyword:
                                    type = 'keyword';
                                    break;
                                case Identifier:
                                    type = 'identifier';
                                    break;
                                case NumericLiteral:
                                    type = 'number';
                                    break;
                                case Punctuator:
                                    type = 'symbol';
                                    break;
                                case BooleanLiteral:
                                    type = 'boolean';
                                    break;
                                case NilLiteral:
                                    return raise(found, errors.unexpected, 'symbol', 'nil', near);
                                case EOF:
                                    return raise(found, errors.unexpectedEOF);
                            }
                            return raise(found, errors.unexpected, type, tokenValue(found), near);
                        }
                        return raise(found, errors.unexpected, 'symbol', found, near);
                    }
                    // Lexer
                    // -----
                    //
                    // The lexer, or the tokenizer reads the input string character by character
                    // and derives a token left-right. To be as efficient as possible the lexer
                    // prioritizes the common cases such as identifiers. It also works with
                    // character codes instead of characters as string comparisons was the
                    // biggest bottleneck of the parser.
                    //
                    // If `options.comments` is enabled, all comments encountered will be stored
                    // in an array which later will be appended to the chunk object. If disabled,
                    // they will simply be disregarded.
                    //
                    // When the lexer has derived a valid token, it will be returned as an object
                    // containing its value and as well as its position in the input string (this
                    // is always enabled to provide proper debug messages).
                    //
                    // `lex()` starts lexing and returns the following token in the stream.
                    var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;
                    exports1.lex = lex;
                    function lex() {
                        skipWhiteSpace();
                        // Skip comments beginning with --
                        while(45 === input.charCodeAt(index) && 45 === input.charCodeAt(index + 1)){
                            scanComment();
                            skipWhiteSpace();
                        }
                        if (index >= length) return {
                            type: EOF,
                            value: '<eof>',
                            line: line,
                            lineStart: lineStart,
                            range: [
                                index,
                                index
                            ]
                        };
                        var charCode = input.charCodeAt(index), next = input.charCodeAt(index + 1);
                        // Memorize the range index where the token begins.
                        tokenStart = index;
                        if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();
                        switch(charCode){
                            case 39:
                            case 34:
                                return scanStringLiteral();
                            case 48:
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                            case 56:
                            case 57:
                                return scanNumericLiteral();
                            case 46:
                                // If the dot is followed by a digit it's a float.
                                if (isDecDigit(next)) return scanNumericLiteral();
                                if (46 === next) {
                                    if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();
                                    return scanPunctuator('..');
                                }
                                return scanPunctuator('.');
                            case 61:
                                if (61 === next) return scanPunctuator('==');
                                return scanPunctuator('=');
                            case 62:
                                if (features.bitwiseOperators) {
                                    if (62 === next) return scanPunctuator('>>');
                                }
                                if (61 === next) return scanPunctuator('>=');
                                return scanPunctuator('>');
                            case 60:
                                if (features.bitwiseOperators) {
                                    if (60 === next) return scanPunctuator('<<');
                                }
                                if (61 === next) return scanPunctuator('<=');
                                return scanPunctuator('<');
                            case 126:
                                if (61 === next) return scanPunctuator('~=');
                                if (!features.bitwiseOperators) break;
                                return scanPunctuator('~');
                            case 58:
                                if (features.labels) {
                                    if (58 === next) return scanPunctuator('::');
                                }
                                return scanPunctuator(':');
                            case 91:
                                // Check for a multiline string, they begin with [= or [[
                                if (91 === next || 61 === next) return scanLongStringLiteral();
                                return scanPunctuator('[');
                            case 47:
                                // Check for integer division op (//)
                                if (features.integerDivision) {
                                    if (47 === next) return scanPunctuator('//');
                                }
                                return scanPunctuator('/');
                            case 38:
                            case 124:
                                if (!features.bitwiseOperators) break;
                            /* fall through */ case 42:
                            case 94:
                            case 37:
                            case 44:
                            case 123:
                            case 125:
                            case 93:
                            case 40:
                            case 41:
                            case 59:
                            case 35:
                            case 45:
                            case 43:
                                return scanPunctuator(input.charAt(index));
                        }
                        return unexpected(input.charAt(index));
                    }
                    // Whitespace has no semantic meaning in lua so simply skip ahead while
                    // tracking the encounted newlines. Any kind of eol sequence is counted as a
                    // single line.
                    function consumeEOL() {
                        var charCode = input.charCodeAt(index), peekCharCode = input.charCodeAt(index + 1);
                        if (isLineTerminator(charCode)) {
                            // Count \n\r and \r\n as one newline.
                            if (10 === charCode && 13 === peekCharCode) ++index;
                            if (13 === charCode && 10 === peekCharCode) ++index;
                            ++line;
                            lineStart = ++index;
                            return true;
                        }
                        return false;
                    }
                    function skipWhiteSpace() {
                        while(index < length){
                            var charCode = input.charCodeAt(index);
                            if (isWhiteSpace(charCode)) {
                                ++index;
                            } else if (!consumeEOL()) {
                                break;
                            }
                        }
                    }
                    // Identifiers, keywords, booleans and nil all look the same syntax wise. We
                    // simply go through them one by one and defaulting to an identifier if no
                    // previous case matched.
                    function scanIdentifierOrKeyword() {
                        var value, type;
                        // Slicing the input string is prefered before string concatenation in a
                        // loop for performance reasons.
                        while(isIdentifierPart(input.charCodeAt(++index)));
                        value = encodingMode.fixup(input.slice(tokenStart, index));
                        // Decide on the token type and possibly cast the value.
                        if (isKeyword(value)) {
                            type = Keyword;
                        } else if ('true' === value || 'false' === value) {
                            type = BooleanLiteral;
                            value = 'true' === value;
                        } else if ('nil' === value) {
                            type = NilLiteral;
                            value = null;
                        } else {
                            type = Identifier;
                        }
                        return {
                            type: type,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Once a punctuator reaches this function it should already have been
                    // validated so we simply return it as a token.
                    function scanPunctuator(value) {
                        index += value.length;
                        return {
                            type: Punctuator,
                            value: value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // A vararg literal consists of three dots.
                    function scanVarargLiteral() {
                        index += 3;
                        return {
                            type: VarargLiteral,
                            value: '...',
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Find the string literal by matching the delimiter marks used.
                    function scanStringLiteral() {
                        var delimiter = input.charCodeAt(index++), beginLine = line, beginLineStart = lineStart, stringStart = index, string = encodingMode.discardStrings ? null : '', charCode;
                        for(;;){
                            charCode = input.charCodeAt(index++);
                            if (delimiter === charCode) break;
                            // EOF or `\n` terminates a string literal. If we haven't found the
                            // ending delimiter by now, raise an exception.
                            if (index > length || isLineTerminator(charCode)) {
                                string += input.slice(stringStart, index - 1);
                                raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));
                            }
                            if (92 === charCode) {
                                if (!encodingMode.discardStrings) {
                                    var beforeEscape = input.slice(stringStart, index - 1);
                                    string += encodingMode.fixup(beforeEscape);
                                }
                                var escapeValue = readEscapeSequence();
                                if (!encodingMode.discardStrings) string += escapeValue;
                                stringStart = index;
                            }
                        }
                        if (!encodingMode.discardStrings) {
                            string += encodingMode.encodeByte(null);
                            string += encodingMode.fixup(input.slice(stringStart, index - 1));
                        }
                        return {
                            type: StringLiteral,
                            value: string,
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Expect a multiline string literal and return it as a regular string
                    // literal, if it doesn't validate into a valid multiline string, throw an
                    // exception.
                    function scanLongStringLiteral() {
                        var beginLine = line, beginLineStart = lineStart, string = readLongString(false);
                        // Fail if it's not a multiline literal.
                        if (false === string) raise(token, errors.expected, '[', tokenValue(token));
                        return {
                            type: StringLiteral,
                            value: encodingMode.discardStrings ? null : encodingMode.fixup(string),
                            line: beginLine,
                            lineStart: beginLineStart,
                            lastLine: line,
                            lastLineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    // Numeric literals will be returned as floating-point numbers instead of
                    // strings. The raw value should be retrieved from slicing the input string
                    // later on in the process.
                    //
                    // If a hexadecimal number is encountered, it will be converted.
                    function scanNumericLiteral() {
                        var character = input.charAt(index), next = input.charAt(index + 1);
                        var literal = '0' === character && 'xX'.indexOf(next || null) >= 0 ? readHexLiteral() : readDecLiteral();
                        var foundImaginaryUnit = readImaginaryUnitSuffix(), foundInt64Suffix = readInt64Suffix();
                        if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {
                            raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        }
                        return {
                            type: NumericLiteral,
                            value: literal.value,
                            line: line,
                            lineStart: lineStart,
                            range: [
                                tokenStart,
                                index
                            ]
                        };
                    }
                    function readImaginaryUnitSuffix() {
                        if (!features.imaginaryNumbers) return;
                        // Imaginary unit number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ('iI'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            return true;
                        } else {
                            return false;
                        }
                    }
                    function readInt64Suffix() {
                        if (!features.integerSuffixes) return;
                        // Int64/uint64 number suffix is optional.
                        // See http://luajit.org/ext_ffi_api.html#literals
                        if ('uU'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                    ++index;
                                    return 'ULL';
                                } else {
                                    // UL but no L
                                    raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                                }
                            } else {
                                // U but no L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                            ++index;
                            if ('lL'.indexOf(input.charAt(index) || null) >= 0) {
                                ++index;
                                return 'LL';
                            } else {
                                // First L but no second L
                                raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            }
                        }
                    }
                    // Lua hexadecimals have an optional fraction part and an optional binary
                    // exoponent part. These are not included in JavaScript so we will compute
                    // all three parts separately and then sum them up at the end of the function
                    // with the following algorithm.
                    //
                    //     Digit := toDec(digit)
                    //     Fraction := toDec(fraction) / 16 ^ fractionCount
                    //     BinaryExp := 2 ^ binaryExp
                    //     Number := ( Digit + Fraction ) * BinaryExp
                    function readHexLiteral() {
                        var fraction = 0 // defaults to 0 as it gets summed
                        , binaryExponent = 1 // defaults to 1 as it gets multiplied
                        , binarySign = 1 // positive
                        , digit, fractionStart, exponentStart, digitStart;
                        digitStart = index += 2; // Skip 0x part
                        // A minimum of one hex digit is required.
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                        while(isHexDigit(input.charCodeAt(index)))++index;
                        // Convert the hexadecimal digit to base 10.
                        digit = parseInt(input.slice(digitStart, index), 16);
                        // Fraction part is optional.
                        var foundFraction = false;
                        if ('.' === input.charAt(index)) {
                            foundFraction = true;
                            fractionStart = ++index;
                            while(isHexDigit(input.charCodeAt(index)))++index;
                            fraction = input.slice(fractionStart, index);
                            // Empty fraction parts should default to 0, others should be converted
                            // 0.x form so we can use summation at the end.
                            fraction = fractionStart === index ? 0 : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);
                        }
                        // Binary exponents are optional
                        var foundBinaryExponent = false;
                        if ('pP'.indexOf(input.charAt(index) || null) >= 0) {
                            foundBinaryExponent = true;
                            ++index;
                            // Sign part is optional and defaults to 1 (positive).
                            if ('+-'.indexOf(input.charAt(index) || null) >= 0) binarySign = '+' === input.charAt(index++) ? 1 : -1;
                            exponentStart = index;
                            // The binary exponent sign requires a decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                            binaryExponent = input.slice(exponentStart, index);
                            // Calculate the binary exponent of the number.
                            binaryExponent = Math.pow(2, binaryExponent * binarySign);
                        }
                        return {
                            value: (digit + fraction) * binaryExponent,
                            hasFractionPart: foundFraction || foundBinaryExponent
                        };
                    }
                    // Decimal numbers are exactly the same in Lua and in JavaScript, because of
                    // this we check where the token ends and then parse it with native
                    // functions.
                    function readDecLiteral() {
                        while(isDecDigit(input.charCodeAt(index)))++index;
                        // Fraction part is optional
                        var foundFraction = false;
                        if ('.' === input.charAt(index)) {
                            foundFraction = true;
                            ++index;
                            // Fraction part defaults to 0
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        // Exponent part is optional.
                        var foundExponent = false;
                        if ('eE'.indexOf(input.charAt(index) || null) >= 0) {
                            foundExponent = true;
                            ++index;
                            // Sign part is optional.
                            if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;
                            // An exponent is required to contain at least one decimal digit.
                            if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));
                            while(isDecDigit(input.charCodeAt(index)))++index;
                        }
                        return {
                            value: parseFloat(input.slice(tokenStart, index)),
                            hasFractionPart: foundFraction || foundExponent
                        };
                    }
                    function readUnicodeEscapeSequence() {
                        var sequenceStart = index++;
                        if (input.charAt(index++) !== '{') raise(null, errors.braceExpected, '{', '\\' + input.slice(sequenceStart, index));
                        if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));
                        while(input.charCodeAt(index) === 0x30)++index;
                        var escStart = index;
                        while(isHexDigit(input.charCodeAt(index))){
                            ++index;
                            if (index - escStart > 6) raise(null, errors.tooLargeCodepoint, '\\' + input.slice(sequenceStart, index));
                        }
                        var b = input.charAt(index++);
                        if (b !== '}') {
                            if (b === '"' || b === "'") raise(null, errors.braceExpected, '}', '\\' + input.slice(sequenceStart, index--));
                            else raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index));
                        }
                        var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);
                        var frag = '\\' + input.slice(sequenceStart, index);
                        if (codepoint > 0x10ffff) {
                            raise(null, errors.tooLargeCodepoint, frag);
                        }
                        return encodingMode.encodeUTF8(codepoint, frag);
                    }
                    // Translate escape sequences to the actual characters.
                    function readEscapeSequence() {
                        var sequenceStart = index;
                        switch(input.charAt(index)){
                            // Lua allow the following escape sequences.
                            case 'a':
                                ++index;
                                return '\x07';
                            case 'n':
                                ++index;
                                return '\n';
                            case 'r':
                                ++index;
                                return '\r';
                            case 't':
                                ++index;
                                return '\t';
                            case 'v':
                                ++index;
                                return '\x0b';
                            case 'b':
                                ++index;
                                return '\b';
                            case 'f':
                                ++index;
                                return '\f';
                            // Backslash at the end of the line. We treat all line endings as equivalent,
                            // and as representing the [LF] character (code 10). Lua 5.1 through 5.3
                            // have been verified to behave the same way.
                            case '\r':
                            case '\n':
                                consumeEOL();
                                return '\n';
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                                // \ddd, where ddd is a sequence of up to three decimal digits.
                                while(isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3)++index;
                                var frag = input.slice(sequenceStart, index);
                                var ddd = parseInt(frag, 10);
                                if (ddd > 255) {
                                    raise(null, errors.decimalEscapeTooLarge, '\\' + ddd);
                                }
                                return encodingMode.encodeByte(ddd, '\\' + frag);
                            case 'z':
                                if (features.skipWhitespaceEscape) {
                                    ++index;
                                    skipWhiteSpace();
                                    return '';
                                }
                                break;
                            case 'x':
                                if (features.hexEscapes) {
                                    // \xXX, where XX is a sequence of exactly two hexadecimal digits
                                    if (isHexDigit(input.charCodeAt(index + 1)) && isHexDigit(input.charCodeAt(index + 2))) {
                                        index += 3;
                                        return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\' + input.slice(sequenceStart, index));
                                    }
                                    raise(null, errors.hexadecimalDigitExpected, '\\' + input.slice(sequenceStart, index + 2));
                                }
                                break;
                            case 'u':
                                if (features.unicodeEscapes) return readUnicodeEscapeSequence();
                                break;
                            case '\\':
                            case '"':
                            case "'":
                                return input.charAt(index++);
                        }
                        if (features.strictEscapes) raise(null, errors.invalidEscape, '\\' + input.slice(sequenceStart, index + 1));
                        return input.charAt(index++);
                    }
                    // Comments begin with -- after which it will be decided if they are
                    // multiline comments or not.
                    //
                    // The multiline functionality works the exact same way as with string
                    // literals so we reuse the functionality.
                    function scanComment() {
                        tokenStart = index;
                        index += 2; // --
                        var character = input.charAt(index), content = '', isLong = false, commentStart = index, lineStartComment = lineStart, lineComment = line;
                        if ('[' === character) {
                            content = readLongString(true);
                            // This wasn't a multiline comment after all.
                            if (false === content) content = character;
                            else isLong = true;
                        }
                        // Scan until next line as long as it's not a multiline comment.
                        if (!isLong) {
                            while(index < length){
                                if (isLineTerminator(input.charCodeAt(index))) break;
                                ++index;
                            }
                            if (options.comments) content = input.slice(commentStart, index);
                        }
                        if (options.comments) {
                            var node = ast.comment(content, input.slice(tokenStart, index));
                            // `Marker`s depend on tokens available in the parser and as comments are
                            // intercepted in the lexer all location data is set manually.
                            if (options.locations) {
                                node.loc = {
                                    start: {
                                        line: lineComment,
                                        column: tokenStart - lineStartComment
                                    },
                                    end: {
                                        line: line,
                                        column: index - lineStart
                                    }
                                };
                            }
                            if (options.ranges) {
                                node.range = [
                                    tokenStart,
                                    index
                                ];
                            }
                            if (options.onCreateNode) options.onCreateNode(node);
                            comments.push(node);
                        }
                    }
                    // Read a multiline string by calculating the depth of `=` characters and
                    // then appending until an equal depth is found.
                    function readLongString(isComment) {
                        var level = 0, content = '', terminator = false, character, stringStart, firstLine = line;
                        ++index; // [
                        // Calculate the depth of the comment.
                        while('=' === input.charAt(index + level))++level;
                        // Exit, this is not a long string afterall.
                        if ('[' !== input.charAt(index + level)) return false;
                        index += level + 1;
                        // If the first character is a newline, ignore it and begin on next line.
                        if (isLineTerminator(input.charCodeAt(index))) consumeEOL();
                        stringStart = index;
                        while(index < length){
                            // To keep track of line numbers run the `consumeEOL()` which increments
                            // its counter.
                            while(isLineTerminator(input.charCodeAt(index)))consumeEOL();
                            character = input.charAt(index++);
                            // Once the delimiter is found, iterate through the depth count and see
                            // if it matches.
                            if (']' === character) {
                                terminator = true;
                                for(var i = 0; i < level; ++i){
                                    if ('=' !== input.charAt(index + i)) terminator = false;
                                }
                                if (']' !== input.charAt(index + level)) terminator = false;
                            }
                            // We reached the end of the multiline string. Get out now.
                            if (terminator) {
                                content += input.slice(stringStart, index - 1);
                                index += level + 1;
                                return content;
                            }
                        }
                        raise(null, isComment ? errors.unfinishedLongComment : errors.unfinishedLongString, firstLine, '<eof>');
                    }
                    // ## Lex functions and helpers.
                    // Read the next token.
                    //
                    // This is actually done by setting the current token to the lookahead and
                    // reading in the new lookahead token.
                    function next() {
                        previousToken = token;
                        token = lookahead;
                        lookahead = lex();
                    }
                    // Consume a token if its value matches. Once consumed or not, return the
                    // success of the operation.
                    function consume(value) {
                        if (value === token.value) {
                            next();
                            return true;
                        }
                        return false;
                    }
                    // Expect the next token value to match. If not, throw an exception.
                    function expect(value) {
                        if (value === token.value) next();
                        else raise(token, errors.expected, value, tokenValue(token));
                    }
                    // ### Validation functions
                    function isWhiteSpace(charCode) {
                        return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;
                    }
                    function isLineTerminator(charCode) {
                        return 10 === charCode || 13 === charCode;
                    }
                    function isDecDigit(charCode) {
                        return charCode >= 48 && charCode <= 57;
                    }
                    function isHexDigit(charCode) {
                        return charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70;
                    }
                    // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards
                    // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).
                    // On the other hand, LuaJIT allows arbitrary octets ≥ 128 in identifiers.
                    function isIdentifierStart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    }
                    function isIdentifierPart(charCode) {
                        if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode || charCode >= 48 && charCode <= 57) return true;
                        if (features.extendedIdentifiers && charCode >= 128) return true;
                        return false;
                    }
                    // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)
                    //
                    // `true`, `false` and `nil` will not be considered keywords, but literals.
                    function isKeyword(id) {
                        switch(id.length){
                            case 2:
                                return 'do' === id || 'if' === id || 'in' === id || 'or' === id;
                            case 3:
                                return 'and' === id || 'end' === id || 'for' === id || 'not' === id;
                            case 4:
                                if ('else' === id || 'then' === id) return true;
                                if (features.labels && !features.contextualGoto) return 'goto' === id;
                                return false;
                            case 5:
                                return 'break' === id || 'local' === id || 'until' === id || 'while' === id;
                            case 6:
                                return 'elseif' === id || 'repeat' === id || 'return' === id;
                            case 8:
                                return 'function' === id;
                        }
                        return false;
                    }
                    function isUnary(token) {
                        if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;
                        if (Keyword === token.type) return 'not' === token.value;
                        return false;
                    }
                    // Check if the token syntactically closes a block.
                    function isBlockFollow(token) {
                        if (EOF === token.type) return true;
                        if (Keyword !== token.type) return false;
                        switch(token.value){
                            case 'else':
                            case 'elseif':
                            case 'end':
                            case 'until':
                                return true;
                            default:
                                return false;
                        }
                    }
                    // Scope
                    // -----
                    // Store each block scope as a an array of identifier names. Each scope is
                    // stored in an FILO-array.
                    var scopes, scopeDepth, globals;
                    // Create a new scope inheriting all declarations from the previous scope.
                    function createScope() {
                        var scope = scopes[scopeDepth++].slice();
                        scopes.push(scope);
                        if (options.onCreateScope) options.onCreateScope();
                    }
                    // Exit and remove the current scope.
                    function destroyScope() {
                        var scope = scopes.pop();
                        --scopeDepth;
                        if (options.onDestroyScope) options.onDestroyScope();
                    }
                    // Add identifier name to the current scope if it doesnt already exist.
                    function scopeIdentifierName(name) {
                        if (options.onLocalDeclaration) options.onLocalDeclaration(name);
                        if (-1 !== indexOf(scopes[scopeDepth], name)) return;
                        scopes[scopeDepth].push(name);
                    }
                    // Add identifier to the current scope
                    function scopeIdentifier(node) {
                        scopeIdentifierName(node.name);
                        attachScope(node, true);
                    }
                    // Attach scope information to node. If the node is global, store it in the
                    // globals array so we can return the information to the user.
                    function attachScope(node, isLocal) {
                        if (!isLocal && -1 === indexOfObject(globals, 'name', node.name)) globals.push(node);
                        node.isLocal = isLocal;
                    }
                    // Is the identifier name available in this scope.
                    function scopeHasName(name) {
                        return -1 !== indexOf(scopes[scopeDepth], name);
                    }
                    // Location tracking
                    // -----------------
                    //
                    // Locations are stored in FILO-array as a `Marker` object consisting of both
                    // `loc` and `range` data. Once a `Marker` is popped off the list an end
                    // location is added and the data is attached to a syntax node.
                    var locations = [], trackLocations;
                    function createLocationMarker() {
                        return new Marker(token);
                    }
                    function Marker(token) {
                        if (options.locations) {
                            this.loc = {
                                start: {
                                    line: token.line,
                                    column: token.range[0] - token.lineStart
                                },
                                end: {
                                    line: 0,
                                    column: 0
                                }
                            };
                        }
                        if (options.ranges) this.range = [
                            token.range[0],
                            0
                        ];
                    }
                    // Complete the location data stored in the `Marker` by adding the location
                    // of the *previous token* as an end location.
                    Marker.prototype.complete = function() {
                        if (options.locations) {
                            this.loc.end.line = previousToken.lastLine || previousToken.line;
                            this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);
                        }
                        if (options.ranges) {
                            this.range[1] = previousToken.range[1];
                        }
                    };
                    Marker.prototype.bless = function(node) {
                        if (this.loc) {
                            var loc = this.loc;
                            node.loc = {
                                start: {
                                    line: loc.start.line,
                                    column: loc.start.column
                                },
                                end: {
                                    line: loc.end.line,
                                    column: loc.end.column
                                }
                            };
                        }
                        if (this.range) {
                            node.range = [
                                this.range[0],
                                this.range[1]
                            ];
                        }
                    };
                    // Create a new `Marker` and add it to the FILO-array.
                    function markLocation() {
                        if (trackLocations) locations.push(createLocationMarker());
                    }
                    // Push an arbitrary `Marker` object onto the FILO-array.
                    function pushLocation(marker) {
                        if (trackLocations) locations.push(marker);
                    }
                    // Control flow tracking
                    // ---------------------
                    // A context object that validates loop breaks and `goto`-based control flow.
                    function FullFlowContext() {
                        this.scopes = [];
                        this.pendingGotos = [];
                    }
                    FullFlowContext.prototype.isInLoop = function() {
                        var i = this.scopes.length;
                        while(i-- > 0){
                            if (this.scopes[i].isLoop) return true;
                        }
                        return false;
                    };
                    FullFlowContext.prototype.pushScope = function(isLoop) {
                        var scope = {
                            labels: {},
                            locals: [],
                            deferredGotos: [],
                            isLoop: !!isLoop
                        };
                        this.scopes.push(scope);
                    };
                    FullFlowContext.prototype.popScope = function() {
                        for(var i = 0; i < this.pendingGotos.length; ++i){
                            var theGoto = this.pendingGotos[i];
                            if (theGoto.maxDepth >= this.scopes.length) {
                                if (--theGoto.maxDepth <= 0) raise(theGoto.token, errors.labelNotVisible, theGoto.target);
                            }
                        }
                        this.scopes.pop();
                    };
                    FullFlowContext.prototype.addGoto = function(target, token) {
                        var localCounts = [];
                        for(var i = 0; i < this.scopes.length; ++i){
                            var scope = this.scopes[i];
                            localCounts.push(scope.locals.length);
                            if (Object.prototype.hasOwnProperty.call(scope.labels, target)) return;
                        }
                        this.pendingGotos.push({
                            maxDepth: this.scopes.length,
                            target: target,
                            token: token,
                            localCounts: localCounts
                        });
                    };
                    FullFlowContext.prototype.addLabel = function(name, token) {
                        var scope = this.currentScope();
                        if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {
                            raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);
                        } else {
                            var newGotos = [];
                            for(var i = 0; i < this.pendingGotos.length; ++i){
                                var theGoto = this.pendingGotos[i];
                                if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {
                                    if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {
                                        scope.deferredGotos.push(theGoto);
                                    }
                                    continue;
                                }
                                newGotos.push(theGoto);
                            }
                            this.pendingGotos = newGotos;
                        }
                        scope.labels[name] = {
                            localCount: scope.locals.length,
                            line: token.line
                        };
                    };
                    FullFlowContext.prototype.addLocal = function(name, token) {
                        this.currentScope().locals.push({
                            name: name,
                            token: token
                        });
                    };
                    FullFlowContext.prototype.currentScope = function() {
                        return this.scopes[this.scopes.length - 1];
                    };
                    FullFlowContext.prototype.raiseDeferredErrors = function() {
                        var scope = this.currentScope();
                        var bads = scope.deferredGotos;
                        for(var i = 0; i < bads.length; ++i){
                            var theGoto = bads[i];
                            raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);
                        }
                    // Would be dead code currently, but may be useful later
                    // if (bads.length)
                    //   scope.deferredGotos = [];
                    };
                    // Simplified context that only checks the validity of loop breaks.
                    function LoopFlowContext() {
                        this.level = 0;
                        this.loopLevels = [];
                    }
                    LoopFlowContext.prototype.isInLoop = function() {
                        return !!this.loopLevels.length;
                    };
                    LoopFlowContext.prototype.pushScope = function(isLoop) {
                        ++this.level;
                        if (isLoop) this.loopLevels.push(this.level);
                    };
                    LoopFlowContext.prototype.popScope = function() {
                        var levels = this.loopLevels;
                        var levlen = levels.length;
                        if (levlen) {
                            if (levels[levlen - 1] === this.level) levels.pop();
                        }
                        --this.level;
                    };
                    LoopFlowContext.prototype.addGoto = LoopFlowContext.prototype.addLabel = /* istanbul ignore next */ function() {
                        throw new Error('This should never happen');
                    };
                    LoopFlowContext.prototype.addLocal = LoopFlowContext.prototype.raiseDeferredErrors = function() {};
                    function makeFlowContext() {
                        return features.labels ? new FullFlowContext() : new LoopFlowContext();
                    }
                    // Parse functions
                    // ---------------
                    // Chunk is the main program object. Syntactically it's the same as a block.
                    //
                    //     chunk ::= block
                    function parseChunk() {
                        next();
                        markLocation();
                        if (options.scope) createScope();
                        var flowContext = makeFlowContext();
                        flowContext.allowVararg = true;
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        if (EOF !== token.type) unexpected(token);
                        // If the body is empty no previousToken exists when finishNode runs.
                        if (trackLocations && !body.length) previousToken = token;
                        return finishNode(ast.chunk(body));
                    }
                    // A block contains a list of statements with an optional return statement
                    // as its last statement.
                    //
                    //     block ::= {stat} [retstat]
                    function parseBlock(flowContext) {
                        var block = [], statement;
                        while(!isBlockFollow(token)){
                            // Return has to be the last statement in a block.
                            // Likewise 'break' in Lua older than 5.2
                            if ('return' === token.value || !features.relaxedBreak && 'break' === token.value) {
                                block.push(parseStatement(flowContext));
                                break;
                            }
                            statement = parseStatement(flowContext);
                            consume(';');
                            // Statements are only added if they are returned, this allows us to
                            // ignore some statements, such as EmptyStatement.
                            if (statement) block.push(statement);
                        }
                        // Doesn't really need an ast node
                        return block;
                    }
                    // There are two types of statements, simple and compound.
                    //
                    //     statement ::= break | goto | do | while | repeat | return
                    //          | if | for | function | local | label | assignment
                    //          | functioncall | ';'
                    function parseStatement(flowContext) {
                        markLocation();
                        if (Punctuator === token.type) {
                            if (consume('::')) return parseLabelStatement(flowContext);
                        }
                        // When a `;` is encounted, simply eat it without storing it.
                        if (features.emptyStatement) {
                            if (consume(';')) {
                                if (trackLocations) locations.pop();
                                return;
                            }
                        }
                        flowContext.raiseDeferredErrors();
                        if (Keyword === token.type) {
                            switch(token.value){
                                case 'local':
                                    next();
                                    return parseLocalStatement(flowContext);
                                case 'if':
                                    next();
                                    return parseIfStatement(flowContext);
                                case 'return':
                                    next();
                                    return parseReturnStatement(flowContext);
                                case 'function':
                                    next();
                                    var name = parseFunctionName();
                                    return parseFunctionDeclaration(name);
                                case 'while':
                                    next();
                                    return parseWhileStatement(flowContext);
                                case 'for':
                                    next();
                                    return parseForStatement(flowContext);
                                case 'repeat':
                                    next();
                                    return parseRepeatStatement(flowContext);
                                case 'break':
                                    next();
                                    if (!flowContext.isInLoop()) raise(token, errors.noLoopToBreak, token.value);
                                    return parseBreakStatement();
                                case 'do':
                                    next();
                                    return parseDoStatement(flowContext);
                                case 'goto':
                                    next();
                                    return parseGotoStatement(flowContext);
                            }
                        }
                        if (features.contextualGoto && token.type === Identifier && token.value === 'goto' && lookahead.type === Identifier && lookahead.value !== 'goto') {
                            next();
                            return parseGotoStatement(flowContext);
                        }
                        // Assignments memorizes the location and pushes it manually for wrapper nodes.
                        if (trackLocations) locations.pop();
                        return parseAssignmentOrCallStatement(flowContext);
                    }
                    // ## Statements
                    //     label ::= '::' Name '::'
                    function parseLabelStatement(flowContext) {
                        var nameToken = token, label = parseIdentifier();
                        if (options.scope) {
                            scopeIdentifierName('::' + nameToken.value + '::');
                            attachScope(label, true);
                        }
                        expect('::');
                        flowContext.addLabel(nameToken.value, nameToken);
                        return finishNode(ast.labelStatement(label));
                    }
                    //     break ::= 'break'
                    function parseBreakStatement() {
                        return finishNode(ast.breakStatement());
                    }
                    //     goto ::= 'goto' Name
                    function parseGotoStatement(flowContext) {
                        var name = token.value, gotoToken = previousToken, label = parseIdentifier();
                        flowContext.addGoto(name, gotoToken);
                        return finishNode(ast.gotoStatement(label));
                    }
                    //     do ::= 'do' block 'end'
                    function parseDoStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect('end');
                        return finishNode(ast.doStatement(body));
                    }
                    //     while ::= 'while' exp 'do' block 'end'
                    function parseWhileStatement(flowContext) {
                        var condition = parseExpectedExpression(flowContext);
                        expect('do');
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        expect('end');
                        return finishNode(ast.whileStatement(condition, body));
                    }
                    //     repeat ::= 'repeat' block 'until' exp
                    function parseRepeatStatement(flowContext) {
                        if (options.scope) createScope();
                        flowContext.pushScope(true);
                        var body = parseBlock(flowContext);
                        expect('until');
                        flowContext.raiseDeferredErrors();
                        var condition = parseExpectedExpression(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        return finishNode(ast.repeatStatement(condition, body));
                    }
                    //     retstat ::= 'return' [exp {',' exp}] [';']
                    function parseReturnStatement(flowContext) {
                        var expressions = [];
                        if ('end' !== token.value) {
                            var expression = parseExpression(flowContext);
                            if (null != expression) expressions.push(expression);
                            while(consume(',')){
                                expression = parseExpectedExpression(flowContext);
                                expressions.push(expression);
                            }
                            consume(';'); // grammar tells us ; is optional here.
                        }
                        return finishNode(ast.returnStatement(expressions));
                    }
                    //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'
                    //     elif ::= 'elseif' exp 'then' block
                    function parseIfStatement(flowContext) {
                        var clauses = [], condition, body, marker;
                        // IfClauses begin at the same location as the parent IfStatement.
                        // It ends at the start of `end`, `else`, or `elseif`.
                        if (trackLocations) {
                            marker = locations[locations.length - 1];
                            locations.push(marker);
                        }
                        condition = parseExpectedExpression(flowContext);
                        expect('then');
                        if (options.scope) createScope();
                        flowContext.pushScope();
                        body = parseBlock(flowContext);
                        flowContext.popScope();
                        if (options.scope) destroyScope();
                        clauses.push(finishNode(ast.ifClause(condition, body)));
                        if (trackLocations) marker = createLocationMarker();
                        while(consume('elseif')){
                            pushLocation(marker);
                            condition = parseExpectedExpression(flowContext);
                            expect('then');
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseifClause(condition, body)));
                            if (trackLocations) marker = createLocationMarker();
                        }
                        if (consume('else')) {
                            // Include the `else` in the location of ElseClause.
                            if (trackLocations) {
                                marker = new Marker(previousToken);
                                locations.push(marker);
                            }
                            if (options.scope) createScope();
                            flowContext.pushScope();
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            if (options.scope) destroyScope();
                            clauses.push(finishNode(ast.elseClause(body)));
                        }
                        expect('end');
                        return finishNode(ast.ifStatement(clauses));
                    }
                    // There are two types of for statements, generic and numeric.
                    //
                    //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'
                    //     for ::= namelist 'in' explist 'do' block 'end'
                    //     namelist ::= Name {',' Name}
                    //     explist ::= exp {',' exp}
                    function parseForStatement(flowContext) {
                        var variable = parseIdentifier(), body;
                        // The start-identifier is local.
                        if (options.scope) {
                            createScope();
                            scopeIdentifier(variable);
                        }
                        // If the first expression is followed by a `=` punctuator, this is a
                        // Numeric For Statement.
                        if (consume('=')) {
                            // Start expression
                            var start = parseExpectedExpression(flowContext);
                            expect(',');
                            // End expression
                            var end = parseExpectedExpression(flowContext);
                            // Optional step expression
                            var step = consume(',') ? parseExpectedExpression(flowContext) : null;
                            expect('do');
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect('end');
                            if (options.scope) destroyScope();
                            return finishNode(ast.forNumericStatement(variable, start, end, step, body));
                        } else {
                            // The namelist can contain one or more identifiers.
                            var variables = [
                                variable
                            ];
                            while(consume(',')){
                                variable = parseIdentifier();
                                // Each variable in the namelist is locally scoped.
                                if (options.scope) scopeIdentifier(variable);
                                variables.push(variable);
                            }
                            expect('in');
                            var iterators = [];
                            // One or more expressions in the explist.
                            do {
                                var expression = parseExpectedExpression(flowContext);
                                iterators.push(expression);
                            }while (consume(','))
                            expect('do');
                            flowContext.pushScope(true);
                            body = parseBlock(flowContext);
                            flowContext.popScope();
                            expect('end');
                            if (options.scope) destroyScope();
                            return finishNode(ast.forGenericStatement(variables, iterators, body));
                        }
                    }
                    // Local statements can either be variable assignments or function
                    // definitions. If a function definition is found, it will be delegated to
                    // `parseFunctionDeclaration()` with the isLocal flag.
                    //
                    // This AST structure might change into a local assignment with a function
                    // child.
                    //
                    //     local ::= 'local' 'function' Name funcdecl
                    //        | 'local' Name {',' Name} ['=' exp {',' exp}]
                    function parseLocalStatement(flowContext) {
                        var name, declToken = previousToken;
                        if (Identifier === token.type) {
                            var variables = [], init = [];
                            do {
                                name = parseIdentifier();
                                variables.push(name);
                                flowContext.addLocal(name.name, declToken);
                            }while (consume(','))
                            if (consume('=')) {
                                do {
                                    var expression = parseExpectedExpression(flowContext);
                                    init.push(expression);
                                }while (consume(','))
                            }
                            // Declarations doesn't exist before the statement has been evaluated.
                            // Therefore assignments can't use their declarator. And the identifiers
                            // shouldn't be added to the scope until the statement is complete.
                            if (options.scope) {
                                for(var i = 0, l = variables.length; i < l; ++i){
                                    scopeIdentifier(variables[i]);
                                }
                            }
                            return finishNode(ast.localStatement(variables, init));
                        }
                        if (consume('function')) {
                            name = parseIdentifier();
                            flowContext.addLocal(name.name, declToken);
                            if (options.scope) {
                                scopeIdentifier(name);
                                createScope();
                            }
                            // MemberExpressions are not allowed in local function statements.
                            return parseFunctionDeclaration(name, true);
                        } else {
                            raiseUnexpectedToken('<name>', token);
                        }
                    }
                    //     assignment ::= varlist '=' explist
                    //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name
                    //     varlist ::= var {',' var}
                    //     explist ::= exp {',' exp}
                    //
                    //     call ::= callexp
                    //     callexp ::= prefixexp args | prefixexp ':' Name args
                    function parseAssignmentOrCallStatement(flowContext) {
                        // Keep a reference to the previous token for better error messages in case
                        // of invalid statement
                        var previous = token, marker, startMarker;
                        var lvalue, base, name;
                        var targets = [];
                        if (trackLocations) startMarker = createLocationMarker();
                        do {
                            if (trackLocations) marker = createLocationMarker();
                            if (Identifier === token.type) {
                                name = token.value;
                                base = parseIdentifier();
                                // Set the parent scope.
                                if (options.scope) attachScope(base, scopeHasName(name));
                                lvalue = true;
                            } else if ('(' === token.value) {
                                next();
                                base = parseExpectedExpression(flowContext);
                                expect(')');
                                lvalue = false;
                            } else {
                                return unexpected(token);
                            }
                            both: for(;;){
                                var newBase;
                                switch(StringLiteral === token.type ? '"' : token.value){
                                    case '.':
                                    case '[':
                                        lvalue = true;
                                        break;
                                    case ':':
                                    case '(':
                                    case '{':
                                    case '"':
                                        lvalue = null;
                                        break;
                                    default:
                                        break both;
                                }
                                base = parsePrefixExpressionPart(base, marker, flowContext);
                            }
                            targets.push(base);
                            if (',' !== token.value) break;
                            if (!lvalue) {
                                return unexpected(token);
                            }
                            next();
                        }while (true)
                        if (targets.length === 1 && lvalue === null) {
                            pushLocation(marker);
                            return finishNode(ast.callStatement(targets[0]));
                        } else if (!lvalue) {
                            return unexpected(token);
                        }
                        expect('=');
                        var values = [];
                        do {
                            values.push(parseExpectedExpression(flowContext));
                        }while (consume(','))
                        pushLocation(startMarker);
                        return finishNode(ast.assignmentStatement(targets, values));
                    }
                    // ### Non-statements
                    //     Identifier ::= Name
                    function parseIdentifier() {
                        markLocation();
                        var identifier = token.value;
                        if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);
                        next();
                        return finishNode(ast.identifier(identifier));
                    }
                    // Parse the functions parameters and body block. The name should already
                    // have been parsed and passed to this declaration function. By separating
                    // this we allow for anonymous functions in expressions.
                    //
                    // For local functions there's a boolean parameter which needs to be set
                    // when parsing the declaration.
                    //
                    //     funcdecl ::= '(' [parlist] ')' block 'end'
                    //     parlist ::= Name {',' Name} | [',' '...'] | '...'
                    function parseFunctionDeclaration(name, isLocal) {
                        var flowContext = makeFlowContext();
                        flowContext.pushScope();
                        var parameters = [];
                        expect('(');
                        // The declaration has arguments
                        if (!consume(')')) {
                            // Arguments are a comma separated list of identifiers, optionally ending
                            // with a vararg.
                            while(true){
                                if (Identifier === token.type) {
                                    var parameter = parseIdentifier();
                                    // Function parameters are local.
                                    if (options.scope) scopeIdentifier(parameter);
                                    parameters.push(parameter);
                                    if (consume(',')) continue;
                                } else if (VarargLiteral === token.type) {
                                    flowContext.allowVararg = true;
                                    parameters.push(parsePrimaryExpression(flowContext));
                                } else {
                                    raiseUnexpectedToken('<name> or \'...\'', token);
                                }
                                expect(')');
                                break;
                            }
                        }
                        var body = parseBlock(flowContext);
                        flowContext.popScope();
                        expect('end');
                        if (options.scope) destroyScope();
                        isLocal = isLocal || false;
                        return finishNode(ast.functionStatement(name, parameters, isLocal, body));
                    }
                    // Parse the function name as identifiers and member expressions.
                    //
                    //     Name {'.' Name} [':' Name]
                    function parseFunctionName() {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        base = parseIdentifier();
                        if (options.scope) {
                            attachScope(base, scopeHasName(base.name));
                            createScope();
                        }
                        while(consume('.')){
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, '.', name));
                        }
                        if (consume(':')) {
                            pushLocation(marker);
                            name = parseIdentifier();
                            base = finishNode(ast.memberExpression(base, ':', name));
                            if (options.scope) scopeIdentifierName('self');
                        }
                        return base;
                    }
                    //     tableconstructor ::= '{' [fieldlist] '}'
                    //     fieldlist ::= field {fieldsep field} fieldsep
                    //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp
                    //
                    //     fieldsep ::= ',' | ';'
                    function parseTableConstructor(flowContext) {
                        var fields = [], key, value;
                        while(true){
                            markLocation();
                            if (Punctuator === token.type && consume('[')) {
                                key = parseExpectedExpression(flowContext);
                                expect(']');
                                expect('=');
                                value = parseExpectedExpression(flowContext);
                                fields.push(finishNode(ast.tableKey(key, value)));
                            } else if (Identifier === token.type) {
                                if ('=' === lookahead.value) {
                                    key = parseIdentifier();
                                    next();
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableKeyString(key, value)));
                                } else {
                                    value = parseExpectedExpression(flowContext);
                                    fields.push(finishNode(ast.tableValue(value)));
                                }
                            } else {
                                if (null == (value = parseExpression(flowContext))) {
                                    locations.pop();
                                    break;
                                }
                                fields.push(finishNode(ast.tableValue(value)));
                            }
                            if (',;'.indexOf(token.value) >= 0) {
                                next();
                                continue;
                            }
                            break;
                        }
                        expect('}');
                        return finishNode(ast.tableConstructorExpression(fields));
                    }
                    // Expression parser
                    // -----------------
                    //
                    // Expressions are evaluated and always return a value. If nothing is
                    // matched null will be returned.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    //
                    //     primary ::= nil | false | true | Number | String | '...'
                    //          | functiondef | tableconstructor
                    //
                    //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'
                    //          | '.' Name | ':' Name args | args }
                    //
                    function parseExpression(flowContext) {
                        var expression = parseSubExpression(0, flowContext);
                        return expression;
                    }
                    // Parse an expression expecting it to be valid.
                    function parseExpectedExpression(flowContext) {
                        var expression = parseExpression(flowContext);
                        if (null == expression) raiseUnexpectedToken('<expression>', token);
                        else return expression;
                    }
                    // Return the precedence priority of the operator.
                    //
                    // As unary `-` can't be distinguished from binary `-`, unary precedence
                    // isn't described in this table but in `parseSubExpression()` itself.
                    //
                    // As this function gets hit on every expression it's been optimized due to
                    // the expensive CompareICStub which took ~8% of the parse time.
                    function binaryPrecedence(operator) {
                        var charCode = operator.charCodeAt(0), length = operator.length;
                        if (1 === length) {
                            switch(charCode){
                                case 94:
                                    return 12; // ^
                                case 42:
                                case 47:
                                case 37:
                                    return 10; // * / %
                                case 43:
                                case 45:
                                    return 9; // + -
                                case 38:
                                    return 6; // &
                                case 126:
                                    return 5; // ~
                                case 124:
                                    return 4; // |
                                case 60:
                                case 62:
                                    return 3; // < >
                            }
                        } else if (2 === length) {
                            switch(charCode){
                                case 47:
                                    return 10; // //
                                case 46:
                                    return 8; // ..
                                case 60:
                                case 62:
                                    if ('<<' === operator || '>>' === operator) return 7; // << >>
                                    return 3; // <= >=
                                case 61:
                                case 126:
                                    return 3; // == ~=
                                case 111:
                                    return 1; // or
                            }
                        } else if (97 === charCode && 'and' === operator) return 2;
                        return 0;
                    }
                    // Implement an operator-precedence parser to handle binary operator
                    // precedence.
                    //
                    // We use this algorithm because it's compact, it's fast and Lua core uses
                    // the same so we can be sure our expressions are parsed in the same manner
                    // without excessive amounts of tests.
                    //
                    //     exp ::= (unop exp | primary | prefixexp ) { binop exp }
                    function parseSubExpression(minPrecedence, flowContext) {
                        var operator = token.value, expression, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // UnaryExpression
                        if (isUnary(token)) {
                            markLocation();
                            next();
                            var argument = parseSubExpression(10, flowContext);
                            if (argument == null) raiseUnexpectedToken('<expression>', token);
                            expression = finishNode(ast.unaryExpression(operator, argument));
                        }
                        if (null == expression) {
                            // PrimaryExpression
                            expression = parsePrimaryExpression(flowContext);
                            // PrefixExpression
                            if (null == expression) {
                                expression = parsePrefixExpression(flowContext);
                            }
                        }
                        // This is not a valid left hand expression.
                        if (null == expression) return null;
                        var precedence;
                        while(true){
                            operator = token.value;
                            precedence = Punctuator === token.type || Keyword === token.type ? binaryPrecedence(operator) : 0;
                            if (precedence === 0 || precedence <= minPrecedence) break;
                            // Right-hand precedence operators
                            if ('^' === operator || '..' === operator) --precedence;
                            next();
                            var right = parseSubExpression(precedence, flowContext);
                            if (null == right) raiseUnexpectedToken('<expression>', token);
                            // Push in the marker created before the loop to wrap its entirety.
                            if (trackLocations) locations.push(marker);
                            expression = finishNode(ast.binaryExpression(operator, expression, right));
                        }
                        return expression;
                    }
                    //     prefixexp ::= prefix {suffix}
                    //     prefix ::= Name | '(' exp ')'
                    //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args
                    //
                    //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parsePrefixExpressionPart(base, marker, flowContext) {
                        var expression, identifier;
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case '[':
                                    pushLocation(marker);
                                    next();
                                    expression = parseExpectedExpression(flowContext);
                                    expect(']');
                                    return finishNode(ast.indexExpression(base, expression));
                                case '.':
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    return finishNode(ast.memberExpression(base, '.', identifier));
                                case ':':
                                    pushLocation(marker);
                                    next();
                                    identifier = parseIdentifier();
                                    base = finishNode(ast.memberExpression(base, ':', identifier));
                                    // Once a : is found, this has to be a CallExpression, otherwise
                                    // throw an error.
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                                case '(':
                                case '{':
                                    pushLocation(marker);
                                    return parseCallExpression(base, flowContext);
                            }
                        } else if (StringLiteral === token.type) {
                            pushLocation(marker);
                            return parseCallExpression(base, flowContext);
                        }
                        return null;
                    }
                    function parsePrefixExpression(flowContext) {
                        var base, name, marker;
                        if (trackLocations) marker = createLocationMarker();
                        // The prefix
                        if (Identifier === token.type) {
                            name = token.value;
                            base = parseIdentifier();
                            // Set the parent scope.
                            if (options.scope) attachScope(base, scopeHasName(name));
                        } else if (consume('(')) {
                            base = parseExpectedExpression(flowContext);
                            expect(')');
                        } else {
                            return null;
                        }
                        // The suffix
                        for(;;){
                            var newBase = parsePrefixExpressionPart(base, marker, flowContext);
                            if (newBase === null) break;
                            base = newBase;
                        }
                        return base;
                    }
                    //     args ::= '(' [explist] ')' | tableconstructor | String
                    function parseCallExpression(base, flowContext) {
                        if (Punctuator === token.type) {
                            switch(token.value){
                                case '(':
                                    if (!features.emptyStatement) {
                                        if (token.line !== previousToken.line) raise(null, errors.ambiguousSyntax, token.value);
                                    }
                                    next();
                                    // List of expressions
                                    var expressions = [];
                                    var expression = parseExpression(flowContext);
                                    if (null != expression) expressions.push(expression);
                                    while(consume(',')){
                                        expression = parseExpectedExpression(flowContext);
                                        expressions.push(expression);
                                    }
                                    expect(')');
                                    return finishNode(ast.callExpression(base, expressions));
                                case '{':
                                    markLocation();
                                    next();
                                    var table = parseTableConstructor(flowContext);
                                    return finishNode(ast.tableCallExpression(base, table));
                            }
                        } else if (StringLiteral === token.type) {
                            return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));
                        }
                        raiseUnexpectedToken('function arguments', token);
                    }
                    //     primary ::= String | Numeric | nil | true | false
                    //          | functiondef | tableconstructor | '...'
                    function parsePrimaryExpression(flowContext) {
                        var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral, value = token.value, type = token.type, marker;
                        if (trackLocations) marker = createLocationMarker();
                        if (type === VarargLiteral && !flowContext.allowVararg) {
                            raise(token, errors.cannotUseVararg, token.value);
                        }
                        if (type & literals) {
                            pushLocation(marker);
                            var raw = input.slice(token.range[0], token.range[1]);
                            next();
                            return finishNode(ast.literal(type, value, raw));
                        } else if (Keyword === type && 'function' === value) {
                            pushLocation(marker);
                            next();
                            if (options.scope) createScope();
                            return parseFunctionDeclaration(null);
                        } else if (consume('{')) {
                            pushLocation(marker);
                            return parseTableConstructor(flowContext);
                        }
                    }
                    // Parser
                    // ------
                    // Export the main parser.
                    //
                    //   - `wait` Hold parsing until end() is called. Defaults to false
                    //   - `comments` Store comments. Defaults to true.
                    //   - `scope` Track identifier scope. Defaults to false.
                    //   - `locations` Store location information. Defaults to false.
                    //   - `ranges` Store the start and end character locations. Defaults to
                    //     false.
                    //   - `onCreateNode` Callback which will be invoked when a syntax node is
                    //     created.
                    //   - `onCreateScope` Callback which will be invoked when a new scope is
                    //     created.
                    //   - `onDestroyScope` Callback which will be invoked when the current scope
                    //     is destroyed.
                    //
                    // Example:
                    //
                    //     var parser = require('luaparser');
                    //     parser.parse('i = 0');
                    exports1.parse = parse;
                    var versionFeatures = {
                        '5.1': {},
                        '5.2': {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            relaxedBreak: true
                        },
                        '5.3': {
                            labels: true,
                            emptyStatement: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            bitwiseOperators: true,
                            integerDivision: true,
                            relaxedBreak: true
                        },
                        'LuaJIT': {
                            // XXX: LuaJIT language features may depend on compilation options; may need to
                            // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT
                            // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?
                            labels: true,
                            contextualGoto: true,
                            hexEscapes: true,
                            skipWhitespaceEscape: true,
                            strictEscapes: true,
                            unicodeEscapes: true,
                            imaginaryNumbers: true,
                            integerSuffixes: true
                        }
                    };
                    function parse(_input, _options) {
                        if ('undefined' === typeof _options && 'object' === typeof _input) {
                            _options = _input;
                            _input = undefined;
                        }
                        if (!_options) _options = {};
                        input = _input || '';
                        options = assign({}, defaultOptions, _options);
                        // Rewind the lexer
                        index = 0;
                        line = 1;
                        lineStart = 0;
                        length = input.length;
                        // When tracking identifier scope, initialize with an empty scope.
                        scopes = [
                            []
                        ];
                        scopeDepth = 0;
                        globals = [];
                        locations = [];
                        if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {
                            throw new Error(sprintf("Lua version '%1' not supported", options.luaVersion));
                        }
                        features = assign({}, versionFeatures[options.luaVersion]);
                        if (options.extendedIdentifiers !== void 0) features.extendedIdentifiers = !!options.extendedIdentifiers;
                        if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {
                            throw new Error(sprintf("Encoding mode '%1' not supported", options.encodingMode));
                        }
                        encodingMode = encodingModes[options.encodingMode];
                        if (options.comments) comments = [];
                        if (!options.wait) return end();
                        return exports1;
                    }
                    // Write to the source code buffer without beginning the parse.
                    exports1.write = write;
                    function write(_input) {
                        input += String(_input);
                        length = input.length;
                        return exports1;
                    }
                    // Send an EOF and begin parsing.
                    exports1.end = end;
                    function end(_input) {
                        if ('undefined' !== typeof _input) write(_input);
                        // Ignore shebangs.
                        if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function(line) {
                            return line.replace(/./g, ' ');
                        });
                        length = input.length;
                        trackLocations = options.locations || options.ranges;
                        // Initialize with a lookahead token.
                        lookahead = lex();
                        var chunk = parseChunk();
                        if (options.comments) chunk.comments = comments;
                        if (options.scope) chunk.globals = globals;
                        /* istanbul ignore if */ if (locations.length > 0) throw new Error('Location tracking failed. This is most likely a bug in luaparse');
                        return chunk;
                    }
                });
            /* vim: set sw=2 ts=2 et tw=79 : */ /***/ },
            /***/ 2372: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 5968: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_301858__)=>{
                "use strict";
                var define1 = __nested_webpack_require_301858__(1857);
                var callBind = __nested_webpack_require_301858__(8498);
                var implementation = __nested_webpack_require_301858__(2372);
                var getPolyfill = __nested_webpack_require_301858__(1937);
                var shim = __nested_webpack_require_301858__(5087);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1937: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_302586__)=>{
                "use strict";
                var implementation = __nested_webpack_require_302586__(2372);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 5087: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_302958__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_302958__(1937);
                var define1 = __nested_webpack_require_302958__(1857);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 8160: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_303646__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_303646__(968); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 9228: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_309615__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_309615__(968);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_309615__(8160);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 968: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 9907: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 6108: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_319979__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_319979__(528);
                var define1 = __nested_webpack_require_319979__(686);
                var hasDescriptors = __nested_webpack_require_319979__(7239)();
                var gOPD = __nested_webpack_require_319979__(9336);
                var $TypeError = __nested_webpack_require_319979__(3468);
                var $floor = GetIntrinsic('%Math.floor%');
                /** @type {import('.')} */ module1.exports = function setFunctionLength(fn, length) {
                    if (typeof fn !== 'function') {
                        throw new $TypeError('`fn` is not a function');
                    }
                    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
                        throw new $TypeError('`length` must be a positive 32-bit integer');
                    }
                    var loose = arguments.length > 2 && !!arguments[2];
                    var functionLengthIsConfigurable = true;
                    var functionLengthIsWritable = true;
                    if ('length' in fn && gOPD) {
                        var desc = gOPD(fn, 'length');
                        if (desc && !desc.configurable) {
                            functionLengthIsConfigurable = false;
                        }
                        if (desc && !desc.writable) {
                            functionLengthIsWritable = false;
                        }
                    }
                    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                        if (hasDescriptors) {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length, true, true);
                        } else {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length);
                        }
                    }
                    return fn;
                };
            /***/ },
            /***/ 2125: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_322053__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_322053__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_322053__(5501);
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_322053__.n(vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__);
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_322053__(7770);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_322053__(8041);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, document1.text);
                    }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    renameDocument(document1, newDocumentUri) {
                        const previousDocument = this.getDocument(document1.uri);
                        this.addDocument({
                            uri: newDocumentUri,
                            version: previousDocument.version,
                            languageId: previousDocument.languageId,
                            text: previousDocument.getText()
                        });
                        this.options[newDocumentUri] = this.options[document1.uri];
                        this.removeDocument(document1);
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setWorkspace(workspaceUri) {
                        this.workspaceUri = workspaceUri;
                    }
                    setOptions(documentUri, options, merge = false) {
                        this.options[documentUri] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_2__ /* .mergeObjects */ .rL)(options, this.options[documentUri]) : options;
                    }
                    getOption(documentUri, optionName) {
                        if (this.options[documentUri] && this.options[documentUri][optionName]) {
                            return this.options[documentUri][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doInlineComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    getSemanticTokens(document1, range) {
                        return Promise.resolve(null);
                    }
                    dispose() {
                        return Promise.resolve();
                    }
                    closeConnection() {
                        return Promise.resolve();
                    }
                    getCodeActions(document1, range, context) {
                        return Promise.resolve(null);
                    }
                    executeCommand(command, args) {
                        return Promise.resolve(null);
                    }
                    sendAppliedResult(result, callbackId) {}
                    sendRequest(name, args) {
                        return Promise.resolve(null);
                    }
                    sendResponse(callbackId, args) {
                        return;
                    }
                    constructor(mode, workspaceUri){
                        _define_property(this, "serviceName", void 0);
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        _define_property(this, "workspaceUri", void 0);
                        _define_property(this, "clientCapabilities", {
                            textDocument: {
                                diagnostic: {
                                    dynamicRegistration: true,
                                    relatedDocumentSupport: true
                                },
                                publishDiagnostics: {
                                    relatedInformation: true,
                                    versionSupport: false,
                                    tagSupport: {
                                        valueSet: [
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Unnecessary,
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Deprecated
                                        ]
                                    }
                                },
                                hover: {
                                    dynamicRegistration: true,
                                    contentFormat: [
                                        'markdown',
                                        'plaintext'
                                    ]
                                },
                                synchronization: {
                                    dynamicRegistration: true,
                                    willSave: false,
                                    didSave: false,
                                    willSaveWaitUntil: false
                                },
                                formatting: {
                                    dynamicRegistration: true
                                },
                                completion: {
                                    dynamicRegistration: true,
                                    completionItem: {
                                        snippetSupport: true,
                                        commitCharactersSupport: false,
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        deprecatedSupport: false,
                                        preselectSupport: false
                                    },
                                    contextSupport: false
                                },
                                signatureHelp: {
                                    signatureInformation: {
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        activeParameterSupport: true
                                    }
                                },
                                documentHighlight: {
                                    dynamicRegistration: true
                                },
                                semanticTokens: {
                                    multilineTokenSupport: false,
                                    overlappingTokenSupport: false,
                                    tokenTypes: [],
                                    tokenModifiers: [],
                                    formats: [
                                        "relative"
                                    ],
                                    requests: {
                                        full: {
                                            delta: false
                                        },
                                        range: true
                                    },
                                    augmentsSyntaxTokens: true
                                },
                                codeAction: {
                                    dynamicRegistration: true
                                },
                                inlineCompletion: {
                                    dynamicRegistration: true
                                }
                            },
                            window: {
                                showDocument: {
                                    support: true
                                }
                            },
                            workspace: {
                                didChangeConfiguration: {
                                    dynamicRegistration: true
                                },
                                executeCommand: {
                                    dynamicRegistration: true
                                },
                                applyEdit: true,
                                workspaceEdit: {
                                    failureHandling: "abort",
                                    normalizesLineEndings: false,
                                    documentChanges: false
                                }
                            }
                        });
                        this.mode = mode;
                        this.workspaceUri = workspaceUri;
                        this.serviceName = "BaseService";
                        this.serviceData = {
                            className: "BaseService",
                            modes: "",
                            module: ()=>{}
                        };
                    }
                }
            /***/ },
            /***/ 7770: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_336972__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_336972__.d(__nested_webpack_exports__, {
                    /* harmony export */ Tk: ()=>/* binding */ checkValueAgainstRegexpArray,
                    /* harmony export */ rL: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, isEmptyRange, mergeRanges, convertToUri */ function mergeObjects(obj1, obj2, excludeUndefined = false) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    if (excludeUndefined) {
                        obj1 = excludeUndefinedValues(obj1);
                        obj2 = excludeUndefinedValues(obj2);
                    }
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function excludeUndefinedValues(obj) {
                    const filteredEntries = Object.entries(obj).filter(([_, value])=>value !== undefined);
                    return Object.fromEntries(filteredEntries);
                }
                function notEmpty1(value) {
                    return value !== null && value !== undefined;
                }
                function isEmptyRange(range) {
                    return range.start.row === range.end.row && range.start.column === range.end.column;
                }
                //taken with small changes from ace-code
                function mergeRanges1(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !isEmptyRange(range) && !isEmptyRange(next)) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
                /**
 * Converts a given file path to a URI format. If the given file path is already a URI,
 * it normalizes and optionally resolves the path against a workspace URI.
 *
 * @param filePath - The file path to convert to a URI. Can be an absolute path or an existing file URI.
 * @param [joinWorkspaceURI] - Optional flag to determine if the converted URI should be joined with given URI
 * @param [workspaceUri] - The base workspace URI to resolve against if `joinWorkspaceURI` is true. Required if resolution is needed.
 * @return {string} - The resulting URI
 */ function convertToUri(filePath, joinWorkspaceURI = false, workspaceUri) {
                    const isFullUri = filePath.startsWith('file://');
                    const normalizedPath = filePath.replace(/\\/g, "/");
                    let uri;
                    if (isFullUri) {
                        uri = URI.parse(normalizedPath);
                    } else {
                        uri = URI.file(normalizedPath);
                    }
                    if (joinWorkspaceURI && workspaceUri) {
                        if (!workspaceUri.startsWith('file://')) {
                            throw new Error('workspaceUri must be a file:// URI');
                        }
                        const workspaceUriParsed = URI.parse(workspaceUri);
                        uri = Utils.joinPath(workspaceUriParsed, uri.path);
                    }
                    return uri.toString();
                }
            /***/ },
            /***/ 5272: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 1531: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_342768__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_342768__(5387);
                var isGeneratorFunction = __nested_webpack_require_342768__(2625);
                var whichTypedArray = __nested_webpack_require_342768__(2730);
                var isTypedArray = __nested_webpack_require_342768__(5943);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 6827: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_355245__)=>{
                /* provided dependency */ var process = __nested_webpack_require_355245__(9907);
                /* provided dependency */ var console = __nested_webpack_require_355245__(4364);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_355245__(1531);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_355245__(5272);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_355245__(5615);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 9208: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_386843__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_386843__(9110);
            /***/ },
            /***/ 9110: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_387402__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_387402__(3312);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_387402__(7672);
                __exportStar(__nested_webpack_require_387402__(7672), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3312: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_391817__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_391817__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_391817__(7672);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 7672: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_400196__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_400196__(7162);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_400196__(1109);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_400196__(8844);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_400196__(2479);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_400196__(6957);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_400196__(3489);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_400196__(656);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_400196__(9036);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_400196__(9805);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_400196__(4054);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_400196__(5091);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 6957: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_418260__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_418260__(5091);
                const Is = __nested_webpack_require_418260__(6618);
                const events_1 = __nested_webpack_require_418260__(2479);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken || (exports1.CancellationToken = CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 4054: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_423185__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_423185__(5091);
                const Is = __nested_webpack_require_423185__(6618);
                const messages_1 = __nested_webpack_require_423185__(7162);
                const linkedMap_1 = __nested_webpack_require_423185__(1109);
                const events_1 = __nested_webpack_require_423185__(2479);
                const cancellation_1 = __nested_webpack_require_423185__(6957);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken || (exports1.ProgressToken = ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues || (exports1.TraceValues = TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification || (exports1.SetTraceNotification = SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification || (exports1.LogTraceNotification = LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors || (exports1.ConnectionErrors = ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy || (exports1.ConnectionStrategy = ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy || (exports1.CancellationSenderStrategy = CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy || (exports1.CancellationStrategy = CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy || (exports1.MessageStrategy = MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions || (exports1.ConnectionOptions = ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8844: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable || (exports1.Disposable = Disposable = {}));
            /***/ },
            /***/ 2479: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_494115__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_494115__(5091);
                var Event;
                (function(Event) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event.None = function() {
                        return _disposable;
                    };
                })(Event || (exports1.Event = Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 6618: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 1109: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch || (exports1.Touch = Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 9805: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error(`Message header must separate key and value using ':'\n${header}`);
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 656: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_529802__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_529802__(5091);
                const Is = __nested_webpack_require_529802__(6618);
                const events_1 = __nested_webpack_require_529802__(2479);
                const semaphore_1 = __nested_webpack_require_529802__(418);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader || (exports1.MessageReader = MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        try {
                            this.buffer.append(data);
                            while(true){
                                if (this.nextMessageLength === -1) {
                                    const headers = this.buffer.tryReadHeaders(true);
                                    if (!headers) {
                                        return;
                                    }
                                    const contentLength = headers.get('content-length');
                                    if (!contentLength) {
                                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
                                        return;
                                    }
                                    const length = parseInt(contentLength);
                                    if (isNaN(length)) {
                                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                                        return;
                                    }
                                    this.nextMessageLength = length;
                                }
                                const body = this.buffer.tryReadBody(this.nextMessageLength);
                                if (body === undefined) {
                                    /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                    return;
                                }
                                this.clearPartialMessageTimer();
                                this.nextMessageLength = -1;
                                // Make sure that we convert one received message after the
                                // other. Otherwise it could happen that a decoding of a second
                                // smaller message finished before the decoding of a first larger
                                // message and then we would deliver the second message first.
                                this.readSemaphore.lock(async ()=>{
                                    const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                    this.callback(message);
                                }).catch((error)=>{
                                    this.fireError(error);
                                });
                            }
                        } catch (error) {
                            this.fireError(error);
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 9036: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_541424__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_541424__(5091);
                const Is = __nested_webpack_require_541424__(6618);
                const semaphore_1 = __nested_webpack_require_541424__(418);
                const events_1 = __nested_webpack_require_541424__(2479);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter || (exports1.MessageWriter = MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 7162: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_548300__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_548300__(6618);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes || (exports1.ErrorCodes = ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message || (exports1.Message = Message = {}));
            /***/ },
            /***/ 5091: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 418: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_563789__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_563789__(5091);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 3489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_567232__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_567232__(6957);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 5501: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_571137__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_571137__(9208);
                __exportStar(__nested_webpack_require_571137__(9208), exports1);
                __exportStar(__nested_webpack_require_571137__(3147), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 3147: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_573326__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_573326__(9110), exports1);
                __exportStar(__nested_webpack_require_573326__(2852), exports1);
                __exportStar(__nested_webpack_require_573326__(8431), exports1);
                __exportStar(__nested_webpack_require_573326__(1815), exports1);
                var connection_1 = __nested_webpack_require_573326__(291);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes || (exports1.LSPErrorCodes = LSPErrorCodes = {}));
            /***/ },
            /***/ 291: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_577466__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_577466__(9110);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8431: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_578703__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_578703__(9110);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection || (exports1.MessageDirection = MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 7602: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_581420__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_581420__(8431);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 3747: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_584424__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_584424__(8431);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest || (exports1.DocumentColorRequest = DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest || (exports1.ColorPresentationRequest = ColorPresentationRequest = {}));
            /***/ },
            /***/ 7639: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_586709__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_586709__(8431);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest || (exports1.ConfigurationRequest = ConfigurationRequest = {}));
            /***/ },
            /***/ 5581: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_588482__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_588482__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
 * or a Thenable that resolves to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest || (exports1.DeclarationRequest = DeclarationRequest = {}));
            /***/ },
            /***/ 1494: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_590111__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_590111__(9110);
                const Is = __nested_webpack_require_590111__(8633);
                const messages_1 = __nested_webpack_require_590111__(8431);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 4781: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_594310__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_594310__(8431);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind || (exports1.FileOperationPatternKind = FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest || (exports1.WillCreateFilesRequest = WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification || (exports1.DidCreateFilesNotification = DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest || (exports1.WillRenameFilesRequest = WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification || (exports1.DidRenameFilesNotification = DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 1203: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_600252__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRefreshRequest = exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_600252__(8431);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest || (exports1.FoldingRangeRequest = FoldingRangeRequest = {}));
                /**
 * @since 3.18.0
 * @proposed
 */ var FoldingRangeRefreshRequest;
                (function(FoldingRangeRefreshRequest) {
                    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;
                    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);
                })(FoldingRangeRefreshRequest || (exports1.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
            /***/ },
            /***/ 7287: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_602311__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_602311__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest || (exports1.ImplementationRequest = ImplementationRequest = {}));
            /***/ },
            /***/ 9383: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_603924__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_603924__(8431);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest || (exports1.InlayHintRequest = InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest || (exports1.InlayHintResolveRequest = InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 2322: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_606700__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineCompletionRequest = void 0;
                const messages_1 = __nested_webpack_require_606700__(8431);
                /**
 * A request to provide inline completions in a document. The request's parameter is of
 * type {@link InlineCompletionParams}, the response is of type
 * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.
 *
 * @since 3.18.0
 * @proposed
 */ var InlineCompletionRequest;
                (function(InlineCompletionRequest) {
                    InlineCompletionRequest.method = 'textDocument/inlineCompletion';
                    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);
                })(InlineCompletionRequest || (exports1.InlineCompletionRequest = InlineCompletionRequest = {}));
            /***/ },
            /***/ 3491: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_608231__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_608231__(8431);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest || (exports1.InlineValueRequest = InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 1815: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_610279__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRefreshRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangesFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.InlineCompletionRequest = exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_610279__(8431);
                const vscode_languageserver_types_1 = __nested_webpack_require_610279__(2852);
                const Is = __nested_webpack_require_610279__(8633);
                const protocol_implementation_1 = __nested_webpack_require_610279__(7287);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_610279__(9264);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_610279__(6860);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_610279__(7639);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_610279__(3747);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_610279__(1203);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "FoldingRangeRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_610279__(5581);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_610279__(1530);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_610279__(4166);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_610279__(7602);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_610279__(2067);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_610279__(4333);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_610279__(2249);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_610279__(4781);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_610279__(7684);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_610279__(7062);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_610279__(3491);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_610279__(9383);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_610279__(1494);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_610279__(4792);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                const protocol_inlineCompletion_1 = __nested_webpack_require_610279__(2322);
                Object.defineProperty(exports1, "InlineCompletionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineCompletion_1.InlineCompletionRequest;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate) || Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter || (exports1.TextDocumentFilter = TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter || (exports1.NotebookDocumentFilter = NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector || (exports1.DocumentSelector = DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest || (exports1.RegistrationRequest = RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest || (exports1.UnregistrationRequest = UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind || (exports1.ResourceOperationKind = ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind || (exports1.FailureHandlingKind = FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind || (exports1.PositionEncodingKind = PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions || (exports1.StaticRegistrationOptions = StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest || (exports1.InitializeRequest = InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes || (exports1.InitializeErrorCodes = InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification || (exports1.InitializedNotification = InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest || (exports1.ShutdownRequest = ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification || (exports1.ExitNotification = ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                    /**
     * A debug message.
     *
     * @since 3.18.0
     */ MessageType.Debug = 5;
                })(MessageType || (exports1.MessageType = MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification || (exports1.ShowMessageNotification = ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest || (exports1.ShowMessageRequest = ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification || (exports1.LogMessageNotification = LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification || (exports1.TelemetryEventNotification = TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind || (exports1.TextDocumentSyncKind = TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason || (exports1.TextDocumentSaveReason = TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType || (exports1.FileChangeType = FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern || (exports1.RelativePattern = RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind || (exports1.WatchKind = WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind || (exports1.CompletionTriggerKind = CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest || (exports1.CompletionRequest = CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest || (exports1.CompletionResolveRequest = CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest || (exports1.HoverRequest = HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest || (exports1.SignatureHelpRequest = SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPosition}
 * the response is of either type {@link Definition} or a typed array of
 * {@link DefinitionLink} or a Thenable that resolves to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest || (exports1.DefinitionRequest = DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest || (exports1.ReferencesRequest = ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type {@link TextDocumentPosition}
 * the request response is an array of type {@link DocumentHighlight}
 * or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest || (exports1.DocumentHighlightRequest = DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest || (exports1.DocumentSymbolRequest = DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest || (exports1.CodeActionRequest = CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest || (exports1.CodeActionResolveRequest = CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest || (exports1.CodeLensRequest = CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest || (exports1.CodeLensResolveRequest = CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest || (exports1.DocumentLinkRequest = DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
                /**
 * A request to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest || (exports1.DocumentFormattingRequest = DocumentFormattingRequest = {}));
                /**
 * A request to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
                /**
 * A request to format ranges in a document.
 *
 * @since 3.18.0
 * @proposed
 */ var DocumentRangesFormattingRequest;
                (function(DocumentRangesFormattingRequest) {
                    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';
                    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);
                })(DocumentRangesFormattingRequest || (exports1.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest || (exports1.RenameRequest = RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest || (exports1.PrepareRenameRequest = PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest || (exports1.ExecuteCommandRequest = ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 2249: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_680334__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_680334__(8431);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 7684: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_681698__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_681698__(8431);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel || (exports1.UniquenessLevel = UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind || (exports1.MonikerKind = MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest || (exports1.MonikerRequest = MonikerRequest = {}));
            /***/ },
            /***/ 4792: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_684705__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_684705__(2852);
                const Is = __nested_webpack_require_684705__(8633);
                const messages_1 = __nested_webpack_require_684705__(8431);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind || (exports1.NotebookCellKind = NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary || (exports1.ExecutionSummary = ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell || (exports1.NotebookCell = NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument || (exports1.NotebookDocument = NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange || (exports1.NotebookCellArrayChange = NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 4166: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_698192__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_698192__(9110);
                const messages_1 = __nested_webpack_require_698192__(8431);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress || (exports1.WorkDoneProgress = WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 1530: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_701006__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_701006__(8431);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest || (exports1.SelectionRangeRequest = SelectionRangeRequest = {}));
            /***/ },
            /***/ 2067: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_702477__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_702477__(8431);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat || (exports1.TokenFormat = TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest || (exports1.SemanticTokensRequest = SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 4333: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_706734__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_706734__(8431);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest || (exports1.ShowDocumentRequest = ShowDocumentRequest = {}));
            /***/ },
            /***/ 9264: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_708203__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_708203__(8431);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest || (exports1.TypeDefinitionRequest = TypeDefinitionRequest = {}));
            /***/ },
            /***/ 7062: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_709816__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_709816__(8431);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 6860: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_712723__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_712723__(8431);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 8633: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 2730: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_717589__)=>{
                "use strict";
                var forEach = __nested_webpack_require_717589__(705);
                var availableTypedArrays = __nested_webpack_require_717589__(4834);
                var callBind = __nested_webpack_require_717589__(8498);
                var callBound = __nested_webpack_require_717589__(9818);
                var gOPD = __nested_webpack_require_717589__(9336);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_717589__(1913)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_717589__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 4834: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_721836__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_721836__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ },
            /***/ 8041: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_722950__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_722950__.d(__nested_webpack_exports__, {
                    /* harmony export */ V: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            const start = this.offsetAt(range.start);
                            const end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(changes, version) {
                        for (const change of changes){
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                const range = getWellformedRange(change.range);
                                // update content
                                const startOffset = this.offsetAt(range.start);
                                const endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                const startLine = Math.max(range.start.line, 0);
                                const endLine = Math.max(range.end.line, 0);
                                let lineOffsets = this._lineOffsets;
                                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(let i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                const diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        const lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            const mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        const line = low - 1;
                        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
                        return {
                            line,
                            character: offset - lineOffsets[line]
                        };
                    }
                    offsetAt(position) {
                        const lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        const lineOffset = lineOffsets[position.line];
                        if (position.character <= 0) {
                            return lineOffset;
                        }
                        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        const offset = Math.min(lineOffset + position.character, nextLineOffset);
                        return this.ensureBeforeEOL(offset, lineOffset);
                    }
                    ensureBeforeEOL(offset, lineOffset) {
                        while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))){
                            offset--;
                        }
                        return offset;
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    static isIncremental(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    static isFull(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        const text = document1.getText();
                        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b)=>{
                            const diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = 0;
                        const spans = [];
                        for (const e of sortedEdits){
                            const startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    const p = data.length / 2 | 0;
                    const left = data.slice(0, p);
                    const right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    let leftIdx = 0;
                    let rightIdx = 0;
                    let i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        const ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
                    const result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(let i = 0; i < text.length; i++){
                        const ch = text.charCodeAt(i);
                        if (isEOL(ch)) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function isEOL(char) {
                    return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;
                }
                function getWellformedRange(range) {
                    const start = range.start;
                    const end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    const range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range
                        };
                    }
                    return textEdit;
                }
            /***/ },
            /***/ 2852: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_737316__)=>{
                "use strict";
                __nested_webpack_require_737316__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_737316__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind1,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineCompletionContext: ()=>/* binding */ InlineCompletionContext,
                    /* harmony export */ InlineCompletionItem: ()=>/* binding */ InlineCompletionItem,
                    /* harmony export */ InlineCompletionList: ()=>/* binding */ InlineCompletionList,
                    /* harmony export */ InlineCompletionTriggerKind: ()=>/* binding */ InlineCompletionTriggerKind,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat1,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString1,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent1,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectedCompletionInfo: ()=>/* binding */ SelectedCompletionInfo,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ StringValue: ()=>/* binding */ StringValue,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI1,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI1;
                (function(URI1) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI1.is = is;
                })(URI1 || (URI1 = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line,
                            character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri,
                            range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri,
                            targetRange,
                            targetSelectionRange,
                            originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red,
                            green,
                            blue,
                            alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range,
                            color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label,
                            textEdit,
                            additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        const result = {
                            startLine,
                            endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location,
                            message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        let result = {
                            range,
                            message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command, ...args) {
                        let result = {
                            title,
                            command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range,
                            newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        const result = {
                            label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range,
                            newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        const candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument,
                            edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        let result = {
                            kind: 'create',
                            uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        let result = {
                            kind: 'rename',
                            oldUri,
                            newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        let result = {
                            kind: 'delete',
                            uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        let candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every((change)=>{
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                class TextEditChangeImpl {
                    insert(position, newText, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    replace(range, newText, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    delete(range, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    add(edit) {
                        this.edits.push(edit);
                    }
                    all() {
                        return this.edits;
                    }
                    clear() {
                        this.edits.splice(0, this.edits.length);
                    }
                    assertChangeAnnotations(value) {
                        if (value === undefined) {
                            throw new Error(`Text edit change is not configured to manage change annotations.`);
                        }
                    }
                    constructor(edits, changeAnnotations){
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                }
                /**
 * A helper class
 */ class ChangeAnnotations {
                    all() {
                        return this._annotations;
                    }
                    get size() {
                        return this._size;
                    }
                    manage(idOrAnnotation, annotation) {
                        let id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error(`Id ${id} is already in use.`);
                        }
                        if (annotation === undefined) {
                            throw new Error(`No annotation provided for id ${id}`);
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    }
                    nextId() {
                        this._counter++;
                        return this._counter.toString();
                    }
                    constructor(annotations){
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                }
                /**
 * A workspace change helps constructing changes to a workspace.
 */ class WorkspaceChange {
                    /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */ get edit() {
                        this.initDocumentChanges();
                        if (this._changeAnnotations !== undefined) {
                            if (this._changeAnnotations.size === 0) {
                                this._workspaceEdit.changeAnnotations = undefined;
                            } else {
                                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                            }
                        }
                        return this._workspaceEdit;
                    }
                    getTextEditChange(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            const textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            let result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                const edits = [];
                                const textDocumentEdit = {
                                    textDocument,
                                    edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            let result = this._textEditChanges[key];
                            if (!result) {
                                let edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    }
                    initDocumentChanges() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    }
                    initChanges() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    }
                    createFile(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    renameFile(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    deleteFile(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    constructor(workspaceEdit){
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach((change)=>{
                                    if (TextDocumentEdit.is(change)) {
                                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                                        this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach((key)=>{
                                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                }
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri,
                            version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri,
                            version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri,
                            languageId,
                            version,
                            text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        const candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent1;
                (function(MarkupContent1) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent1.is = is;
                })(MarkupContent1 || (MarkupContent1 = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind1;
                (function(CompletionItemKind1) {
                    CompletionItemKind1.Text = 1;
                    CompletionItemKind1.Method = 2;
                    CompletionItemKind1.Function = 3;
                    CompletionItemKind1.Constructor = 4;
                    CompletionItemKind1.Field = 5;
                    CompletionItemKind1.Variable = 6;
                    CompletionItemKind1.Class = 7;
                    CompletionItemKind1.Interface = 8;
                    CompletionItemKind1.Module = 9;
                    CompletionItemKind1.Property = 10;
                    CompletionItemKind1.Unit = 11;
                    CompletionItemKind1.Value = 12;
                    CompletionItemKind1.Enum = 13;
                    CompletionItemKind1.Keyword = 14;
                    CompletionItemKind1.Snippet = 15;
                    CompletionItemKind1.Color = 16;
                    CompletionItemKind1.File = 17;
                    CompletionItemKind1.Reference = 18;
                    CompletionItemKind1.Folder = 19;
                    CompletionItemKind1.EnumMember = 20;
                    CompletionItemKind1.Constant = 21;
                    CompletionItemKind1.Struct = 22;
                    CompletionItemKind1.Event = 23;
                    CompletionItemKind1.Operator = 24;
                    CompletionItemKind1.TypeParameter = 25;
                })(CompletionItemKind1 || (CompletionItemKind1 = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat1;
                (function(InsertTextFormat1) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
                })(InsertTextFormat1 || (InsertTextFormat1 = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText,
                            insert,
                            replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString1;
                (function(MarkedString1) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString1.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        const candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString1.is = is;
                })(MarkedString1 || (MarkedString1 = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        let candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent1.is(candidate.contents) || MarkedString1.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString1.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label,
                            documentation
                        } : {
                            label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation, ...parameters) {
                        let result = {
                            label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        let result = {
                            range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        let result = {
                            name,
                            kind,
                            location: {
                                uri,
                                range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name,
                            kind,
                            location: {
                                uri,
                                range
                            }
                        } : {
                            name,
                            kind,
                            location: {
                                uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        let result = {
                            name,
                            detail,
                            kind,
                            range,
                            selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        let candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        let result = {
                            diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        let result = {
                            title
                        };
                        let checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        let result = {
                            range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize,
                            insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range,
                            target,
                            data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range,
                            parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range,
                            text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range,
                            variableName,
                            caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range,
                            expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId,
                            stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        const result = {
                            position,
                            label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var StringValue;
                (function(StringValue) {
                    function createSnippet(value) {
                        return {
                            kind: 'snippet',
                            value
                        };
                    }
                    StringValue.createSnippet = createSnippet;
                })(StringValue || (StringValue = {}));
                var InlineCompletionItem;
                (function(InlineCompletionItem) {
                    function create(insertText, filterText, range, command) {
                        return {
                            insertText,
                            filterText,
                            range,
                            command
                        };
                    }
                    InlineCompletionItem.create = create;
                })(InlineCompletionItem || (InlineCompletionItem = {}));
                var InlineCompletionList;
                (function(InlineCompletionList) {
                    function create(items) {
                        return {
                            items
                        };
                    }
                    InlineCompletionList.create = create;
                })(InlineCompletionList || (InlineCompletionList = {}));
                /**
 * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
 *
 * @since 3.18.0
 * @proposed
 */ var InlineCompletionTriggerKind;
                (function(InlineCompletionTriggerKind) {
                    /**
     * Completion was triggered explicitly by a user gesture.
     */ InlineCompletionTriggerKind.Invoked = 0;
                    /**
     * Completion was triggered automatically while editing.
     */ InlineCompletionTriggerKind.Automatic = 1;
                })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
                var SelectedCompletionInfo;
                (function(SelectedCompletionInfo) {
                    function create(range, text) {
                        return {
                            range,
                            text
                        };
                    }
                    SelectedCompletionInfo.create = create;
                })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
                var InlineCompletionContext;
                (function(InlineCompletionContext) {
                    function create(triggerKind, selectedCompletionInfo) {
                        return {
                            triggerKind,
                            selectedCompletionInfo
                        };
                    }
                    InlineCompletionContext.create = create;
                })(InlineCompletionContext || (InlineCompletionContext = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && URI1.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                const EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        let text = document1.getText();
                        let sortedEdits = mergeSort(edits, (a, b)=>{
                            let diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = text.length;
                        for(let i = sortedEdits.length - 1; i >= 0; i--){
                            let e = sortedEdits[i];
                            let startOffset = document1.offsetAt(e.range.start);
                            let endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        const p = data.length / 2 | 0;
                        const left = data.slice(0, p);
                        const right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        let leftIdx = 0;
                        let rightIdx = 0;
                        let i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            let ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            let start = this.offsetAt(range.start);
                            let end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            let lineOffsets = [];
                            let text = this._content;
                            let isLineStart = true;
                            for(let i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                let ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        let lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            let mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        let line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    }
                    offsetAt(position) {
                        let lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        let lineOffset = lineOffsets[position.line];
                        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var Is;
                (function(Is) {
                    const toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_848313__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ id: moduleId,
                /******/ loaded: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_848313__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.loaded = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __nested_webpack_require_848313__.n = (module1)=>{
                /******/ var getter = module1 && module1.__esModule ? /******/ ()=>module1['default'] : /******/ ()=>module1;
                /******/ __nested_webpack_require_848313__.d(getter, {
                    a: getter
                });
                /******/ return getter;
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_848313__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_848313__.o(definition, key) && !__nested_webpack_require_848313__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_848313__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_848313__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_848313__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/node module decorator */ /******/ (()=>{
            /******/ __nested_webpack_require_848313__.nmd = (module1)=>{
                /******/ module1.paths = [];
                /******/ if (!module1.children) module1.children = [];
                /******/ return module1;
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_848313__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_848313__.d(__nested_webpack_exports__, {
                LuaService: ()=>/* binding */ LuaService
            });
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_848313__(2125);
            // EXTERNAL MODULE: ../../node_modules/luaparse/luaparse.js
            var luaparse = __nested_webpack_require_848313__(98);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var main = __nested_webpack_require_848313__(5501);
            // EXTERNAL MODULE: ./src/utils.ts
            var utils = __nested_webpack_require_848313__(7770);
            ; // CONCATENATED MODULE: ./src/ace/range-singleton.ts
            function _define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class AceRange {
                static getConstructor(editor) {
                    if (!AceRange._instance && editor) {
                        AceRange._instance = editor.getSelectionRange().constructor;
                    }
                    return AceRange._instance;
                }
            }
            _define_property(AceRange, "_instance", void 0);
            ; // CONCATENATED MODULE: ./src/type-converters/common-converters.ts
            var common_converters_CommonConverter;
            (function(CommonConverter1) {
                function normalizeRanges(completions) {
                    return completions && completions.map((el)=>{
                        if (el["range"]) {
                            el["range"] = toRange(el["range"]);
                        }
                        return el;
                    });
                }
                CommonConverter1.normalizeRanges = normalizeRanges;
                function cleanHtml(html) {
                    return html.replace(/<a\s/, "<a target='_blank' ");
                }
                CommonConverter1.cleanHtml = cleanHtml;
                function toRange(range) {
                    if (!range || !range.start || !range.end) {
                        return;
                    }
                    let Range = AceRange.getConstructor();
                    // @ts-ignore
                    return Range.fromPoints(range.start, range.end);
                }
                CommonConverter1.toRange = toRange;
                function convertKind(kind) {
                    switch(kind){
                        case "primitiveType":
                        case "keyword":
                            return main.CompletionItemKind.Keyword;
                        case "variable":
                        case "localVariable":
                            return main.CompletionItemKind.Variable;
                        case "memberVariable":
                        case "memberGetAccessor":
                        case "memberSetAccessor":
                            return main.CompletionItemKind.Field;
                        case "function":
                        case "memberFunction":
                        case "constructSignature":
                        case "callSignature":
                        case "indexSignature":
                            return main.CompletionItemKind.Function;
                        case "enum":
                            return main.CompletionItemKind.Enum;
                        case "module":
                            return main.CompletionItemKind.Module;
                        case "class":
                            return main.CompletionItemKind.Class;
                        case "interface":
                            return main.CompletionItemKind.Interface;
                        case "warning":
                            return main.CompletionItemKind.File;
                    }
                    return main.CompletionItemKind.Property;
                }
                CommonConverter1.convertKind = convertKind;
                function excludeByErrorMessage(diagnostics, errorMessagesToIgnore, fieldName = "message") {
                    if (!errorMessagesToIgnore) return diagnostics;
                    return diagnostics.filter((el)=>!(0, utils /* checkValueAgainstRegexpArray */ .Tk)(el[fieldName], errorMessagesToIgnore));
                }
                CommonConverter1.excludeByErrorMessage = excludeByErrorMessage;
            })(common_converters_CommonConverter || (common_converters_CommonConverter = {}));
            ; // CONCATENATED MODULE: ./src/type-converters/lsp/lsp-converters.ts
            function fromRange(range) {
                return {
                    start: {
                        line: range.start.row,
                        character: range.start.column
                    },
                    end: {
                        line: range.end.row,
                        character: range.end.column
                    }
                };
            }
            function rangeFromPositions(start, end) {
                return {
                    start: start,
                    end: end
                };
            }
            function toRange(range) {
                return {
                    start: {
                        row: range.start.line,
                        column: range.start.character
                    },
                    end: {
                        row: range.end.line,
                        column: range.end.character
                    }
                };
            }
            function fromPoint(point) {
                return {
                    line: point.row,
                    character: point.column
                };
            }
            function toPoint(position) {
                return {
                    row: position.line,
                    column: position.character
                };
            }
            function toAnnotations(diagnostics) {
                var _diagnostics;
                return (_diagnostics = diagnostics) === null || _diagnostics === void 0 ? void 0 : _diagnostics.map((el)=>{
                    return {
                        row: el.range.start.line,
                        column: el.range.start.character,
                        text: el.message,
                        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info",
                        code: el.code
                    };
                });
            }
            function fromAnnotations(annotations) {
                var _annotations;
                return (_annotations = annotations) === null || _annotations === void 0 ? void 0 : _annotations.map((el)=>{
                    return {
                        range: {
                            start: {
                                line: el.row,
                                character: el.column
                            },
                            end: {
                                line: el.row,
                                character: el.column
                            }
                        },
                        message: el.text,
                        severity: el.type === "error" ? 1 : el.type === "warning" ? 2 : 3,
                        code: el["code"]
                    };
                });
            }
            function toCompletion(item) {
                var _item_textEdit, _item_command;
                let itemKind = item.kind;
                let kind = itemKind ? Object.keys(CompletionItemKind)[Object.values(CompletionItemKind).indexOf(itemKind)] : undefined;
                var _item_textEdit_newText, _ref;
                let text = (_ref = (_item_textEdit_newText = (_item_textEdit = item.textEdit) === null || _item_textEdit === void 0 ? void 0 : _item_textEdit.newText) !== null && _item_textEdit_newText !== void 0 ? _item_textEdit_newText : item.insertText) !== null && _ref !== void 0 ? _ref : item.label;
                let filterText;
                // filtering would happen on ace editor side
                //TODO: if filtering and sorting are on server side, we should disable FilteredList in ace completer
                if (item.filterText) {
                    const firstWordMatch = item.filterText.match(/\w+/);
                    const firstWord = firstWordMatch ? firstWordMatch[0] : null;
                    if (firstWord) {
                        const wordRegex = new RegExp(`\\b${firstWord}\\b`, 'i');
                        if (!wordRegex.test(text)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    } else {
                        if (!text.includes(item.filterText)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    }
                }
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.textEdit ? getTextEditRange(item.textEdit, filterText) : undefined;
                let completion = {
                    meta: kind,
                    caption: item.label,
                    score: undefined
                };
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (item.insertTextFormat == InsertTextFormat.Snippet) {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["documentation"] = item.documentation; //TODO: this is workaround for services with instant completion
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = getCompletionItems(completions);
                    return combinedCompletions.map((item)=>toCompletion(item));
                }
                return [];
            }
            function getCompletionItems(completions) {
                return completions.map((el)=>{
                    if (!el.completions) {
                        return [];
                    }
                    let allCompletions;
                    if (Array.isArray(el.completions)) {
                        allCompletions = el.completions;
                    } else {
                        allCompletions = el.completions.items;
                    }
                    return allCompletions.map((item)=>{
                        item["service"] = el.service;
                        return item;
                    });
                }).flat();
            }
            function toInlineCompletion(item) {
                var _item_command;
                let text = typeof item.insertText === "string" ? item.insertText : item.insertText.value;
                let filterText;
                // filtering would happen on ace editor side
                //TODO: if filtering and sorting are on server side, we should disable FilteredList in ace completer
                if (item.filterText) {
                    const firstWordMatch = item.filterText.match(/\w+/);
                    const firstWord = firstWordMatch ? firstWordMatch[0] : null;
                    if (firstWord) {
                        const wordRegex = new RegExp(`\\b${firstWord}\\b`, 'i');
                        if (!wordRegex.test(text)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    } else {
                        if (!text.includes(item.filterText)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    }
                }
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.range ? getInlineCompletionRange(item.range, filterText) : undefined;
                let completion = {};
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (typeof item.insertText !== "string") {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toInlineCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = getCompletionItems(completions);
                    return combinedCompletions.map((item)=>toInlineCompletion(item));
                }
                return [];
            }
            function toResolvedCompletion(completion, item) {
                completion["docMarkdown"] = fromMarkupContent(item.documentation);
                return completion;
            }
            function toCompletionItem(completion) {
                let command;
                if (completion["command"]) {
                    command = {
                        title: "triggerSuggest",
                        command: completion["command"]
                    };
                }
                var _completion_caption;
                let completionItem = {
                    label: (_completion_caption = completion.caption) !== null && _completion_caption !== void 0 ? _completion_caption : "",
                    kind: CommonConverter.convertKind(completion.meta),
                    command: command,
                    insertTextFormat: completion["snippet"] ? InsertTextFormat.Snippet : InsertTextFormat.PlainText,
                    documentation: completion["documentation"]
                };
                if (completion["range"]) {
                    var _completion_snippet;
                    completionItem.textEdit = {
                        range: fromRange(completion["range"]),
                        newText: (_completion_snippet = completion["snippet"]) !== null && _completion_snippet !== void 0 ? _completion_snippet : completion["value"]
                    };
                } else {
                    var _completion_snippet1;
                    completionItem.insertText = (_completion_snippet1 = completion["snippet"]) !== null && _completion_snippet1 !== void 0 ? _completion_snippet1 : completion["value"];
                }
                completionItem["fileName"] = completion["fileName"];
                completionItem["position"] = completion["position"];
                completionItem["item"] = completion["item"];
                completionItem["service"] = completion["service"]; //TODO:
                return completionItem;
            }
            function getTextEditRange(textEdit, filterText) {
                const filterLength = filterText ? filterText.length : 0;
                if ("insert" in textEdit && "replace" in textEdit) {
                    let mergedRanges = mergeRanges([
                        toRange(textEdit.insert),
                        toRange(textEdit.replace)
                    ]);
                    return mergedRanges[0];
                } else {
                    textEdit.range.start.character -= filterLength;
                    return toRange(textEdit.range);
                }
            }
            function getInlineCompletionRange(range, filterText) {
                const filterLength = filterText ? filterText.length : 0;
                range.start.character -= filterLength;
                return toRange(range);
            }
            function toTooltip(hover) {
                var _hover_find;
                if (!hover) return;
                let content = hover.map((el)=>{
                    if (!el || !el.contents) return;
                    if (MarkupContent.is(el.contents)) {
                        return fromMarkupContent(el.contents);
                    } else if (MarkedString.is(el.contents)) {
                        if (typeof el.contents === "string") {
                            return el.contents;
                        }
                        return "```" + el.contents.value + "```";
                    } else {
                        let contents = el.contents.map((el)=>{
                            if (typeof el !== "string") {
                                return `\`\`\`${el.value}\`\`\``;
                            } else {
                                return el;
                            }
                        });
                        return contents.join("\n\n");
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                //TODO: it could be merged within all ranges in future
                let lspRange = (_hover_find = hover.find((el)=>{
                    var _el;
                    return (_el = el) === null || _el === void 0 ? void 0 : _el.range;
                })) === null || _hover_find === void 0 ? void 0 : _hover_find.range;
                let range;
                if (lspRange) range = toRange(lspRange);
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    },
                    range: range
                };
            }
            function fromSignatureHelp(signatureHelp) {
                if (!signatureHelp) return;
                let content = signatureHelp.map((el)=>{
                    var _el, _el1;
                    if (!el) return;
                    let signatureIndex = ((_el = el) === null || _el === void 0 ? void 0 : _el.activeSignature) || 0;
                    let activeSignature = el.signatures[signatureIndex];
                    if (!activeSignature) return;
                    let activeParam = (_el1 = el) === null || _el1 === void 0 ? void 0 : _el1.activeParameter;
                    let contents = activeSignature.label;
                    if (activeParam != undefined && activeSignature.parameters && activeSignature.parameters[activeParam]) {
                        let param = activeSignature.parameters[activeParam].label;
                        if (typeof param == "string") {
                            contents = contents.replace(param, `**${param}**`);
                        }
                    }
                    if (activeSignature.documentation) {
                        if (MarkupContent.is(activeSignature.documentation)) {
                            return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
                        } else {
                            contents += "\n\n" + activeSignature.documentation;
                            return contents;
                        }
                    } else {
                        return contents;
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            }
            function fromMarkupContent(content) {
                if (!content) return;
                if (typeof content === "string") {
                    return content;
                } else {
                    return content.value;
                }
            }
            function fromAceDelta(delta, eol) {
                const text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
                return {
                    range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
                    text: delta.action === "insert" ? text : ""
                };
            }
            function filterDiagnostics(diagnostics, filterErrors) {
                return common_converters_CommonConverter.excludeByErrorMessage(diagnostics, filterErrors.errorMessagesToIgnore).map((el)=>{
                    if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsWarning)) {
                        el.severity = main.DiagnosticSeverity.Warning;
                    } else if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsInfo)) {
                        el.severity = main.DiagnosticSeverity.Information;
                    }
                    return el;
                });
            }
            function fromDocumentHighlights(documentHighlights) {
                return documentHighlights.map(function(el) {
                    let className = el.kind == 2 ? "language_highlight_read" : el.kind == 3 ? "language_highlight_write" : "language_highlight_text";
                    return toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), className);
                });
            }
            function toMarkerGroupItem(range, className, tooltipText) {
                let markerGroupItem = {
                    range: range,
                    className: className
                };
                if (tooltipText) {
                    markerGroupItem["tooltipText"] = tooltipText;
                }
                return markerGroupItem;
            }
            ; // CONCATENATED MODULE: ./src/services/lua/lua-service.ts
            function lua_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class LuaService extends base_service.BaseService {
                async doValidation(document1) {
                    let value = this.getDocumentValue(document1.uri);
                    if (!value) return [];
                    let errors = [];
                    try {
                        this.$service.parse(value);
                    } catch (e) {
                        if (e instanceof this.$service.SyntaxError) {
                            errors.push({
                                range: {
                                    start: {
                                        line: e.line - 1,
                                        character: e.column
                                    },
                                    end: {
                                        line: e.line - 1,
                                        character: e.column
                                    }
                                },
                                message: e.message,
                                severity: 1
                            });
                        }
                    }
                    return filterDiagnostics(errors, this.optionsToFilterDiagnostics);
                }
                constructor(mode){
                    super(mode);
                    lua_service_define_property(this, "$service", void 0);
                    lua_service_define_property(this, "serviceCapabilities", {
                        diagnosticProvider: {
                            interFileDependencies: true,
                            workspaceDiagnostics: true
                        }
                    });
                    this.$service = luaparse;
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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STRsQixTQUFTLEVBQUU7b0JBQ2YsSUFBSTt3QkFDQSxJQUFJLENBQUNxcEQsUUFBUSxDQUFDajRDLEtBQUssQ0FBQ2gzQjtvQkFDeEIsRUFBRSxPQUFPOEIsR0FBRzt3QkFDUixJQUFJQSxhQUFhLElBQUksQ0FBQ210RSxRQUFRLENBQUNyMkQsV0FBVyxFQUFFOzRCQUN4Q2dOLE9BQU9sa0IsSUFBSSxDQUFDO2dDQUNSeXFCLE9BQU87b0NBQ0gvZSxPQUFPO3dDQUNIMGUsTUFBTWhxQixFQUFFZ3FCLElBQUksR0FBRzt3Q0FDZjRDLFdBQVc1c0IsRUFBRWlxQixNQUFNO29DQUN2QjtvQ0FDQS9oQixLQUFLO3dDQUNEOGhCLE1BQU1ocUIsRUFBRWdxQixJQUFJLEdBQUc7d0NBQ2Y0QyxXQUFXNXNCLEVBQUVpcUIsTUFBTTtvQ0FDdkI7Z0NBQ0o7Z0NBQ0FwdEIsU0FBU21ELEVBQUVuRCxPQUFPO2dDQUNsQjZqRSxVQUFVOzRCQUNkO3dCQUNKO29CQUNKO29CQUNBLE9BQU9pTSxrQkFBa0I3b0QsUUFBUSxJQUFJLENBQUM4WiwwQkFBMEI7Z0JBQ3BFO2dCQUNBNWpDLFlBQVlvbEMsSUFBSSxDQUFDO29CQUNiLEtBQUssQ0FBQ0E7b0JBQ044dEMsNEJBQTRCLElBQUksRUFBRSxZQUFZLEtBQUs7b0JBQ25EQSw0QkFBNEIsSUFBSSxFQUFFLHVCQUF1Qjt3QkFDckRFLG9CQUFvQjs0QkFDaEJDLHVCQUF1Qjs0QkFDdkJDLHNCQUFzQjt3QkFDMUI7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDSCxRQUFRLEdBQUdsRjtnQkFDcEI7WUFDSjtRQUVBO1FBRUEsTUFBTSxHQUFJLE9BQU9qdEMsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL2FjZS1saW50ZXJzLXJvb3QvLi9wYWNrYWdlcy9hY2UtbGludGVycy9idWlsZC9sdWEtc2VydmljZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA2MDkzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MDcpO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2NCk7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2Fzc2VydC5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8yYTUxYWU0MjRhNTEzZWM5YTZhYTM0NjZiYWEwY2MxZDU1ZGQ0ZjNiXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzQyKSxcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUztcblxudmFyIEFzc2VydGlvbkVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODAxKTtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgX3JlcXVpcmUkdHlwZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KS50eXBlcyksXG4gICAgaXNQcm9taXNlID0gX3JlcXVpcmUkdHlwZXMuaXNQcm9taXNlLFxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHA7XG5cbnZhciBvYmplY3RBc3NpZ24gPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbiA6IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMwNDYpLmFzc2lnbik7XG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIGVycm9yQ2FjaGUgPSBuZXcgTWFwKCk7XG52YXIgaXNEZWVwRXF1YWw7XG52YXIgaXNEZWVwU3RyaWN0RXF1YWw7XG52YXIgcGFyc2VFeHByZXNzaW9uQXQ7XG52YXIgZmluZE5vZGVBcm91bmQ7XG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gbGF6eUxvYWRDb21wYXJpc29uKCkge1xuICB2YXIgY29tcGFyaXNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTY1Nik7XG5cbiAgaXNEZWVwRXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcEVxdWFsO1xuICBpc0RlZXBTdHJpY3RFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwU3RyaWN0RXF1YWw7XG59IC8vIEVzY2FwZSBjb250cm9sIGNoYXJhY3RlcnMgYnV0IG5vdCBcXG4gYW5kIFxcdCB0byBrZWVwIHRoZSBsaW5lIGJyZWFrcyBhbmRcbi8vIGluZGVudGF0aW9uIGludGFjdC5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cblxudmFyIGVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZdL2c7XG52YXIgbWV0YSA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFtcIlxcXFx1MDAwMFwiLCBcIlxcXFx1MDAwMVwiLCBcIlxcXFx1MDAwMlwiLCBcIlxcXFx1MDAwM1wiLCBcIlxcXFx1MDAwNFwiLCBcIlxcXFx1MDAwNVwiLCBcIlxcXFx1MDAwNlwiLCBcIlxcXFx1MDAwN1wiLCAnXFxcXGInLCAnJywgJycsIFwiXFxcXHUwMDBiXCIsICdcXFxcZicsICcnLCBcIlxcXFx1MDAwZVwiLCBcIlxcXFx1MDAwZlwiLCBcIlxcXFx1MDAxMFwiLCBcIlxcXFx1MDAxMVwiLCBcIlxcXFx1MDAxMlwiLCBcIlxcXFx1MDAxM1wiLCBcIlxcXFx1MDAxNFwiLCBcIlxcXFx1MDAxNVwiLCBcIlxcXFx1MDAxNlwiLCBcIlxcXFx1MDAxN1wiLCBcIlxcXFx1MDAxOFwiLCBcIlxcXFx1MDAxOVwiLCBcIlxcXFx1MDAxYVwiLCBcIlxcXFx1MDAxYlwiLCBcIlxcXFx1MDAxY1wiLCBcIlxcXFx1MDAxZFwiLCBcIlxcXFx1MDAxZVwiLCBcIlxcXFx1MDAxZlwiXSkpO1xuXG52YXIgZXNjYXBlRm4gPSBmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xufTtcblxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuXG4gIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XG4gIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGlmICh3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nID8gcHJvY2Vzcy5lbWl0V2FybmluZyA6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgd2FybignYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwOTQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuXG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcblxuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblxuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufSAvLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuXG5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5vayA9IG9rOyAvLyBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGggPT0uXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuXG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cblxuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxuXG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBleHBlY3RlZFtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gIHJldHVybiBpc1Byb21pc2Uob2JqKSB8fCBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7IC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHBlY3RzRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgIHZhciBkZXRhaWxzID0gJyc7XG5cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlcnJvciAmJiAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWVycm9yIHx8IGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0JyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBhY3R1YWw7XG59XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcblxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxuICAgIH0pOyAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXG4gICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdG1wMi5zaGlmdCgpOyAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pO1xuXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3RXJyO1xuICB9XG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG5cbmZ1bmN0aW9uIHN0cmljdCgpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDk4MDE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwNyk7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuXG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykgeyBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlOyB9KSk7IH0gb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7IGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7IGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHsgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7IF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpOyB9IGZ1bmN0aW9uIFdyYXBwZXIoKSB7IHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH0gV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogV3JhcHBlciwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7IH07IHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTsgfVxuXG5mdW5jdGlvbiBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7IH0gZWxzZSB7IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgdmFyIGEgPSBbbnVsbF07IGEucHVzaC5hcHBseShhLCBhcmdzKTsgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpOyB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTsgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7IHJldHVybiBpbnN0YW5jZTsgfTsgfSByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZS5pbnNwZWN0O1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzQyKSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlMi5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTsgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xuICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGNvdW50ID09IDApIHJldHVybiAnJztcbiAgdmFyIG1heENvdW50ID0gc3RyLmxlbmd0aCAqIGNvdW50O1xuICBjb3VudCA9IE1hdGguZmxvb3IoTWF0aC5sb2coY291bnQpIC8gTWF0aC5sb2coMikpO1xuXG4gIHdoaWxlIChjb3VudCkge1xuICAgIHN0ciArPSBzdHI7XG4gICAgY291bnQtLTtcbiAgfVxuXG4gIHN0ciArPSBzdHIuc3Vic3RyaW5nKDAsIG1heENvdW50IC0gc3RyLmxlbmd0aCk7XG4gIHJldHVybiBzdHI7XG59XG5cbnZhciBibHVlID0gJyc7XG52YXIgZ3JlZW4gPSAnJztcbnZhciByZWQgPSAnJztcbnZhciB3aGl0ZSA9ICcnO1xudmFyIGtSZWFkYWJsZU9wZXJhdG9yID0ge1xuICBkZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbDonLFxuICBzdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBlcXVhbDonLFxuICBzdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBkZWVwRXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsOicsXG4gIGVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZXF1YWw6JyxcbiAgbm90RGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgc3RyaWN0bHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgc3RyaWN0bHkgdW5lcXVhbCB0bzonLFxuICBub3RTdHJpY3RFcXVhbE9iamVjdDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86JyxcbiAgbm90SWRlbnRpY2FsOiAnVmFsdWVzIGlkZW50aWNhbCBidXQgbm90IHJlZmVyZW5jZS1lcXVhbDonXG59OyAvLyBDb21wYXJpbmcgc2hvcnQgcHJpbWl0aXZlcyBzaG91bGQganVzdCBzaG93ID09PSAvICE9PSBpbnN0ZWFkIG9mIHVzaW5nIHRoZVxuLy8gZGlmZi5cblxudmFyIGtNYXhTaG9ydExlbmd0aCA9IDEwO1xuXG5mdW5jdGlvbiBjb3B5RXJyb3Ioc291cmNlKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIHRhcmdldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnbWVzc2FnZScsIHtcbiAgICB2YWx1ZTogc291cmNlLm1lc3NhZ2VcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RWYWx1ZSh2YWwpIHtcbiAgLy8gVGhlIHV0aWwuaW5zcGVjdCBkZWZhdWx0IHZhbHVlcyBjb3VsZCBiZSBjaGFuZ2VkLiBUaGlzIG1ha2VzIHN1cmUgdGhlXG4gIC8vIGVycm9yIG1lc3NhZ2VzIGNvbnRhaW4gdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBuZXZlcnRoZWxlc3MuXG4gIHJldHVybiBpbnNwZWN0KHZhbCwge1xuICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgIGRlcHRoOiAxMDAwLFxuICAgIG1heEFycmF5TGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgY29tcGFyZXMgb25seSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgKHdpdGggYSBmZXcgZXhjZXB0aW9ucykuXG4gICAgc2hvd0hpZGRlbjogZmFsc2UsXG4gICAgLy8gSGF2aW5nIGEgbG9uZyBsaW5lIGFzIGVycm9yIGlzIGJldHRlciB0aGFuIHdyYXBwaW5nIHRoZSBsaW5lIGZvclxuICAgIC8vIGNvbXBhcmlzb24gZm9yIG5vdy5cbiAgICAvLyBUT0RPKEJyaWRnZUFSKTogYGJyZWFrTGVuZ3RoYCBzaG91bGQgYmUgbGltaXRlZCBhcyBzb29uIGFzIHNvb24gYXMgd2VcbiAgICAvLyBoYXZlIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3BlY3RlZCBwcm9wZXJ0aWVzIChpLmUuLCBrbm93IHdoZXJlXG4gICAgLy8gaW4gd2hhdCBsaW5lIHRoZSBwcm9wZXJ0eSBzdGFydHMgYW5kIGVuZHMpLlxuICAgIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSxcbiAgICAvLyBBc3NlcnQgZG9lcyBub3QgZGV0ZWN0IHByb3hpZXMgY3VycmVudGx5LlxuICAgIHNob3dQcm94eTogZmFsc2UsXG4gICAgc29ydGVkOiB0cnVlLFxuICAgIC8vIEluc3BlY3QgZ2V0dGVycyBhcyB3ZSBhbHNvIGNoZWNrIHRoZW0gd2hlbiBjb21wYXJpbmcgZW50cmllcy5cbiAgICBnZXR0ZXJzOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSB7XG4gIHZhciBvdGhlciA9ICcnO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIGVuZCA9ICcnO1xuICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICB2YXIgYWN0dWFsSW5zcGVjdGVkID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG4gIHZhciBhY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7XG4gIHZhciBleHBlY3RlZExpbmVzID0gaW5zcGVjdFZhbHVlKGV4cGVjdGVkKS5zcGxpdCgnXFxuJyk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGluZGljYXRvciA9ICcnOyAvLyBJbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzIGV4cGxpY2l0bHkgbWFyayB0aGVtIGFzIG5vdCByZWZlcmVuY2UgZXF1YWxcbiAgLy8gZm9yIHRoZSBgc3RyaWN0RXF1YWxgIG9wZXJhdG9yLlxuXG4gIGlmIChvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICBvcGVyYXRvciA9ICdzdHJpY3RFcXVhbE9iamVjdCc7XG4gIH0gLy8gSWYgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIGZpdCBvbiBhIHNpbmdsZSBsaW5lIGFuZCB0aGV5IGFyZSBub3Qgc3RyaWN0bHlcbiAgLy8gZXF1YWwsIGNoZWNrIGZ1cnRoZXIgc3BlY2lhbCBoYW5kbGluZy5cblxuXG4gIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDEgJiYgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDEgJiYgYWN0dWFsTGluZXNbMF0gIT09IGV4cGVjdGVkTGluZXNbMF0pIHtcbiAgICB2YXIgaW5wdXRMZW5ndGggPSBhY3R1YWxMaW5lc1swXS5sZW5ndGggKyBleHBlY3RlZExpbmVzWzBdLmxlbmd0aDsgLy8gSWYgdGhlIGNoYXJhY3RlciBsZW5ndGggb2YgXCJhY3R1YWxcIiBhbmQgXCJleHBlY3RlZFwiIHRvZ2V0aGVyIGlzIGxlc3MgdGhhblxuICAgIC8vIGtNYXhTaG9ydExlbmd0aCBhbmQgaWYgbmVpdGhlciBpcyBhbiBvYmplY3QgYW5kIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzXG4gICAgLy8gbm90IGB6ZXJvYCwgdXNlIHRoZSBzdHJpY3QgZXF1YWwgY29tcGFyaXNvbiB0byB2aXN1YWxpemUgdGhlIG91dHB1dC5cblxuICAgIGlmIChpbnB1dExlbmd0aCA8PSBrTWF4U2hvcnRMZW5ndGgpIHtcbiAgICAgIGlmICgoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpICYmIChfdHlwZW9mKGV4cGVjdGVkKSAhPT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQgPT09IG51bGwpICYmIChhY3R1YWwgIT09IDAgfHwgZXhwZWN0ZWQgIT09IDApKSB7XG4gICAgICAgIC8vIC0wID09PSArMFxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKSArIFwiXCIuY29uY2F0KGFjdHVhbExpbmVzWzBdLCBcIiAhPT0gXCIpLmNvbmNhdChleHBlY3RlZExpbmVzWzBdLCBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yICE9PSAnc3RyaWN0RXF1YWxPYmplY3QnKSB7XG4gICAgICAvLyBJZiB0aGUgc3RkZXJyIGlzIGEgdHR5IGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgIC8vIGNvbHVtbnMgcGVyIGxpbmUsIGFkZCBhIG1pc21hdGNoIGluZGljYXRvciBiZWxvdyB0aGUgb3V0cHV0LiBJZiBpdCBpc1xuICAgICAgLy8gbm90IGEgdHR5LCB1c2UgYSBkZWZhdWx0IHZhbHVlIG9mIDgwIGNoYXJhY3RlcnMuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gcHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkgPyBwcm9jZXNzLnN0ZGVyci5jb2x1bW5zIDogODA7XG5cbiAgICAgIGlmIChpbnB1dExlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB3aGlsZSAoYWN0dWFsTGluZXNbMF1baV0gPT09IGV4cGVjdGVkTGluZXNbMF1baV0pIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gLy8gSWdub3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXJzLlxuXG5cbiAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgLy8gQWRkIHBvc2l0aW9uIGluZGljYXRvciBmb3IgdGhlIGZpcnN0IG1pc21hdGNoIGluIGNhc2UgaXQgaXMgYVxuICAgICAgICAgIC8vIHNpbmdsZSBsaW5lIGFuZCB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgY29sdW1uIGxlbmd0aC5cbiAgICAgICAgICBpbmRpY2F0b3IgPSBcIlxcbiAgXCIuY29uY2F0KHJlcGVhdCgnICcsIGkpLCBcIl5cIik7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVtb3ZlIGFsbCBlbmRpbmcgbGluZXMgdGhhdCBtYXRjaCAodGhpcyBvcHRpbWl6ZXMgdGhlIG91dHB1dCBmb3JcbiAgLy8gcmVhZGFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiB0b3RhbCBjaGFuZ2VkIGxpbmVzKS5cblxuXG4gIHZhciBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gIHZhciBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuXG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgaWYgKGkrKyA8IDIpIHtcbiAgICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQoYSkuY29uY2F0KGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyID0gYTtcbiAgICB9XG5cbiAgICBhY3R1YWxMaW5lcy5wb3AoKTtcbiAgICBleHBlY3RlZExpbmVzLnBvcCgpO1xuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPT09IDAgfHwgZXhwZWN0ZWRMaW5lcy5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgICBiID0gZXhwZWN0ZWRMaW5lc1tleHBlY3RlZExpbmVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgdmFyIG1heExpbmVzID0gTWF0aC5tYXgoYWN0dWFsTGluZXMubGVuZ3RoLCBleHBlY3RlZExpbmVzLmxlbmd0aCk7IC8vIFN0cmljdCBlcXVhbCB3aXRoIGlkZW50aWNhbCBvYmplY3RzIHRoYXQgYXJlIG5vdCBpZGVudGljYWwgYnkgcmVmZXJlbmNlLlxuICAvLyBFLmcuLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKHsgYTogU3ltYm9sKCkgfSwgeyBhOiBTeW1ib2woKSB9KVxuXG4gIGlmIChtYXhMaW5lcyA9PT0gMCkge1xuICAgIC8vIFdlIGhhdmUgdG8gZ2V0IHRoZSByZXN1bHQgYWdhaW4uIFRoZSBsaW5lcyB3ZXJlIGFsbCByZW1vdmVkIGJlZm9yZS5cbiAgICB2YXIgX2FjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTsgLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICBpZiAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICBfYWN0dWFsTGluZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcblxuICAgICAgd2hpbGUgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAyNykge1xuICAgICAgICBfYWN0dWFsTGluZXMucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yLm5vdElkZW50aWNhbCwgXCJcXG5cXG5cIikuY29uY2F0KF9hY3R1YWxMaW5lcy5qb2luKCdcXG4nKSwgXCJcXG5cIik7XG4gIH1cblxuICBpZiAoaSA+IDMpIHtcbiAgICBlbmQgPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChlbmQpO1xuICAgIHNraXBwZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG90aGVyICE9PSAnJykge1xuICAgIGVuZCA9IFwiXFxuICBcIi5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpO1xuICAgIG90aGVyID0gJyc7XG4gIH1cblxuICB2YXIgcHJpbnRlZExpbmVzID0gMDtcbiAgdmFyIG1zZyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSArIFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIisgYWN0dWFsXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChyZWQsIFwiLSBleHBlY3RlZFwiKS5jb25jYXQod2hpdGUpO1xuICB2YXIgc2tpcHBlZE1zZyA9IFwiIFwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUsIFwiIExpbmVzIHNraXBwZWRcIik7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heExpbmVzOyBpKyspIHtcbiAgICAvLyBPbmx5IGV4dHJhIGV4cGVjdGVkIGxpbmVzIGV4aXN0XG4gICAgdmFyIGN1ciA9IGkgLSBsYXN0UG9zO1xuXG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGV4cGVjdGVkTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGV4cGVjdGVkIGxpbmUgdG8gdGhlIGNhY2hlLlxuXG4gICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gT25seSBleHRyYSBhY3R1YWwgbGluZXMgZXhpc3RcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7IC8vIExpbmVzIGRpdmVyZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4cGVjdGVkTGluZSA9IGV4cGVjdGVkTGluZXNbaV07XG4gICAgICB2YXIgYWN0dWFsTGluZSA9IGFjdHVhbExpbmVzW2ldOyAvLyBJZiB0aGUgbGluZXMgZGl2ZXJnZSwgc3BlY2lmaWNhbGx5IGNoZWNrIGZvciBsaW5lcyB0aGF0IG9ubHkgZGl2ZXJnZSBieVxuICAgICAgLy8gYSB0cmFpbGluZyBjb21tYS4gSW4gdGhhdCBjYXNlIGl0IGlzIGFjdHVhbGx5IGlkZW50aWNhbCBhbmQgd2Ugc2hvdWxkXG4gICAgICAvLyBtYXJrIGl0IGFzIHN1Y2guXG5cbiAgICAgIHZhciBkaXZlcmdpbmdMaW5lcyA9IGFjdHVhbExpbmUgIT09IGV4cGVjdGVkTGluZSAmJiAoIWVuZHNXaXRoKGFjdHVhbExpbmUsICcsJykgfHwgYWN0dWFsTGluZS5zbGljZSgwLCAtMSkgIT09IGV4cGVjdGVkTGluZSk7IC8vIElmIHRoZSBleHBlY3RlZCBsaW5lIGhhcyBhIHRyYWlsaW5nIGNvbW1hIGJ1dCBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLFxuICAgICAgLy8gYWRkIGEgY29tbWEgYXQgdGhlIGVuZCBvZiB0aGUgYWN0dWFsIGxpbmUuIE90aGVyd2lzZSB0aGUgb3V0cHV0IGNvdWxkXG4gICAgICAvLyBsb29rIHdlaXJkIGFzIGluOlxuICAgICAgLy9cbiAgICAgIC8vICAgW1xuICAgICAgLy8gICAgIDEgICAgICAgICAvLyBObyBjb21tYSBhdCB0aGUgZW5kIVxuICAgICAgLy8gKyAgIDJcbiAgICAgIC8vICAgXVxuICAgICAgLy9cblxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzICYmIGVuZHNXaXRoKGV4cGVjdGVkTGluZSwgJywnKSAmJiBleHBlY3RlZExpbmUuc2xpY2UoMCwgLTEpID09PSBhY3R1YWxMaW5lKSB7XG4gICAgICAgIGRpdmVyZ2luZ0xpbmVzID0gZmFsc2U7XG4gICAgICAgIGFjdHVhbExpbmUgKz0gJywnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDJdKTtcbiAgICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAxXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBhY3R1YWwgbGluZSB0byB0aGUgcmVzdWx0IGFuZCBjYWNoZSB0aGUgZXhwZWN0ZWQgZGl2ZXJnaW5nXG4gICAgICAgIC8vIGxpbmUgc28gY29uc2VjdXRpdmUgZGl2ZXJnaW5nIGxpbmVzIHNob3cgdXAgYXMgKysrLS0tIGFuZCBub3QgKy0rLSstLlxuXG4gICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZSk7XG4gICAgICAgIHByaW50ZWRMaW5lcyArPSAyOyAvLyBMaW5lcyBhcmUgaWRlbnRpY2FsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgYWxsIGNhY2hlZCBpbmZvcm1hdGlvbiB0byB0aGUgcmVzdWx0IGJlZm9yZSBhZGRpbmcgb3RoZXIgdGhpbmdzXG4gICAgICAgIC8vIGFuZCByZXNldCB0aGUgY2FjaGUuXG4gICAgICAgIHJlcyArPSBvdGhlcjtcbiAgICAgICAgb3RoZXIgPSAnJzsgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgZXhhY3RseSBvbmUgbGluZSBhYm92ZSBvciBpZiBpdCBpcyB0aGVcbiAgICAgICAgLy8gdmVyeSBmaXJzdCBsaW5lLCBhZGQgdGhlIGxpbmUgdG8gdGhlIHJlc3VsdC5cblxuICAgICAgICBpZiAoY3VyID09PSAxIHx8IGkgPT09IDApIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSW5zcGVjdGVkIG9iamVjdCB0byBiaWcgKFNob3cgfjIwIHJvd3MgbWF4KVxuXG5cbiAgICBpZiAocHJpbnRlZExpbmVzID4gMjAgJiYgaSA8IG1heExpbmVzIC0gMikge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWRNc2csIFwiXFxuXCIpLmNvbmNhdChyZXMsIFwiXFxuXCIpLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpLmNvbmNhdChvdGhlciwgXCJcXG5cIikgKyBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkID8gc2tpcHBlZE1zZyA6ICcnLCBcIlxcblwiKS5jb25jYXQocmVzKS5jb25jYXQob3RoZXIpLmNvbmNhdChlbmQpLmNvbmNhdChpbmRpY2F0b3IpO1xufVxuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoQXNzZXJ0aW9uRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb25FcnJvcik7XG5cbiAgICBpZiAoX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdvcHRpb25zJywgJ09iamVjdCcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICBvcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3IsXG4gICAgICAgIHN0YWNrU3RhcnRGbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZuO1xuICAgIHZhciBhY3R1YWwgPSBvcHRpb25zLmFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuXG4gICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgU3RyaW5nKG1lc3NhZ2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICAvLyBSZXNldCBvbiBlYWNoIGNhbGwgdG8gbWFrZSBzdXJlIHdlIGhhbmRsZSBkeW5hbWljYWxseSBzZXQgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gdmFyaWFibGVzIGNvcnJlY3QuXG4gICAgICAgIGlmIChwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGgoKSAhPT0gMSkge1xuICAgICAgICAgIGJsdWUgPSBcIlxceDFCWzM0bVwiO1xuICAgICAgICAgIGdyZWVuID0gXCJcXHgxQlszMm1cIjtcbiAgICAgICAgICB3aGl0ZSA9IFwiXFx4MUJbMzltXCI7XG4gICAgICAgICAgcmVkID0gXCJcXHgxQlszMW1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibHVlID0gJyc7XG4gICAgICAgICAgZ3JlZW4gPSAnJztcbiAgICAgICAgICB3aGl0ZSA9ICcnO1xuICAgICAgICAgIHJlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IC8vIFByZXZlbnQgdGhlIGVycm9yIHN0YWNrIGZyb20gYmVpbmcgdmlzaWJsZSBieSBkdXBsaWNhdGluZyB0aGUgZXJyb3JcbiAgICAgIC8vIGluIGEgdmVyeSBjbG9zZSB3YXkgdG8gdGhlIG9yaWdpbmFsIGluIGNhc2UgYm90aCBzaWRlcyBhcmUgYWN0dWFsbHlcbiAgICAgIC8vIGluc3RhbmNlcyBvZiBFcnJvci5cblxuXG4gICAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkICE9PSBudWxsICYmICdzdGFjaycgaW4gYWN0dWFsICYmIGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yICYmICdzdGFjaycgaW4gZXhwZWN0ZWQgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBhY3R1YWwgPSBjb3B5RXJyb3IoYWN0dWFsKTtcbiAgICAgICAgZXhwZWN0ZWQgPSBjb3B5RXJyb3IoZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpKSk7XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJykge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBidXQgdGhlIG9wZXJhdG9yIHJlcXVpcmVzIHVuZXF1YWwsIHNob3dcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9iamVjdCBhbmQgc2F5IEEgZXF1YWxzIEJcbiAgICAgICAgdmFyIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG4gICAgICAgIHZhciByZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKS5zcGxpdCgnXFxuJyk7IC8vIEluIGNhc2UgXCJhY3R1YWxcIiBpcyBhbiBvYmplY3QsIGl0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlIGVxdWFsLlxuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdFN0cmljdEVxdWFsJyAmJiBfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGJhc2UgPSBrUmVhZGFibGVPcGVyYXRvci5ub3RTdHJpY3RFcXVhbE9iamVjdDtcbiAgICAgICAgfSAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgICAgICAvLyBUT0RPOiBBY2NlcHQgZW52IHRvIGFsd2F5cyBzaG93IHRoZSBmdWxsIGVycm9yLlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAzMCkge1xuICAgICAgICAgIHJlc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICAgICAgd2hpbGUgKHJlcy5sZW5ndGggPiAyNykge1xuICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPbmx5IHByaW50IGEgc2luZ2xlIGlucHV0LlxuXG5cbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIiBcIikuY29uY2F0KHJlc1swXSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChiYXNlLCBcIlxcblxcblwiKS5jb25jYXQocmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpO1xuXG4gICAgICAgIHZhciBvdGhlciA9ICcnO1xuICAgICAgICB2YXIga25vd25PcGVyYXRvcnMgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl07XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90RGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ25vdEVxdWFsJykge1xuICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChfcmVzLnNsaWNlKDAsIDEwMjEpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpKTtcblxuICAgICAgICAgIGlmIChfcmVzLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgb3RoZXIgPSBcIlwiLmNvbmNhdChvdGhlci5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdkZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnZXF1YWwnKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa25vd25PcGVyYXRvcnMsIFwiXFxuXFxuXCIpLmNvbmNhdChfcmVzLCBcIlxcblxcbnNob3VsZCBlcXVhbFxcblxcblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXIgPSBcIiBcIi5jb25jYXQob3BlcmF0b3IsIFwiIFwiKS5jb25jYXQob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KF9yZXMpLmNvbmNhdChvdGhlcikpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICBfdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW1lc3NhZ2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnQXNzZXJ0aW9uRXJyb3IgW0VSUl9BU1NFUlRJT05dJyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIF90aGlzLmFjdHVhbCA9IGFjdHVhbDtcbiAgICBfdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIF90aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHN0YWNrU3RhcnRGbik7XG4gICAgfSAvLyBDcmVhdGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGUgaW4gdGhlIG5hbWUuXG5cblxuICAgIF90aGlzLnN0YWNrOyAvLyBSZXNldCB0aGUgbmFtZS5cblxuICAgIF90aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXNzZXJ0aW9uRXJyb3IsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIgW1wiKS5jb25jYXQodGhpcy5jb2RlLCBcIl06IFwiKS5jb25jYXQodGhpcy5tZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IGluc3BlY3QuY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZWN1cnNlVGltZXMsIGN0eCkge1xuICAgICAgLy8gVGhpcyBsaW1pdHMgdGhlIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgIHByb3BlcnR5IGRlZmF1bHQgaW5zcGVjdGlvbiB0b1xuICAgICAgLy8gdGhlIG1pbmltdW0gZGVwdGguIE90aGVyd2lzZSB0aG9zZSB2YWx1ZXMgd291bGQgYmUgdG9vIHZlcmJvc2UgY29tcGFyZWRcbiAgICAgIC8vIHRvIHRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZSB3aGljaCBjb250YWlucyBhIGNvbWJpbmVkIHZpZXcgb2YgdGhlc2UgdHdvXG4gICAgICAvLyBpbnB1dCB2YWx1ZXMuXG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBjdHgsIHtcbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAgIGRlcHRoOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzQyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvZXJyb3JzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzNiMDQ0OTYyYzQ4ZmUzMTM5MDU4NzdhOTZiNWQwODk0YTU0MDRmNmZcblxuLyogZXNsaW50IG5vZGUtY29yZS9kb2N1bWVudGVkLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvYWxwaGFiZXRpemUtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9wcmVmZXItdXRpbC1mb3JtYXQtZXJyb3JzOiBcImVycm9yXCIgKi9cbiAvLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cbi8vIGxvbmdlciBiZSBmb3JjZWQgdG8gdHJlYXQgZXZlcnkgZXJyb3IgbWVzc2FnZSBjaGFuZ2UgYXMgYSBzZW12ZXItbWFqb3Jcbi8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxuLy8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuLy8gbWVzc2FnZSBtYXkgY2hhbmdlLCB0aGUgY29kZSBzaG91bGQgbm90LlxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBjb2RlcyA9IHt9OyAvLyBMYXp5IGxvYWRlZFxuXG52YXIgYXNzZXJ0O1xudmFyIHV0aWw7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHMoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUVycm9yKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTm9kZUVycm9yKS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpKTtcbiAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9BTUJJR1VPVVNfQVJHVU1FTlQnLCAnVGhlIFwiJXNcIiBhcmd1bWVudCBpcyBhbWJpZ3VvdXMuICVzJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5Myk7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcblxuICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgIGluc3BlY3RlZCA9IFwiXCIuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCBcIi4uLlwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGlucHV0LCBcIiB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCJcIikgKyBcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlLCBcIi5cIik7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwOTMpO1xuICBhc3NlcnQoYXJncy5sZW5ndGggPiAwLCAnQXQgbGVhc3Qgb25lIGFyZyBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgdmFyIG1zZyA9ICdUaGUgJztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KGEsIFwiXFxcIlwiKTtcbiAgfSk7XG5cbiAgc3dpdGNoIChsZW4pIHtcbiAgICBjYXNlIDE6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYXJndW1lbnRcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhbmQgXCIpLmNvbmNhdChhcmdzWzFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpO1xuICAgICAgbXNnICs9IFwiLCBhbmQgXCIuY29uY2F0KGFyZ3NbbGVuIC0gMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZywgXCIgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG59LCBUeXBlRXJyb3IpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcblxuLyoqKi8gfSksXG5cbi8qKiovIDU2NTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPSAvYS9nLmZsYWdzICE9PSB1bmRlZmluZWQ7XG5cbnZhciBhcnJheUZyb21TZXQgPSBmdW5jdGlvbiBhcnJheUZyb21TZXQoc2V0KSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaCh2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlGcm9tTWFwID0gZnVuY3Rpb24gYXJyYXlGcm9tTWFwKG1hcCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gYXJyYXkucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdO1xufTtcbnZhciBudW1iZXJJc05hTiA9IE51bWJlci5pc05hTiA/IE51bWJlci5pc05hTiA6IF9fd2VicGFja19yZXF1aXJlX18oNzgzOCk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpLnR5cGVzKSxcbiAgICBpc0FueUFycmF5QnVmZmVyID0gX3JlcXVpcmUkdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcixcbiAgICBpc0FycmF5QnVmZmVyVmlldyA9IF9yZXF1aXJlJHR5cGVzLmlzQXJyYXlCdWZmZXJWaWV3LFxuICAgIGlzRGF0ZSA9IF9yZXF1aXJlJHR5cGVzLmlzRGF0ZSxcbiAgICBpc01hcCA9IF9yZXF1aXJlJHR5cGVzLmlzTWFwLFxuICAgIGlzUmVnRXhwID0gX3JlcXVpcmUkdHlwZXMuaXNSZWdFeHAsXG4gICAgaXNTZXQgPSBfcmVxdWlyZSR0eXBlcy5pc1NldCxcbiAgICBpc05hdGl2ZUVycm9yID0gX3JlcXVpcmUkdHlwZXMuaXNOYXRpdmVFcnJvcixcbiAgICBpc0JveGVkUHJpbWl0aXZlID0gX3JlcXVpcmUkdHlwZXMuaXNCb3hlZFByaW1pdGl2ZSxcbiAgICBpc051bWJlck9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzTnVtYmVyT2JqZWN0LFxuICAgIGlzU3RyaW5nT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTdHJpbmdPYmplY3QsXG4gICAgaXNCb29sZWFuT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCb29sZWFuT2JqZWN0LFxuICAgIGlzQmlnSW50T2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNCaWdJbnRPYmplY3QsXG4gICAgaXNTeW1ib2xPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N5bWJvbE9iamVjdCxcbiAgICBpc0Zsb2F0MzJBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQzMkFycmF5LFxuICAgIGlzRmxvYXQ2NEFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTm9uSW5kZXgoa2V5KSB7XG4gIGlmIChrZXkubGVuZ3RoID09PSAwIHx8IGtleS5sZW5ndGggPiAxMCkgcmV0dXJuIHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBUaGUgbWF4aW11bSBzaXplIGZvciBhbiBhcnJheSBpcyAyICoqIDMyIC0xLlxuXG5cbiAgcmV0dXJuIGtleS5sZW5ndGggPT09IDEwICYmIGtleSA+PSBNYXRoLnBvdygyLCAzMik7XG59XG5cbmZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihpc05vbkluZGV4KS5jb25jYXQob2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKS5maWx0ZXIoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5iaW5kKHZhbHVlKSkpO1xufSAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG52YXIgT05MWV9FTlVNRVJBQkxFID0gdW5kZWZpbmVkO1xudmFyIGtTdHJpY3QgPSB0cnVlO1xudmFyIGtMb29zZSA9IGZhbHNlO1xudmFyIGtOb0l0ZXJhdG9yID0gMDtcbnZhciBrSXNBcnJheSA9IDE7XG52YXIga0lzU2V0ID0gMjtcbnZhciBrSXNNYXAgPSAzOyAvLyBDaGVjayBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgc291cmNlIGFuZCBmbGFnc1xuXG5mdW5jdGlvbiBhcmVTaW1pbGFyUmVnRXhwcyhhLCBiKSB7XG4gIHJldHVybiByZWdleEZsYWdzU3VwcG9ydGVkID8gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3MgOiBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgPT09IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhckZsb2F0QXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYS5ieXRlTGVuZ3RoOyBvZmZzZXQrKykge1xuICAgIGlmIChhW29mZnNldF0gIT09IGJbb2Zmc2V0XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyVHlwZWRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpLCBuZXcgVWludDhBcnJheShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gYXJlRXF1YWxBcnJheUJ1ZmZlcnMoYnVmMSwgYnVmMikge1xuICByZXR1cm4gYnVmMS5ieXRlTGVuZ3RoID09PSBidWYyLmJ5dGVMZW5ndGggJiYgY29tcGFyZShuZXcgVWludDhBcnJheShidWYxKSwgbmV3IFVpbnQ4QXJyYXkoYnVmMikpID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikge1xuICBpZiAoaXNOdW1iZXJPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNOdW1iZXJPYmplY3QodmFsMikgJiYgb2JqZWN0SXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSksIE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpKTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZ09iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc1N0cmluZ09iamVjdCh2YWwyKSAmJiBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQm9vbGVhbk9iamVjdCh2YWwyKSAmJiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0ludE9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0JpZ0ludE9iamVjdCh2YWwyKSAmJiBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICByZXR1cm4gaXNTeW1ib2xPYmplY3QodmFsMikgJiYgU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xufSAvLyBOb3RlczogVHlwZSB0YWdzIGFyZSBoaXN0b3JpY2FsIFtbQ2xhc3NdXSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCBieVxuLy8gRnVuY3Rpb25UZW1wbGF0ZTo6U2V0Q2xhc3NOYW1lKCkgaW4gQysrIG9yIFN5bWJvbC50b1N0cmluZ1RhZyBpbiBKU1xuLy8gYW5kIHJldHJpZXZlZCB1c2luZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSBpbiBKU1xuLy8gU2VlIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbi8vIGZvciBhIGxpc3Qgb2YgdGFncyBwcmUtZGVmaW5lZCBpbiB0aGUgc3BlYy5cbi8vIFRoZXJlIGFyZSBzb21lIHVuc3BlY2lmaWVkIHRhZ3MgaW4gdGhlIHdpbGQgdG9vIChlLmcuIHR5cGVkIGFycmF5IHRhZ3MpLlxuLy8gU2luY2UgdGFncyBjYW4gYmUgYWx0ZXJlZCwgdGhleSBvbmx5IHNlcnZlIGZhc3QgZmFpbHVyZXNcbi8vXG4vLyBUeXBlZCBhcnJheXMgYW5kIGJ1ZmZlcnMgYXJlIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZSBjb250ZW50IGluIHRoZWlyXG4vLyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGF0IGl0J3Ncbi8vIHJlYXNvbmFibGUgdG8gaW50ZXJwcmV0IHRoZWlyIHVuZGVybHlpbmcgbWVtb3J5IGluIHRoZSBzYW1lIHdheSxcbi8vIHdoaWNoIGlzIGNoZWNrZWQgYnkgY29tcGFyaW5nIHRoZWlyIHR5cGUgdGFncy5cbi8vIChlLmcuIGEgVWludDhBcnJheSBhbmQgYSBVaW50MTZBcnJheSB3aXRoIHRoZSBzYW1lIG1lbW9yeSBjb250ZW50XG4vLyBjb3VsZCBzdGlsbCBiZSBkaWZmZXJlbnQgYmVjYXVzZSB0aGV5IHdpbGwgYmUgaW50ZXJwcmV0ZWQgZGlmZmVyZW50bHkpLlxuLy9cbi8vIEZvciBzdHJpY3QgY29tcGFyaXNvbiwgb2JqZWN0cyBzaG91bGQgaGF2ZVxuLy8gYSkgVGhlIHNhbWUgYnVpbHQtaW4gdHlwZSB0YWdzXG4vLyBiKSBUaGUgc2FtZSBwcm90b3R5cGVzLlxuXG5cbmZ1bmN0aW9uIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAodmFsMSA9PT0gdmFsMikge1xuICAgIGlmICh2YWwxICE9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc3RyaWN0ID8gb2JqZWN0SXModmFsMSwgdmFsMikgOiB0cnVlO1xuICB9IC8vIENoZWNrIG1vcmUgY2xvc2VseSBpZiB2YWwxIGFuZCB2YWwyIGFyZSBlcXVhbC5cblxuXG4gIGlmIChzdHJpY3QpIHtcbiAgICBpZiAoX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsMSA9PT0gJ251bWJlcicgJiYgbnVtYmVySXNOYU4odmFsMSkgJiYgbnVtYmVySXNOYU4odmFsMik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnIHx8IHZhbDEgPT09IG51bGwgfHwgdmFsMiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsMSA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICByZXR1cm4gdmFsMSA9PSB2YWwyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHZhbDIgPT09IG51bGwgfHwgX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsMVRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDEpO1xuICB2YXIgdmFsMlRhZyA9IG9iamVjdFRvU3RyaW5nKHZhbDIpO1xuXG4gIGlmICh2YWwxVGFnICE9PSB2YWwyVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsMSkpIHtcbiAgICAvLyBDaGVjayBmb3Igc3BhcnNlIGFycmF5cyBhbmQgZ2VuZXJhbCBmYXN0IHBhdGhcbiAgICBpZiAodmFsMS5sZW5ndGggIT09IHZhbDIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGtleXMxID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG4gICAgdmFyIGtleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzQXJyYXksIGtleXMxKTtcbiAgfSAvLyBbYnJvd3NlcmlmeV0gVGhpcyB0cmlnZ2VycyBvbiBjZXJ0YWluIHR5cGVzIGluIElFIChNYXAvU2V0KSBzbyB3ZSBkb24ndFxuICAvLyB3YW4ndCB0byBlYXJseSByZXR1cm4gb3V0IG9mIHRoZSByZXN0IG9mIHRoZSBjaGVja3MuIEhvd2V2ZXIgd2UgY2FuIGNoZWNrXG4gIC8vIGlmIHRoZSBzZWNvbmQgdmFsdWUgaXMgb25lIG9mIHRoZXNlIHZhbHVlcyBhbmQgdGhlIGZpcnN0IGlzbid0LlxuXG5cbiAgaWYgKHZhbDFUYWcgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgLy8gcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbiAgICBpZiAoIWlzTWFwKHZhbDEpICYmIGlzTWFwKHZhbDIpIHx8ICFpc1NldCh2YWwxKSAmJiBpc1NldCh2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0RhdGUodmFsMSkpIHtcbiAgICBpZiAoIWlzRGF0ZSh2YWwyKSB8fCBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMSkgIT09IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWwxKSkge1xuICAgIGlmICghaXNSZWdFeHAodmFsMikgfHwgIWFyZVNpbWlsYXJSZWdFeHBzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmF0aXZlRXJyb3IodmFsMSkgfHwgdmFsMSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgLy8gRG8gbm90IGNvbXBhcmUgdGhlIHN0YWNrIGFzIGl0IG1pZ2h0IGRpZmZlciBldmVuIHRob3VnaCB0aGUgZXJyb3IgaXRzZWxmXG4gICAgLy8gaXMgb3RoZXJ3aXNlIGlkZW50aWNhbC5cbiAgICBpZiAodmFsMS5tZXNzYWdlICE9PSB2YWwyLm1lc3NhZ2UgfHwgdmFsMS5uYW1lICE9PSB2YWwyLm5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlclZpZXcodmFsMSkpIHtcbiAgICBpZiAoIXN0cmljdCAmJiAoaXNGbG9hdDMyQXJyYXkodmFsMSkgfHwgaXNGbG9hdDY0QXJyYXkodmFsMSkpKSB7XG4gICAgICBpZiAoIWFyZVNpbWlsYXJGbG9hdEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYXJlU2ltaWxhclR5cGVkQXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBCdWZmZXIuY29tcGFyZSByZXR1cm5zIHRydWUsIHNvIHZhbDEubGVuZ3RoID09PSB2YWwyLmxlbmd0aC4gSWYgdGhleSBib3RoXG4gICAgLy8gb25seSBjb250YWluIG51bWVyaWMga2V5cywgd2UgZG9uJ3QgbmVlZCB0byBleGFtIGZ1cnRoZXIgdGhhbiBjaGVja2luZ1xuICAgIC8vIHRoZSBzeW1ib2xzLlxuXG5cbiAgICB2YXIgX2tleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIHZhciBfa2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChfa2V5cy5sZW5ndGggIT09IF9rZXlzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IsIF9rZXlzKTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWwxKSkge1xuICAgIGlmICghaXNTZXQodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzU2V0KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWwxKSkge1xuICAgIGlmICghaXNNYXAodmFsMikgfHwgdmFsMS5zaXplICE9PSB2YWwyLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga0lzTWFwKTtcbiAgfSBlbHNlIGlmIChpc0FueUFycmF5QnVmZmVyKHZhbDEpKSB7XG4gICAgaWYgKCFhcmVFcXVhbEFycmF5QnVmZmVycyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbDEpICYmICFpc0VxdWFsQm94ZWRQcmltaXRpdmUodmFsMSwgdmFsMikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlcyh2YWwsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbCwgayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBpdGVyYXRpb25UeXBlLCBhS2V5cykge1xuICAvLyBGb3IgYWxsIHJlbWFpbmluZyBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSwgb2JqZWN0cyBhbmQgTWFwcyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSBoYXZpbmc6XG4gIC8vIGEpIFRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgLy8gYikgVGhlIHNhbWUgc2V0IG9mIGtleXMvaW5kZXhlcyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKVxuICAvLyBjKSBFcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkvaW5kZXhcbiAgLy8gZCkgRm9yIFNldHMgYW5kIE1hcHMsIGVxdWFsIGNvbnRlbnRzXG4gIC8vIE5vdGU6IHRoaXMgYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgYUtleXMgPSBPYmplY3Qua2V5cyh2YWwxKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyh2YWwyKTsgLy8gVGhlIHBhaXIgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzLlxuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIENoZWFwIGtleSB0ZXN0XG5cblxuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkodmFsMiwgYUtleXNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cmljdCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgdmFyIHN5bWJvbEtleXNBID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDEpO1xuXG4gICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHN5bWJvbEtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBzeW1ib2xLZXlzQVtpXTtcblxuICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMSwga2V5KSkge1xuICAgICAgICAgIGlmICghcHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xuXG4gICAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSBzeW1ib2xLZXlzQi5sZW5ndGggJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3N5bWJvbEtleXNCID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbDIpO1xuXG4gICAgICBpZiAoX3N5bWJvbEtleXNCLmxlbmd0aCAhPT0gMCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBfc3ltYm9sS2V5c0IpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFLZXlzLmxlbmd0aCA9PT0gMCAmJiAoaXRlcmF0aW9uVHlwZSA9PT0ga05vSXRlcmF0b3IgfHwgaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkgJiYgdmFsMS5sZW5ndGggPT09IDAgfHwgdmFsMS5zaXplID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFVzZSBtZW1vcyB0byBoYW5kbGUgY3ljbGVzLlxuXG5cbiAgaWYgKG1lbW9zID09PSB1bmRlZmluZWQpIHtcbiAgICBtZW1vcyA9IHtcbiAgICAgIHZhbDE6IG5ldyBNYXAoKSxcbiAgICAgIHZhbDI6IG5ldyBNYXAoKSxcbiAgICAgIHBvc2l0aW9uOiAwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBwcmV2ZW50IHVwIHRvIHR3byBtYXAuaGFzKHgpIGNhbGxzIGJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlXG4gICAgLy8gYW5kIGNoZWNraW5nIGZvciB1bmRlZmluZWQuIFRoZSBtYXAgY2FuIG9ubHkgY29udGFpbiBudW1iZXJzLCBzbyBpdCBpc1xuICAgIC8vIHNhZmUgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZCBvbmx5LlxuICAgIHZhciB2YWwyTWVtb0EgPSBtZW1vcy52YWwxLmdldCh2YWwxKTtcblxuICAgIGlmICh2YWwyTWVtb0EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHZhbDJNZW1vQiA9IG1lbW9zLnZhbDIuZ2V0KHZhbDIpO1xuXG4gICAgICBpZiAodmFsMk1lbW9CICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbDJNZW1vQSA9PT0gdmFsMk1lbW9CO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLnBvc2l0aW9uKys7XG4gIH1cblxuICBtZW1vcy52YWwxLnNldCh2YWwxLCBtZW1vcy5wb3NpdGlvbik7XG4gIG1lbW9zLnZhbDIuc2V0KHZhbDIsIG1lbW9zLnBvc2l0aW9uKTtcbiAgdmFyIGFyZUVxID0gb2JqRXF1aXYodmFsMSwgdmFsMiwgc3RyaWN0LCBhS2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpO1xuICBtZW1vcy52YWwxLmRlbGV0ZSh2YWwxKTtcbiAgbWVtb3MudmFsMi5kZWxldGUodmFsMik7XG4gIHJldHVybiBhcmVFcTtcbn1cblxuZnVuY3Rpb24gc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgdmFsMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIEdvIGxvb2tpbmcuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWwyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbWF0Y2hpbmcgZWxlbWVudCB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGNoZWNrIHRoYXQgYWdhaW4uXG4gICAgICBzZXQuZGVsZXRlKHZhbDIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9FcXVhbGl0eV9jb21wYXJpc29uc19hbmRfc2FtZW5lc3MjTG9vc2VfZXF1YWxpdHlfdXNpbmdcbi8vIFNhZGx5IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgY29ycmVzcG9uZGluZyB2YWx1ZXMgcHJvcGVybHkgaW4gY2FzZSB0aGVcbi8vIHR5cGUgaXMgYSBzdHJpbmcsIG51bWJlciwgYmlnaW50IG9yIGJvb2xlYW4uIFRoZSByZWFzb24gaXMgdGhhdCB0aG9zZSB2YWx1ZXNcbi8vIGNhbiBtYXRjaCBsb3RzIG9mIGRpZmZlcmVudCBzdHJpbmcgdmFsdWVzIChlLmcuLCAxbiA9PSAnKzAwMDAxJykuXG5cblxuZnVuY3Rpb24gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pIHtcbiAgc3dpdGNoIChfdHlwZW9mKHByaW0pKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIC8vIE9ubHkgcGFzcyBpbiBudWxsIGFzIG9iamVjdCFcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHByaW0gPSArcHJpbTtcbiAgICAvLyBMb29zZSBlcXVhbCBlbnRyaWVzIGV4aXN0IG9ubHkgaWYgdGhlIHN0cmluZyBpcyBwb3NzaWJsZSB0byBjb252ZXJ0IHRvXG4gICAgLy8gYSByZWd1bGFyIG51bWJlciBhbmQgbm90IE5hTi5cbiAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAobnVtYmVySXNOYU4ocHJpbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkgcmV0dXJuIGFsdFZhbHVlO1xuICByZXR1cm4gYi5oYXMoYWx0VmFsdWUpICYmICFhLmhhcyhhbHRWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIG1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltLCBpdGVtLCBtZW1vKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcblxuICBpZiAoYWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhbHRWYWx1ZTtcbiAgfVxuXG4gIHZhciBjdXJCID0gYi5nZXQoYWx0VmFsdWUpO1xuXG4gIGlmIChjdXJCID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGFsdFZhbHVlKSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICFhLmhhcyhhbHRWYWx1ZSkgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbSwgY3VyQiwgZmFsc2UsIG1lbW8pO1xufVxuXG5mdW5jdGlvbiBzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVGhpcyBpcyBhIGxhemlseSBpbml0aWF0ZWQgU2V0IG9mIGVudHJpZXMgd2hpY2ggaGF2ZSB0byBiZSBjb21wYXJlZFxuICAvLyBwYWlyd2lzZS5cbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhVmFsdWVzID0gYXJyYXlGcm9tU2V0KGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYVZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWwgPSBhVmFsdWVzW2ldOyAvLyBOb3RlOiBDaGVja2luZyBmb3IgdGhlIG9iamVjdHMgZmlyc3QgaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlIGZvciBvYmplY3RcbiAgICAvLyBoZWF2eSBzZXRzIGJ1dCBpdCBpcyBhIG1pbm9yIHNsb3cgZG93biBmb3IgcHJpbWl0aXZlcy4gQXMgdGhleSBhcmUgZmFzdFxuICAgIC8vIHRvIGNoZWNrIHRoaXMgaW1wcm92ZXMgdGhlIHdvcnN0IGNhc2Ugc2NlbmFyaW8gaW5zdGVhZC5cblxuICAgIGlmIChfdHlwZW9mKHZhbCkgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9IC8vIElmIHRoZSBzcGVjaWZpZWQgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2Vjb25kIHNldCBpdHMgYW4gbm90IG51bGxcbiAgICAgIC8vIG9iamVjdCAob3Igbm9uIHN0cmljdCBvbmx5OiBhIG5vdCBtYXRjaGluZyBwcmltaXRpdmUpIHdlJ2xsIG5lZWQgdG8gZ29cbiAgICAgIC8vIGh1bnRpbmcgZm9yIHNvbWV0aGluZyB0aGF0cyBkZWVwLShzdHJpY3QtKWVxdWFsIHRvIGl0LiBUbyBtYWtlIHRoaXNcbiAgICAgIC8vIE8obiBsb2cgbikgY29tcGxleGl0eSB3ZSBoYXZlIHRvIGNvcHkgdGhlc2UgdmFsdWVzIGluIGEgbmV3IHNldCBmaXJzdC5cblxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfSBlbHNlIGlmICghYi5oYXModmFsKSkge1xuICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbCB2YWx1ZXMuXG5cbiAgICAgIGlmICghc2V0TWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYlZhbHVlcyA9IGFycmF5RnJvbVNldChiKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBiVmFsdWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF92YWwgPSBiVmFsdWVzW19pXTsgLy8gV2UgaGF2ZSB0byBjaGVjayBpZiBhIHByaW1pdGl2ZSB2YWx1ZSBpcyBhbHJlYWR5XG4gICAgICAvLyBtYXRjaGluZyBhbmQgb25seSBpZiBpdCdzIG5vdCwgZ28gaHVudGluZyBmb3IgaXQuXG5cbiAgICAgIGlmIChfdHlwZW9mKF92YWwpID09PSAnb2JqZWN0JyAmJiBfdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICFhLmhhcyhfdmFsKSAmJiAhc2V0SGFzRXF1YWxFbGVtZW50KHNldCwgX3ZhbCwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hcEhhc0VxdWFsRW50cnkoc2V0LCBtYXAsIGtleTEsIGl0ZW0xLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gVG8gYmUgYWJsZSB0byBoYW5kbGUgY2FzZXMgbGlrZTpcbiAgLy8gICBNYXAoW1t7fSwgJ2EnXSwgW3t9LCAnYiddXSkgdnMgTWFwKFtbe30sICdiJ10sIFt7fSwgJ2EnXV0pXG4gIC8vIC4uLiB3ZSBuZWVkIHRvIGNvbnNpZGVyICphbGwqIG1hdGNoaW5nIGtleXMsIG5vdCBqdXN0IHRoZSBmaXJzdCB3ZSBmaW5kLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5MiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbChrZXkxLCBrZXkyLCBzdHJpY3QsIG1lbW8pICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0xLCBtYXAuZ2V0KGtleTIpLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICBzZXQuZGVsZXRlKGtleTIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW8pIHtcbiAgdmFyIHNldCA9IG51bGw7XG4gIHZhciBhRW50cmllcyA9IGFycmF5RnJvbU1hcChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9hRW50cmllcyRpID0gX3NsaWNlZFRvQXJyYXkoYUVudHJpZXNbaV0sIDIpLFxuICAgICAgICBrZXkgPSBfYUVudHJpZXMkaVswXSxcbiAgICAgICAgaXRlbTEgPSBfYUVudHJpZXMkaVsxXTtcblxuICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWUgd2UgcHJldmVudCBhbm90aGVyIGIuaGFzKGtleSkgY2hlY2sgaW5cbiAgICAgIC8vIGFsbW9zdCBhbGwgcG9zc2libGUgY2FzZXMuXG4gICAgICB2YXIgaXRlbTIgPSBiLmdldChrZXkpO1xuXG4gICAgICBpZiAoaXRlbTIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoaXRlbTEsIGl0ZW0yLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGxcbiAgICAgICAgLy8ga2V5cy5cblxuICAgICAgICBpZiAoIW1hcE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBrZXksIGl0ZW0xLCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiRW50cmllcyA9IGFycmF5RnJvbU1hcChiKTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGJFbnRyaWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfYkVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShiRW50cmllc1tfaTJdLCAyKSxcbiAgICAgICAgICBrZXkgPSBfYkVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgaXRlbSA9IF9iRW50cmllcyRfaVsxXTtcblxuICAgICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgc3RyaWN0LCBtZW1vKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmICghYS5oYXMoa2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYS5nZXQoa2V5KSwgaXRlbSwgZmFsc2UsIG1lbW8pKSAmJiAhbWFwSGFzRXF1YWxFbnRyeShzZXQsIGEsIGtleSwgaXRlbSwgZmFsc2UsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBrZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSkge1xuICAvLyBTZXRzIGFuZCBtYXBzIGRvbid0IGhhdmUgdGhlaXIgZW50cmllcyBhY2Nlc3NpYmxlIHZpYSBub3JtYWwgb2JqZWN0XG4gIC8vIHByb3BlcnRpZXMuXG4gIHZhciBpID0gMDtcblxuICBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzU2V0KSB7XG4gICAgaWYgKCFzZXRFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNNYXApIHtcbiAgICBpZiAoIW1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5KSB7XG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkoYSwgaSkpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBpKSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtpXSwgYltpXSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYiwgaSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXJyYXkgaXMgc3BhcnNlLlxuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcblxuICAgICAgICBmb3IgKDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNBW2ldO1xuXG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShiLCBrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlIHBhaXIgbXVzdCBoYXZlIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS5cbiAgLy8gUG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdDpcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9rZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKCFpbm5lckRlZXBFcXVhbChhW19rZXldLCBiW19rZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0RlZXBFcXVhbCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrTG9vc2UpO1xufVxuXG5mdW5jdGlvbiBpc0RlZXBTdHJpY3RFcXVhbCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBrU3RyaWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRGVlcEVxdWFsOiBpc0RlZXBFcXVhbCxcbiAgaXNEZWVwU3RyaWN0RXF1YWw6IGlzRGVlcFN0cmljdEVxdWFsXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgxODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDk4KTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDk4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEzOCk7XG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xudmFyIHNldEZ1bmN0aW9uTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTA4KTtcblxudmFyICRUeXBlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjgpO1xudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0MCk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0aWYgKHR5cGVvZiBvcmlnaW5hbEZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2EgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcblx0fVxuXHR2YXIgZnVuYyA9ICRyZWZsZWN0QXBwbHkoYmluZCwgJGNhbGwsIGFyZ3VtZW50cyk7XG5cdHJldHVybiBzZXRGdW5jdGlvbkxlbmd0aChcblx0XHRmdW5jLFxuXHRcdDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSksXG5cdFx0dHJ1ZVxuXHQpO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MzY0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNylcbnZhciBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwOTMpXG5mdW5jdGlvbiBub3coKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSB9XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxudmFyIGNvbnNvbGVcbnZhciB0aW1lcyA9IHt9XG5cbmlmICh0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nICE9PSBcInVuZGVmaW5lZFwiICYmIF9fd2VicGFja19yZXF1aXJlX18uZy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18uZy5jb25zb2xlXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGVcbn0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9XG59XG5cbnZhciBmdW5jdGlvbnMgPSBbXG4gICAgW2xvZywgXCJsb2dcIl0sXG4gICAgW2luZm8sIFwiaW5mb1wiXSxcbiAgICBbd2FybiwgXCJ3YXJuXCJdLFxuICAgIFtlcnJvciwgXCJlcnJvclwiXSxcbiAgICBbdGltZSwgXCJ0aW1lXCJdLFxuICAgIFt0aW1lRW5kLCBcInRpbWVFbmRcIl0sXG4gICAgW3RyYWNlLCBcInRyYWNlXCJdLFxuICAgIFtkaXIsIFwiZGlyXCJdLFxuICAgIFtjb25zb2xlQXNzZXJ0LCBcImFzc2VydFwiXVxuXVxuXG5mb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0dXBsZSA9IGZ1bmN0aW9uc1tpXVxuICAgIHZhciBmID0gdHVwbGVbMF1cbiAgICB2YXIgbmFtZSA9IHR1cGxlWzFdXG5cbiAgICBpZiAoIWNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgY29uc29sZVtuYW1lXSA9IGZcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc29sZVxuXG5mdW5jdGlvbiBsb2coKSB7fVxuXG5mdW5jdGlvbiBpbmZvKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gd2FybigpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICB0aW1lc1tsYWJlbF0gPSBub3coKVxufVxuXG5mdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgdmFyIHRpbWUgPSB0aW1lc1tsYWJlbF1cbiAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbDogXCIgKyBsYWJlbClcbiAgICB9XG5cbiAgICBkZWxldGUgdGltZXNbbGFiZWxdXG4gICAgdmFyIGR1cmF0aW9uID0gbm93KCkgLSB0aW1lXG4gICAgY29uc29sZS5sb2cobGFiZWwgKyBcIjogXCIgKyBkdXJhdGlvbiArIFwibXNcIilcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpXG4gICAgZXJyLm5hbWUgPSBcIlRyYWNlXCJcbiAgICBlcnIubWVzc2FnZSA9IHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjaylcbn1cblxuZnVuY3Rpb24gZGlyKG9iamVjdCkge1xuICAgIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChvYmplY3QpICsgXCJcXG5cIilcbn1cblxuZnVuY3Rpb24gY29uc29sZUFzc2VydChleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBhcnIgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICAgYXNzZXJ0Lm9rKGZhbHNlLCB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcnIpKVxuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTQwKTtcblxudmFyICRTeW50YXhFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTczMSk7XG52YXIgJFR5cGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2OCk7XG5cbnZhciBnb3BkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lRGF0YVByb3BlcnR5KFxuXHRvYmosXG5cdHByb3BlcnR5LFxuXHR2YWx1ZVxuKSB7XG5cdGlmICghb2JqIHx8ICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgb2JqYCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uYCcpO1xuXHR9XG5cdGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N5bWJvbCcpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYHByb3BlcnR5YCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sYCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzNdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25FbnVtZXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgdHlwZW9mIGFyZ3VtZW50c1s0XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s0XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uV3JpdGFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNSAmJiB0eXBlb2YgYXJndW1lbnRzWzVdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzVdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Db25maWd1cmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNiAmJiB0eXBlb2YgYXJndW1lbnRzWzZdICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGxvb3NlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgbm9uRW51bWVyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblx0dmFyIG5vbldyaXRhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuXHR2YXIgbm9uQ29uZmlndXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuXHR2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNiA/IGFyZ3VtZW50c1s2XSA6IGZhbHNlO1xuXG5cdC8qIEB0eXBlIHtmYWxzZSB8IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPHVua25vd24+fSAqL1xuXHR2YXIgZGVzYyA9ICEhZ29wZCAmJiBnb3BkKG9iaiwgcHJvcGVydHkpO1xuXG5cdGlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0XHQkZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiBub25Db25maWd1cmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuY29uZmlndXJhYmxlIDogIW5vbkNvbmZpZ3VyYWJsZSxcblx0XHRcdGVudW1lcmFibGU6IG5vbkVudW1lcmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuZW51bWVyYWJsZSA6ICFub25FbnVtZXJhYmxlLFxuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IG5vbldyaXRhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLndyaXRhYmxlIDogIW5vbldyaXRhYmxlXG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAobG9vc2UgfHwgKCFub25FbnVtZXJhYmxlICYmICFub25Xcml0YWJsZSAmJiAhbm9uQ29uZmlndXJhYmxlKSkge1xuXHRcdC8vIG11c3QgZmFsbCBiYWNrIHRvIFtbU2V0XV0sIGFuZCB3YXMgbm90IGV4cGxpY2l0bHkgYXNrZWQgdG8gbWFrZSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tY29uZmlndXJhYmxlXG5cdFx0b2JqW3Byb3BlcnR5XSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGRlZmluaW5nIGEgcHJvcGVydHkgYXMgbm9uLWNvbmZpZ3VyYWJsZSwgbm9uLXdyaXRhYmxlLCBvciBub24tZW51bWVyYWJsZS4nKTtcblx0fVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTg1Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMjgpO1xudmFyIGhhc1N5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2woJ2ZvbycpID09PSAnc3ltYm9sJztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyIGRlZmluZURhdGFQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNjg2KTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjM5KSgpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCkge1xuXHRcdGlmIChwcmVkaWNhdGUgPT09IHRydWUpIHtcblx0XHRcdGlmIChvYmplY3RbbmFtZV0gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRkZWZpbmVEYXRhUHJvcGVydHkob2JqZWN0LCBuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0ZGVmaW5lRGF0YVByb3BlcnR5KG9iamVjdCwgbmFtZSwgdmFsdWUpO1xuXHR9XG59O1xuXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCkge1xuXHR2YXIgcHJlZGljYXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDoge307XG5cdHZhciBwcm9wcyA9IGtleXMobWFwKTtcblx0aWYgKGhhc1N5bWJvbHMpIHtcblx0XHRwcm9wcyA9IGNvbmNhdC5jYWxsKHByb3BzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1hcCkpO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BzW2ldLCBtYXBbcHJvcHNbaV1dLCBwcmVkaWNhdGVzW3Byb3BzW2ldXSk7XG5cdH1cbn07XG5cbmRlZmluZVByb3BlcnRpZXMuc3VwcG9ydHNEZXNjcmlwdG9ycyA9ICEhc3VwcG9ydHNEZXNjcmlwdG9ycztcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0OTQwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKSB8fCBmYWxzZTtcbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZGVmaW5lUHJvcGVydHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY3Mjk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9ldmFsJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWxFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgzODpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMTU1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmFuZ2UnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDk0Mzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlZicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWZlcmVuY2VFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTczMTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3N5bnRheCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBTeW50YXhFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ2ODpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gVHlwZUVycm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTQwOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdXJpJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFVSSUVycm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMDQ2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvZGUgcmVmYWN0b3JlZCBmcm9tIE1vemlsbGEgRGV2ZWxvcGVyIE5ldHdvcms6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG4gKi9cblxuXG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIGZpcnN0U291cmNlKSB7XG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBmaXJzdCBhcmd1bWVudCB0byBvYmplY3QnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSk7XG4gICAgZm9yICh2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXgrKykge1xuICAgICAgdmFyIG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2Fzc2lnbicsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYXNzaWduXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzc2lnbjogYXNzaWduLFxuICBwb2x5ZmlsbDogcG9seWZpbGxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2MTcpO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZvckVhY2hBcnJheSA9IGZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2hTdHJpbmcgPSBmdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2hPYmplY3QgPSBmdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcihvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgdGhpc0FyZykge1xuICAgIGlmICghaXNDYWxsYWJsZShpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlY2VpdmVyO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmVjZWl2ZXIgPSB0aGlzQXJnO1xuICAgIH1cblxuICAgIGlmICh0b1N0ci5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4Nzk0OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxudmFyIGNvbmNhdHR5ID0gZnVuY3Rpb24gY29uY2F0dHkoYSwgYikge1xuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJbaV0gPSBhW2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgYXJyW2ogKyBhLmxlbmd0aF0gPSBiW2pdO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgc2xpY3kgPSBmdW5jdGlvbiBzbGljeShhcnJMaWtlLCBvZmZzZXQpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldCB8fCAwLCBqID0gMDsgaSA8IGFyckxpa2UubGVuZ3RoOyBpICs9IDEsIGogKz0gMSkge1xuICAgICAgICBhcnJbal0gPSBhcnJMaWtlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIGpvaW55ID0gZnVuY3Rpb24gKGFyciwgam9pbmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBhcnJbaV07XG4gICAgICAgIGlmIChpICsgMSA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0ciArPSBqb2luZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuYXBwbHkodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljeShhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICAgICk7XG5cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gbWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3NbaV0gPSAnJCcgKyBpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBqb2lueShib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTEzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nzk0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTI4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODM4KTtcbnZhciAkRXZhbEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzI5KTtcbnZhciAkUmFuZ2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTE1NSk7XG52YXIgJFJlZmVyZW5jZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTQzKTtcbnZhciAkU3ludGF4RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MzEpO1xudmFyICRUeXBlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjgpO1xudmFyICRVUklFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjE0MCk7XG5cbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oMzU1OCkoKTtcbnZhciBoYXNQcm90byA9IF9fd2VicGFja19yZXF1aXJlX18oNjg2OSkoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IChcblx0aGFzUHJvdG9cblx0XHQ/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cdFx0OiBudWxsXG4pO1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJpZ0ludDY0QXJyYXklJzogdHlwZW9mIEJpZ0ludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50NjRBcnJheSxcblx0JyVCaWdVaW50NjRBcnJheSUnOiB0eXBlb2YgQmlnVWludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnVWludDY0QXJyYXksXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiAkRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogJEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiAkUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiAkUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6ICRVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxuaWYgKGdldFByb3RvKSB7XG5cdHRyeSB7XG5cdFx0bnVsbC5lcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXNoYWRvd3JlYWxtL3B1bGwvMzg0I2lzc3VlY29tbWVudC0xMzY0MjY0MjI5XG5cdFx0dmFyIGVycm9yUHJvdG8gPSBnZXRQcm90byhnZXRQcm90byhlKSk7XG5cdFx0SU5UUklOU0lDU1snJUVycm9yLnByb3RvdHlwZSUnXSA9IGVycm9yUHJvdG87XG5cdH1cbn1cblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbiAmJiBnZXRQcm90bykge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMzgpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oODU1NCk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzM2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuXG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MjM5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTQwKTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHRyZXR1cm4gISEkZGVmaW5lUHJvcGVydHk7XG59O1xuXG5oYXNQcm9wZXJ0eURlc2NyaXB0b3JzLmhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnID0gZnVuY3Rpb24gaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKSB7XG5cdC8vIG5vZGUgdjAuNiBoYXMgYSBidWcgd2hlcmUgYXJyYXkgbGVuZ3RocyBjYW4gYmUgU2V0IGJ1dCBub3QgRGVmaW5lZFxuXHRpZiAoISRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDEgfSkubGVuZ3RoICE9PSAxO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSW4gRmlyZWZveCA0LTIyLCBkZWZpbmluZyBsZW5ndGggb24gYW4gYXJyYXkgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODY5OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHRlc3QgPSB7XG5cdGZvbzoge31cbn07XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1Byb3RvKCkge1xuXHRyZXR1cm4geyBfX3Byb3RvX186IHRlc3QgfS5mb28gPT09IHRlc3QuZm9vICYmICEoeyBfX3Byb3RvX186IG51bGwgfSBpbnN0YW5jZW9mICRPYmplY3QpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzU1ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkwOCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI5MDg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE5MTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBoYXNTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODU1NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciAkaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKGNhbGwsICRoYXNPd24pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjE1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Mzg3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MTMpKCk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODE4KTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTYxNzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHJlZmxlY3RBcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0ICE9PSBudWxsICYmIFJlZmxlY3QuYXBwbHk7XG52YXIgYmFkQXJyYXlMaWtlO1xudmFyIGlzQ2FsbGFibGVNYXJrZXI7XG5pZiAodHlwZW9mIHJlZmxlY3RBcHBseSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG5cdHRyeSB7XG5cdFx0YmFkQXJyYXlMaWtlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnbGVuZ3RoJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cdFx0cmVmbGVjdEFwcGx5KGZ1bmN0aW9uICgpIHsgdGhyb3cgNDI7IH0sIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRpZiAoXyAhPT0gaXNDYWxsYWJsZU1hcmtlcikge1xuXHRcdFx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcblx0XHR9XG5cdH1cbn0gZWxzZSB7XG5cdHJlZmxlY3RBcHBseSA9IG51bGw7XG59XG5cbnZhciBjb25zdHJ1Y3RvclJlZ2V4ID0gL15cXHMqY2xhc3NcXGIvO1xudmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdHZhciBmblN0ciA9IGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vdCBhIGZ1bmN0aW9uXG5cdH1cbn07XG5cbnZhciB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uVG9TdHIodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbnZhciBkZGFDbGFzcyA9ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXSc7IC8vIElFIDExXG52YXIgZGRhQ2xhc3MyID0gJ1tvYmplY3QgSFRNTCBkb2N1bWVudC5hbGwgY2xhc3NdJztcbnZhciBkZGFDbGFzczMgPSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nOyAvLyBJRSA5LTEwXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnOyAvLyBiZXR0ZXI6IHVzZSBgaGFzLXRvc3RyaW5ndGFnYFxuXG52YXIgaXNJRTY4ID0gISgwIGluIFssXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc3BhcnNlLWFycmF5cywgY29tbWEtc3BhY2luZ1xuXG52YXIgaXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKCkgeyByZXR1cm4gZmFsc2U7IH07XG5pZiAodHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0Jykge1xuXHQvLyBGaXJlZm94IDMgY2Fub25pY2FsaXplcyBEREEgdG8gdW5kZWZpbmVkIHdoZW4gaXQncyBub3QgYWNjZXNzZWQgZGlyZWN0bHlcblx0dmFyIGFsbCA9IGRvY3VtZW50LmFsbDtcblx0aWYgKHRvU3RyLmNhbGwoYWxsKSA9PT0gdG9TdHIuY2FsbChkb2N1bWVudC5hbGwpKSB7XG5cdFx0aXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKHZhbHVlKSB7XG5cdFx0XHQvKiBnbG9iYWxzIGRvY3VtZW50OiBmYWxzZSAqL1xuXHRcdFx0Ly8gaW4gSUUgNi04LCB0eXBlb2YgZG9jdW1lbnQuYWxsIGlzIFwib2JqZWN0XCIgYW5kIGl0J3MgdHJ1dGh5XG5cdFx0XHRpZiAoKGlzSUU2OCB8fCAhdmFsdWUpICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRzdHIgPT09IGRkYUNsYXNzXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczMgLy8gb3BlcmEgMTIuMTZcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gb2JqZWN0Q2xhc3MgLy8gSUUgNi04XG5cdFx0XHRcdFx0KSAmJiB2YWx1ZSgnJykgPT0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblx0XHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEFwcGx5XG5cdD8gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR0cnkge1xuXHRcdFx0cmVmbGVjdEFwcGx5KHZhbHVlLCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmIChlICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSkgJiYgdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cdDogZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkge1xuXHRcdGlmIChpc0REQSh2YWx1ZSkpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfVxuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHZhciBzdHJDbGFzcyA9IHRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdGlmIChzdHJDbGFzcyAhPT0gZm5DbGFzcyAmJiBzdHJDbGFzcyAhPT0gZ2VuQ2xhc3MgJiYgISgvXlxcW29iamVjdCBIVE1MLykudGVzdChzdHJDbGFzcykpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0cmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjYyNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoaXNGblJlZ2V4LnRlc3QoZm5Ub1N0ci5jYWxsKGZuKSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwoZm4pO1xuXHRcdHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cdH1cblx0aWYgKCFnZXRQcm90bykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAodHlwZW9mIEdlbmVyYXRvckZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xuXHRcdEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2U7XG5cdH1cblx0cmV0dXJuIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb247XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MDA2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3ODM4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0OTgpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1Nyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODAwNik7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OTEpO1xudmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NDEpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBOdW1iZXIpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbmRlZmluZShwb2x5ZmlsbCwge1xuXHRnZXRQb2x5ZmlsbDogZ2V0UG9seWZpbGwsXG5cdGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvbixcblx0c2hpbTogc2hpbVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9seWZpbGw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE1OTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODAwNik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdGlmIChOdW1iZXIuaXNOYU4gJiYgTnVtYmVyLmlzTmFOKE5hTikgJiYgIU51bWJlci5pc05hTignYScpKSB7XG5cdFx0cmV0dXJuIE51bWJlci5pc05hTjtcblx0fVxuXHRyZXR1cm4gaW1wbGVtZW50YXRpb247XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNjQxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODU3KTtcbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTU5MSk7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTnVtYmVySXNOYU4oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShOdW1iZXIsIHsgaXNOYU46IHBvbHlmaWxsIH0sIHtcblx0XHRpc05hTjogZnVuY3Rpb24gdGVzdElzTmFOKCkge1xuXHRcdFx0cmV0dXJuIE51bWJlci5pc05hTiAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTk0Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHdoaWNoVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMjczMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiAhIXdoaWNoVHlwZWRBcnJheSh2YWx1ZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogbW9kdWxlIGRlY29yYXRvciAqLyBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZChtb2R1bGUpO1xudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgbW9kdWxlOnRydWUsIHJlcXVpcmU6dHJ1ZSwgZGVmaW5lOnRydWUsIGdsb2JhbDp0cnVlICovXG5cbihmdW5jdGlvbiAocm9vdCwgbmFtZSwgZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBgT2JqZWN0YFxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgICAgICdmdW5jdGlvbic6IHRydWVcbiAgICAgICwgJ29iamVjdCc6IHRydWVcbiAgICB9XG4gICAgLy8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgXG4gICAgLCBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHNcbiAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuICAgICwgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW1wib2JqZWN0XCJdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZVxuICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsIGFuZFxuICAgIC8vIHVzZSBpdCBhcyBgd2luZG93YFxuICAgICwgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18uZyA9PT0gJ29iamVjdCcgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nXG4gICAgLy8gRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgXG4gICAgLCBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcbiAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvblxuICAvLyBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHJ1ZSkge1xuICAgIC8vIGRlZmluZWQgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbZXhwb3J0c10sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmYWN0b3J5KSxcblx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cblx0XHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXG5cdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICAgIC8vIEluIGNhc2UgdGhlIHNvdXJjZSBoYXMgYmVlbiBwcm9jZXNzZWQgYW5kIHdyYXBwZWQgaW4gYSBkZWZpbmUgbW9kdWxlIHVzZVxuICAgIC8vIHRoZSBzdXBwbGllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICAgIGlmIChmcmVlRXhwb3J0cyAmJiBtb2R1bGVFeHBvcnRzKSBmYWN0b3J5KGZyZWVNb2R1bGUuZXhwb3J0cyk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW5cbiAgLy8gYGV4cG9ydHNgIG9iamVjdFxuICBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIHt9XG59KHRoaXMsICdsdWFwYXJzZScsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBleHBvcnRzLnZlcnNpb24gPSBcIjAuMy4xXCI7XG5cbiAgdmFyIGlucHV0LCBvcHRpb25zLCBsZW5ndGgsIGZlYXR1cmVzLCBlbmNvZGluZ01vZGU7XG5cbiAgLy8gT3B0aW9ucyBjYW4gYmUgc2V0IGVpdGhlciBnbG9iYWxseSBvbiB0aGUgcGFyc2VyIG9iamVjdCB0aHJvdWdoXG4gIC8vIGRlZmF1bHRPcHRpb25zLCBvciBkdXJpbmcgdGhlIHBhcnNlIGNhbGwuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLy8gRXhwbGljaXRseSB0ZWxsIHRoZSBwYXJzZXIgd2hlbiB0aGUgaW5wdXQgZW5kcy5cbiAgICAgIHdhaXQ6IGZhbHNlXG4gICAgLy8gU3RvcmUgY29tbWVudHMgYXMgYW4gYXJyYXkgaW4gdGhlIGNodW5rIG9iamVjdC5cbiAgICAsIGNvbW1lbnRzOiB0cnVlXG4gICAgLy8gVHJhY2sgaWRlbnRpZmllciBzY29wZXMgYnkgYWRkaW5nIGFuIGlzTG9jYWwgYXR0cmlidXRlIHRvIGVhY2hcbiAgICAvLyBpZGVudGlmaWVyLW5vZGUuXG4gICAgLCBzY29wZTogZmFsc2VcbiAgICAvLyBTdG9yZSBsb2NhdGlvbiBpbmZvcm1hdGlvbiBvbiBlYWNoIHN5bnRheCBub2RlIGFzXG4gICAgLy8gYGxvYzogeyBzdGFydDogeyBsaW5lLCBjb2x1bW4gfSwgZW5kOiB7IGxpbmUsIGNvbHVtbiB9IH1gLlxuICAgICwgbG9jYXRpb25zOiBmYWxzZVxuICAgIC8vIFN0b3JlIHRoZSBzdGFydCBhbmQgZW5kIGNoYXJhY3RlciBsb2NhdGlvbnMgb24gZWFjaCBzeW50YXggbm9kZSBhc1xuICAgIC8vIGByYW5nZTogW3N0YXJ0LCBlbmRdYC5cbiAgICAsIHJhbmdlczogZmFsc2VcbiAgICAvLyBBIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgc3ludGF4IG5vZGUgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgIC8vIFRoZSBub2RlIHdoaWNoIGhhcyBiZWVuIGNyZWF0ZWQgd2lsbCBiZSBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyLlxuICAgICwgb25DcmVhdGVOb2RlOiBudWxsXG4gICAgLy8gQSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIG5ldyBzY29wZSBpcyBjcmVhdGVkLlxuICAgICwgb25DcmVhdGVTY29wZTogbnVsbFxuICAgIC8vIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGN1cnJlbnQgc2NvcGUgaXMgZGVzdHJveWVkLlxuICAgICwgb25EZXN0cm95U2NvcGU6IG51bGxcbiAgICAvLyBBIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIGEgbG9jYWwgdmFyaWFibGUgaXMgZGVjbGFyZWQgaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAgLy8gVGhlIHZhcmlhYmxlJ3MgbmFtZSB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXJcbiAgICAsIG9uTG9jYWxEZWNsYXJhdGlvbjogbnVsbFxuICAgIC8vIFRoZSB2ZXJzaW9uIG9mIEx1YSB0YXJnZXRlZCBieSB0aGUgcGFyc2VyIChzdHJpbmc7IGFsbG93ZWQgdmFsdWVzIGFyZVxuICAgIC8vICc1LjEnLCAnNS4yJywgJzUuMycpLlxuICAgICwgbHVhVmVyc2lvbjogJzUuMSdcbiAgICAvLyBFbmNvZGluZyBtb2RlOiBob3cgdG8gaW50ZXJwcmV0IGNvZGUgdW5pdHMgaGlnaGVyIHRoYW4gVSswMDdGIGluIGlucHV0XG4gICAgLCBlbmNvZGluZ01vZGU6ICdub25lJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVuY29kZVVURjgoY29kZXBvaW50LCBoaWdoTWFzaykge1xuICAgIGhpZ2hNYXNrID0gaGlnaE1hc2sgfHwgMDtcblxuICAgIGlmIChjb2RlcG9pbnQgPCAweDgwKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlcG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZXBvaW50IDwgMHg4MDApIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICBoaWdoTWFzayB8IDB4YzAgfCAgKGNvZGVwb2ludCA+PiAgNikgICAgICAgICxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKCBjb2RlcG9pbnQgICAgICAgICYgMHgzZilcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlcG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgaGlnaE1hc2sgfCAweGUwIHwgIChjb2RlcG9pbnQgPj4gMTIpICAgICAgICAsXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICgoY29kZXBvaW50ID4+ICA2KSAmIDB4M2YpLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoIGNvZGVwb2ludCAgICAgICAgJiAweDNmKVxuICAgICAgKTtcbiAgICB9IGVsc2UgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi8gaWYgKGNvZGVwb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgaGlnaE1hc2sgfCAweGYwIHwgIChjb2RlcG9pbnQgPj4gMTgpICAgICAgICAsXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICgoY29kZXBvaW50ID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoKGNvZGVwb2ludCA+PiAgNikgJiAweDNmKSxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKCBjb2RlcG9pbnQgICAgICAgICYgMHgzZilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEx1YSA1LjQgYWxsb3dzIHVwIHRvIHNpeC1ieXRlIHNlcXVlbmNlcywgYXMgaW4gVVRGLTg6MTk5M1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9IZXgobnVtLCBkaWdpdHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGRpZ2l0cylcbiAgICAgIHJlc3VsdCA9ICcwJyArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDaGFycyhyeCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocykge1xuICAgICAgdmFyIG0gPSByeC5leGVjKHMpO1xuICAgICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5pbnZhbGlkQ29kZVVuaXQsIHRvSGV4KG1bMF0uY2hhckNvZGVBdCgwKSwgNCkudG9VcHBlckNhc2UoKSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbmNvZGluZ01vZGVzID0ge1xuICAgIC8vIGBwc2V1ZG8tbGF0aW4xYCBlbmNvZGluZyBtb2RlOiBhc3N1bWUgdGhlIGlucHV0IHdhcyBkZWNvZGVkIHdpdGggdGhlIGxhdGluMSBlbmNvZGluZ1xuICAgIC8vIFdBUk5JTkc6IGxhdGluMSBkb2VzICoqTk9UKiogbWVhbiBjcDEyNTIgaGVyZSBsaWtlIGluIHRoZSBib25lLWhlYWRlZCBXSEFUV0cgc3RhbmRhcmQ7XG4gICAgLy8gaXQgbWVhbnMgdHJ1ZSBJU08vSUVDIDg4NTktMSBpZGVudGl0eS1tYXBwZWQgdG8gQmFzaWMgTGF0aW4gYW5kIExhdGluLTEgU3VwcGxlbWVudCBibG9ja3NcbiAgICAncHNldWRvLWxhdGluMSc6IHtcbiAgICAgIGZpeHVwOiBjaGVja0NoYXJzKC9bXlxceDAwLVxceGZmXS8pLFxuICAgICAgZW5jb2RlQnl0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBlbmNvZGVVVEY4OiBmdW5jdGlvbiAoY29kZXBvaW50KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVVEY4KGNvZGVwb2ludCk7XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyBgeC11c2VyLWRlZmluZWRgIGVuY29kaW5nIG1vZGU6IGFzc3VtZSB0aGUgaW5wdXQgd2FzIGRlY29kZWQgd2l0aCB0aGUgV0hBVFdHIGB4LXVzZXItZGVmaW5lZGAgZW5jb2RpbmdcbiAgICAneC11c2VyLWRlZmluZWQnOiB7XG4gICAgICBmaXh1cDogY2hlY2tDaGFycygvW15cXHgwMC1cXHg3ZlxcdWY3ODAtXFx1ZjdmZl0vKSxcbiAgICAgIGVuY29kZUJ5dGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHg4MClcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSB8IDB4ZjcwMCk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBlbmNvZGVVVEY4OiBmdW5jdGlvbiAoY29kZXBvaW50KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVVEY4KGNvZGVwb2ludCwgMHhmNzAwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gYG5vbmVgIGVuY29kaW5nIG1vZGU6IGRpc3JlZ2FyZCBpbnRyZXByZXRhdGlvbiBvZiBzdHJpbmcgbGl0ZXJhbHMsIGxlYXZlIGlkZW50aWZpZXJzIGFzLWlzXG4gICAgJ25vbmUnOiB7XG4gICAgICBkaXNjYXJkU3RyaW5nczogdHJ1ZSxcbiAgICAgIGZpeHVwOiBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sXG4gICAgICBlbmNvZGVCeXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSxcbiAgICAgIGVuY29kZVVURjg6IGZ1bmN0aW9uIChjb2RlcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgYXZhaWxhYmxlIHRva2VucyBleHByZXNzZWQgYXMgZW51bSBmbGFncyBzbyB0aGV5IGNhbiBiZSBjaGVja2VkIHdpdGhcbiAgLy8gYml0d2lzZSBvcGVyYXRpb25zLlxuXG4gIHZhciBFT0YgPSAxLCBTdHJpbmdMaXRlcmFsID0gMiwgS2V5d29yZCA9IDQsIElkZW50aWZpZXIgPSA4XG4gICAgLCBOdW1lcmljTGl0ZXJhbCA9IDE2LCBQdW5jdHVhdG9yID0gMzIsIEJvb2xlYW5MaXRlcmFsID0gNjRcbiAgICAsIE5pbExpdGVyYWwgPSAxMjgsIFZhcmFyZ0xpdGVyYWwgPSAyNTY7XG5cbiAgZXhwb3J0cy50b2tlblR5cGVzID0geyBFT0Y6IEVPRiwgU3RyaW5nTGl0ZXJhbDogU3RyaW5nTGl0ZXJhbFxuICAgICwgS2V5d29yZDogS2V5d29yZCwgSWRlbnRpZmllcjogSWRlbnRpZmllciwgTnVtZXJpY0xpdGVyYWw6IE51bWVyaWNMaXRlcmFsXG4gICAgLCBQdW5jdHVhdG9yOiBQdW5jdHVhdG9yLCBCb29sZWFuTGl0ZXJhbDogQm9vbGVhbkxpdGVyYWxcbiAgICAsIE5pbExpdGVyYWw6IE5pbExpdGVyYWwsIFZhcmFyZ0xpdGVyYWw6IFZhcmFyZ0xpdGVyYWxcbiAgfTtcblxuICAvLyBBcyB0aGlzIHBhcnNlciBpcyBhIGJpdCBkaWZmZXJlbnQgZnJvbSBsdWFzIG93biwgdGhlIGVycm9yIG1lc3NhZ2VzXG4gIC8vIHdpbGwgYmUgZGlmZmVyZW50IGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICB2YXIgZXJyb3JzID0gZXhwb3J0cy5lcnJvcnMgPSB7XG4gICAgICB1bmV4cGVjdGVkOiAndW5leHBlY3RlZCAlMSBcXCclMlxcJyBuZWFyIFxcJyUzXFwnJ1xuICAgICwgdW5leHBlY3RlZEVPRjogJ3VuZXhwZWN0ZWQgc3ltYm9sIG5lYXIgXFwnPGVvZj5cXCcnXG4gICAgLCBleHBlY3RlZDogJ1xcJyUxXFwnIGV4cGVjdGVkIG5lYXIgXFwnJTJcXCcnXG4gICAgLCBleHBlY3RlZFRva2VuOiAnJTEgZXhwZWN0ZWQgbmVhciBcXCclMlxcJydcbiAgICAsIHVuZmluaXNoZWRTdHJpbmc6ICd1bmZpbmlzaGVkIHN0cmluZyBuZWFyIFxcJyUxXFwnJ1xuICAgICwgbWFsZm9ybWVkTnVtYmVyOiAnbWFsZm9ybWVkIG51bWJlciBuZWFyIFxcJyUxXFwnJ1xuICAgICwgZGVjaW1hbEVzY2FwZVRvb0xhcmdlOiAnZGVjaW1hbCBlc2NhcGUgdG9vIGxhcmdlIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBpbnZhbGlkRXNjYXBlOiAnaW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgbmVhciBcXCclMVxcJydcbiAgICAsIGhleGFkZWNpbWFsRGlnaXRFeHBlY3RlZDogJ2hleGFkZWNpbWFsIGRpZ2l0IGV4cGVjdGVkIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBicmFjZUV4cGVjdGVkOiAnbWlzc2luZyBcXCclMVxcJyBuZWFyIFxcJyUyXFwnJ1xuICAgICwgdG9vTGFyZ2VDb2RlcG9pbnQ6ICdVVEYtOCB2YWx1ZSB0b28gbGFyZ2UgbmVhciBcXCclMVxcJydcbiAgICAsIHVuZmluaXNoZWRMb25nU3RyaW5nOiAndW5maW5pc2hlZCBsb25nIHN0cmluZyAoc3RhcnRpbmcgYXQgbGluZSAlMSkgbmVhciBcXCclMlxcJydcbiAgICAsIHVuZmluaXNoZWRMb25nQ29tbWVudDogJ3VuZmluaXNoZWQgbG9uZyBjb21tZW50IChzdGFydGluZyBhdCBsaW5lICUxKSBuZWFyIFxcJyUyXFwnJ1xuICAgICwgYW1iaWd1b3VzU3ludGF4OiAnYW1iaWd1b3VzIHN5bnRheCAoZnVuY3Rpb24gY2FsbCB4IG5ldyBzdGF0ZW1lbnQpIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBub0xvb3BUb0JyZWFrOiAnbm8gbG9vcCB0byBicmVhayBuZWFyIFxcJyUxXFwnJ1xuICAgICwgbGFiZWxBbHJlYWR5RGVmaW5lZDogJ2xhYmVsIFxcJyUxXFwnIGFscmVhZHkgZGVmaW5lZCBvbiBsaW5lICUyJ1xuICAgICwgbGFiZWxOb3RWaXNpYmxlOiAnbm8gdmlzaWJsZSBsYWJlbCBcXCclMVxcJyBmb3IgPGdvdG8+J1xuICAgICwgZ290b0p1bXBJbkxvY2FsU2NvcGU6ICc8Z290byAlMT4ganVtcHMgaW50byB0aGUgc2NvcGUgb2YgbG9jYWwgXFwnJTJcXCcnXG4gICAgLCBjYW5ub3RVc2VWYXJhcmc6ICdjYW5ub3QgdXNlIFxcJy4uLlxcJyBvdXRzaWRlIGEgdmFyYXJnIGZ1bmN0aW9uIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBpbnZhbGlkQ29kZVVuaXQ6ICdjb2RlIHVuaXQgVSslMSBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBlbmNvZGluZyBtb2RlJ1xuICB9O1xuXG4gIC8vICMjIyBBYnN0cmFjdCBTeW50YXggVHJlZVxuICAvL1xuICAvLyBUaGUgZGVmYXVsdCBBU1Qgc3RydWN0dXJlIGlzIGluc3BpcmVkIGJ5IHRoZSBNb3ppbGxhIFBhcnNlciBBUEkgYnV0IGNhblxuICAvLyBlYXNpbHkgYmUgY3VzdG9taXplZCBieSBvdmVycmlkaW5nIHRoZXNlIGZ1bmN0aW9ucy5cblxuICB2YXIgYXN0ID0gZXhwb3J0cy5hc3QgPSB7XG4gICAgICBsYWJlbFN0YXRlbWVudDogZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0xhYmVsU3RhdGVtZW50J1xuICAgICAgICAsIGxhYmVsOiBsYWJlbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0JyZWFrU3RhdGVtZW50J1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGdvdG9TdGF0ZW1lbnQ6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdHb3RvU3RhdGVtZW50J1xuICAgICAgICAsIGxhYmVsOiBsYWJlbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHJldHVyblN0YXRlbWVudDogZnVuY3Rpb24oYXJncykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnUmV0dXJuU3RhdGVtZW50J1xuICAgICAgICAsICdhcmd1bWVudHMnOiBhcmdzXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgaWZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGNsYXVzZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0lmU3RhdGVtZW50J1xuICAgICAgICAsIGNsYXVzZXM6IGNsYXVzZXNcbiAgICAgIH07XG4gICAgfVxuICAgICwgaWZDbGF1c2U6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnSWZDbGF1c2UnXG4gICAgICAgICwgY29uZGl0aW9uOiBjb25kaXRpb25cbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cbiAgICAsIGVsc2VpZkNsYXVzZTogZnVuY3Rpb24oY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdFbHNlaWZDbGF1c2UnXG4gICAgICAgICwgY29uZGl0aW9uOiBjb25kaXRpb25cbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cbiAgICAsIGVsc2VDbGF1c2U6IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0Vsc2VDbGF1c2UnXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbihjb25kaXRpb24sIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1doaWxlU3RhdGVtZW50J1xuICAgICAgICAsIGNvbmRpdGlvbjogY29uZGl0aW9uXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGRvU3RhdGVtZW50OiBmdW5jdGlvbihib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdEb1N0YXRlbWVudCdcbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgcmVwZWF0U3RhdGVtZW50OiBmdW5jdGlvbihjb25kaXRpb24sIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1JlcGVhdFN0YXRlbWVudCdcbiAgICAgICAgLCBjb25kaXRpb246IGNvbmRpdGlvblxuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBsb2NhbFN0YXRlbWVudDogZnVuY3Rpb24odmFyaWFibGVzLCBpbml0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdMb2NhbFN0YXRlbWVudCdcbiAgICAgICAgLCB2YXJpYWJsZXM6IHZhcmlhYmxlc1xuICAgICAgICAsIGluaXQ6IGluaXRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBhc3NpZ25tZW50U3RhdGVtZW50OiBmdW5jdGlvbih2YXJpYWJsZXMsIGluaXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0Fzc2lnbm1lbnRTdGF0ZW1lbnQnXG4gICAgICAgICwgdmFyaWFibGVzOiB2YXJpYWJsZXNcbiAgICAgICAgLCBpbml0OiBpbml0XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgY2FsbFN0YXRlbWVudDogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQ2FsbFN0YXRlbWVudCdcbiAgICAgICAgLCBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgZnVuY3Rpb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKGlkZW50aWZpZXIsIHBhcmFtZXRlcnMsIGlzTG9jYWwsIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nXG4gICAgICAgICwgaWRlbnRpZmllcjogaWRlbnRpZmllclxuICAgICAgICAsIGlzTG9jYWw6IGlzTG9jYWxcbiAgICAgICAgLCBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGZvck51bWVyaWNTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHZhcmlhYmxlLCBzdGFydCwgZW5kLCBzdGVwLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdGb3JOdW1lcmljU3RhdGVtZW50J1xuICAgICAgICAsIHZhcmlhYmxlOiB2YXJpYWJsZVxuICAgICAgICAsIHN0YXJ0OiBzdGFydFxuICAgICAgICAsIGVuZDogZW5kXG4gICAgICAgICwgc3RlcDogc3RlcFxuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBmb3JHZW5lcmljU3RhdGVtZW50OiBmdW5jdGlvbih2YXJpYWJsZXMsIGl0ZXJhdG9ycywgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRm9yR2VuZXJpY1N0YXRlbWVudCdcbiAgICAgICAgLCB2YXJpYWJsZXM6IHZhcmlhYmxlc1xuICAgICAgICAsIGl0ZXJhdG9yczogaXRlcmF0b3JzXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGNodW5rOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdDaHVuaydcbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgaWRlbnRpZmllcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcidcbiAgICAgICAgLCBuYW1lOiBuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgbGl0ZXJhbDogZnVuY3Rpb24odHlwZSwgdmFsdWUsIHJhdykge1xuICAgICAgdHlwZSA9ICh0eXBlID09PSBTdHJpbmdMaXRlcmFsKSA/ICdTdHJpbmdMaXRlcmFsJ1xuICAgICAgICA6ICh0eXBlID09PSBOdW1lcmljTGl0ZXJhbCkgPyAnTnVtZXJpY0xpdGVyYWwnXG4gICAgICAgIDogKHR5cGUgPT09IEJvb2xlYW5MaXRlcmFsKSA/ICdCb29sZWFuTGl0ZXJhbCdcbiAgICAgICAgOiAodHlwZSA9PT0gTmlsTGl0ZXJhbCkgPyAnTmlsTGl0ZXJhbCdcbiAgICAgICAgOiAnVmFyYXJnTGl0ZXJhbCc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgICAsIHJhdzogcmF3XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgdGFibGVLZXk6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1RhYmxlS2V5J1xuICAgICAgICAsIGtleToga2V5XG4gICAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICAsIHRhYmxlS2V5U3RyaW5nOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdUYWJsZUtleVN0cmluZydcbiAgICAgICAgLCBrZXk6IGtleVxuICAgICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLCB0YWJsZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVGFibGVWYWx1ZSdcbiAgICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuXG5cbiAgICAsIHRhYmxlQ29uc3RydWN0b3JFeHByZXNzaW9uOiBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1RhYmxlQ29uc3RydWN0b3JFeHByZXNzaW9uJ1xuICAgICAgICAsIGZpZWxkczogZmllbGRzXG4gICAgICB9O1xuICAgIH1cbiAgICAsIGJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIHR5cGUgPSAoJ2FuZCcgPT09IG9wZXJhdG9yIHx8ICdvcicgPT09IG9wZXJhdG9yKSA/XG4gICAgICAgICdMb2dpY2FsRXhwcmVzc2lvbicgOlxuICAgICAgICAnQmluYXJ5RXhwcmVzc2lvbic7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgICAgICAsIGxlZnQ6IGxlZnRcbiAgICAgICAgLCByaWdodDogcmlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgICwgdW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbihvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1VuYXJ5RXhwcmVzc2lvbidcbiAgICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICAgICAgLCBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgIH07XG4gICAgfVxuICAgICwgbWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgaW5kZXhlciwgaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbidcbiAgICAgICAgLCBpbmRleGVyOiBpbmRleGVyXG4gICAgICAgICwgaWRlbnRpZmllcjogaWRlbnRpZmllclxuICAgICAgICAsIGJhc2U6IGJhc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBpbmRleEV4cHJlc3Npb246IGZ1bmN0aW9uKGJhc2UsIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdJbmRleEV4cHJlc3Npb24nXG4gICAgICAgICwgYmFzZTogYmFzZVxuICAgICAgICAsIGluZGV4OiBpbmRleFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGNhbGxFeHByZXNzaW9uOiBmdW5jdGlvbihiYXNlLCBhcmdzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdDYWxsRXhwcmVzc2lvbidcbiAgICAgICAgLCBiYXNlOiBiYXNlXG4gICAgICAgICwgJ2FyZ3VtZW50cyc6IGFyZ3NcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCB0YWJsZUNhbGxFeHByZXNzaW9uOiBmdW5jdGlvbihiYXNlLCBhcmdzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdUYWJsZUNhbGxFeHByZXNzaW9uJ1xuICAgICAgICAsIGJhc2U6IGJhc2VcbiAgICAgICAgLCAnYXJndW1lbnRzJzogYXJnc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHN0cmluZ0NhbGxFeHByZXNzaW9uOiBmdW5jdGlvbihiYXNlLCBhcmd1bWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnU3RyaW5nQ2FsbEV4cHJlc3Npb24nXG4gICAgICAgICwgYmFzZTogYmFzZVxuICAgICAgICAsIGFyZ3VtZW50OiBhcmd1bWVudFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGNvbW1lbnQ6IGZ1bmN0aW9uKHZhbHVlLCByYXcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0NvbW1lbnQnXG4gICAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICAgICwgcmF3OiByYXdcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8vIFdyYXAgdXAgdGhlIG5vZGUgb2JqZWN0LlxuXG4gIGZ1bmN0aW9uIGZpbmlzaE5vZGUobm9kZSkge1xuICAgIC8vIFBvcCBhIGBNYXJrZXJgIG9mZiB0aGUgbG9jYXRpb24tYXJyYXkgYW5kIGF0dGFjaCBpdHMgbG9jYXRpb24gZGF0YS5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGxvY2F0aW9ucy5wb3AoKTtcbiAgICAgIGxvY2F0aW9uLmNvbXBsZXRlKCk7XG4gICAgICBsb2NhdGlvbi5ibGVzcyhub2RlKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub25DcmVhdGVOb2RlKSBvcHRpb25zLm9uQ3JlYXRlTm9kZShub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgLCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICA7XG5cbiAgdmFyIGluZGV4T2YgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoYXJyYXksIGVsZW1lbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gZWxlbWVudCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpXG4gICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoZWxlbWVudCk7XG4gICAgfTtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgcmV0dXJuIHRoZSBpbmRleCBvZiBhbiBvYmplY3RcbiAgLy8gd2l0aCBhIG1hdGNoaW5nIHByb3BlcnR5LlxuXG4gIGZ1bmN0aW9uIGluZGV4T2ZPYmplY3QoYXJyYXksIHByb3BlcnR5LCBlbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoYXJyYXlbaV1bcHJvcGVydHldID09PSBlbGVtZW50KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gQSBzcHJpbnRmIGltcGxlbWVudGF0aW9uIHVzaW5nICVpbmRleCAoYmVnaW5uaW5nIGF0IDEpIHRvIGlucHV0XG4gIC8vIGFyZ3VtZW50cyBpbiB0aGUgZm9ybWF0IHN0cmluZy5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgIC8vIFVuZXhwZWN0ZWQgZnVuY3Rpb24gaW4gdG9rZW5cbiAgLy8gICAgIHNwcmludGYoJ1VuZXhwZWN0ZWQgJTIgaW4gJTEuJywgJ3Rva2VuJywgJ2Z1bmN0aW9uJyk7XG5cbiAgZnVuY3Rpb24gc3ByaW50Zihmb3JtYXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiAnJyArIGFyZ3NbaW5kZXggLSAxXSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG5cbiAgLy8gUG9seWZpbGwgZm9yIGBPYmplY3QuYXNzaWduYC5cblxuICB2YXIgYXNzaWduID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgLCBzcmMsIHByb3A7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgc3JjID0gYXJnc1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzcmMpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBwcm9wKSkge1xuICAgICAgICAgIGRlc3RbcHJvcF0gPSBzcmNbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdDtcbiAgfTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoT2JqZWN0LmFzc2lnbilcbiAgICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4gIC8vICMjIyBFcnJvciBmdW5jdGlvbnNcblxuICBleHBvcnRzLlN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG5cbiAgLy8gWFhYOiBFbGltaW5hdGUgdGhpcyBmdW5jdGlvbiBhbmQgY2hhbmdlIHRoZSBlcnJvciB0eXBlIHRvIGJlIGRpZmZlcmVudCBmcm9tIFN5bnRheEVycm9yLlxuICAvLyBUaGlzIHdpbGwgdW5mb3J0dW5hdGVseSBiZSBhIGJyZWFraW5nIGNoYW5nZSwgYmVjYXVzZSBzb21lIGRvd25zdHJlYW0gdXNlcnMgZGVwZW5kXG4gIC8vIG9uIHRoZSBlcnJvciB0aHJvd24gYmVpbmcgYW4gaW5zdGFuY2Ugb2YgU3ludGF4RXJyb3IuIEZvciBleGFtcGxlLCB0aGUgQWNlIGVkaXRvcjpcbiAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL2FjZS9ibG9iLzRjN2U1ZWIzZjVkNWNhOTQzNDg0N2JlNTE4MzRhNGU0MTY2MWI4NTIvbGliL2FjZS9tb2RlL2x1YV93b3JrZXIuanMjTDU1PlxuXG4gIGZ1bmN0aW9uIGZpeHVwRXJyb3IoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghT2JqZWN0LmNyZWF0ZSlcbiAgICAgIHJldHVybiBlO1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKGUsIHtcbiAgICAgICdsaW5lJzogeyAnd3JpdGFibGUnOiB0cnVlLCB2YWx1ZTogZS5saW5lIH0sXG4gICAgICAnaW5kZXgnOiB7ICd3cml0YWJsZSc6IHRydWUsIHZhbHVlOiBlLmluZGV4IH0sXG4gICAgICAnY29sdW1uJzogeyAnd3JpdGFibGUnOiB0cnVlLCB2YWx1ZTogZS5jb2x1bW4gfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gIyMjIyBSYWlzZSBhbiBleGNlcHRpb24uXG4gIC8vXG4gIC8vIFJhaXNlIGFuIGV4Y2VwdGlvbiBieSBwYXNzaW5nIGEgdG9rZW4sIGEgc3RyaW5nIGZvcm1hdCBhbmQgaXRzIHBhcmFtdGVycy5cbiAgLy9cbiAgLy8gVGhlIHBhc3NlZCB0b2tlbnMgbG9jYXRpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGFkZGVkIHRvIHRoZSBlcnJvclxuICAvLyBtZXNzYWdlIGlmIGl0IGV4aXN0cywgaWYgbm90IGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbGV4ZXJzIGN1cnJlbnRcbiAgLy8gcG9zaXRpb24uXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBbMTowXSBleHBlY3RlZCBbIG5lYXIgKFxuICAvLyAgICAgcmFpc2UodG9rZW4sIFwiZXhwZWN0ZWQgJTEgbmVhciAlMlwiLCAnWycsIHRva2VuLnZhbHVlKTtcblxuICBmdW5jdGlvbiByYWlzZSh0b2tlbikge1xuICAgIHZhciBtZXNzYWdlID0gc3ByaW50Zi5hcHBseShudWxsLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gICAgICAsIGVycm9yLCBjb2w7XG5cbiAgICBpZiAodG9rZW4gPT09IG51bGwgfHwgdHlwZW9mIHRva2VuLmxpbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb2wgPSBpbmRleCAtIGxpbmVTdGFydCArIDE7XG4gICAgICBlcnJvciA9IGZpeHVwRXJyb3IobmV3IFN5bnRheEVycm9yKHNwcmludGYoJ1slMTolMl0gJTMnLCBsaW5lLCBjb2wsIG1lc3NhZ2UpKSk7XG4gICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xuICAgICAgZXJyb3IubGluZSA9IGxpbmU7XG4gICAgICBlcnJvci5jb2x1bW4gPSBjb2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbCA9IHRva2VuLnJhbmdlWzBdIC0gdG9rZW4ubGluZVN0YXJ0O1xuICAgICAgZXJyb3IgPSBmaXh1cEVycm9yKG5ldyBTeW50YXhFcnJvcihzcHJpbnRmKCdbJTE6JTJdICUzJywgdG9rZW4ubGluZSwgY29sLCBtZXNzYWdlKSkpO1xuICAgICAgZXJyb3IubGluZSA9IHRva2VuLmxpbmU7XG4gICAgICBlcnJvci5pbmRleCA9IHRva2VuLnJhbmdlWzBdO1xuICAgICAgZXJyb3IuY29sdW1uID0gY29sO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuVmFsdWUodG9rZW4pIHtcbiAgICB2YXIgcmF3ID0gaW5wdXQuc2xpY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKTtcbiAgICBpZiAocmF3KVxuICAgICAgcmV0dXJuIHJhdztcbiAgICByZXR1cm4gdG9rZW4udmFsdWU7XG4gIH1cblxuICAvLyAjIyMjIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBleHBlY3RlZCA8bmFtZT4gbmVhciAnMCdcbiAgLy8gICAgIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8bmFtZT4nLCB0b2tlbik7XG5cbiAgZnVuY3Rpb24gcmFpc2VVbmV4cGVjdGVkVG9rZW4odHlwZSwgdG9rZW4pIHtcbiAgICByYWlzZSh0b2tlbiwgZXJyb3JzLmV4cGVjdGVkVG9rZW4sIHR5cGUsIHRva2VuVmFsdWUodG9rZW4pKTtcbiAgfVxuXG4gIC8vICMjIyMgUmFpc2UgYSBnZW5lcmFsIHVuZXhwZWN0ZWQgZXJyb3JcbiAgLy9cbiAgLy8gVXNhZ2Ugc2hvdWxkIHBhc3MgZWl0aGVyIGEgdG9rZW4gb2JqZWN0IG9yIGEgc3ltYm9sIHN0cmluZyB3aGljaCB3YXNcbiAgLy8gZXhwZWN0ZWQuIFdlIGNhbiBhbHNvIHNwZWNpZnkgYSBuZWFyYnkgdG9rZW4gc3VjaCBhcyA8ZW9mPiwgdGhpcyB3aWxsXG4gIC8vIGRlZmF1bHQgdG8gdGhlIGN1cnJlbnRseSBhY3RpdmUgdG9rZW4uXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBVbmV4cGVjdGVkIHN5bWJvbCAnZW5kJyBuZWFyICc8ZW9mPidcbiAgLy8gICAgIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAvL1xuICAvLyBJZiB0aGVyZSdzIG5vIHRva2VuIGluIHRoZSBidWZmZXIgaXQgbWVhbnMgd2UgaGF2ZSByZWFjaGVkIDxlb2Y+LlxuXG4gIGZ1bmN0aW9uIHVuZXhwZWN0ZWQoZm91bmQpIHtcbiAgICB2YXIgbmVhciA9IHRva2VuVmFsdWUobG9va2FoZWFkKTtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBmb3VuZC50eXBlKSB7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHN3aXRjaCAoZm91bmQudHlwZSkge1xuICAgICAgICBjYXNlIFN0cmluZ0xpdGVyYWw6ICAgdHlwZSA9ICdzdHJpbmcnOyAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEtleXdvcmQ6ICAgICAgICAgdHlwZSA9ICdrZXl3b3JkJzsgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIElkZW50aWZpZXI6ICAgICAgdHlwZSA9ICdpZGVudGlmaWVyJzsgIGJyZWFrO1xuICAgICAgICBjYXNlIE51bWVyaWNMaXRlcmFsOiAgdHlwZSA9ICdudW1iZXInOyAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFB1bmN0dWF0b3I6ICAgICAgdHlwZSA9ICdzeW1ib2wnOyAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJvb2xlYW5MaXRlcmFsOiAgdHlwZSA9ICdib29sZWFuJzsgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5pbExpdGVyYWw6XG4gICAgICAgICAgcmV0dXJuIHJhaXNlKGZvdW5kLCBlcnJvcnMudW5leHBlY3RlZCwgJ3N5bWJvbCcsICduaWwnLCBuZWFyKTtcbiAgICAgICAgY2FzZSBFT0Y6XG4gICAgICAgICAgcmV0dXJuIHJhaXNlKGZvdW5kLCBlcnJvcnMudW5leHBlY3RlZEVPRik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFpc2UoZm91bmQsIGVycm9ycy51bmV4cGVjdGVkLCB0eXBlLCB0b2tlblZhbHVlKGZvdW5kKSwgbmVhcik7XG4gICAgfVxuICAgIHJldHVybiByYWlzZShmb3VuZCwgZXJyb3JzLnVuZXhwZWN0ZWQsICdzeW1ib2wnLCBmb3VuZCwgbmVhcik7XG4gIH1cblxuICAvLyBMZXhlclxuICAvLyAtLS0tLVxuICAvL1xuICAvLyBUaGUgbGV4ZXIsIG9yIHRoZSB0b2tlbml6ZXIgcmVhZHMgdGhlIGlucHV0IHN0cmluZyBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyXG4gIC8vIGFuZCBkZXJpdmVzIGEgdG9rZW4gbGVmdC1yaWdodC4gVG8gYmUgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHRoZSBsZXhlclxuICAvLyBwcmlvcml0aXplcyB0aGUgY29tbW9uIGNhc2VzIHN1Y2ggYXMgaWRlbnRpZmllcnMuIEl0IGFsc28gd29ya3Mgd2l0aFxuICAvLyBjaGFyYWN0ZXIgY29kZXMgaW5zdGVhZCBvZiBjaGFyYWN0ZXJzIGFzIHN0cmluZyBjb21wYXJpc29ucyB3YXMgdGhlXG4gIC8vIGJpZ2dlc3QgYm90dGxlbmVjayBvZiB0aGUgcGFyc2VyLlxuICAvL1xuICAvLyBJZiBgb3B0aW9ucy5jb21tZW50c2AgaXMgZW5hYmxlZCwgYWxsIGNvbW1lbnRzIGVuY291bnRlcmVkIHdpbGwgYmUgc3RvcmVkXG4gIC8vIGluIGFuIGFycmF5IHdoaWNoIGxhdGVyIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGNodW5rIG9iamVjdC4gSWYgZGlzYWJsZWQsXG4gIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgZGlzcmVnYXJkZWQuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGxleGVyIGhhcyBkZXJpdmVkIGEgdmFsaWQgdG9rZW4sIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgaXRzIHZhbHVlIGFuZCBhcyB3ZWxsIGFzIGl0cyBwb3NpdGlvbiBpbiB0aGUgaW5wdXQgc3RyaW5nICh0aGlzXG4gIC8vIGlzIGFsd2F5cyBlbmFibGVkIHRvIHByb3ZpZGUgcHJvcGVyIGRlYnVnIG1lc3NhZ2VzKS5cbiAgLy9cbiAgLy8gYGxleCgpYCBzdGFydHMgbGV4aW5nIGFuZCByZXR1cm5zIHRoZSBmb2xsb3dpbmcgdG9rZW4gaW4gdGhlIHN0cmVhbS5cblxuICB2YXIgaW5kZXhcbiAgICAsIHRva2VuXG4gICAgLCBwcmV2aW91c1Rva2VuXG4gICAgLCBsb29rYWhlYWRcbiAgICAsIGNvbW1lbnRzXG4gICAgLCB0b2tlblN0YXJ0XG4gICAgLCBsaW5lXG4gICAgLCBsaW5lU3RhcnQ7XG5cbiAgZXhwb3J0cy5sZXggPSBsZXg7XG5cbiAgZnVuY3Rpb24gbGV4KCkge1xuICAgIHNraXBXaGl0ZVNwYWNlKCk7XG5cbiAgICAvLyBTa2lwIGNvbW1lbnRzIGJlZ2lubmluZyB3aXRoIC0tXG4gICAgd2hpbGUgKDQ1ID09PSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSAmJlxuICAgICAgICAgICA0NSA9PT0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpKSB7XG4gICAgICBzY2FuQ29tbWVudCgpO1xuICAgICAgc2tpcFdoaXRlU3BhY2UoKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IGxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgdHlwZSA6IEVPRlxuICAgICAgLCB2YWx1ZTogJzxlb2Y+J1xuICAgICAgLCBsaW5lOiBsaW5lXG4gICAgICAsIGxpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbaW5kZXgsIGluZGV4XVxuICAgIH07XG5cbiAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KVxuICAgICAgLCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgLy8gTWVtb3JpemUgdGhlIHJhbmdlIGluZGV4IHdoZXJlIHRoZSB0b2tlbiBiZWdpbnMuXG4gICAgdG9rZW5TdGFydCA9IGluZGV4O1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaGFyQ29kZSkpIHJldHVybiBzY2FuSWRlbnRpZmllck9yS2V5d29yZCgpO1xuXG4gICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgY2FzZSAzOTogY2FzZSAzNDogLy8gJ1wiXG4gICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIDQ4OiBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOlxuICAgICAgY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogLy8gMC05XG4gICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcblxuICAgICAgY2FzZSA0NjogLy8gLlxuICAgICAgICAvLyBJZiB0aGUgZG90IGlzIGZvbGxvd2VkIGJ5IGEgZGlnaXQgaXQncyBhIGZsb2F0LlxuICAgICAgICBpZiAoaXNEZWNEaWdpdChuZXh0KSkgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgICBpZiAoNDYgPT09IG5leHQpIHtcbiAgICAgICAgICBpZiAoNDYgPT09IGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAyKSkgcmV0dXJuIHNjYW5WYXJhcmdMaXRlcmFsKCk7XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignLicpO1xuXG4gICAgICBjYXNlIDYxOiAvLyA9XG4gICAgICAgIGlmICg2MSA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc9PScpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJz0nKTtcblxuICAgICAgY2FzZSA2MjogLy8gPlxuICAgICAgICBpZiAoZmVhdHVyZXMuYml0d2lzZU9wZXJhdG9ycylcbiAgICAgICAgICBpZiAoNjIgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignPj4nKTtcbiAgICAgICAgaWYgKDYxID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJz49Jyk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignPicpO1xuXG4gICAgICBjYXNlIDYwOiAvLyA8XG4gICAgICAgIGlmIChmZWF0dXJlcy5iaXR3aXNlT3BlcmF0b3JzKVxuICAgICAgICAgIGlmICg2MCA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc8PCcpO1xuICAgICAgICBpZiAoNjEgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignPD0nKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc8Jyk7XG5cbiAgICAgIGNhc2UgMTI2OiAvLyB+XG4gICAgICAgIGlmICg2MSA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCd+PScpO1xuICAgICAgICBpZiAoIWZlYXR1cmVzLmJpdHdpc2VPcGVyYXRvcnMpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignficpO1xuXG4gICAgICBjYXNlIDU4OiAvLyA6XG4gICAgICAgIGlmIChmZWF0dXJlcy5sYWJlbHMpXG4gICAgICAgICAgaWYgKDU4ID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJzo6Jyk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignOicpO1xuXG4gICAgICBjYXNlIDkxOiAvLyBbXG4gICAgICAgIC8vIENoZWNrIGZvciBhIG11bHRpbGluZSBzdHJpbmcsIHRoZXkgYmVnaW4gd2l0aCBbPSBvciBbW1xuICAgICAgICBpZiAoOTEgPT09IG5leHQgfHwgNjEgPT09IG5leHQpIHJldHVybiBzY2FuTG9uZ1N0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCdbJyk7XG5cbiAgICAgIGNhc2UgNDc6IC8vIC9cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVnZXIgZGl2aXNpb24gb3AgKC8vKVxuICAgICAgICBpZiAoZmVhdHVyZXMuaW50ZWdlckRpdmlzaW9uKVxuICAgICAgICAgIGlmICg0NyA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCcvLycpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJy8nKTtcblxuICAgICAgY2FzZSAzODogY2FzZSAxMjQ6IC8vICYgfFxuICAgICAgICBpZiAoIWZlYXR1cmVzLmJpdHdpc2VPcGVyYXRvcnMpXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogZmFsbCB0aHJvdWdoICovXG4gICAgICBjYXNlIDQyOiBjYXNlIDk0OiBjYXNlIDM3OiBjYXNlIDQ0OiBjYXNlIDEyMzogY2FzZSAxMjU6XG4gICAgICBjYXNlIDkzOiBjYXNlIDQwOiBjYXNlIDQxOiBjYXNlIDU5OiBjYXNlIDM1OiBjYXNlIDQ1OlxuICAgICAgY2FzZSA0MzogLy8gKiBeICUgLCB7IH0gXSAoICkgOyAjIC0gK1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoaW5wdXQuY2hhckF0KGluZGV4KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZXhwZWN0ZWQoaW5wdXQuY2hhckF0KGluZGV4KSk7XG4gIH1cblxuICAvLyBXaGl0ZXNwYWNlIGhhcyBubyBzZW1hbnRpYyBtZWFuaW5nIGluIGx1YSBzbyBzaW1wbHkgc2tpcCBhaGVhZCB3aGlsZVxuICAvLyB0cmFja2luZyB0aGUgZW5jb3VudGVkIG5ld2xpbmVzLiBBbnkga2luZCBvZiBlb2wgc2VxdWVuY2UgaXMgY291bnRlZCBhcyBhXG4gIC8vIHNpbmdsZSBsaW5lLlxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVFT0woKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleClcbiAgICAgICwgcGVla0NoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2hhckNvZGUpKSB7XG4gICAgICAvLyBDb3VudCBcXG5cXHIgYW5kIFxcclxcbiBhcyBvbmUgbmV3bGluZS5cbiAgICAgIGlmICgxMCA9PT0gY2hhckNvZGUgJiYgMTMgPT09IHBlZWtDaGFyQ29kZSkgKytpbmRleDtcbiAgICAgIGlmICgxMyA9PT0gY2hhckNvZGUgJiYgMTAgPT09IHBlZWtDaGFyQ29kZSkgKytpbmRleDtcbiAgICAgICsrbGluZTtcbiAgICAgIGxpbmVTdGFydCA9ICsraW5kZXg7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpdGVTcGFjZSgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaGFyQ29kZSkpIHtcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbnN1bWVFT0woKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZGVudGlmaWVycywga2V5d29yZHMsIGJvb2xlYW5zIGFuZCBuaWwgYWxsIGxvb2sgdGhlIHNhbWUgc3ludGF4IHdpc2UuIFdlXG4gIC8vIHNpbXBseSBnbyB0aHJvdWdoIHRoZW0gb25lIGJ5IG9uZSBhbmQgZGVmYXVsdGluZyB0byBhbiBpZGVudGlmaWVyIGlmIG5vXG4gIC8vIHByZXZpb3VzIGNhc2UgbWF0Y2hlZC5cblxuICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllck9yS2V5d29yZCgpIHtcbiAgICB2YXIgdmFsdWUsIHR5cGU7XG5cbiAgICAvLyBTbGljaW5nIHRoZSBpbnB1dCBzdHJpbmcgaXMgcHJlZmVyZWQgYmVmb3JlIHN0cmluZyBjb25jYXRlbmF0aW9uIGluIGFcbiAgICAvLyBsb29wIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KGlucHV0LmNoYXJDb2RlQXQoKytpbmRleCkpKTtcbiAgICB2YWx1ZSA9IGVuY29kaW5nTW9kZS5maXh1cChpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgLy8gRGVjaWRlIG9uIHRoZSB0b2tlbiB0eXBlIGFuZCBwb3NzaWJseSBjYXN0IHRoZSB2YWx1ZS5cbiAgICBpZiAoaXNLZXl3b3JkKHZhbHVlKSkge1xuICAgICAgdHlwZSA9IEtleXdvcmQ7XG4gICAgfSBlbHNlIGlmICgndHJ1ZScgPT09IHZhbHVlIHx8ICdmYWxzZScgPT09IHZhbHVlKSB7XG4gICAgICB0eXBlID0gQm9vbGVhbkxpdGVyYWw7XG4gICAgICB2YWx1ZSA9ICgndHJ1ZScgPT09IHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCduaWwnID09PSB2YWx1ZSkge1xuICAgICAgdHlwZSA9IE5pbExpdGVyYWw7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSBJZGVudGlmaWVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gT25jZSBhIHB1bmN0dWF0b3IgcmVhY2hlcyB0aGlzIGZ1bmN0aW9uIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlblxuICAvLyB2YWxpZGF0ZWQgc28gd2Ugc2ltcGx5IHJldHVybiBpdCBhcyBhIHRva2VuLlxuXG4gIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKHZhbHVlKSB7XG4gICAgaW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFB1bmN0dWF0b3JcbiAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gQSB2YXJhcmcgbGl0ZXJhbCBjb25zaXN0cyBvZiB0aHJlZSBkb3RzLlxuXG4gIGZ1bmN0aW9uIHNjYW5WYXJhcmdMaXRlcmFsKCkge1xuICAgIGluZGV4ICs9IDM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVmFyYXJnTGl0ZXJhbFxuICAgICAgLCB2YWx1ZTogJy4uLidcbiAgICAgICwgbGluZTogbGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW3Rva2VuU3RhcnQsIGluZGV4XVxuICAgIH07XG4gIH1cblxuICAvLyBGaW5kIHRoZSBzdHJpbmcgbGl0ZXJhbCBieSBtYXRjaGluZyB0aGUgZGVsaW1pdGVyIG1hcmtzIHVzZWQuXG5cbiAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgdmFyIGRlbGltaXRlciA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKylcbiAgICAgICwgYmVnaW5MaW5lID0gbGluZVxuICAgICAgLCBiZWdpbkxpbmVTdGFydCA9IGxpbmVTdGFydFxuICAgICAgLCBzdHJpbmdTdGFydCA9IGluZGV4XG4gICAgICAsIHN0cmluZyA9IGVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncyA/IG51bGwgOiAnJ1xuICAgICAgLCBjaGFyQ29kZTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgICAgIGlmIChkZWxpbWl0ZXIgPT09IGNoYXJDb2RlKSBicmVhaztcbiAgICAgIC8vIEVPRiBvciBgXFxuYCB0ZXJtaW5hdGVzIGEgc3RyaW5nIGxpdGVyYWwuIElmIHdlIGhhdmVuJ3QgZm91bmQgdGhlXG4gICAgICAvLyBlbmRpbmcgZGVsaW1pdGVyIGJ5IG5vdywgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIHx8IGlzTGluZVRlcm1pbmF0b3IoY2hhckNvZGUpKSB7XG4gICAgICAgIHN0cmluZyArPSBpbnB1dC5zbGljZShzdHJpbmdTdGFydCwgaW5kZXggLSAxKTtcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLnVuZmluaXNoZWRTdHJpbmcsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4IC0gMSkpO1xuICAgICAgfVxuICAgICAgaWYgKDkyID09PSBjaGFyQ29kZSkgeyAvLyBiYWNrc2xhc2hcbiAgICAgICAgaWYgKCFlbmNvZGluZ01vZGUuZGlzY2FyZFN0cmluZ3MpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlRXNjYXBlID0gaW5wdXQuc2xpY2Uoc3RyaW5nU3RhcnQsIGluZGV4IC0gMSk7XG4gICAgICAgICAgc3RyaW5nICs9IGVuY29kaW5nTW9kZS5maXh1cChiZWZvcmVFc2NhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlc2NhcGVWYWx1ZSA9IHJlYWRFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICBpZiAoIWVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncylcbiAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlVmFsdWU7XG4gICAgICAgIHN0cmluZ1N0YXJ0ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZW5jb2RpbmdNb2RlLmRpc2NhcmRTdHJpbmdzKSB7XG4gICAgICBzdHJpbmcgKz0gZW5jb2RpbmdNb2RlLmVuY29kZUJ5dGUobnVsbCk7XG4gICAgICBzdHJpbmcgKz0gZW5jb2RpbmdNb2RlLmZpeHVwKGlucHV0LnNsaWNlKHN0cmluZ1N0YXJ0LCBpbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTdHJpbmdMaXRlcmFsXG4gICAgICAsIHZhbHVlOiBzdHJpbmdcbiAgICAgICwgbGluZTogYmVnaW5MaW5lXG4gICAgICAsIGxpbmVTdGFydDogYmVnaW5MaW5lU3RhcnRcbiAgICAgICwgbGFzdExpbmU6IGxpbmVcbiAgICAgICwgbGFzdExpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbdG9rZW5TdGFydCwgaW5kZXhdXG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cGVjdCBhIG11bHRpbGluZSBzdHJpbmcgbGl0ZXJhbCBhbmQgcmV0dXJuIGl0IGFzIGEgcmVndWxhciBzdHJpbmdcbiAgLy8gbGl0ZXJhbCwgaWYgaXQgZG9lc24ndCB2YWxpZGF0ZSBpbnRvIGEgdmFsaWQgbXVsdGlsaW5lIHN0cmluZywgdGhyb3cgYW5cbiAgLy8gZXhjZXB0aW9uLlxuXG4gIGZ1bmN0aW9uIHNjYW5Mb25nU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICB2YXIgYmVnaW5MaW5lID0gbGluZVxuICAgICAgLCBiZWdpbkxpbmVTdGFydCA9IGxpbmVTdGFydFxuICAgICAgLCBzdHJpbmcgPSByZWFkTG9uZ1N0cmluZyhmYWxzZSk7XG4gICAgLy8gRmFpbCBpZiBpdCdzIG5vdCBhIG11bHRpbGluZSBsaXRlcmFsLlxuICAgIGlmIChmYWxzZSA9PT0gc3RyaW5nKSByYWlzZSh0b2tlbiwgZXJyb3JzLmV4cGVjdGVkLCAnWycsIHRva2VuVmFsdWUodG9rZW4pKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ0xpdGVyYWxcbiAgICAgICwgdmFsdWU6IGVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncyA/IG51bGwgOiBlbmNvZGluZ01vZGUuZml4dXAoc3RyaW5nKVxuICAgICAgLCBsaW5lOiBiZWdpbkxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBiZWdpbkxpbmVTdGFydFxuICAgICAgLCBsYXN0TGluZTogbGluZVxuICAgICAgLCBsYXN0TGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gTnVtZXJpYyBsaXRlcmFscyB3aWxsIGJlIHJldHVybmVkIGFzIGZsb2F0aW5nLXBvaW50IG51bWJlcnMgaW5zdGVhZCBvZlxuICAvLyBzdHJpbmdzLiBUaGUgcmF3IHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQgZnJvbSBzbGljaW5nIHRoZSBpbnB1dCBzdHJpbmdcbiAgLy8gbGF0ZXIgb24gaW4gdGhlIHByb2Nlc3MuXG4gIC8vXG4gIC8vIElmIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGlzIGVuY291bnRlcmVkLCBpdCB3aWxsIGJlIGNvbnZlcnRlZC5cblxuICBmdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IGlucHV0LmNoYXJBdChpbmRleClcbiAgICAgICwgbmV4dCA9IGlucHV0LmNoYXJBdChpbmRleCArIDEpO1xuXG4gICAgdmFyIGxpdGVyYWwgPSAoJzAnID09PSBjaGFyYWN0ZXIgJiYgJ3hYJy5pbmRleE9mKG5leHQgfHwgbnVsbCkgPj0gMCkgP1xuICAgICAgcmVhZEhleExpdGVyYWwoKSA6IHJlYWREZWNMaXRlcmFsKCk7XG5cbiAgICB2YXIgZm91bmRJbWFnaW5hcnlVbml0ID0gcmVhZEltYWdpbmFyeVVuaXRTdWZmaXgoKVxuICAgICAgLCBmb3VuZEludDY0U3VmZml4ID0gcmVhZEludDY0U3VmZml4KCk7XG5cbiAgICBpZiAoZm91bmRJbnQ2NFN1ZmZpeCAmJiAoZm91bmRJbWFnaW5hcnlVbml0IHx8IGxpdGVyYWwuaGFzRnJhY3Rpb25QYXJ0KSkge1xuICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBOdW1lcmljTGl0ZXJhbFxuICAgICAgLCB2YWx1ZTogbGl0ZXJhbC52YWx1ZVxuICAgICAgLCBsaW5lOiBsaW5lXG4gICAgICAsIGxpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbdG9rZW5TdGFydCwgaW5kZXhdXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRJbWFnaW5hcnlVbml0U3VmZml4KCkge1xuICAgIGlmICghZmVhdHVyZXMuaW1hZ2luYXJ5TnVtYmVycykgcmV0dXJuO1xuXG4gICAgLy8gSW1hZ2luYXJ5IHVuaXQgbnVtYmVyIHN1ZmZpeCBpcyBvcHRpb25hbC5cbiAgICAvLyBTZWUgaHR0cDovL2x1YWppdC5vcmcvZXh0X2ZmaV9hcGkuaHRtbCNsaXRlcmFsc1xuICAgIGlmICgnaUknLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSW50NjRTdWZmaXgoKSB7XG4gICAgaWYgKCFmZWF0dXJlcy5pbnRlZ2VyU3VmZml4ZXMpIHJldHVybjtcblxuICAgIC8vIEludDY0L3VpbnQ2NCBudW1iZXIgc3VmZml4IGlzIG9wdGlvbmFsLlxuICAgIC8vIFNlZSBodHRwOi8vbHVhaml0Lm9yZy9leHRfZmZpX2FwaS5odG1sI2xpdGVyYWxzXG5cbiAgICBpZiAoJ3VVJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMCkge1xuICAgICAgKytpbmRleDtcbiAgICAgIGlmICgnbEwnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICAgICsraW5kZXg7XG4gICAgICAgIGlmICgnbEwnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICByZXR1cm4gJ1VMTCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVUwgYnV0IG5vIExcbiAgICAgICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVIGJ1dCBubyBMXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnbEwnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICAgICsraW5kZXg7XG4gICAgICAgIGlmICgnbEwnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICByZXR1cm4gJ0xMJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXJzdCBMIGJ1dCBubyBzZWNvbmQgTFxuICAgICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBMdWEgaGV4YWRlY2ltYWxzIGhhdmUgYW4gb3B0aW9uYWwgZnJhY3Rpb24gcGFydCBhbmQgYW4gb3B0aW9uYWwgYmluYXJ5XG4gIC8vIGV4b3BvbmVudCBwYXJ0LiBUaGVzZSBhcmUgbm90IGluY2x1ZGVkIGluIEphdmFTY3JpcHQgc28gd2Ugd2lsbCBjb21wdXRlXG4gIC8vIGFsbCB0aHJlZSBwYXJ0cyBzZXBhcmF0ZWx5IGFuZCB0aGVuIHN1bSB0aGVtIHVwIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uXG4gIC8vIHdpdGggdGhlIGZvbGxvd2luZyBhbGdvcml0aG0uXG4gIC8vXG4gIC8vICAgICBEaWdpdCA6PSB0b0RlYyhkaWdpdClcbiAgLy8gICAgIEZyYWN0aW9uIDo9IHRvRGVjKGZyYWN0aW9uKSAvIDE2IF4gZnJhY3Rpb25Db3VudFxuICAvLyAgICAgQmluYXJ5RXhwIDo9IDIgXiBiaW5hcnlFeHBcbiAgLy8gICAgIE51bWJlciA6PSAoIERpZ2l0ICsgRnJhY3Rpb24gKSAqIEJpbmFyeUV4cFxuXG4gIGZ1bmN0aW9uIHJlYWRIZXhMaXRlcmFsKCkge1xuICAgIHZhciBmcmFjdGlvbiA9IDAgLy8gZGVmYXVsdHMgdG8gMCBhcyBpdCBnZXRzIHN1bW1lZFxuICAgICAgLCBiaW5hcnlFeHBvbmVudCA9IDEgLy8gZGVmYXVsdHMgdG8gMSBhcyBpdCBnZXRzIG11bHRpcGxpZWRcbiAgICAgICwgYmluYXJ5U2lnbiA9IDEgLy8gcG9zaXRpdmVcbiAgICAgICwgZGlnaXQsIGZyYWN0aW9uU3RhcnQsIGV4cG9uZW50U3RhcnQsIGRpZ2l0U3RhcnQ7XG5cbiAgICBkaWdpdFN0YXJ0ID0gaW5kZXggKz0gMjsgLy8gU2tpcCAweCBwYXJ0XG5cbiAgICAvLyBBIG1pbmltdW0gb2Ygb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cbiAgICBpZiAoIWlzSGV4RGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKVxuICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcblxuICAgIHdoaWxlIChpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgKytpbmRleDtcbiAgICAvLyBDb252ZXJ0IHRoZSBoZXhhZGVjaW1hbCBkaWdpdCB0byBiYXNlIDEwLlxuICAgIGRpZ2l0ID0gcGFyc2VJbnQoaW5wdXQuc2xpY2UoZGlnaXRTdGFydCwgaW5kZXgpLCAxNik7XG5cbiAgICAvLyBGcmFjdGlvbiBwYXJ0IGlzIG9wdGlvbmFsLlxuICAgIHZhciBmb3VuZEZyYWN0aW9uID0gZmFsc2U7XG4gICAgaWYgKCcuJyA9PT0gaW5wdXQuY2hhckF0KGluZGV4KSkge1xuICAgICAgZm91bmRGcmFjdGlvbiA9IHRydWU7XG4gICAgICBmcmFjdGlvblN0YXJ0ID0gKytpbmRleDtcblxuICAgICAgd2hpbGUgKGlzSGV4RGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgICAgZnJhY3Rpb24gPSBpbnB1dC5zbGljZShmcmFjdGlvblN0YXJ0LCBpbmRleCk7XG5cbiAgICAgIC8vIEVtcHR5IGZyYWN0aW9uIHBhcnRzIHNob3VsZCBkZWZhdWx0IHRvIDAsIG90aGVycyBzaG91bGQgYmUgY29udmVydGVkXG4gICAgICAvLyAwLnggZm9ybSBzbyB3ZSBjYW4gdXNlIHN1bW1hdGlvbiBhdCB0aGUgZW5kLlxuICAgICAgZnJhY3Rpb24gPSAoZnJhY3Rpb25TdGFydCA9PT0gaW5kZXgpID8gMFxuICAgICAgICA6IHBhcnNlSW50KGZyYWN0aW9uLCAxNikgLyBNYXRoLnBvdygxNiwgaW5kZXggLSBmcmFjdGlvblN0YXJ0KTtcbiAgICB9XG5cbiAgICAvLyBCaW5hcnkgZXhwb25lbnRzIGFyZSBvcHRpb25hbFxuICAgIHZhciBmb3VuZEJpbmFyeUV4cG9uZW50ID0gZmFsc2U7XG4gICAgaWYgKCdwUCcuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgIGZvdW5kQmluYXJ5RXhwb25lbnQgPSB0cnVlO1xuICAgICAgKytpbmRleDtcblxuICAgICAgLy8gU2lnbiBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAxIChwb3NpdGl2ZSkuXG4gICAgICBpZiAoJystJy5pbmRleE9mKGlucHV0LmNoYXJBdChpbmRleCkgfHwgbnVsbCkgPj0gMClcbiAgICAgICAgYmluYXJ5U2lnbiA9ICgnKycgPT09IGlucHV0LmNoYXJBdChpbmRleCsrKSkgPyAxIDogLTE7XG5cbiAgICAgIGV4cG9uZW50U3RhcnQgPSBpbmRleDtcblxuICAgICAgLy8gVGhlIGJpbmFyeSBleHBvbmVudCBzaWduIHJlcXVpcmVzIGEgZGVjaW1hbCBkaWdpdC5cbiAgICAgIGlmICghaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG5cbiAgICAgIHdoaWxlIChpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgKytpbmRleDtcbiAgICAgIGJpbmFyeUV4cG9uZW50ID0gaW5wdXQuc2xpY2UoZXhwb25lbnRTdGFydCwgaW5kZXgpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJpbmFyeSBleHBvbmVudCBvZiB0aGUgbnVtYmVyLlxuICAgICAgYmluYXJ5RXhwb25lbnQgPSBNYXRoLnBvdygyLCBiaW5hcnlFeHBvbmVudCAqIGJpbmFyeVNpZ24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogKGRpZ2l0ICsgZnJhY3Rpb24pICogYmluYXJ5RXhwb25lbnQsXG4gICAgICBoYXNGcmFjdGlvblBhcnQ6IGZvdW5kRnJhY3Rpb24gfHwgZm91bmRCaW5hcnlFeHBvbmVudFxuICAgIH07XG4gIH1cblxuICAvLyBEZWNpbWFsIG51bWJlcnMgYXJlIGV4YWN0bHkgdGhlIHNhbWUgaW4gTHVhIGFuZCBpbiBKYXZhU2NyaXB0LCBiZWNhdXNlIG9mXG4gIC8vIHRoaXMgd2UgY2hlY2sgd2hlcmUgdGhlIHRva2VuIGVuZHMgYW5kIHRoZW4gcGFyc2UgaXQgd2l0aCBuYXRpdmVcbiAgLy8gZnVuY3Rpb25zLlxuXG4gIGZ1bmN0aW9uIHJlYWREZWNMaXRlcmFsKCkge1xuICAgIHdoaWxlIChpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgKytpbmRleDtcbiAgICAvLyBGcmFjdGlvbiBwYXJ0IGlzIG9wdGlvbmFsXG4gICAgdmFyIGZvdW5kRnJhY3Rpb24gPSBmYWxzZTtcbiAgICBpZiAoJy4nID09PSBpbnB1dC5jaGFyQXQoaW5kZXgpKSB7XG4gICAgICBmb3VuZEZyYWN0aW9uID0gdHJ1ZTtcbiAgICAgICsraW5kZXg7XG4gICAgICAvLyBGcmFjdGlvbiBwYXJ0IGRlZmF1bHRzIHRvIDBcbiAgICAgIHdoaWxlIChpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgKytpbmRleDtcbiAgICB9XG5cbiAgICAvLyBFeHBvbmVudCBwYXJ0IGlzIG9wdGlvbmFsLlxuICAgIHZhciBmb3VuZEV4cG9uZW50ID0gZmFsc2U7XG4gICAgaWYgKCdlRScuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgIGZvdW5kRXhwb25lbnQgPSB0cnVlO1xuICAgICAgKytpbmRleDtcbiAgICAgIC8vIFNpZ24gcGFydCBpcyBvcHRpb25hbC5cbiAgICAgIGlmICgnKy0nLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSArK2luZGV4O1xuICAgICAgLy8gQW4gZXhwb25lbnQgaXMgcmVxdWlyZWQgdG8gY29udGFpbiBhdCBsZWFzdCBvbmUgZGVjaW1hbCBkaWdpdC5cbiAgICAgIGlmICghaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG5cbiAgICAgIHdoaWxlIChpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgKytpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHBhcnNlRmxvYXQoaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKSxcbiAgICAgIGhhc0ZyYWN0aW9uUGFydDogZm91bmRGcmFjdGlvbiB8fCBmb3VuZEV4cG9uZW50XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgdmFyIHNlcXVlbmNlU3RhcnQgPSBpbmRleCsrO1xuXG4gICAgaWYgKGlucHV0LmNoYXJBdChpbmRleCsrKSAhPT0gJ3snKVxuICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmJyYWNlRXhwZWN0ZWQsICd7JywgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcbiAgICBpZiAoIWlzSGV4RGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKVxuICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmhleGFkZWNpbWFsRGlnaXRFeHBlY3RlZCwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcblxuICAgIHdoaWxlIChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzMCkgKytpbmRleDtcbiAgICB2YXIgZXNjU3RhcnQgPSBpbmRleDtcblxuICAgIHdoaWxlIChpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgKytpbmRleDtcbiAgICAgIGlmIChpbmRleCAtIGVzY1N0YXJ0ID4gNilcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLnRvb0xhcmdlQ29kZXBvaW50LCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCkpO1xuICAgIH1cblxuICAgIHZhciBiID0gaW5wdXQuY2hhckF0KGluZGV4KyspO1xuICAgIGlmIChiICE9PSAnfScpIHtcbiAgICAgIGlmICgoYiA9PT0gJ1wiJykgfHwgKGIgPT09IFwiJ1wiKSlcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmJyYWNlRXhwZWN0ZWQsICd9JywgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgtLSkpO1xuICAgICAgZWxzZVxuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMuaGV4YWRlY2ltYWxEaWdpdEV4cGVjdGVkLCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCkpO1xuICAgIH1cblxuICAgIHZhciBjb2RlcG9pbnQgPSBwYXJzZUludChpbnB1dC5zbGljZShlc2NTdGFydCwgaW5kZXggLSAxKSB8fCAnMCcsIDE2KTtcbiAgICB2YXIgZnJhZyA9ICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KTtcblxuICAgIGlmIChjb2RlcG9pbnQgPiAweDEwZmZmZikge1xuICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLnRvb0xhcmdlQ29kZXBvaW50LCBmcmFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RpbmdNb2RlLmVuY29kZVVURjgoY29kZXBvaW50LCBmcmFnKTtcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZSBlc2NhcGUgc2VxdWVuY2VzIHRvIHRoZSBhY3R1YWwgY2hhcmFjdGVycy5cbiAgZnVuY3Rpb24gcmVhZEVzY2FwZVNlcXVlbmNlKCkge1xuICAgIHZhciBzZXF1ZW5jZVN0YXJ0ID0gaW5kZXg7XG4gICAgc3dpdGNoIChpbnB1dC5jaGFyQXQoaW5kZXgpKSB7XG4gICAgICAvLyBMdWEgYWxsb3cgdGhlIGZvbGxvd2luZyBlc2NhcGUgc2VxdWVuY2VzLlxuICAgICAgY2FzZSAnYSc6ICsraW5kZXg7IHJldHVybiAnXFx4MDcnO1xuICAgICAgY2FzZSAnbic6ICsraW5kZXg7IHJldHVybiAnXFxuJztcbiAgICAgIGNhc2UgJ3InOiArK2luZGV4OyByZXR1cm4gJ1xccic7XG4gICAgICBjYXNlICd0JzogKytpbmRleDsgcmV0dXJuICdcXHQnO1xuICAgICAgY2FzZSAndic6ICsraW5kZXg7IHJldHVybiAnXFx4MGInO1xuICAgICAgY2FzZSAnYic6ICsraW5kZXg7IHJldHVybiAnXFxiJztcbiAgICAgIGNhc2UgJ2YnOiArK2luZGV4OyByZXR1cm4gJ1xcZic7XG5cbiAgICAgIC8vIEJhY2tzbGFzaCBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLiBXZSB0cmVhdCBhbGwgbGluZSBlbmRpbmdzIGFzIGVxdWl2YWxlbnQsXG4gICAgICAvLyBhbmQgYXMgcmVwcmVzZW50aW5nIHRoZSBbTEZdIGNoYXJhY3RlciAoY29kZSAxMCkuIEx1YSA1LjEgdGhyb3VnaCA1LjNcbiAgICAgIC8vIGhhdmUgYmVlbiB2ZXJpZmllZCB0byBiZWhhdmUgdGhlIHNhbWUgd2F5LlxuICAgICAgY2FzZSAnXFxyJzpcbiAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNvbnN1bWVFT0woKTtcbiAgICAgICAgcmV0dXJuICdcXG4nO1xuXG4gICAgICBjYXNlICcwJzogY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6XG4gICAgICBjYXNlICc1JzogY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICAgIC8vIFxcZGRkLCB3aGVyZSBkZGQgaXMgYSBzZXF1ZW5jZSBvZiB1cCB0byB0aHJlZSBkZWNpbWFsIGRpZ2l0cy5cbiAgICAgICAgd2hpbGUgKGlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpICYmIGluZGV4IC0gc2VxdWVuY2VTdGFydCA8IDMpICsraW5kZXg7XG5cbiAgICAgICAgdmFyIGZyYWcgPSBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCk7XG4gICAgICAgIHZhciBkZGQgPSBwYXJzZUludChmcmFnLCAxMCk7XG4gICAgICAgIGlmIChkZGQgPiAyNTUpIHtcbiAgICAgICAgICByYWlzZShudWxsLCBlcnJvcnMuZGVjaW1hbEVzY2FwZVRvb0xhcmdlLCAnXFxcXCcgKyBkZGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGluZ01vZGUuZW5jb2RlQnl0ZShkZGQsICdcXFxcJyArIGZyYWcpO1xuXG4gICAgICBjYXNlICd6JzpcbiAgICAgICAgaWYgKGZlYXR1cmVzLnNraXBXaGl0ZXNwYWNlRXNjYXBlKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBza2lwV2hpdGVTcGFjZSgpO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneCc6XG4gICAgICAgIGlmIChmZWF0dXJlcy5oZXhFc2NhcGVzKSB7XG4gICAgICAgICAgLy8gXFx4WFgsIHdoZXJlIFhYIGlzIGEgc2VxdWVuY2Ugb2YgZXhhY3RseSB0d28gaGV4YWRlY2ltYWwgZGlnaXRzXG4gICAgICAgICAgaWYgKGlzSGV4RGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpKSAmJlxuICAgICAgICAgICAgICBpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAyKSkpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RpbmdNb2RlLmVuY29kZUJ5dGUocGFyc2VJbnQoaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCArIDEsIGluZGV4KSwgMTYpLCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByYWlzZShudWxsLCBlcnJvcnMuaGV4YWRlY2ltYWxEaWdpdEV4cGVjdGVkLCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndSc6XG4gICAgICAgIGlmIChmZWF0dXJlcy51bmljb2RlRXNjYXBlcylcbiAgICAgICAgICByZXR1cm4gcmVhZFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnXFxcXCc6IGNhc2UgJ1wiJzogY2FzZSBcIidcIjpcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdChpbmRleCsrKTtcbiAgICB9XG5cbiAgICBpZiAoZmVhdHVyZXMuc3RyaWN0RXNjYXBlcylcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5pbnZhbGlkRXNjYXBlLCAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCArIDEpKTtcbiAgICByZXR1cm4gaW5wdXQuY2hhckF0KGluZGV4KyspO1xuICB9XG5cbiAgLy8gQ29tbWVudHMgYmVnaW4gd2l0aCAtLSBhZnRlciB3aGljaCBpdCB3aWxsIGJlIGRlY2lkZWQgaWYgdGhleSBhcmVcbiAgLy8gbXVsdGlsaW5lIGNvbW1lbnRzIG9yIG5vdC5cbiAgLy9cbiAgLy8gVGhlIG11bHRpbGluZSBmdW5jdGlvbmFsaXR5IHdvcmtzIHRoZSBleGFjdCBzYW1lIHdheSBhcyB3aXRoIHN0cmluZ1xuICAvLyBsaXRlcmFscyBzbyB3ZSByZXVzZSB0aGUgZnVuY3Rpb25hbGl0eS5cblxuICBmdW5jdGlvbiBzY2FuQ29tbWVudCgpIHtcbiAgICB0b2tlblN0YXJ0ID0gaW5kZXg7XG4gICAgaW5kZXggKz0gMjsgLy8gLS1cblxuICAgIHZhciBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQXQoaW5kZXgpXG4gICAgICAsIGNvbnRlbnQgPSAnJ1xuICAgICAgLCBpc0xvbmcgPSBmYWxzZVxuICAgICAgLCBjb21tZW50U3RhcnQgPSBpbmRleFxuICAgICAgLCBsaW5lU3RhcnRDb21tZW50ID0gbGluZVN0YXJ0XG4gICAgICAsIGxpbmVDb21tZW50ID0gbGluZTtcblxuICAgIGlmICgnWycgPT09IGNoYXJhY3Rlcikge1xuICAgICAgY29udGVudCA9IHJlYWRMb25nU3RyaW5nKHRydWUpO1xuICAgICAgLy8gVGhpcyB3YXNuJ3QgYSBtdWx0aWxpbmUgY29tbWVudCBhZnRlciBhbGwuXG4gICAgICBpZiAoZmFsc2UgPT09IGNvbnRlbnQpIGNvbnRlbnQgPSBjaGFyYWN0ZXI7XG4gICAgICBlbHNlIGlzTG9uZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIFNjYW4gdW50aWwgbmV4dCBsaW5lIGFzIGxvbmcgYXMgaXQncyBub3QgYSBtdWx0aWxpbmUgY29tbWVudC5cbiAgICBpZiAoIWlzTG9uZykge1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgYnJlYWs7XG4gICAgICAgICsraW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jb21tZW50cykgY29udGVudCA9IGlucHV0LnNsaWNlKGNvbW1lbnRTdGFydCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNvbW1lbnRzKSB7XG4gICAgICB2YXIgbm9kZSA9IGFzdC5jb21tZW50KGNvbnRlbnQsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG5cbiAgICAgIC8vIGBNYXJrZXJgcyBkZXBlbmQgb24gdG9rZW5zIGF2YWlsYWJsZSBpbiB0aGUgcGFyc2VyIGFuZCBhcyBjb21tZW50cyBhcmVcbiAgICAgIC8vIGludGVyY2VwdGVkIGluIHRoZSBsZXhlciBhbGwgbG9jYXRpb24gZGF0YSBpcyBzZXQgbWFudWFsbHkuXG4gICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgbm9kZS5sb2MgPSB7XG4gICAgICAgICAgICBzdGFydDogeyBsaW5lOiBsaW5lQ29tbWVudCwgY29sdW1uOiB0b2tlblN0YXJ0IC0gbGluZVN0YXJ0Q29tbWVudCB9XG4gICAgICAgICAgLCBlbmQ6IHsgbGluZTogbGluZSwgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgbm9kZS5yYW5nZSA9IFt0b2tlblN0YXJ0LCBpbmRleF07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vbkNyZWF0ZU5vZGUpIG9wdGlvbnMub25DcmVhdGVOb2RlKG5vZGUpO1xuICAgICAgY29tbWVudHMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIGEgbXVsdGlsaW5lIHN0cmluZyBieSBjYWxjdWxhdGluZyB0aGUgZGVwdGggb2YgYD1gIGNoYXJhY3RlcnMgYW5kXG4gIC8vIHRoZW4gYXBwZW5kaW5nIHVudGlsIGFuIGVxdWFsIGRlcHRoIGlzIGZvdW5kLlxuXG4gIGZ1bmN0aW9uIHJlYWRMb25nU3RyaW5nKGlzQ29tbWVudCkge1xuICAgIHZhciBsZXZlbCA9IDBcbiAgICAgICwgY29udGVudCA9ICcnXG4gICAgICAsIHRlcm1pbmF0b3IgPSBmYWxzZVxuICAgICAgLCBjaGFyYWN0ZXIsIHN0cmluZ1N0YXJ0LCBmaXJzdExpbmUgPSBsaW5lO1xuXG4gICAgKytpbmRleDsgLy8gW1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXB0aCBvZiB0aGUgY29tbWVudC5cbiAgICB3aGlsZSAoJz0nID09PSBpbnB1dC5jaGFyQXQoaW5kZXggKyBsZXZlbCkpICsrbGV2ZWw7XG4gICAgLy8gRXhpdCwgdGhpcyBpcyBub3QgYSBsb25nIHN0cmluZyBhZnRlcmFsbC5cbiAgICBpZiAoJ1snICE9PSBpbnB1dC5jaGFyQXQoaW5kZXggKyBsZXZlbCkpIHJldHVybiBmYWxzZTtcblxuICAgIGluZGV4ICs9IGxldmVsICsgMTtcblxuICAgIC8vIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgYSBuZXdsaW5lLCBpZ25vcmUgaXQgYW5kIGJlZ2luIG9uIG5leHQgbGluZS5cbiAgICBpZiAoaXNMaW5lVGVybWluYXRvcihpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpIGNvbnN1bWVFT0woKTtcblxuICAgIHN0cmluZ1N0YXJ0ID0gaW5kZXg7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAvLyBUbyBrZWVwIHRyYWNrIG9mIGxpbmUgbnVtYmVycyBydW4gdGhlIGBjb25zdW1lRU9MKClgIHdoaWNoIGluY3JlbWVudHNcbiAgICAgIC8vIGl0cyBjb3VudGVyLlxuICAgICAgd2hpbGUgKGlzTGluZVRlcm1pbmF0b3IoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSBjb25zdW1lRU9MKCk7XG5cbiAgICAgIGNoYXJhY3RlciA9IGlucHV0LmNoYXJBdChpbmRleCsrKTtcblxuICAgICAgLy8gT25jZSB0aGUgZGVsaW1pdGVyIGlzIGZvdW5kLCBpdGVyYXRlIHRocm91Z2ggdGhlIGRlcHRoIGNvdW50IGFuZCBzZWVcbiAgICAgIC8vIGlmIGl0IG1hdGNoZXMuXG4gICAgICBpZiAoJ10nID09PSBjaGFyYWN0ZXIpIHtcbiAgICAgICAgdGVybWluYXRvciA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWw7ICsraSkge1xuICAgICAgICAgIGlmICgnPScgIT09IGlucHV0LmNoYXJBdChpbmRleCArIGkpKSB0ZXJtaW5hdG9yID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCddJyAhPT0gaW5wdXQuY2hhckF0KGluZGV4ICsgbGV2ZWwpKSB0ZXJtaW5hdG9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbXVsdGlsaW5lIHN0cmluZy4gR2V0IG91dCBub3cuXG4gICAgICBpZiAodGVybWluYXRvcikge1xuICAgICAgICBjb250ZW50ICs9IGlucHV0LnNsaWNlKHN0cmluZ1N0YXJ0LCBpbmRleCAtIDEpO1xuICAgICAgICBpbmRleCArPSBsZXZlbCArIDE7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJhaXNlKG51bGwsIGlzQ29tbWVudCA/XG4gICAgICAgICAgICAgICAgZXJyb3JzLnVuZmluaXNoZWRMb25nQ29tbWVudCA6XG4gICAgICAgICAgICAgICAgZXJyb3JzLnVuZmluaXNoZWRMb25nU3RyaW5nLFxuICAgICAgICAgIGZpcnN0TGluZSwgJzxlb2Y+Jyk7XG4gIH1cblxuICAvLyAjIyBMZXggZnVuY3Rpb25zIGFuZCBoZWxwZXJzLlxuXG4gIC8vIFJlYWQgdGhlIG5leHQgdG9rZW4uXG4gIC8vXG4gIC8vIFRoaXMgaXMgYWN0dWFsbHkgZG9uZSBieSBzZXR0aW5nIHRoZSBjdXJyZW50IHRva2VuIHRvIHRoZSBsb29rYWhlYWQgYW5kXG4gIC8vIHJlYWRpbmcgaW4gdGhlIG5ldyBsb29rYWhlYWQgdG9rZW4uXG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgbG9va2FoZWFkID0gbGV4KCk7XG4gIH1cblxuICAvLyBDb25zdW1lIGEgdG9rZW4gaWYgaXRzIHZhbHVlIG1hdGNoZXMuIE9uY2UgY29uc3VtZWQgb3Igbm90LCByZXR1cm4gdGhlXG4gIC8vIHN1Y2Nlc3Mgb2YgdGhlIG9wZXJhdGlvbi5cblxuICBmdW5jdGlvbiBjb25zdW1lKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0b2tlbi52YWx1ZSkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB2YWx1ZSB0byBtYXRjaC4gSWYgbm90LCB0aHJvdyBhbiBleGNlcHRpb24uXG5cbiAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0b2tlbi52YWx1ZSkgbmV4dCgpO1xuICAgIGVsc2UgcmFpc2UodG9rZW4sIGVycm9ycy5leHBlY3RlZCwgdmFsdWUsIHRva2VuVmFsdWUodG9rZW4pKTtcbiAgfVxuXG4gIC8vICMjIyBWYWxpZGF0aW9uIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaGFyQ29kZSkge1xuICAgIHJldHVybiA5ID09PSBjaGFyQ29kZSB8fCAzMiA9PT0gY2hhckNvZGUgfHwgMHhCID09PSBjaGFyQ29kZSB8fCAweEMgPT09IGNoYXJDb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaGFyQ29kZSkge1xuICAgIHJldHVybiAxMCA9PT0gY2hhckNvZGUgfHwgMTMgPT09IGNoYXJDb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWNEaWdpdChjaGFyQ29kZSkge1xuICAgIHJldHVybiBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB8fCAoY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyKSB8fCAoY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApO1xuICB9XG5cbiAgLy8gRnJvbSBbTHVhIDUuMl0oaHR0cDovL3d3dy5sdWEub3JnL21hbnVhbC81LjIvbWFudWFsLmh0bWwjOC4xKSBvbndhcmRzXG4gIC8vIGlkZW50aWZpZXJzIGNhbm5vdCB1c2UgJ2xvY2FsZS1kZXBlbmRlbnQnIGxldHRlcnMgKGkuZS4gZGVwZW5kZW50IG9uIHRoZSBDIGxvY2FsZSkuXG4gIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBMdWFKSVQgYWxsb3dzIGFyYml0cmFyeSBvY3RldHMg4omlIDEyOCBpbiBpZGVudGlmaWVycy5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaGFyQ29kZSkge1xuICAgIGlmICgoY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gOTApIHx8IChjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMjIpIHx8IDk1ID09PSBjaGFyQ29kZSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChmZWF0dXJlcy5leHRlbmRlZElkZW50aWZpZXJzICYmIGNoYXJDb2RlID49IDEyOClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY2hhckNvZGUpIHtcbiAgICBpZiAoKGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDkwKSB8fCAoY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTIyKSB8fCA5NSA9PT0gY2hhckNvZGUgfHwgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChmZWF0dXJlcy5leHRlbmRlZElkZW50aWZpZXJzICYmIGNoYXJDb2RlID49IDEyOClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFszLjEgTGV4aWNhbCBDb252ZW50aW9uc10oaHR0cDovL3d3dy5sdWEub3JnL21hbnVhbC81LjIvbWFudWFsLmh0bWwjMy4xKVxuICAvL1xuICAvLyBgdHJ1ZWAsIGBmYWxzZWAgYW5kIGBuaWxgIHdpbGwgbm90IGJlIGNvbnNpZGVyZWQga2V5d29yZHMsIGJ1dCBsaXRlcmFscy5cblxuICBmdW5jdGlvbiBpc0tleXdvcmQoaWQpIHtcbiAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gJ2RvJyA9PT0gaWQgfHwgJ2lmJyA9PT0gaWQgfHwgJ2luJyA9PT0gaWQgfHwgJ29yJyA9PT0gaWQ7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiAnYW5kJyA9PT0gaWQgfHwgJ2VuZCcgPT09IGlkIHx8ICdmb3InID09PSBpZCB8fCAnbm90JyA9PT0gaWQ7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmICgnZWxzZScgPT09IGlkIHx8ICd0aGVuJyA9PT0gaWQpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChmZWF0dXJlcy5sYWJlbHMgJiYgIWZlYXR1cmVzLmNvbnRleHR1YWxHb3RvKVxuICAgICAgICAgIHJldHVybiAoJ2dvdG8nID09PSBpZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuICdicmVhaycgPT09IGlkIHx8ICdsb2NhbCcgPT09IGlkIHx8ICd1bnRpbCcgPT09IGlkIHx8ICd3aGlsZScgPT09IGlkO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gJ2Vsc2VpZicgPT09IGlkIHx8ICdyZXBlYXQnID09PSBpZCB8fCAncmV0dXJuJyA9PT0gaWQ7XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24nID09PSBpZDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmFyeSh0b2tlbikge1xuICAgIGlmIChQdW5jdHVhdG9yID09PSB0b2tlbi50eXBlKSByZXR1cm4gJyMtficuaW5kZXhPZih0b2tlbi52YWx1ZSkgPj0gMDtcbiAgICBpZiAoS2V5d29yZCA9PT0gdG9rZW4udHlwZSkgcmV0dXJuICdub3QnID09PSB0b2tlbi52YWx1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgdG9rZW4gc3ludGFjdGljYWxseSBjbG9zZXMgYSBibG9jay5cblxuICBmdW5jdGlvbiBpc0Jsb2NrRm9sbG93KHRva2VuKSB7XG4gICAgaWYgKEVPRiA9PT0gdG9rZW4udHlwZSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKEtleXdvcmQgIT09IHRva2VuLnR5cGUpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICBjYXNlICdlbHNlJzogY2FzZSAnZWxzZWlmJzpcbiAgICAgIGNhc2UgJ2VuZCc6IGNhc2UgJ3VudGlsJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gU2NvcGVcbiAgLy8gLS0tLS1cblxuICAvLyBTdG9yZSBlYWNoIGJsb2NrIHNjb3BlIGFzIGEgYW4gYXJyYXkgb2YgaWRlbnRpZmllciBuYW1lcy4gRWFjaCBzY29wZSBpc1xuICAvLyBzdG9yZWQgaW4gYW4gRklMTy1hcnJheS5cbiAgdmFyIHNjb3Blc1xuICAgIC8vIFRoZSBjdXJyZW50IHNjb3BlIGluZGV4XG4gICAgLCBzY29wZURlcHRoXG4gICAgLy8gQSBsaXN0IG9mIGFsbCBnbG9iYWwgaWRlbnRpZmllciBub2Rlcy5cbiAgICAsIGdsb2JhbHM7XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHNjb3BlIGluaGVyaXRpbmcgYWxsIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBwcmV2aW91cyBzY29wZS5cbiAgZnVuY3Rpb24gY3JlYXRlU2NvcGUoKSB7XG4gICAgdmFyIHNjb3BlID0gc2NvcGVzW3Njb3BlRGVwdGgrK10uc2xpY2UoKTtcbiAgICBzY29wZXMucHVzaChzY29wZSk7XG4gICAgaWYgKG9wdGlvbnMub25DcmVhdGVTY29wZSkgb3B0aW9ucy5vbkNyZWF0ZVNjb3BlKCk7XG4gIH1cblxuICAvLyBFeGl0IGFuZCByZW1vdmUgdGhlIGN1cnJlbnQgc2NvcGUuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lTY29wZSgpIHtcbiAgICB2YXIgc2NvcGUgPSBzY29wZXMucG9wKCk7XG4gICAgLS1zY29wZURlcHRoO1xuICAgIGlmIChvcHRpb25zLm9uRGVzdHJveVNjb3BlKSBvcHRpb25zLm9uRGVzdHJveVNjb3BlKCk7XG4gIH1cblxuICAvLyBBZGQgaWRlbnRpZmllciBuYW1lIHRvIHRoZSBjdXJyZW50IHNjb3BlIGlmIGl0IGRvZXNudCBhbHJlYWR5IGV4aXN0LlxuICBmdW5jdGlvbiBzY29wZUlkZW50aWZpZXJOYW1lKG5hbWUpIHtcbiAgICBpZiAob3B0aW9ucy5vbkxvY2FsRGVjbGFyYXRpb24pIG9wdGlvbnMub25Mb2NhbERlY2xhcmF0aW9uKG5hbWUpO1xuICAgIGlmICgtMSAhPT0gaW5kZXhPZihzY29wZXNbc2NvcGVEZXB0aF0sIG5hbWUpKSByZXR1cm47XG4gICAgc2NvcGVzW3Njb3BlRGVwdGhdLnB1c2gobmFtZSk7XG4gIH1cblxuICAvLyBBZGQgaWRlbnRpZmllciB0byB0aGUgY3VycmVudCBzY29wZVxuICBmdW5jdGlvbiBzY29wZUlkZW50aWZpZXIobm9kZSkge1xuICAgIHNjb3BlSWRlbnRpZmllck5hbWUobm9kZS5uYW1lKTtcbiAgICBhdHRhY2hTY29wZShub2RlLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBzY29wZSBpbmZvcm1hdGlvbiB0byBub2RlLiBJZiB0aGUgbm9kZSBpcyBnbG9iYWwsIHN0b3JlIGl0IGluIHRoZVxuICAvLyBnbG9iYWxzIGFycmF5IHNvIHdlIGNhbiByZXR1cm4gdGhlIGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyLlxuICBmdW5jdGlvbiBhdHRhY2hTY29wZShub2RlLCBpc0xvY2FsKSB7XG4gICAgaWYgKCFpc0xvY2FsICYmIC0xID09PSBpbmRleE9mT2JqZWN0KGdsb2JhbHMsICduYW1lJywgbm9kZS5uYW1lKSlcbiAgICAgIGdsb2JhbHMucHVzaChub2RlKTtcblxuICAgIG5vZGUuaXNMb2NhbCA9IGlzTG9jYWw7XG4gIH1cblxuICAvLyBJcyB0aGUgaWRlbnRpZmllciBuYW1lIGF2YWlsYWJsZSBpbiB0aGlzIHNjb3BlLlxuICBmdW5jdGlvbiBzY29wZUhhc05hbWUobmFtZSkge1xuICAgIHJldHVybiAoLTEgIT09IGluZGV4T2Yoc2NvcGVzW3Njb3BlRGVwdGhdLCBuYW1lKSk7XG4gIH1cblxuICAvLyBMb2NhdGlvbiB0cmFja2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBMb2NhdGlvbnMgYXJlIHN0b3JlZCBpbiBGSUxPLWFycmF5IGFzIGEgYE1hcmtlcmAgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgYm90aFxuICAvLyBgbG9jYCBhbmQgYHJhbmdlYCBkYXRhLiBPbmNlIGEgYE1hcmtlcmAgaXMgcG9wcGVkIG9mZiB0aGUgbGlzdCBhbiBlbmRcbiAgLy8gbG9jYXRpb24gaXMgYWRkZWQgYW5kIHRoZSBkYXRhIGlzIGF0dGFjaGVkIHRvIGEgc3ludGF4IG5vZGUuXG5cbiAgdmFyIGxvY2F0aW9ucyA9IFtdXG4gICAgLCB0cmFja0xvY2F0aW9ucztcblxuICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbk1hcmtlcigpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtlcih0b2tlbik7XG4gIH1cblxuICBmdW5jdGlvbiBNYXJrZXIodG9rZW4pIHtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHRoaXMubG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBsaW5lOiB0b2tlbi5saW5lXG4gICAgICAgICAgLCBjb2x1bW46IHRva2VuLnJhbmdlWzBdIC0gdG9rZW4ubGluZVN0YXJ0XG4gICAgICAgIH1cbiAgICAgICAgLCBlbmQ6IHtcbiAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAsIGNvbHVtbjogMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpIHRoaXMucmFuZ2UgPSBbdG9rZW4ucmFuZ2VbMF0sIDBdO1xuICB9XG5cbiAgLy8gQ29tcGxldGUgdGhlIGxvY2F0aW9uIGRhdGEgc3RvcmVkIGluIHRoZSBgTWFya2VyYCBieSBhZGRpbmcgdGhlIGxvY2F0aW9uXG4gIC8vIG9mIHRoZSAqcHJldmlvdXMgdG9rZW4qIGFzIGFuIGVuZCBsb2NhdGlvbi5cbiAgTWFya2VyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgdGhpcy5sb2MuZW5kLmxpbmUgPSBwcmV2aW91c1Rva2VuLmxhc3RMaW5lIHx8IHByZXZpb3VzVG9rZW4ubGluZTtcbiAgICAgIHRoaXMubG9jLmVuZC5jb2x1bW4gPSBwcmV2aW91c1Rva2VuLnJhbmdlWzFdIC0gKHByZXZpb3VzVG9rZW4ubGFzdExpbmVTdGFydCB8fCBwcmV2aW91c1Rva2VuLmxpbmVTdGFydCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcykge1xuICAgICAgdGhpcy5yYW5nZVsxXSA9IHByZXZpb3VzVG9rZW4ucmFuZ2VbMV07XG4gICAgfVxuICB9O1xuXG4gIE1hcmtlci5wcm90b3R5cGUuYmxlc3MgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0aGlzLmxvYykge1xuICAgICAgdmFyIGxvYyA9IHRoaXMubG9jO1xuICAgICAgbm9kZS5sb2MgPSB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgbGluZTogbG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBsb2Muc3RhcnQuY29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIGxpbmU6IGxvYy5lbmQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGxvYy5lbmQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLnJhbmdlKSB7XG4gICAgICBub2RlLnJhbmdlID0gW1xuICAgICAgICB0aGlzLnJhbmdlWzBdLFxuICAgICAgICB0aGlzLnJhbmdlWzFdXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgYE1hcmtlcmAgYW5kIGFkZCBpdCB0byB0aGUgRklMTy1hcnJheS5cbiAgZnVuY3Rpb24gbWFya0xvY2F0aW9uKCkge1xuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnB1c2goY3JlYXRlTG9jYXRpb25NYXJrZXIoKSk7XG4gIH1cblxuICAvLyBQdXNoIGFuIGFyYml0cmFyeSBgTWFya2VyYCBvYmplY3Qgb250byB0aGUgRklMTy1hcnJheS5cbiAgZnVuY3Rpb24gcHVzaExvY2F0aW9uKG1hcmtlcikge1xuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnB1c2gobWFya2VyKTtcbiAgfVxuXG4gIC8vIENvbnRyb2wgZmxvdyB0cmFja2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQSBjb250ZXh0IG9iamVjdCB0aGF0IHZhbGlkYXRlcyBsb29wIGJyZWFrcyBhbmQgYGdvdG9gLWJhc2VkIGNvbnRyb2wgZmxvdy5cblxuICBmdW5jdGlvbiBGdWxsRmxvd0NvbnRleHQoKSB7XG4gICAgdGhpcy5zY29wZXMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdHb3RvcyA9IFtdO1xuICB9XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5pc0luTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuc2NvcGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSAtLT4gMCkge1xuICAgICAgaWYgKHRoaXMuc2NvcGVzW2ldLmlzTG9vcClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLnB1c2hTY29wZSA9IGZ1bmN0aW9uIChpc0xvb3ApIHtcbiAgICB2YXIgc2NvcGUgPSB7XG4gICAgICBsYWJlbHM6IHt9LFxuICAgICAgbG9jYWxzOiBbXSxcbiAgICAgIGRlZmVycmVkR290b3M6IFtdLFxuICAgICAgaXNMb29wOiAhIWlzTG9vcFxuICAgIH07XG4gICAgdGhpcy5zY29wZXMucHVzaChzY29wZSk7XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5wb3BTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0dvdG9zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdGhlR290byA9IHRoaXMucGVuZGluZ0dvdG9zW2ldO1xuICAgICAgaWYgKHRoZUdvdG8ubWF4RGVwdGggPj0gdGhpcy5zY29wZXMubGVuZ3RoKVxuICAgICAgICBpZiAoLS10aGVHb3RvLm1heERlcHRoIDw9IDApXG4gICAgICAgICAgcmFpc2UodGhlR290by50b2tlbiwgZXJyb3JzLmxhYmVsTm90VmlzaWJsZSwgdGhlR290by50YXJnZXQpO1xuICAgIH1cblxuICAgIHRoaXMuc2NvcGVzLnBvcCgpO1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkR290byA9IGZ1bmN0aW9uICh0YXJnZXQsIHRva2VuKSB7XG4gICAgdmFyIGxvY2FsQ291bnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2NvcGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3Blc1tpXTtcbiAgICAgIGxvY2FsQ291bnRzLnB1c2goc2NvcGUubG9jYWxzLmxlbmd0aCk7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjb3BlLmxhYmVscywgdGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0dvdG9zLnB1c2goe1xuICAgICAgbWF4RGVwdGg6IHRoaXMuc2NvcGVzLmxlbmd0aCxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgbG9jYWxDb3VudHM6IGxvY2FsQ291bnRzXG4gICAgfSk7XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRMYWJlbCA9IGZ1bmN0aW9uIChuYW1lLCB0b2tlbikge1xuICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjb3BlLmxhYmVscywgbmFtZSkpIHtcbiAgICAgIHJhaXNlKHRva2VuLCBlcnJvcnMubGFiZWxBbHJlYWR5RGVmaW5lZCwgbmFtZSwgc2NvcGUubGFiZWxzW25hbWVdLmxpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV3R290b3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdHb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdGhlR290byA9IHRoaXMucGVuZGluZ0dvdG9zW2ldO1xuXG4gICAgICAgIGlmICh0aGVHb3RvLm1heERlcHRoID49IHRoaXMuc2NvcGVzLmxlbmd0aCAmJiB0aGVHb3RvLnRhcmdldCA9PT0gbmFtZSkge1xuICAgICAgICAgIGlmICh0aGVHb3RvLmxvY2FsQ291bnRzW3RoaXMuc2NvcGVzLmxlbmd0aCAtIDFdIDwgc2NvcGUubG9jYWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2NvcGUuZGVmZXJyZWRHb3Rvcy5wdXNoKHRoZUdvdG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0dvdG9zLnB1c2godGhlR290byk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGVuZGluZ0dvdG9zID0gbmV3R290b3M7XG4gICAgfVxuXG4gICAgc2NvcGUubGFiZWxzW25hbWVdID0ge1xuICAgICAgbG9jYWxDb3VudDogc2NvcGUubG9jYWxzLmxlbmd0aCxcbiAgICAgIGxpbmU6IHRva2VuLmxpbmVcbiAgICB9O1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkTG9jYWwgPSBmdW5jdGlvbiAobmFtZSwgdG9rZW4pIHtcbiAgICB0aGlzLmN1cnJlbnRTY29wZSgpLmxvY2Fscy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0b2tlbjogdG9rZW5cbiAgICB9KTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZXNbdGhpcy5zY29wZXMubGVuZ3RoIC0gMV07XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5yYWlzZURlZmVycmVkRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgdmFyIGJhZHMgPSBzY29wZS5kZWZlcnJlZEdvdG9zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFkcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHRoZUdvdG8gPSBiYWRzW2ldO1xuICAgICAgcmFpc2UodGhlR290by50b2tlbiwgZXJyb3JzLmdvdG9KdW1wSW5Mb2NhbFNjb3BlLCB0aGVHb3RvLnRhcmdldCwgc2NvcGUubG9jYWxzW3RoZUdvdG8ubG9jYWxDb3VudHNbdGhpcy5zY29wZXMubGVuZ3RoIC0gMV1dLm5hbWUpO1xuICAgIH1cbiAgICAvLyBXb3VsZCBiZSBkZWFkIGNvZGUgY3VycmVudGx5LCBidXQgbWF5IGJlIHVzZWZ1bCBsYXRlclxuICAgIC8vIGlmIChiYWRzLmxlbmd0aClcbiAgICAvLyAgIHNjb3BlLmRlZmVycmVkR290b3MgPSBbXTtcbiAgfTtcblxuICAvLyBTaW1wbGlmaWVkIGNvbnRleHQgdGhhdCBvbmx5IGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgbG9vcCBicmVha3MuXG5cbiAgZnVuY3Rpb24gTG9vcEZsb3dDb250ZXh0KCkge1xuICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgIHRoaXMubG9vcExldmVscyA9IFtdO1xuICB9XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5pc0luTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLmxvb3BMZXZlbHMubGVuZ3RoO1xuICB9O1xuXG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUucHVzaFNjb3BlID0gZnVuY3Rpb24gKGlzTG9vcCkge1xuICAgICsrdGhpcy5sZXZlbDtcbiAgICBpZiAoaXNMb29wKVxuICAgICAgdGhpcy5sb29wTGV2ZWxzLnB1c2godGhpcy5sZXZlbCk7XG4gIH07XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5wb3BTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sb29wTGV2ZWxzO1xuICAgIHZhciBsZXZsZW4gPSBsZXZlbHMubGVuZ3RoO1xuICAgIGlmIChsZXZsZW4pIHtcbiAgICAgIGlmIChsZXZlbHNbbGV2bGVuIC0gMV0gPT09IHRoaXMubGV2ZWwpXG4gICAgICAgIGxldmVscy5wb3AoKTtcbiAgICB9XG4gICAgLS10aGlzLmxldmVsO1xuICB9O1xuXG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkR290byA9XG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkTGFiZWwgPVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuJyk7IH07XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRMb2NhbCA9XG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUucmFpc2VEZWZlcnJlZEVycm9ycyA9XG4gIGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIG1ha2VGbG93Q29udGV4dCgpIHtcbiAgICByZXR1cm4gZmVhdHVyZXMubGFiZWxzID8gbmV3IEZ1bGxGbG93Q29udGV4dCgpIDogbmV3IExvb3BGbG93Q29udGV4dCgpO1xuICB9XG5cbiAgLy8gUGFyc2UgZnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIENodW5rIGlzIHRoZSBtYWluIHByb2dyYW0gb2JqZWN0LiBTeW50YWN0aWNhbGx5IGl0J3MgdGhlIHNhbWUgYXMgYSBibG9jay5cbiAgLy9cbiAgLy8gICAgIGNodW5rIDo6PSBibG9ja1xuXG4gIGZ1bmN0aW9uIHBhcnNlQ2h1bmsoKSB7XG4gICAgbmV4dCgpO1xuICAgIG1hcmtMb2NhdGlvbigpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIHZhciBmbG93Q29udGV4dCA9IG1ha2VGbG93Q29udGV4dCgpO1xuICAgIGZsb3dDb250ZXh0LmFsbG93VmFyYXJnID0gdHJ1ZTtcbiAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUoKTtcbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgIGlmIChFT0YgIT09IHRva2VuLnR5cGUpIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAgIC8vIElmIHRoZSBib2R5IGlzIGVtcHR5IG5vIHByZXZpb3VzVG9rZW4gZXhpc3RzIHdoZW4gZmluaXNoTm9kZSBydW5zLlxuICAgIGlmICh0cmFja0xvY2F0aW9ucyAmJiAhYm9keS5sZW5ndGgpIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuY2h1bmsoYm9keSkpO1xuICB9XG5cbiAgLy8gQSBibG9jayBjb250YWlucyBhIGxpc3Qgb2Ygc3RhdGVtZW50cyB3aXRoIGFuIG9wdGlvbmFsIHJldHVybiBzdGF0ZW1lbnRcbiAgLy8gYXMgaXRzIGxhc3Qgc3RhdGVtZW50LlxuICAvL1xuICAvLyAgICAgYmxvY2sgOjo9IHtzdGF0fSBbcmV0c3RhdF1cblxuICBmdW5jdGlvbiBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGJsb2NrID0gW11cbiAgICAgICwgc3RhdGVtZW50O1xuXG4gICAgd2hpbGUgKCFpc0Jsb2NrRm9sbG93KHRva2VuKSkge1xuICAgICAgLy8gUmV0dXJuIGhhcyB0byBiZSB0aGUgbGFzdCBzdGF0ZW1lbnQgaW4gYSBibG9jay5cbiAgICAgIC8vIExpa2V3aXNlICdicmVhaycgaW4gTHVhIG9sZGVyIHRoYW4gNS4yXG4gICAgICBpZiAoJ3JldHVybicgPT09IHRva2VuLnZhbHVlIHx8ICghZmVhdHVyZXMucmVsYXhlZEJyZWFrICYmICdicmVhaycgPT09IHRva2VuLnZhbHVlKSkge1xuICAgICAgICBibG9jay5wdXNoKHBhcnNlU3RhdGVtZW50KGZsb3dDb250ZXh0KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgY29uc3VtZSgnOycpO1xuICAgICAgLy8gU3RhdGVtZW50cyBhcmUgb25seSBhZGRlZCBpZiB0aGV5IGFyZSByZXR1cm5lZCwgdGhpcyBhbGxvd3MgdXMgdG9cbiAgICAgIC8vIGlnbm9yZSBzb21lIHN0YXRlbWVudHMsIHN1Y2ggYXMgRW1wdHlTdGF0ZW1lbnQuXG4gICAgICBpZiAoc3RhdGVtZW50KSBibG9jay5wdXNoKHN0YXRlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gRG9lc24ndCByZWFsbHkgbmVlZCBhbiBhc3Qgbm9kZVxuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSB0d28gdHlwZXMgb2Ygc3RhdGVtZW50cywgc2ltcGxlIGFuZCBjb21wb3VuZC5cbiAgLy9cbiAgLy8gICAgIHN0YXRlbWVudCA6Oj0gYnJlYWsgfCBnb3RvIHwgZG8gfCB3aGlsZSB8IHJlcGVhdCB8IHJldHVyblxuICAvLyAgICAgICAgICB8IGlmIHwgZm9yIHwgZnVuY3Rpb24gfCBsb2NhbCB8IGxhYmVsIHwgYXNzaWdubWVudFxuICAvLyAgICAgICAgICB8IGZ1bmN0aW9uY2FsbCB8ICc7J1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgbWFya0xvY2F0aW9uKCk7XG5cbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgaWYgKGNvbnN1bWUoJzo6JykpIHJldHVybiBwYXJzZUxhYmVsU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGEgYDtgIGlzIGVuY291bnRlZCwgc2ltcGx5IGVhdCBpdCB3aXRob3V0IHN0b3JpbmcgaXQuXG4gICAgaWYgKGZlYXR1cmVzLmVtcHR5U3RhdGVtZW50KSB7XG4gICAgICBpZiAoY29uc3VtZSgnOycpKSB7XG4gICAgICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmxvd0NvbnRleHQucmFpc2VEZWZlcnJlZEVycm9ycygpO1xuXG4gICAgaWYgKEtleXdvcmQgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbG9jYWwnOiAgICBuZXh0KCk7IHJldHVybiBwYXJzZUxvY2FsU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAnaWYnOiAgICAgICBuZXh0KCk7IHJldHVybiBwYXJzZUlmU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAncmV0dXJuJzogICBuZXh0KCk7IHJldHVybiBwYXJzZVJldHVyblN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzogbmV4dCgpO1xuICAgICAgICAgIHZhciBuYW1lID0gcGFyc2VGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5hbWUpO1xuICAgICAgICBjYXNlICd3aGlsZSc6ICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlV2hpbGVTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdmb3InOiAgICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlRm9yU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAncmVwZWF0JzogICBuZXh0KCk7IHJldHVybiBwYXJzZVJlcGVhdFN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2JyZWFrJzogICAgbmV4dCgpO1xuICAgICAgICAgIGlmICghZmxvd0NvbnRleHQuaXNJbkxvb3AoKSlcbiAgICAgICAgICAgIHJhaXNlKHRva2VuLCBlcnJvcnMubm9Mb29wVG9CcmVhaywgdG9rZW4udmFsdWUpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUJyZWFrU3RhdGVtZW50KCk7XG4gICAgICAgIGNhc2UgJ2RvJzogICAgICAgbmV4dCgpOyByZXR1cm4gcGFyc2VEb1N0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2dvdG8nOiAgICAgbmV4dCgpOyByZXR1cm4gcGFyc2VHb3RvU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmVhdHVyZXMuY29udGV4dHVhbEdvdG8gJiZcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gSWRlbnRpZmllciAmJiB0b2tlbi52YWx1ZSA9PT0gJ2dvdG8nICYmXG4gICAgICAgIGxvb2thaGVhZC50eXBlID09PSBJZGVudGlmaWVyICYmIGxvb2thaGVhZC52YWx1ZSAhPT0gJ2dvdG8nKSB7XG4gICAgICBuZXh0KCk7IHJldHVybiBwYXJzZUdvdG9TdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIEFzc2lnbm1lbnRzIG1lbW9yaXplcyB0aGUgbG9jYXRpb24gYW5kIHB1c2hlcyBpdCBtYW51YWxseSBmb3Igd3JhcHBlciBub2Rlcy5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIGxvY2F0aW9ucy5wb3AoKTtcblxuICAgIHJldHVybiBwYXJzZUFzc2lnbm1lbnRPckNhbGxTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICB9XG5cbiAgLy8gIyMgU3RhdGVtZW50c1xuXG4gIC8vICAgICBsYWJlbCA6Oj0gJzo6JyBOYW1lICc6OidcblxuICBmdW5jdGlvbiBwYXJzZUxhYmVsU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIG5hbWVUb2tlbiA9IHRva2VuXG4gICAgICAsIGxhYmVsID0gcGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgc2NvcGVJZGVudGlmaWVyTmFtZSgnOjonICsgbmFtZVRva2VuLnZhbHVlICsgJzo6Jyk7XG4gICAgICBhdHRhY2hTY29wZShsYWJlbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZXhwZWN0KCc6OicpO1xuXG4gICAgZmxvd0NvbnRleHQuYWRkTGFiZWwobmFtZVRva2VuLnZhbHVlLCBuYW1lVG9rZW4pO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5sYWJlbFN0YXRlbWVudChsYWJlbCkpO1xuICB9XG5cbiAgLy8gICAgIGJyZWFrIDo6PSAnYnJlYWsnXG5cbiAgZnVuY3Rpb24gcGFyc2VCcmVha1N0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuYnJlYWtTdGF0ZW1lbnQoKSk7XG4gIH1cblxuICAvLyAgICAgZ290byA6Oj0gJ2dvdG8nIE5hbWVcblxuICBmdW5jdGlvbiBwYXJzZUdvdG9TdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgbmFtZSA9IHRva2VuLnZhbHVlXG4gICAgICAsIGdvdG9Ub2tlbiA9IHByZXZpb3VzVG9rZW5cbiAgICAgICwgbGFiZWwgPSBwYXJzZUlkZW50aWZpZXIoKTtcblxuICAgIGZsb3dDb250ZXh0LmFkZEdvdG8obmFtZSwgZ290b1Rva2VuKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZ290b1N0YXRlbWVudChsYWJlbCkpO1xuICB9XG5cbiAgLy8gICAgIGRvIDo6PSAnZG8nIGJsb2NrICdlbmQnXG5cbiAgZnVuY3Rpb24gcGFyc2VEb1N0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgIHZhciBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgZXhwZWN0KCdlbmQnKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZG9TdGF0ZW1lbnQoYm9keSkpO1xuICB9XG5cbiAgLy8gICAgIHdoaWxlIDo6PSAnd2hpbGUnIGV4cCAnZG8nIGJsb2NrICdlbmQnXG5cbiAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBjb25kaXRpb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgZXhwZWN0KCdkbycpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSh0cnVlKTtcbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgIGV4cGVjdCgnZW5kJyk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LndoaWxlU3RhdGVtZW50KGNvbmRpdGlvbiwgYm9keSkpO1xuICB9XG5cbiAgLy8gICAgIHJlcGVhdCA6Oj0gJ3JlcGVhdCcgYmxvY2sgJ3VudGlsJyBleHBcblxuICBmdW5jdGlvbiBwYXJzZVJlcGVhdFN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSh0cnVlKTtcbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGV4cGVjdCgndW50aWwnKTtcbiAgICBmbG93Q29udGV4dC5yYWlzZURlZmVycmVkRXJyb3JzKCk7XG4gICAgdmFyIGNvbmRpdGlvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QucmVwZWF0U3RhdGVtZW50KGNvbmRpdGlvbiwgYm9keSkpO1xuICB9XG5cbiAgLy8gICAgIHJldHN0YXQgOjo9ICdyZXR1cm4nIFtleHAgeycsJyBleHB9XSBbJzsnXVxuXG4gIGZ1bmN0aW9uIHBhcnNlUmV0dXJuU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGV4cHJlc3Npb25zID0gW107XG5cbiAgICBpZiAoJ2VuZCcgIT09IHRva2VuLnZhbHVlKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICBpZiAobnVsbCAhPSBleHByZXNzaW9uKSBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgd2hpbGUgKGNvbnN1bWUoJywnKSkge1xuICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3VtZSgnOycpOyAvLyBncmFtbWFyIHRlbGxzIHVzIDsgaXMgb3B0aW9uYWwgaGVyZS5cbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LnJldHVyblN0YXRlbWVudChleHByZXNzaW9ucykpO1xuICB9XG5cbiAgLy8gICAgIGlmIDo6PSAnaWYnIGV4cCAndGhlbicgYmxvY2sge2VsaWZ9IFsnZWxzZScgYmxvY2tdICdlbmQnXG4gIC8vICAgICBlbGlmIDo6PSAnZWxzZWlmJyBleHAgJ3RoZW4nIGJsb2NrXG5cbiAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBjbGF1c2VzID0gW11cbiAgICAgICwgY29uZGl0aW9uXG4gICAgICAsIGJvZHlcbiAgICAgICwgbWFya2VyO1xuXG4gICAgLy8gSWZDbGF1c2VzIGJlZ2luIGF0IHRoZSBzYW1lIGxvY2F0aW9uIGFzIHRoZSBwYXJlbnQgSWZTdGF0ZW1lbnQuXG4gICAgLy8gSXQgZW5kcyBhdCB0aGUgc3RhcnQgb2YgYGVuZGAsIGBlbHNlYCwgb3IgYGVsc2VpZmAuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSB7XG4gICAgICBtYXJrZXIgPSBsb2NhdGlvbnNbbG9jYXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb25zLnB1c2gobWFya2VyKTtcbiAgICB9XG4gICAgY29uZGl0aW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgIGV4cGVjdCgndGhlbicpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICBjbGF1c2VzLnB1c2goZmluaXNoTm9kZShhc3QuaWZDbGF1c2UoY29uZGl0aW9uLCBib2R5KSkpO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuICAgIHdoaWxlIChjb25zdW1lKCdlbHNlaWYnKSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICBjb25kaXRpb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICBleHBlY3QoJ3RoZW4nKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKCk7XG4gICAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgICAgY2xhdXNlcy5wdXNoKGZpbmlzaE5vZGUoYXN0LmVsc2VpZkNsYXVzZShjb25kaXRpb24sIGJvZHkpKSk7XG4gICAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnN1bWUoJ2Vsc2UnKSkge1xuICAgICAgLy8gSW5jbHVkZSB0aGUgYGVsc2VgIGluIHRoZSBsb2NhdGlvbiBvZiBFbHNlQ2xhdXNlLlxuICAgICAgaWYgKHRyYWNrTG9jYXRpb25zKSB7XG4gICAgICAgIG1hcmtlciA9IG5ldyBNYXJrZXIocHJldmlvdXNUb2tlbik7XG4gICAgICAgIGxvY2F0aW9ucy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgICAgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICAgIGNsYXVzZXMucHVzaChmaW5pc2hOb2RlKGFzdC5lbHNlQ2xhdXNlKGJvZHkpKSk7XG4gICAgfVxuXG4gICAgZXhwZWN0KCdlbmQnKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuaWZTdGF0ZW1lbnQoY2xhdXNlcykpO1xuICB9XG5cbiAgLy8gVGhlcmUgYXJlIHR3byB0eXBlcyBvZiBmb3Igc3RhdGVtZW50cywgZ2VuZXJpYyBhbmQgbnVtZXJpYy5cbiAgLy9cbiAgLy8gICAgIGZvciA6Oj0gTmFtZSAnPScgZXhwICcsJyBleHAgWycsJyBleHBdICdkbycgYmxvY2sgJ2VuZCdcbiAgLy8gICAgIGZvciA6Oj0gbmFtZWxpc3QgJ2luJyBleHBsaXN0ICdkbycgYmxvY2sgJ2VuZCdcbiAgLy8gICAgIG5hbWVsaXN0IDo6PSBOYW1lIHsnLCcgTmFtZX1cbiAgLy8gICAgIGV4cGxpc3QgOjo9IGV4cCB7JywnIGV4cH1cblxuICBmdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciB2YXJpYWJsZSA9IHBhcnNlSWRlbnRpZmllcigpXG4gICAgICAsIGJvZHk7XG5cbiAgICAvLyBUaGUgc3RhcnQtaWRlbnRpZmllciBpcyBsb2NhbC5cblxuICAgIGlmIChvcHRpb25zLnNjb3BlKSB7XG4gICAgICBjcmVhdGVTY29wZSgpO1xuICAgICAgc2NvcGVJZGVudGlmaWVyKHZhcmlhYmxlKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgZXhwcmVzc2lvbiBpcyBmb2xsb3dlZCBieSBhIGA9YCBwdW5jdHVhdG9yLCB0aGlzIGlzIGFcbiAgICAvLyBOdW1lcmljIEZvciBTdGF0ZW1lbnQuXG4gICAgaWYgKGNvbnN1bWUoJz0nKSkge1xuICAgICAgLy8gU3RhcnQgZXhwcmVzc2lvblxuICAgICAgdmFyIHN0YXJ0ID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAvLyBFbmQgZXhwcmVzc2lvblxuICAgICAgdmFyIGVuZCA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIC8vIE9wdGlvbmFsIHN0ZXAgZXhwcmVzc2lvblxuICAgICAgdmFyIHN0ZXAgPSBjb25zdW1lKCcsJykgPyBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCkgOiBudWxsO1xuXG4gICAgICBleHBlY3QoJ2RvJyk7XG4gICAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUodHJ1ZSk7XG4gICAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgICAgZXhwZWN0KCdlbmQnKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcblxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmZvck51bWVyaWNTdGF0ZW1lbnQodmFyaWFibGUsIHN0YXJ0LCBlbmQsIHN0ZXAsIGJvZHkpKTtcbiAgICB9XG4gICAgLy8gSWYgbm90LCBpdCdzIGEgR2VuZXJpYyBGb3IgU3RhdGVtZW50XG4gICAgZWxzZSB7XG4gICAgICAvLyBUaGUgbmFtZWxpc3QgY2FuIGNvbnRhaW4gb25lIG9yIG1vcmUgaWRlbnRpZmllcnMuXG4gICAgICB2YXIgdmFyaWFibGVzID0gW3ZhcmlhYmxlXTtcbiAgICAgIHdoaWxlIChjb25zdW1lKCcsJykpIHtcbiAgICAgICAgdmFyaWFibGUgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgLy8gRWFjaCB2YXJpYWJsZSBpbiB0aGUgbmFtZWxpc3QgaXMgbG9jYWxseSBzY29wZWQuXG4gICAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBzY29wZUlkZW50aWZpZXIodmFyaWFibGUpO1xuICAgICAgICB2YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgICB9XG4gICAgICBleHBlY3QoJ2luJyk7XG4gICAgICB2YXIgaXRlcmF0b3JzID0gW107XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIGV4cHJlc3Npb25zIGluIHRoZSBleHBsaXN0LlxuICAgICAgZG8ge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgaXRlcmF0b3JzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICB9IHdoaWxlIChjb25zdW1lKCcsJykpO1xuXG4gICAgICBleHBlY3QoJ2RvJyk7XG4gICAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUodHJ1ZSk7XG4gICAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgICAgZXhwZWN0KCdlbmQnKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcblxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmZvckdlbmVyaWNTdGF0ZW1lbnQodmFyaWFibGVzLCBpdGVyYXRvcnMsIGJvZHkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb2NhbCBzdGF0ZW1lbnRzIGNhbiBlaXRoZXIgYmUgdmFyaWFibGUgYXNzaWdubWVudHMgb3IgZnVuY3Rpb25cbiAgLy8gZGVmaW5pdGlvbnMuIElmIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBpcyBmb3VuZCwgaXQgd2lsbCBiZSBkZWxlZ2F0ZWQgdG9cbiAgLy8gYHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpYCB3aXRoIHRoZSBpc0xvY2FsIGZsYWcuXG4gIC8vXG4gIC8vIFRoaXMgQVNUIHN0cnVjdHVyZSBtaWdodCBjaGFuZ2UgaW50byBhIGxvY2FsIGFzc2lnbm1lbnQgd2l0aCBhIGZ1bmN0aW9uXG4gIC8vIGNoaWxkLlxuICAvL1xuICAvLyAgICAgbG9jYWwgOjo9ICdsb2NhbCcgJ2Z1bmN0aW9uJyBOYW1lIGZ1bmNkZWNsXG4gIC8vICAgICAgICB8ICdsb2NhbCcgTmFtZSB7JywnIE5hbWV9IFsnPScgZXhwIHsnLCcgZXhwfV1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIG5hbWVcbiAgICAgICwgZGVjbFRva2VuID0gcHJldmlvdXNUb2tlbjtcblxuICAgIGlmIChJZGVudGlmaWVyID09PSB0b2tlbi50eXBlKSB7XG4gICAgICB2YXIgdmFyaWFibGVzID0gW11cbiAgICAgICAgLCBpbml0ID0gW107XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmFtZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgICAgIHZhcmlhYmxlcy5wdXNoKG5hbWUpO1xuICAgICAgICBmbG93Q29udGV4dC5hZGRMb2NhbChuYW1lLm5hbWUsIGRlY2xUb2tlbik7XG4gICAgICB9IHdoaWxlIChjb25zdW1lKCcsJykpO1xuXG4gICAgICBpZiAoY29uc3VtZSgnPScpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICBpbml0LnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgIH0gd2hpbGUgKGNvbnN1bWUoJywnKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlY2xhcmF0aW9ucyBkb2Vzbid0IGV4aXN0IGJlZm9yZSB0aGUgc3RhdGVtZW50IGhhcyBiZWVuIGV2YWx1YXRlZC5cbiAgICAgIC8vIFRoZXJlZm9yZSBhc3NpZ25tZW50cyBjYW4ndCB1c2UgdGhlaXIgZGVjbGFyYXRvci4gQW5kIHRoZSBpZGVudGlmaWVyc1xuICAgICAgLy8gc2hvdWxkbid0IGJlIGFkZGVkIHRvIHRoZSBzY29wZSB1bnRpbCB0aGUgc3RhdGVtZW50IGlzIGNvbXBsZXRlLlxuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YXJpYWJsZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgc2NvcGVJZGVudGlmaWVyKHZhcmlhYmxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmxvY2FsU3RhdGVtZW50KHZhcmlhYmxlcywgaW5pdCkpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZSgnZnVuY3Rpb24nKSkge1xuICAgICAgbmFtZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgZmxvd0NvbnRleHQuYWRkTG9jYWwobmFtZS5uYW1lLCBkZWNsVG9rZW4pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgICBzY29wZUlkZW50aWZpZXIobmFtZSk7XG4gICAgICAgIGNyZWF0ZVNjb3BlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1lbWJlckV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBsb2NhbCBmdW5jdGlvbiBzdGF0ZW1lbnRzLlxuICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuYW1lLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxuYW1lPicsIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICAvLyAgICAgYXNzaWdubWVudCA6Oj0gdmFybGlzdCAnPScgZXhwbGlzdFxuICAvLyAgICAgdmFyIDo6PSBOYW1lIHwgcHJlZml4ZXhwICdbJyBleHAgJ10nIHwgcHJlZml4ZXhwICcuJyBOYW1lXG4gIC8vICAgICB2YXJsaXN0IDo6PSB2YXIgeycsJyB2YXJ9XG4gIC8vICAgICBleHBsaXN0IDo6PSBleHAgeycsJyBleHB9XG4gIC8vXG4gIC8vICAgICBjYWxsIDo6PSBjYWxsZXhwXG4gIC8vICAgICBjYWxsZXhwIDo6PSBwcmVmaXhleHAgYXJncyB8IHByZWZpeGV4cCAnOicgTmFtZSBhcmdzXG5cbiAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50T3JDYWxsU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdG9rZW4gZm9yIGJldHRlciBlcnJvciBtZXNzYWdlcyBpbiBjYXNlXG4gICAgLy8gb2YgaW52YWxpZCBzdGF0ZW1lbnRcbiAgICB2YXIgcHJldmlvdXMgPSB0b2tlblxuICAgICAgLCBtYXJrZXIsIHN0YXJ0TWFya2VyO1xuICAgIHZhciBsdmFsdWUsIGJhc2UsIG5hbWU7XG5cbiAgICB2YXIgdGFyZ2V0cyA9IFtdO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBzdGFydE1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAgIGlmIChJZGVudGlmaWVyID09PSB0b2tlbi50eXBlKSB7XG4gICAgICAgIG5hbWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgYmFzZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCBzY29wZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGF0dGFjaFNjb3BlKGJhc2UsIHNjb3BlSGFzTmFtZShuYW1lKSk7XG4gICAgICAgIGx2YWx1ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCcoJyA9PT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBiYXNlID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgbHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGJvdGg6IGZvciAoOzspIHtcbiAgICAgICAgdmFyIG5ld0Jhc2U7XG5cbiAgICAgICAgc3dpdGNoIChTdHJpbmdMaXRlcmFsID09PSB0b2tlbi50eXBlID8gJ1wiJyA6IHRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICBsdmFsdWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgbHZhbHVlID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayBib3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZSA9IHBhcnNlUHJlZml4RXhwcmVzc2lvblBhcnQoYmFzZSwgbWFya2VyLCBmbG93Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldHMucHVzaChiYXNlKTtcblxuICAgICAgaWYgKCcsJyAhPT0gdG9rZW4udmFsdWUpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBpZiAoIWx2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIG5leHQoKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMSAmJiBsdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmNhbGxTdGF0ZW1lbnQodGFyZ2V0c1swXSkpO1xuICAgIH0gZWxzZSBpZiAoIWx2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAgIH1cblxuICAgIGV4cGVjdCgnPScpO1xuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgdmFsdWVzLnB1c2gocGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpKTtcbiAgICB9IHdoaWxlIChjb25zdW1lKCcsJykpO1xuXG4gICAgcHVzaExvY2F0aW9uKHN0YXJ0TWFya2VyKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuYXNzaWdubWVudFN0YXRlbWVudCh0YXJnZXRzLCB2YWx1ZXMpKTtcbiAgfVxuXG4gIC8vICMjIyBOb24tc3RhdGVtZW50c1xuXG4gIC8vICAgICBJZGVudGlmaWVyIDo6PSBOYW1lXG5cbiAgZnVuY3Rpb24gcGFyc2VJZGVudGlmaWVyKCkge1xuICAgIG1hcmtMb2NhdGlvbigpO1xuICAgIHZhciBpZGVudGlmaWVyID0gdG9rZW4udmFsdWU7XG4gICAgaWYgKElkZW50aWZpZXIgIT09IHRva2VuLnR5cGUpIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8bmFtZT4nLCB0b2tlbik7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5pZGVudGlmaWVyKGlkZW50aWZpZXIpKTtcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBmdW5jdGlvbnMgcGFyYW1ldGVycyBhbmQgYm9keSBibG9jay4gVGhlIG5hbWUgc2hvdWxkIGFscmVhZHlcbiAgLy8gaGF2ZSBiZWVuIHBhcnNlZCBhbmQgcGFzc2VkIHRvIHRoaXMgZGVjbGFyYXRpb24gZnVuY3Rpb24uIEJ5IHNlcGFyYXRpbmdcbiAgLy8gdGhpcyB3ZSBhbGxvdyBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyBpbiBleHByZXNzaW9ucy5cbiAgLy9cbiAgLy8gRm9yIGxvY2FsIGZ1bmN0aW9ucyB0aGVyZSdzIGEgYm9vbGVhbiBwYXJhbWV0ZXIgd2hpY2ggbmVlZHMgdG8gYmUgc2V0XG4gIC8vIHdoZW4gcGFyc2luZyB0aGUgZGVjbGFyYXRpb24uXG4gIC8vXG4gIC8vICAgICBmdW5jZGVjbCA6Oj0gJygnIFtwYXJsaXN0XSAnKScgYmxvY2sgJ2VuZCdcbiAgLy8gICAgIHBhcmxpc3QgOjo9IE5hbWUgeycsJyBOYW1lfSB8IFsnLCcgJy4uLiddIHwgJy4uLidcblxuICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obmFtZSwgaXNMb2NhbCkge1xuICAgIHZhciBmbG93Q29udGV4dCA9IG1ha2VGbG93Q29udGV4dCgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuXG4gICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICBleHBlY3QoJygnKTtcblxuICAgIC8vIFRoZSBkZWNsYXJhdGlvbiBoYXMgYXJndW1lbnRzXG4gICAgaWYgKCFjb25zdW1lKCcpJykpIHtcbiAgICAgIC8vIEFyZ3VtZW50cyBhcmUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBpZGVudGlmaWVycywgb3B0aW9uYWxseSBlbmRpbmdcbiAgICAgIC8vIHdpdGggYSB2YXJhcmcuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoSWRlbnRpZmllciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAvLyBGdW5jdGlvbiBwYXJhbWV0ZXJzIGFyZSBsb2NhbC5cbiAgICAgICAgICBpZiAob3B0aW9ucy5zY29wZSkgc2NvcGVJZGVudGlmaWVyKHBhcmFtZXRlcik7XG5cbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gocGFyYW1ldGVyKTtcblxuICAgICAgICAgIGlmIChjb25zdW1lKCcsJykpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGFyZ3VtZW50cyBhcmUgYWxsb3dlZCBhZnRlciBhIHZhcmFyZy5cbiAgICAgICAgZWxzZSBpZiAoVmFyYXJnTGl0ZXJhbCA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgICAgIGZsb3dDb250ZXh0LmFsbG93VmFyYXJnID0gdHJ1ZTtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gocGFyc2VQcmltYXJ5RXhwcmVzc2lvbihmbG93Q29udGV4dCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8bmFtZT4gb3IgXFwnLi4uXFwnJywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgZXhwZWN0KCdlbmQnKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG5cbiAgICBpc0xvY2FsID0gaXNMb2NhbCB8fCBmYWxzZTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZnVuY3Rpb25TdGF0ZW1lbnQobmFtZSwgcGFyYW1ldGVycywgaXNMb2NhbCwgYm9keSkpO1xuICB9XG5cbiAgLy8gUGFyc2UgdGhlIGZ1bmN0aW9uIG5hbWUgYXMgaWRlbnRpZmllcnMgYW5kIG1lbWJlciBleHByZXNzaW9ucy5cbiAgLy9cbiAgLy8gICAgIE5hbWUgeycuJyBOYW1lfSBbJzonIE5hbWVdXG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbk5hbWUoKSB7XG4gICAgdmFyIGJhc2UsIG5hbWUsIG1hcmtlcjtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcbiAgICBiYXNlID0gcGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgYXR0YWNoU2NvcGUoYmFzZSwgc2NvcGVIYXNOYW1lKGJhc2UubmFtZSkpO1xuICAgICAgY3JlYXRlU2NvcGUoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY29uc3VtZSgnLicpKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIG5hbWUgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGJhc2UgPSBmaW5pc2hOb2RlKGFzdC5tZW1iZXJFeHByZXNzaW9uKGJhc2UsICcuJywgbmFtZSkpO1xuICAgIH1cblxuICAgIGlmIChjb25zdW1lKCc6JykpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgbmFtZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgYmFzZSA9IGZpbmlzaE5vZGUoYXN0Lm1lbWJlckV4cHJlc3Npb24oYmFzZSwgJzonLCBuYW1lKSk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgc2NvcGVJZGVudGlmaWVyTmFtZSgnc2VsZicpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLy8gICAgIHRhYmxlY29uc3RydWN0b3IgOjo9ICd7JyBbZmllbGRsaXN0XSAnfSdcbiAgLy8gICAgIGZpZWxkbGlzdCA6Oj0gZmllbGQge2ZpZWxkc2VwIGZpZWxkfSBmaWVsZHNlcFxuICAvLyAgICAgZmllbGQgOjo9ICdbJyBleHAgJ10nICc9JyBleHAgfCBOYW1lID0gJ2V4cCcgfCBleHBcbiAgLy9cbiAgLy8gICAgIGZpZWxkc2VwIDo6PSAnLCcgfCAnOydcblxuICBmdW5jdGlvbiBwYXJzZVRhYmxlQ29uc3RydWN0b3IoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgZmllbGRzID0gW11cbiAgICAgICwga2V5LCB2YWx1ZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBtYXJrTG9jYXRpb24oKTtcbiAgICAgIGlmIChQdW5jdHVhdG9yID09PSB0b2tlbi50eXBlICYmIGNvbnN1bWUoJ1snKSkge1xuICAgICAgICBrZXkgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgIGV4cGVjdCgnXScpO1xuICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZpbmlzaE5vZGUoYXN0LnRhYmxlS2V5KGtleSwgdmFsdWUpKSk7XG4gICAgICB9IGVsc2UgaWYgKElkZW50aWZpZXIgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgICAgaWYgKCc9JyA9PT0gbG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAga2V5ID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgIGZpZWxkcy5wdXNoKGZpbmlzaE5vZGUoYXN0LnRhYmxlS2V5U3RyaW5nKGtleSwgdmFsdWUpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgZmllbGRzLnB1c2goZmluaXNoTm9kZShhc3QudGFibGVWYWx1ZSh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgPT0gKHZhbHVlID0gcGFyc2VFeHByZXNzaW9uKGZsb3dDb250ZXh0KSkpIHtcbiAgICAgICAgICBsb2NhdGlvbnMucG9wKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzLnB1c2goZmluaXNoTm9kZShhc3QudGFibGVWYWx1ZSh2YWx1ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmICgnLDsnLmluZGV4T2YodG9rZW4udmFsdWUpID49IDApIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBleHBlY3QoJ30nKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QudGFibGVDb25zdHJ1Y3RvckV4cHJlc3Npb24oZmllbGRzKSk7XG4gIH1cblxuICAvLyBFeHByZXNzaW9uIHBhcnNlclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBFeHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkIGFuZCBhbHdheXMgcmV0dXJuIGEgdmFsdWUuIElmIG5vdGhpbmcgaXNcbiAgLy8gbWF0Y2hlZCBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gIC8vXG4gIC8vICAgICBleHAgOjo9ICh1bm9wIGV4cCB8IHByaW1hcnkgfCBwcmVmaXhleHAgKSB7IGJpbm9wIGV4cCB9XG4gIC8vXG4gIC8vICAgICBwcmltYXJ5IDo6PSBuaWwgfCBmYWxzZSB8IHRydWUgfCBOdW1iZXIgfCBTdHJpbmcgfCAnLi4uJ1xuICAvLyAgICAgICAgICB8IGZ1bmN0aW9uZGVmIHwgdGFibGVjb25zdHJ1Y3RvclxuICAvL1xuICAvLyAgICAgcHJlZml4ZXhwIDo6PSAoTmFtZSB8ICcoJyBleHAgJyknICkgeyAnWycgZXhwICddJ1xuICAvLyAgICAgICAgICB8ICcuJyBOYW1lIHwgJzonIE5hbWUgYXJncyB8IGFyZ3MgfVxuICAvL1xuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCkge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VTdWJFeHByZXNzaW9uKDAsIGZsb3dDb250ZXh0KTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIC8vIFBhcnNlIGFuIGV4cHJlc3Npb24gZXhwZWN0aW5nIGl0IHRvIGJlIHZhbGlkLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgIGlmIChudWxsID09IGV4cHJlc3Npb24pIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8ZXhwcmVzc2lvbj4nLCB0b2tlbik7XG4gICAgZWxzZSByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG5cbiAgLy8gUmV0dXJuIHRoZSBwcmVjZWRlbmNlIHByaW9yaXR5IG9mIHRoZSBvcGVyYXRvci5cbiAgLy9cbiAgLy8gQXMgdW5hcnkgYC1gIGNhbid0IGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBiaW5hcnkgYC1gLCB1bmFyeSBwcmVjZWRlbmNlXG4gIC8vIGlzbid0IGRlc2NyaWJlZCBpbiB0aGlzIHRhYmxlIGJ1dCBpbiBgcGFyc2VTdWJFeHByZXNzaW9uKClgIGl0c2VsZi5cbiAgLy9cbiAgLy8gQXMgdGhpcyBmdW5jdGlvbiBnZXRzIGhpdCBvbiBldmVyeSBleHByZXNzaW9uIGl0J3MgYmVlbiBvcHRpbWl6ZWQgZHVlIHRvXG4gIC8vIHRoZSBleHBlbnNpdmUgQ29tcGFyZUlDU3R1YiB3aGljaCB0b29rIH44JSBvZiB0aGUgcGFyc2UgdGltZS5cblxuICBmdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKG9wZXJhdG9yKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gb3BlcmF0b3IuY2hhckNvZGVBdCgwKVxuICAgICAgLCBsZW5ndGggPSBvcGVyYXRvci5sZW5ndGg7XG5cbiAgICBpZiAoMSA9PT0gbGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgIGNhc2UgOTQ6IHJldHVybiAxMjsgLy8gXlxuICAgICAgICBjYXNlIDQyOiBjYXNlIDQ3OiBjYXNlIDM3OiByZXR1cm4gMTA7IC8vICogLyAlXG4gICAgICAgIGNhc2UgNDM6IGNhc2UgNDU6IHJldHVybiA5OyAvLyArIC1cbiAgICAgICAgY2FzZSAzODogcmV0dXJuIDY7IC8vICZcbiAgICAgICAgY2FzZSAxMjY6IHJldHVybiA1OyAvLyB+XG4gICAgICAgIGNhc2UgMTI0OiByZXR1cm4gNDsgLy8gfFxuICAgICAgICBjYXNlIDYwOiBjYXNlIDYyOiByZXR1cm4gMzsgLy8gPCA+XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgyID09PSBsZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgY2FzZSA0NzogcmV0dXJuIDEwOyAvLyAvL1xuICAgICAgICBjYXNlIDQ2OiByZXR1cm4gODsgLy8gLi5cbiAgICAgICAgY2FzZSA2MDogY2FzZSA2MjpcbiAgICAgICAgICAgIGlmKCc8PCcgPT09IG9wZXJhdG9yIHx8ICc+PicgPT09IG9wZXJhdG9yKSByZXR1cm4gNzsgLy8gPDwgPj5cbiAgICAgICAgICAgIHJldHVybiAzOyAvLyA8PSA+PVxuICAgICAgICBjYXNlIDYxOiBjYXNlIDEyNjogcmV0dXJuIDM7IC8vID09IH49XG4gICAgICAgIGNhc2UgMTExOiByZXR1cm4gMTsgLy8gb3JcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKDk3ID09PSBjaGFyQ29kZSAmJiAnYW5kJyA9PT0gb3BlcmF0b3IpIHJldHVybiAyO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50IGFuIG9wZXJhdG9yLXByZWNlZGVuY2UgcGFyc2VyIHRvIGhhbmRsZSBiaW5hcnkgb3BlcmF0b3JcbiAgLy8gcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gV2UgdXNlIHRoaXMgYWxnb3JpdGhtIGJlY2F1c2UgaXQncyBjb21wYWN0LCBpdCdzIGZhc3QgYW5kIEx1YSBjb3JlIHVzZXNcbiAgLy8gdGhlIHNhbWUgc28gd2UgY2FuIGJlIHN1cmUgb3VyIGV4cHJlc3Npb25zIGFyZSBwYXJzZWQgaW4gdGhlIHNhbWUgbWFubmVyXG4gIC8vIHdpdGhvdXQgZXhjZXNzaXZlIGFtb3VudHMgb2YgdGVzdHMuXG4gIC8vXG4gIC8vICAgICBleHAgOjo9ICh1bm9wIGV4cCB8IHByaW1hcnkgfCBwcmVmaXhleHAgKSB7IGJpbm9wIGV4cCB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdWJFeHByZXNzaW9uKG1pblByZWNlZGVuY2UsIGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIG9wZXJhdG9yID0gdG9rZW4udmFsdWVcbiAgICAvLyBUaGUgbGVmdC1oYW5kIHNpZGUgaW4gYmluYXJ5IG9wZXJhdGlvbnMuXG4gICAgICAsIGV4cHJlc3Npb24sIG1hcmtlcjtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgIC8vIFVuYXJ5RXhwcmVzc2lvblxuICAgIGlmIChpc1VuYXJ5KHRva2VuKSkge1xuICAgICAgbWFya0xvY2F0aW9uKCk7XG4gICAgICBuZXh0KCk7XG4gICAgICB2YXIgYXJndW1lbnQgPSBwYXJzZVN1YkV4cHJlc3Npb24oMTAsIGZsb3dDb250ZXh0KTtcbiAgICAgIGlmIChhcmd1bWVudCA9PSBudWxsKSByYWlzZVVuZXhwZWN0ZWRUb2tlbignPGV4cHJlc3Npb24+JywgdG9rZW4pO1xuICAgICAgZXhwcmVzc2lvbiA9IGZpbmlzaE5vZGUoYXN0LnVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQpKTtcbiAgICB9XG4gICAgaWYgKG51bGwgPT0gZXhwcmVzc2lvbikge1xuICAgICAgLy8gUHJpbWFyeUV4cHJlc3Npb25cbiAgICAgIGV4cHJlc3Npb24gPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcblxuICAgICAgLy8gUHJlZml4RXhwcmVzc2lvblxuICAgICAgaWYgKG51bGwgPT0gZXhwcmVzc2lvbikge1xuICAgICAgICBleHByZXNzaW9uID0gcGFyc2VQcmVmaXhFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBpcyBub3QgYSB2YWxpZCBsZWZ0IGhhbmQgZXhwcmVzc2lvbi5cbiAgICBpZiAobnVsbCA9PSBleHByZXNzaW9uKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBwcmVjZWRlbmNlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBvcGVyYXRvciA9IHRva2VuLnZhbHVlO1xuXG4gICAgICBwcmVjZWRlbmNlID0gKFB1bmN0dWF0b3IgPT09IHRva2VuLnR5cGUgfHwgS2V5d29yZCA9PT0gdG9rZW4udHlwZSkgP1xuICAgICAgICBiaW5hcnlQcmVjZWRlbmNlKG9wZXJhdG9yKSA6IDA7XG5cbiAgICAgIGlmIChwcmVjZWRlbmNlID09PSAwIHx8IHByZWNlZGVuY2UgPD0gbWluUHJlY2VkZW5jZSkgYnJlYWs7XG4gICAgICAvLyBSaWdodC1oYW5kIHByZWNlZGVuY2Ugb3BlcmF0b3JzXG4gICAgICBpZiAoJ14nID09PSBvcGVyYXRvciB8fCAnLi4nID09PSBvcGVyYXRvcikgLS1wcmVjZWRlbmNlO1xuICAgICAgbmV4dCgpO1xuICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VTdWJFeHByZXNzaW9uKHByZWNlZGVuY2UsIGZsb3dDb250ZXh0KTtcbiAgICAgIGlmIChudWxsID09IHJpZ2h0KSByYWlzZVVuZXhwZWN0ZWRUb2tlbignPGV4cHJlc3Npb24+JywgdG9rZW4pO1xuICAgICAgLy8gUHVzaCBpbiB0aGUgbWFya2VyIGNyZWF0ZWQgYmVmb3JlIHRoZSBsb29wIHRvIHdyYXAgaXRzIGVudGlyZXR5LlxuICAgICAgaWYgKHRyYWNrTG9jYXRpb25zKSBsb2NhdGlvbnMucHVzaChtYXJrZXIpO1xuICAgICAgZXhwcmVzc2lvbiA9IGZpbmlzaE5vZGUoYXN0LmJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHJlc3Npb24sIHJpZ2h0KSk7XG5cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG4gIH1cblxuICAvLyAgICAgcHJlZml4ZXhwIDo6PSBwcmVmaXgge3N1ZmZpeH1cbiAgLy8gICAgIHByZWZpeCA6Oj0gTmFtZSB8ICcoJyBleHAgJyknXG4gIC8vICAgICBzdWZmaXggOjo9ICdbJyBleHAgJ10nIHwgJy4nIE5hbWUgfCAnOicgTmFtZSBhcmdzIHwgYXJnc1xuICAvL1xuICAvLyAgICAgYXJncyA6Oj0gJygnIFtleHBsaXN0XSAnKScgfCB0YWJsZWNvbnN0cnVjdG9yIHwgU3RyaW5nXG5cbiAgZnVuY3Rpb24gcGFyc2VQcmVmaXhFeHByZXNzaW9uUGFydChiYXNlLCBtYXJrZXIsIGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGV4cHJlc3Npb24sIGlkZW50aWZpZXI7XG5cbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICBleHBlY3QoJ10nKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuaW5kZXhFeHByZXNzaW9uKGJhc2UsIGV4cHJlc3Npb24pKTtcbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGlkZW50aWZpZXIgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QubWVtYmVyRXhwcmVzc2lvbihiYXNlLCAnLicsIGlkZW50aWZpZXIpKTtcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGlkZW50aWZpZXIgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBiYXNlID0gZmluaXNoTm9kZShhc3QubWVtYmVyRXhwcmVzc2lvbihiYXNlLCAnOicsIGlkZW50aWZpZXIpKTtcbiAgICAgICAgICAvLyBPbmNlIGEgOiBpcyBmb3VuZCwgdGhpcyBoYXMgdG8gYmUgYSBDYWxsRXhwcmVzc2lvbiwgb3RoZXJ3aXNlXG4gICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQ2FsbEV4cHJlc3Npb24oYmFzZSwgZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICcoJzogY2FzZSAneyc6IC8vIGFyZ3NcbiAgICAgICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VDYWxsRXhwcmVzc2lvbihiYXNlLCBmbG93Q29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChTdHJpbmdMaXRlcmFsID09PSB0b2tlbi50eXBlKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIHJldHVybiBwYXJzZUNhbGxFeHByZXNzaW9uKGJhc2UsIGZsb3dDb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJlZml4RXhwcmVzc2lvbihmbG93Q29udGV4dCkge1xuICAgIHZhciBiYXNlLCBuYW1lLCBtYXJrZXI7XG5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAvLyBUaGUgcHJlZml4XG4gICAgaWYgKElkZW50aWZpZXIgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIG5hbWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGJhc2UgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIC8vIFNldCB0aGUgcGFyZW50IHNjb3BlLlxuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGF0dGFjaFNjb3BlKGJhc2UsIHNjb3BlSGFzTmFtZShuYW1lKSk7XG4gICAgfSBlbHNlIGlmIChjb25zdW1lKCcoJykpIHtcbiAgICAgIGJhc2UgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICBleHBlY3QoJyknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVGhlIHN1ZmZpeFxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBuZXdCYXNlID0gcGFyc2VQcmVmaXhFeHByZXNzaW9uUGFydChiYXNlLCBtYXJrZXIsIGZsb3dDb250ZXh0KTtcbiAgICAgIGlmIChuZXdCYXNlID09PSBudWxsKVxuICAgICAgICBicmVhaztcbiAgICAgIGJhc2UgPSBuZXdCYXNlO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLy8gICAgIGFyZ3MgOjo9ICcoJyBbZXhwbGlzdF0gJyknIHwgdGFibGVjb25zdHJ1Y3RvciB8IFN0cmluZ1xuXG4gIGZ1bmN0aW9uIHBhcnNlQ2FsbEV4cHJlc3Npb24oYmFzZSwgZmxvd0NvbnRleHQpIHtcbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICBpZiAoIWZlYXR1cmVzLmVtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubGluZSAhPT0gcHJldmlvdXNUb2tlbi5saW5lKVxuICAgICAgICAgICAgICByYWlzZShudWxsLCBlcnJvcnMuYW1iaWd1b3VzU3ludGF4LCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgIC8vIExpc3Qgb2YgZXhwcmVzc2lvbnNcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gZXhwcmVzc2lvbikgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICB3aGlsZSAoY29uc3VtZSgnLCcpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuY2FsbEV4cHJlc3Npb24oYmFzZSwgZXhwcmVzc2lvbnMpKTtcblxuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICBtYXJrTG9jYXRpb24oKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgdmFyIHRhYmxlID0gcGFyc2VUYWJsZUNvbnN0cnVjdG9yKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QudGFibGVDYWxsRXhwcmVzc2lvbihiYXNlLCB0YWJsZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoU3RyaW5nTGl0ZXJhbCA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LnN0cmluZ0NhbGxFeHByZXNzaW9uKGJhc2UsIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oZmxvd0NvbnRleHQpKSk7XG4gICAgfVxuXG4gICAgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJ2Z1bmN0aW9uIGFyZ3VtZW50cycsIHRva2VuKTtcbiAgfVxuXG4gIC8vICAgICBwcmltYXJ5IDo6PSBTdHJpbmcgfCBOdW1lcmljIHwgbmlsIHwgdHJ1ZSB8IGZhbHNlXG4gIC8vICAgICAgICAgIHwgZnVuY3Rpb25kZWYgfCB0YWJsZWNvbnN0cnVjdG9yIHwgJy4uLidcblxuICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGxpdGVyYWxzID0gU3RyaW5nTGl0ZXJhbCB8IE51bWVyaWNMaXRlcmFsIHwgQm9vbGVhbkxpdGVyYWwgfCBOaWxMaXRlcmFsIHwgVmFyYXJnTGl0ZXJhbFxuICAgICAgLCB2YWx1ZSA9IHRva2VuLnZhbHVlXG4gICAgICAsIHR5cGUgPSB0b2tlbi50eXBlXG4gICAgICAsIG1hcmtlcjtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgIGlmICh0eXBlID09PSBWYXJhcmdMaXRlcmFsICYmICFmbG93Q29udGV4dC5hbGxvd1ZhcmFyZykge1xuICAgICAgcmFpc2UodG9rZW4sIGVycm9ycy5jYW5ub3RVc2VWYXJhcmcsIHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAmIGxpdGVyYWxzKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIHZhciByYXcgPSBpbnB1dC5zbGljZSh0b2tlbi5yYW5nZVswXSwgdG9rZW4ucmFuZ2VbMV0pO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmxpdGVyYWwodHlwZSwgdmFsdWUsIHJhdykpO1xuICAgIH0gZWxzZSBpZiAoS2V5d29yZCA9PT0gdHlwZSAmJiAnZnVuY3Rpb24nID09PSB2YWx1ZSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICBuZXh0KCk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obnVsbCk7XG4gICAgfSBlbHNlIGlmIChjb25zdW1lKCd7JykpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgcmV0dXJuIHBhcnNlVGFibGVDb25zdHJ1Y3RvcihmbG93Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2VyXG4gIC8vIC0tLS0tLVxuXG4gIC8vIEV4cG9ydCB0aGUgbWFpbiBwYXJzZXIuXG4gIC8vXG4gIC8vICAgLSBgd2FpdGAgSG9sZCBwYXJzaW5nIHVudGlsIGVuZCgpIGlzIGNhbGxlZC4gRGVmYXVsdHMgdG8gZmFsc2VcbiAgLy8gICAtIGBjb21tZW50c2AgU3RvcmUgY29tbWVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gIC8vICAgLSBgc2NvcGVgIFRyYWNrIGlkZW50aWZpZXIgc2NvcGUuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAvLyAgIC0gYGxvY2F0aW9uc2AgU3RvcmUgbG9jYXRpb24gaW5mb3JtYXRpb24uIERlZmF1bHRzIHRvIGZhbHNlLlxuICAvLyAgIC0gYHJhbmdlc2AgU3RvcmUgdGhlIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVyIGxvY2F0aW9ucy4gRGVmYXVsdHMgdG9cbiAgLy8gICAgIGZhbHNlLlxuICAvLyAgIC0gYG9uQ3JlYXRlTm9kZWAgQ2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBzeW50YXggbm9kZSBpc1xuICAvLyAgICAgY3JlYXRlZC5cbiAgLy8gICAtIGBvbkNyZWF0ZVNjb3BlYCBDYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIG5ldyBzY29wZSBpc1xuICAvLyAgICAgY3JlYXRlZC5cbiAgLy8gICAtIGBvbkRlc3Ryb3lTY29wZWAgQ2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgLy8gICAgIGlzIGRlc3Ryb3llZC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgIHZhciBwYXJzZXIgPSByZXF1aXJlKCdsdWFwYXJzZXInKTtcbiAgLy8gICAgIHBhcnNlci5wYXJzZSgnaSA9IDAnKTtcblxuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbiAgdmFyIHZlcnNpb25GZWF0dXJlcyA9IHtcbiAgICAnNS4xJzoge1xuICAgIH0sXG4gICAgJzUuMic6IHtcbiAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgIGVtcHR5U3RhdGVtZW50OiB0cnVlLFxuICAgICAgaGV4RXNjYXBlczogdHJ1ZSxcbiAgICAgIHNraXBXaGl0ZXNwYWNlRXNjYXBlOiB0cnVlLFxuICAgICAgc3RyaWN0RXNjYXBlczogdHJ1ZSxcbiAgICAgIHJlbGF4ZWRCcmVhazogdHJ1ZVxuICAgIH0sXG4gICAgJzUuMyc6IHtcbiAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgIGVtcHR5U3RhdGVtZW50OiB0cnVlLFxuICAgICAgaGV4RXNjYXBlczogdHJ1ZSxcbiAgICAgIHNraXBXaGl0ZXNwYWNlRXNjYXBlOiB0cnVlLFxuICAgICAgc3RyaWN0RXNjYXBlczogdHJ1ZSxcbiAgICAgIHVuaWNvZGVFc2NhcGVzOiB0cnVlLFxuICAgICAgYml0d2lzZU9wZXJhdG9yczogdHJ1ZSxcbiAgICAgIGludGVnZXJEaXZpc2lvbjogdHJ1ZSxcbiAgICAgIHJlbGF4ZWRCcmVhazogdHJ1ZVxuICAgIH0sXG4gICAgJ0x1YUpJVCc6IHtcbiAgICAgIC8vIFhYWDogTHVhSklUIGxhbmd1YWdlIGZlYXR1cmVzIG1heSBkZXBlbmQgb24gY29tcGlsYXRpb24gb3B0aW9uczsgbWF5IG5lZWQgdG9cbiAgICAgIC8vIHJldGhpbmsgaG93IHRvIGhhbmRsZSB0aGlzLiBTcGVjaWZpY2FsbHksIHRoZXJlIGlzIGEgTFVBSklUX0VOQUJMRV9MVUE1MkNPTVBBVFxuICAgICAgLy8gdGhhdCByZW1vdmVzIGNvbnRleHR1YWwgZ290by4gTWF5YmUgYWRkICdMdWFKSVQtNS4yY29tcGF0JyBhcyB3ZWxsP1xuICAgICAgbGFiZWxzOiB0cnVlLFxuICAgICAgY29udGV4dHVhbEdvdG86IHRydWUsXG4gICAgICBoZXhFc2NhcGVzOiB0cnVlLFxuICAgICAgc2tpcFdoaXRlc3BhY2VFc2NhcGU6IHRydWUsXG4gICAgICBzdHJpY3RFc2NhcGVzOiB0cnVlLFxuICAgICAgdW5pY29kZUVzY2FwZXM6IHRydWUsXG4gICAgICBpbWFnaW5hcnlOdW1iZXJzOiB0cnVlLFxuICAgICAgaW50ZWdlclN1ZmZpeGVzOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlKF9pbnB1dCwgX29wdGlvbnMpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBfb3B0aW9ucyAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIF9pbnB1dCkge1xuICAgICAgX29wdGlvbnMgPSBfaW5wdXQ7XG4gICAgICBfaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghX29wdGlvbnMpIF9vcHRpb25zID0ge307XG5cbiAgICBpbnB1dCA9IF9pbnB1dCB8fCAnJztcbiAgICBvcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgX29wdGlvbnMpO1xuXG4gICAgLy8gUmV3aW5kIHRoZSBsZXhlclxuICAgIGluZGV4ID0gMDtcbiAgICBsaW5lID0gMTtcbiAgICBsaW5lU3RhcnQgPSAwO1xuICAgIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAvLyBXaGVuIHRyYWNraW5nIGlkZW50aWZpZXIgc2NvcGUsIGluaXRpYWxpemUgd2l0aCBhbiBlbXB0eSBzY29wZS5cbiAgICBzY29wZXMgPSBbW11dO1xuICAgIHNjb3BlRGVwdGggPSAwO1xuICAgIGdsb2JhbHMgPSBbXTtcbiAgICBsb2NhdGlvbnMgPSBbXTtcblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZlcnNpb25GZWF0dXJlcywgb3B0aW9ucy5sdWFWZXJzaW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHNwcmludGYoXCJMdWEgdmVyc2lvbiAnJTEnIG5vdCBzdXBwb3J0ZWRcIiwgb3B0aW9ucy5sdWFWZXJzaW9uKSk7XG4gICAgfVxuXG4gICAgZmVhdHVyZXMgPSBhc3NpZ24oe30sIHZlcnNpb25GZWF0dXJlc1tvcHRpb25zLmx1YVZlcnNpb25dKTtcbiAgICBpZiAob3B0aW9ucy5leHRlbmRlZElkZW50aWZpZXJzICE9PSB2b2lkIDApXG4gICAgICBmZWF0dXJlcy5leHRlbmRlZElkZW50aWZpZXJzID0gISFvcHRpb25zLmV4dGVuZGVkSWRlbnRpZmllcnM7XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbmNvZGluZ01vZGVzLCBvcHRpb25zLmVuY29kaW5nTW9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzcHJpbnRmKFwiRW5jb2RpbmcgbW9kZSAnJTEnIG5vdCBzdXBwb3J0ZWRcIiwgb3B0aW9ucy5lbmNvZGluZ01vZGUpKTtcbiAgICB9XG5cbiAgICBlbmNvZGluZ01vZGUgPSBlbmNvZGluZ01vZGVzW29wdGlvbnMuZW5jb2RpbmdNb2RlXTtcblxuICAgIGlmIChvcHRpb25zLmNvbW1lbnRzKSBjb21tZW50cyA9IFtdO1xuICAgIGlmICghb3B0aW9ucy53YWl0KSByZXR1cm4gZW5kKCk7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICAvLyBXcml0ZSB0byB0aGUgc291cmNlIGNvZGUgYnVmZmVyIHdpdGhvdXQgYmVnaW5uaW5nIHRoZSBwYXJzZS5cbiAgZXhwb3J0cy53cml0ZSA9IHdyaXRlO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKF9pbnB1dCkge1xuICAgIGlucHV0ICs9IFN0cmluZyhfaW5wdXQpO1xuICAgIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIC8vIFNlbmQgYW4gRU9GIGFuZCBiZWdpbiBwYXJzaW5nLlxuICBleHBvcnRzLmVuZCA9IGVuZDtcblxuICBmdW5jdGlvbiBlbmQoX2lucHV0KSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgX2lucHV0KSB3cml0ZShfaW5wdXQpO1xuXG4gICAgLy8gSWdub3JlIHNoZWJhbmdzLlxuICAgIGlmIChpbnB1dCAmJiBpbnB1dC5zdWJzdHIoMCwgMikgPT09ICcjIScpIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXi4qLywgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLnJlcGxhY2UoLy4vZywgJyAnKTtcbiAgICB9KTtcblxuICAgIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0cmFja0xvY2F0aW9ucyA9IG9wdGlvbnMubG9jYXRpb25zIHx8IG9wdGlvbnMucmFuZ2VzO1xuICAgIC8vIEluaXRpYWxpemUgd2l0aCBhIGxvb2thaGVhZCB0b2tlbi5cbiAgICBsb29rYWhlYWQgPSBsZXgoKTtcblxuICAgIHZhciBjaHVuayA9IHBhcnNlQ2h1bmsoKTtcbiAgICBpZiAob3B0aW9ucy5jb21tZW50cykgY2h1bmsuY29tbWVudHMgPSBjb21tZW50cztcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgY2h1bmsuZ2xvYmFscyA9IGdsb2JhbHM7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAobG9jYXRpb25zLmxlbmd0aCA+IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2F0aW9uIHRyYWNraW5nIGZhaWxlZC4gVGhpcyBpcyBtb3N0IGxpa2VseSBhIGJ1ZyBpbiBsdWFwYXJzZScpO1xuXG4gICAgcmV0dXJuIGNodW5rO1xuICB9XG5cbn0pKTtcbi8qIHZpbTogc2V0IHN3PTIgdHM9MiBldCB0dz03OSA6ICovXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIzNzI6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXMoYSwgYikge1xuXHRpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG5cdFx0cmV0dXJuIDEgLyBhID09PSAxIC8gYjtcblx0fVxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTk2ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1Nyk7XG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0OTgpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNzIpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTM3KTtcbnZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDg3KTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTkzNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzcyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQb2x5ZmlsbCgpIHtcblx0cmV0dXJuIHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpbXBsZW1lbnRhdGlvbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwODc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBnZXRQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkzNyk7XG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODU3KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODE2MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oOTY4KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyMjg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2OCk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYwKTtcblxudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHR2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTY4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OTA3OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjEwODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4Nik7XG52YXIgaGFzRGVzY3JpcHRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMzkpKCk7XG52YXIgZ09QRCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMzNik7XG5cbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcbnZhciAkZmxvb3IgPSBHZXRJbnRyaW5zaWMoJyVNYXRoLmZsb29yJScpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXRGdW5jdGlvbkxlbmd0aChmbiwgbGVuZ3RoKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYGZuYCBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHR9XG5cdGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBsZW5ndGggPCAwIHx8IGxlbmd0aCA+IDB4RkZGRkZGRkYgfHwgJGZsb29yKGxlbmd0aCkgIT09IGxlbmd0aCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbGVuZ3RoYCBtdXN0IGJlIGEgcG9zaXRpdmUgMzItYml0IGludGVnZXInKTtcblx0fVxuXG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmICEhYXJndW1lbnRzWzJdO1xuXG5cdHZhciBmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gdHJ1ZTtcblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IHRydWU7XG5cdGlmICgnbGVuZ3RoJyBpbiBmbiAmJiBnT1BEKSB7XG5cdFx0dmFyIGRlc2MgPSBnT1BEKGZuLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmIChkZXNjICYmICFkZXNjLndyaXRhYmxlKSB7XG5cdFx0XHRmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRpZiAoZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSB8fCBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgfHwgIWxvb3NlKSB7XG5cdFx0aWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgsIHRydWUsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWZpbmUoLyoqIEB0eXBlIHtQYXJhbWV0ZXJzPGRlZmluZT5bMF19ICovIChmbiksICdsZW5ndGgnLCBsZW5ndGgpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZm47XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTI1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEJhc2VTZXJ2aWNlOiAoKSA9PiAoLyogYmluZGluZyAqLyBCYXNlU2VydmljZSlcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTAxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3NzApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODA0MSk7XG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cblxuXG5jbGFzcyBCYXNlU2VydmljZSB7XG4gICAgYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXSA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYuY3JlYXRlKGRvY3VtZW50LnVyaSwgZG9jdW1lbnQubGFuZ3VhZ2VJZCwgZG9jdW1lbnQudmVyc2lvbiwgZG9jdW1lbnQudGV4dCk7XG4gICAgfVxuICAgIGdldERvY3VtZW50KHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudHNbdXJpXTtcbiAgICB9XG4gICAgcmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRzW2RvY3VtZW50LnVyaV07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbZG9jdW1lbnQudXJpXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmFtZURvY3VtZW50KGRvY3VtZW50LCBuZXdEb2N1bWVudFVyaSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c0RvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChkb2N1bWVudC51cmkpO1xuICAgICAgICB0aGlzLmFkZERvY3VtZW50KHtcbiAgICAgICAgICAgIHVyaTogbmV3RG9jdW1lbnRVcmksXG4gICAgICAgICAgICB2ZXJzaW9uOiBwcmV2aW91c0RvY3VtZW50LnZlcnNpb24sXG4gICAgICAgICAgICBsYW5ndWFnZUlkOiBwcmV2aW91c0RvY3VtZW50Lmxhbmd1YWdlSWQsXG4gICAgICAgICAgICB0ZXh0OiBwcmV2aW91c0RvY3VtZW50LmdldFRleHQoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRpb25zW25ld0RvY3VtZW50VXJpXSA9IHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldO1xuICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50KGRvY3VtZW50KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRWYWx1ZSh1cmkpIHtcbiAgICAgICAgdmFyIF90aGlzX2dldERvY3VtZW50O1xuICAgICAgICByZXR1cm4gKF90aGlzX2dldERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCh1cmkpKSA9PT0gbnVsbCB8fCBfdGhpc19nZXREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfZ2V0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGlkZW50aWZpZXIudXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYuY3JlYXRlKGRvY3VtZW50LnVyaSwgZG9jdW1lbnQubGFuZ3VhZ2VJZCwgZG9jdW1lbnQudmVyc2lvbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXSA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICB9XG4gICAgc2V0V29ya3NwYWNlKHdvcmtzcGFjZVVyaSkge1xuICAgICAgICB0aGlzLndvcmtzcGFjZVVyaSA9IHdvcmtzcGFjZVVyaTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhkb2N1bWVudFVyaSwgb3B0aW9ucywgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldID0gbWVyZ2UgPyAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5tZXJnZU9iamVjdHMgKi8gLnJMKShvcHRpb25zLCB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldKSA6IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbihkb2N1bWVudFVyaSwgb3B0aW9uTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXSAmJiB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXVtvcHRpb25OYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYudXBkYXRlKGRvY3VtZW50LCBkZWx0YXMsIGlkZW50aWZpZXIudmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb0lubGluZUNvbXBsZXRlKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvUmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb1ZhbGlkYXRpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBmb3JtYXQoZG9jdW1lbnQsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgICBhc3luYyBwcm92aWRlU2lnbmF0dXJlSGVscChkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGZpbmREb2N1bWVudEhpZ2hsaWdodHMoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzKCkge1xuICAgICAgICB2YXIgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8sIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlLCBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nLCBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvSWdub3JlOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvSWdub3JlKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUgOiBbXSxcbiAgICAgICAgICAgIGVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm86IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNJbmZvKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNJbmZvIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8gOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTZW1hbnRpY1Rva2Vucyhkb2N1bWVudCwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjbG9zZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0Q29kZUFjdGlvbnMoZG9jdW1lbnQsIHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGV4ZWN1dGVDb21tYW5kKGNvbW1hbmQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgc2VuZEFwcGxpZWRSZXN1bHQocmVzdWx0LCBjYWxsYmFja0lkKSB7fVxuICAgIHNlbmRSZXF1ZXN0KG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgc2VuZFJlc3BvbnNlKGNhbGxiYWNrSWQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihtb2RlLCB3b3Jrc3BhY2VVcmkpe1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZU5hbWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImRvY3VtZW50c1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImdsb2JhbE9wdGlvbnNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZURhdGFcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VDYXBhYmlsaXRpZXNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwid29ya3NwYWNlVXJpXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjbGllbnRDYXBhYmlsaXRpZXNcIiwge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgZGlhZ25vc3RpYzoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkRG9jdW1lbnRTdXBwb3J0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwdWJsaXNoRGlhZ25vc3RpY3M6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEluZm9ybWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRhZ1N1cHBvcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlU2V0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRGlhZ25vc3RpY1RhZy5Vbm5lY2Vzc2FyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5EaWFnbm9zdGljVGFnLkRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEZvcm1hdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFpbnRleHQnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN5bmNocm9uaXphdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3aWxsU2F2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRpZFNhdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3aWxsU2F2ZVdhaXRVbnRpbDogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uSXRlbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc25pcHBldFN1cHBvcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXRDaGFyYWN0ZXJzU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uRm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxhaW50ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZWRTdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbGVjdFN1cHBvcnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRTdXBwb3J0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlSGVscDoge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVJbmZvcm1hdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbkZvcm1hdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWludGV4dCdcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVQYXJhbWV0ZXJTdXBwb3J0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbWFudGljVG9rZW5zOiB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpbGluZVRva2VuU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nVG9rZW5TdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogW10sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuTW9kaWZpZXJzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWxhdGl2ZVwiXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXVnbWVudHNTeW50YXhUb2tlbnM6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvZGVBY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lQ29tcGxldGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdpbmRvdzoge1xuICAgICAgICAgICAgICAgIHNob3dEb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0OiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdvcmtzcGFjZToge1xuICAgICAgICAgICAgICAgIGRpZENoYW5nZUNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUNvbW1hbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXBwbHlFZGl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUhhbmRsaW5nOiBcImFib3J0XCIsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZXNMaW5lRW5kaW5nczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Q2hhbmdlczogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLndvcmtzcGFjZVVyaSA9IHdvcmtzcGFjZVVyaTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IFwiQmFzZVNlcnZpY2VcIjtcbiAgICAgICAgdGhpcy5zZXJ2aWNlRGF0YSA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYXNlU2VydmljZVwiLFxuICAgICAgICAgICAgbW9kZXM6IFwiXCIsXG4gICAgICAgICAgICBtb2R1bGU6ICgpPT57fVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzc3MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBUazogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJMOiAoKSA9PiAoLyogYmluZGluZyAqLyBtZXJnZU9iamVjdHMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydHMgbm90RW1wdHksIGlzRW1wdHlSYW5nZSwgbWVyZ2VSYW5nZXMsIGNvbnZlcnRUb1VyaSAqL1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIsIGV4Y2x1ZGVVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIGlmICghb2JqMSkgcmV0dXJuIG9iajI7XG4gICAgaWYgKCFvYmoyKSByZXR1cm4gb2JqMTtcbiAgICBpZiAoZXhjbHVkZVVuZGVmaW5lZCkge1xuICAgICAgICBvYmoxID0gZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyhvYmoxKTtcbiAgICAgICAgb2JqMiA9IGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqMik7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZE9iamVjdHMgPSB7XG4gICAgICAgIC4uLm9iajIsXG4gICAgICAgIC4uLm9iajFcbiAgICB9OyAvLyBHaXZlIHByaW9yaXR5IHRvIG9iajEgdmFsdWVzIGJ5IHNwcmVhZGluZyBvYmoyIGZpcnN0LCB0aGVuIG9iajFcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtZXJnZWRPYmplY3RzKSl7XG4gICAgICAgIGlmIChvYmoxW2tleV0gJiYgb2JqMltrZXldKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoxW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gb2JqMVtrZXldLmNvbmNhdChvYmoyW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iajJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBvYmoyW2tleV0uY29uY2F0KG9iajFba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmoxW2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoyW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gbWVyZ2VPYmplY3RzKG9iajFba2V5XSwgb2JqMltrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkT2JqZWN0cztcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqKSB7XG4gICAgY29uc3QgZmlsdGVyZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtfLCB2YWx1ZV0pPT52YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGZpbHRlcmVkRW50cmllcyk7XG59XG5mdW5jdGlvbiBub3RFbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNFbXB0eVJhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnN0YXJ0LnJvdyA9PT0gcmFuZ2UuZW5kLnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPT09IHJhbmdlLmVuZC5jb2x1bW47XG59XG4vL3Rha2VuIHdpdGggc21hbGwgY2hhbmdlcyBmcm9tIGFjZS1jb2RlXG5mdW5jdGlvbiBtZXJnZVJhbmdlcyhyYW5nZXMpIHtcbiAgICB2YXIgbGlzdCA9IHJhbmdlcztcbiAgICBsaXN0ID0gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVQb2ludHMoYS5zdGFydCwgYi5zdGFydCk7XG4gICAgfSk7XG4gICAgdmFyIG5leHQgPSBsaXN0WzBdLCByYW5nZTtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgbmV4dCA9IGxpc3RbaV07XG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5zdGFydCk7XG4gICAgICAgIGlmIChjbXAgPCAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGNtcCA9PSAwICYmICFpc0VtcHR5UmFuZ2UocmFuZ2UpICYmICFpc0VtcHR5UmFuZ2UobmV4dCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuZW5kKSA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBuZXh0LmVuZC5yb3c7XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gbmV4dC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBuZXh0ID0gcmFuZ2U7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBjb21wYXJlUG9pbnRzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgLSBwMi5yb3cgfHwgcDEuY29sdW1uIC0gcDIuY29sdW1uO1xufVxuZnVuY3Rpb24gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSh2YWx1ZSwgcmVnZXhwQXJyYXkpIHtcbiAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHJlZ2V4cEFycmF5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHJlZ2V4cEFycmF5W2ldLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBnaXZlbiBmaWxlIHBhdGggdG8gYSBVUkkgZm9ybWF0LiBJZiB0aGUgZ2l2ZW4gZmlsZSBwYXRoIGlzIGFscmVhZHkgYSBVUkksXG4gKiBpdCBub3JtYWxpemVzIGFuZCBvcHRpb25hbGx5IHJlc29sdmVzIHRoZSBwYXRoIGFnYWluc3QgYSB3b3Jrc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBmaWxlIHBhdGggdG8gY29udmVydCB0byBhIFVSSS4gQ2FuIGJlIGFuIGFic29sdXRlIHBhdGggb3IgYW4gZXhpc3RpbmcgZmlsZSBVUkkuXG4gKiBAcGFyYW0gW2pvaW5Xb3Jrc3BhY2VVUkldIC0gT3B0aW9uYWwgZmxhZyB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbnZlcnRlZCBVUkkgc2hvdWxkIGJlIGpvaW5lZCB3aXRoIGdpdmVuIFVSSVxuICogQHBhcmFtIFt3b3Jrc3BhY2VVcmldIC0gVGhlIGJhc2Ugd29ya3NwYWNlIFVSSSB0byByZXNvbHZlIGFnYWluc3QgaWYgYGpvaW5Xb3Jrc3BhY2VVUklgIGlzIHRydWUuIFJlcXVpcmVkIGlmIHJlc29sdXRpb24gaXMgbmVlZGVkLlxuICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSByZXN1bHRpbmcgVVJJXG4gKi8gZnVuY3Rpb24gY29udmVydFRvVXJpKGZpbGVQYXRoLCBqb2luV29ya3NwYWNlVVJJID0gZmFsc2UsIHdvcmtzcGFjZVVyaSkge1xuICAgIGNvbnN0IGlzRnVsbFVyaSA9IGZpbGVQYXRoLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICAgIGxldCB1cmk7XG4gICAgaWYgKGlzRnVsbFVyaSkge1xuICAgICAgICB1cmkgPSBVUkkucGFyc2Uobm9ybWFsaXplZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IFVSSS5maWxlKG5vcm1hbGl6ZWRQYXRoKTtcbiAgICB9XG4gICAgaWYgKGpvaW5Xb3Jrc3BhY2VVUkkgJiYgd29ya3NwYWNlVXJpKSB7XG4gICAgICAgIGlmICghd29ya3NwYWNlVXJpLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3Jrc3BhY2VVcmkgbXVzdCBiZSBhIGZpbGU6Ly8gVVJJJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya3NwYWNlVXJpUGFyc2VkID0gVVJJLnBhcnNlKHdvcmtzcGFjZVVyaSk7XG4gICAgICAgIHVyaSA9IFV0aWxzLmpvaW5QYXRoKHdvcmtzcGFjZVVyaVBhcnNlZCwgdXJpLnBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyNzI6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTMxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cblxuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzODcpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MjUpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMjczMCk7XG52YXIgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTQzKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4Mjc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MDcpO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2NCk7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MzEpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjcyKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjE1KTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyMDg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTExMDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBleHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IHJpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzEyKTtcbi8vIEluc3RhbGwgdGhlIGJyb3dzZXIgcnVudGltZSBhYnN0cmFjdC5cbnJpbF8xLmRlZmF1bHQuaW5zdGFsbCgpO1xuY29uc3QgYXBpXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzIpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNzY3MiksIGV4cG9ydHMpO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fb25EYXRhID0gbmV3IGFwaV8xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkRhdGEuZmlyZShldmVudC5kYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICAgICAgcG9ydC5vbm1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlTGlzdGVuZXI7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlUmVhZGVyID0gQnJvd3Nlck1lc3NhZ2VSZWFkZXI7XG5jbGFzcyBCcm93c2VyTWVzc2FnZVdyaXRlciBleHRlbmRzIGFwaV8xLkFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IocG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgICAgICB0aGlzLmVycm9yQ291bnQgPSAwO1xuICAgICAgICBwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB0aGlzLmZpcmVFcnJvcihldmVudCkpO1xuICAgIH1cbiAgICB3cml0ZShtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1zZykge1xuICAgICAgICB0aGlzLmVycm9yQ291bnQrKztcbiAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IsIG1zZywgdGhpcy5lcnJvckNvdW50KTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VXcml0ZXIgPSBCcm93c2VyTWVzc2FnZVdyaXRlcjtcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyID0gYXBpXzEuTnVsbExvZ2dlcjtcbiAgICB9XG4gICAgaWYgKGFwaV8xLkNvbm5lY3Rpb25TdHJhdGVneS5pcyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBjb25uZWN0aW9uU3RyYXRlZ3k6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBhcGlfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMzMTI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2NCk7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuY29uc3QgYXBpXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzIpO1xuY2xhc3MgTWVzc2FnZUJ1ZmZlciBleHRlbmRzIGFwaV8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZW5jb2RpbmcgPSAndXRmLTgnKSB7XG4gICAgICAgIHN1cGVyKGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5hc2NpaURlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ2FzY2lpJyk7XG4gICAgfVxuICAgIGVtcHR5QnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlcjtcbiAgICB9XG4gICAgZnJvbVN0cmluZyh2YWx1ZSwgX2VuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzY2lpRGVjb2Rlci5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzTmF0aXZlKGJ1ZmZlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGxvY05hdGl2ZShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfVxufVxuTWVzc2FnZUJ1ZmZlci5lbXB0eUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuY2xhc3MgUmVhZGFibGVTdHJlYW1XcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBibG9iLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGFwaV8xLlJBTCkoKS5jb25zb2xlLmVycm9yKGBDb252ZXJ0aW5nIGJsb2IgdG8gYXJyYXkgYnVmZmVyIGZhaWxlZC5gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fbWVzc2FnZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25EYXRhKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkRhdGEuZXZlbnQobGlzdGVuZXIpO1xuICAgIH1cbn1cbmNsYXNzIFdyaXRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIH1cbiAgICBvbkNsb3NlKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVycm9yKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICBvbkVuZChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCBsaXN0ZW5lcikpO1xuICAgIH1cbiAgICB3cml0ZShkYXRhLCBlbmNvZGluZykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyAhPT0gJ3V0Zi04Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgfVxufVxuY29uc3QgX3RleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBfcmlsID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgbWVzc2FnZUJ1ZmZlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGNyZWF0ZTogKGVuY29kaW5nKSA9PiBuZXcgTWVzc2FnZUJ1ZmZlcihlbmNvZGluZylcbiAgICB9KSxcbiAgICBhcHBsaWNhdGlvbkpzb246IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBlbmNvZGVyOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIG5hbWU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGVuY29kZTogKG1zZywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzZXQgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbiBhIEJyb3dzZXIgZW52aXJvbm1lbnRzIG9ubHkgdXRmLTggdGV4dCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQuIEJ1dCBnb3QgZW5jb2Rpbmc6ICR7b3B0aW9ucy5jaGFyc2V0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobXNnLCB1bmRlZmluZWQsIDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBkZWNvZGVyOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIG5hbWU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGRlY29kZTogKGJ1ZmZlciwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IFVpbnQ4QXJyYXlzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoSlNPTi5wYXJzZShuZXcgVGV4dERlY29kZXIob3B0aW9ucy5jaGFyc2V0KS5kZWNvZGUoYnVmZmVyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pLFxuICAgIHN0cmVhbTogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGFzUmVhZGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBSZWFkYWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KSxcbiAgICAgICAgYXNXcml0YWJsZVN0cmVhbTogKHNvY2tldCkgPT4gbmV3IFdyaXRhYmxlU3RyZWFtV3JhcHBlcihzb2NrZXQpXG4gICAgfSksXG4gICAgY29uc29sZTogY29uc29sZSxcbiAgICB0aW1lcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4geyBkaXNwb3NlOiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDAsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRJbnRlcnZhbChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJJbnRlcnZhbChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgfSlcbn0pO1xuZnVuY3Rpb24gUklMKCkge1xuICAgIHJldHVybiBfcmlsO1xufVxuKGZ1bmN0aW9uIChSSUwpIHtcbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgICBhcGlfMS5SQUwuaW5zdGFsbChfcmlsKTtcbiAgICB9XG4gICAgUklMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUklMIHx8IChSSUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSSUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2NzI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vdHlwaW5ncy90aGVuYWJsZS5kLnRzXCIgLz5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBleHBvcnRzLlByb2dyZXNzVG9rZW4gPSBleHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5OdWxsTG9nZ2VyID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSBleHBvcnRzLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IGV4cG9ydHMuRGlzcG9zYWJsZSA9IGV4cG9ydHMuTFJVQ2FjaGUgPSBleHBvcnRzLlRvdWNoID0gZXhwb3J0cy5MaW5rZWRNYXAgPSBleHBvcnRzLlBhcmFtZXRlclN0cnVjdHVyZXMgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTcgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTQgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5FcnJvckNvZGVzID0gZXhwb3J0cy5SZXNwb25zZUVycm9yID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBleHBvcnRzLlJlcXVlc3RUeXBlOCA9IGV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBleHBvcnRzLlJlcXVlc3RUeXBlNSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBleHBvcnRzLlJlcXVlc3RUeXBlMiA9IGV4cG9ydHMuUmVxdWVzdFR5cGUxID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBleHBvcnRzLlJlcXVlc3RUeXBlID0gZXhwb3J0cy5NZXNzYWdlID0gZXhwb3J0cy5SQUwgPSB2b2lkIDA7XG5leHBvcnRzLk1lc3NhZ2VTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlVmFsdWVzID0gZXhwb3J0cy5UcmFjZSA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNjIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTWVzc2FnZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0VHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTA7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU1XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTY7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU4XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5SZXF1ZXN0VHlwZTk7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzcG9uc2VFcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckNvZGVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5FcnJvckNvZGVzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTBcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUxXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTZcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU3XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTg7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTlcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcmFtZXRlclN0cnVjdHVyZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXM7IH0gfSkpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMDkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlua2VkTWFwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTGlua2VkTWFwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxSVUNhY2hlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuTFJVQ2FjaGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVG91Y2hcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5rZWRNYXBfMS5Ub3VjaDsgfSB9KSk7XG5jb25zdCBkaXNwb3NhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4NDQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzcG9zYWJsZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3Bvc2FibGVfMS5EaXNwb3NhYmxlOyB9IH0pKTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRzXzEuRXZlbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW1pdHRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkVtaXR0ZXI7IH0gfSkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pKTtcbmNvbnN0IHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0ODkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneTsgfSB9KSk7XG5jb25zdCBtZXNzYWdlUmVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1Nik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLk1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLkFic3RyYWN0TWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VXcml0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTAzNik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLk1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLkFic3RyYWN0TWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVdyaXRlcl8xLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZUJ1ZmZlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODA1KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZUJ1ZmZlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VCdWZmZXJfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXI7IH0gfSkpO1xuY29uc3QgY29ubmVjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDU0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25TdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbk9wdGlvbnNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbk9wdGlvbnM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbExvZ2dlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5OdWxsTG9nZ2VyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVG9rZW5cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuUHJvZ3Jlc3NUb2tlbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc1R5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuUHJvZ3Jlc3NUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlVmFsdWVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlVmFsdWVzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYWNlRm9ybWF0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlRyYWNlRm9ybWF0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNldFRyYWNlTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlNldFRyYWNlTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ1RyYWNlTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkxvZ1RyYWNlTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvcnNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbkVycm9yczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvbkVycm9yOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25TdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTWVzc2FnZVN0cmF0ZWd5OyB9IH0pKTtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmV4cG9ydHMuUkFMID0gcmFsXzEuZGVmYXVsdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk1Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbnZhciBDYW5jZWxsYXRpb25Ub2tlbjtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBmYWxzZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IHRydWUsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZVxuICAgICAgICAgICAgfHwgY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWRcbiAgICAgICAgICAgIHx8IChJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkgJiYgISFjYW5kaWRhdGUub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQpKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblRva2VuIHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDU0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNjIpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMDkpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xudmFyIENhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoQ2FuY2VsTm90aWZpY2F0aW9uKSB7XG4gICAgQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2NhbmNlbFJlcXVlc3QnKTtcbn0pKENhbmNlbE5vdGlmaWNhdGlvbiB8fCAoQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBQcm9ncmVzc1Rva2VuO1xuKGZ1bmN0aW9uIChQcm9ncmVzc1Rva2VuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgUHJvZ3Jlc3NUb2tlbi5pcyA9IGlzO1xufSkoUHJvZ3Jlc3NUb2tlbiB8fCAoZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gUHJvZ3Jlc3NUb2tlbiA9IHt9KSk7XG52YXIgUHJvZ3Jlc3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFByb2dyZXNzTm90aWZpY2F0aW9uKSB7XG4gICAgUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvcHJvZ3Jlc3MnKTtcbn0pKFByb2dyZXNzTm90aWZpY2F0aW9uIHx8IChQcm9ncmVzc05vdGlmaWNhdGlvbiA9IHt9KSk7XG5jbGFzcyBQcm9ncmVzc1R5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gUHJvZ3Jlc3NUeXBlO1xudmFyIFN0YXJSZXF1ZXN0SGFuZGxlcjtcbihmdW5jdGlvbiAoU3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElzLmZ1bmModmFsdWUpO1xuICAgIH1cbiAgICBTdGFyUmVxdWVzdEhhbmRsZXIuaXMgPSBpcztcbn0pKFN0YXJSZXF1ZXN0SGFuZGxlciB8fCAoU3RhclJlcXVlc3RIYW5kbGVyID0ge30pKTtcbmV4cG9ydHMuTnVsbExvZ2dlciA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiAoKSA9PiB7IH0sXG4gICAgd2FybjogKCkgPT4geyB9LFxuICAgIGluZm86ICgpID0+IHsgfSxcbiAgICBsb2c6ICgpID0+IHsgfVxufSk7XG52YXIgVHJhY2U7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgVHJhY2VbVHJhY2VbXCJPZmZcIl0gPSAwXSA9IFwiT2ZmXCI7XG4gICAgVHJhY2VbVHJhY2VbXCJNZXNzYWdlc1wiXSA9IDFdID0gXCJNZXNzYWdlc1wiO1xuICAgIFRyYWNlW1RyYWNlW1wiQ29tcGFjdFwiXSA9IDJdID0gXCJDb21wYWN0XCI7XG4gICAgVHJhY2VbVHJhY2VbXCJWZXJib3NlXCJdID0gM10gPSBcIlZlcmJvc2VcIjtcbn0pKFRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0gVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlVmFsdWVzO1xuKGZ1bmN0aW9uIChUcmFjZVZhbHVlcykge1xuICAgIC8qKlxuICAgICAqIFR1cm4gdHJhY2luZyBvZmYuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuT2ZmID0gJ29mZic7XG4gICAgLyoqXG4gICAgICogVHJhY2UgbWVzc2FnZXMgb25seS5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5NZXNzYWdlcyA9ICdtZXNzYWdlcyc7XG4gICAgLyoqXG4gICAgICogQ29tcGFjdCBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuQ29tcGFjdCA9ICdjb21wYWN0JztcbiAgICAvKipcbiAgICAgKiBWZXJib3NlIG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5WZXJib3NlID0gJ3ZlcmJvc2UnO1xufSkoVHJhY2VWYWx1ZXMgfHwgKGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSBUcmFjZVZhbHVlcyA9IHt9KSk7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk1lc3NhZ2VzO1xuICAgICAgICAgICAgY2FzZSAnY29tcGFjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgICAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuVmVyYm9zZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk9mZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk1lc3NhZ2VzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnY29tcGFjdCc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJib3NlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLnRvU3RyaW5nID0gdG9TdHJpbmc7XG59KShUcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IFRyYWNlID0ge30pKTtcbnZhciBUcmFjZUZvcm1hdDtcbihmdW5jdGlvbiAoVHJhY2VGb3JtYXQpIHtcbiAgICBUcmFjZUZvcm1hdFtcIlRleHRcIl0gPSBcInRleHRcIjtcbiAgICBUcmFjZUZvcm1hdFtcIkpTT05cIl0gPSBcImpzb25cIjtcbn0pKFRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuSlNPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlRm9ybWF0LmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdCA9IHt9KSk7XG52YXIgU2V0VHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFNldFRyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvc2V0VHJhY2UnKTtcbn0pKFNldFRyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0gU2V0VHJhY2VOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIExvZ1RyYWNlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dUcmFjZU5vdGlmaWNhdGlvbikge1xuICAgIExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2xvZ1RyYWNlJyk7XG59KShMb2dUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IExvZ1RyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBDb25uZWN0aW9uRXJyb3JzO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JzKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkNsb3NlZFwiXSA9IDFdID0gXCJDbG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiRGlzcG9zZWRcIl0gPSAyXSA9IFwiRGlzcG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGluIGxpc3RlbmluZyBtb2RlLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkFscmVhZHlMaXN0ZW5pbmdcIl0gPSAzXSA9IFwiQWxyZWFkeUxpc3RlbmluZ1wiO1xufSkoQ29ubmVjdGlvbkVycm9ycyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gQ29ubmVjdGlvbkVycm9ycyA9IHt9KSk7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gQ29ubmVjdGlvbkVycm9yO1xudmFyIENvbm5lY3Rpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2FuY2VsVW5kaXNwYXRjaGVkKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDb25uZWN0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gQ29ubmVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbnZhciBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5raW5kID09PSAnaWQnKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSkgJiYgKGNhbmRpZGF0ZS5kaXNwb3NlID09PSB1bmRlZmluZWQgfHwgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkpO1xuICAgIH1cbiAgICBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVxdWVzdCcgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoXykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSkgfHwgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXModmFsdWUpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHNlbmRDYW5jZWxsYXRpb24oY29ubiwgaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25uLnNlbmROb3RpZmljYXRpb24oQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUsIHsgaWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXAoXykgeyB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuc2VuZENhbmNlbGxhdGlvbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2xlYW51cCk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHJlY2VpdmVyOiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UsXG4gICAgICAgIHNlbmRlcjogQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnJlY2VpdmVyKSAmJiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUuc2VuZGVyKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIE1lc3NhZ2VTdHJhdGVneTtcbihmdW5jdGlvbiAoTWVzc2FnZVN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuaGFuZGxlTWVzc2FnZSk7XG4gICAgfVxuICAgIE1lc3NhZ2VTdHJhdGVneS5pcyA9IGlzO1xufSkoTWVzc2FnZVN0cmF0ZWd5IHx8IChleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSA9IE1lc3NhZ2VTdHJhdGVneSA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jYW5jZWxsYXRpb25TdHJhdGVneSkgfHwgQ29ubmVjdGlvblN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5jb25uZWN0aW9uU3RyYXRlZ3kpIHx8IE1lc3NhZ2VTdHJhdGVneS5pcyhjYW5kaWRhdGUubWVzc2FnZVN0cmF0ZWd5KSk7XG4gICAgfVxuICAgIENvbm5lY3Rpb25PcHRpb25zLmlzID0gaXM7XG59KShDb25uZWN0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IENvbm5lY3Rpb25PcHRpb25zID0ge30pKTtcbnZhciBDb25uZWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJOZXdcIl0gPSAxXSA9IFwiTmV3XCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkxpc3RlbmluZ1wiXSA9IDJdID0gXCJMaXN0ZW5pbmdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiQ2xvc2VkXCJdID0gM10gPSBcIkNsb3NlZFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJEaXNwb3NlZFwiXSA9IDRdID0gXCJEaXNwb3NlZFwiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24obWVzc2FnZVJlYWRlciwgbWVzc2FnZVdyaXRlciwgX2xvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIgIT09IHVuZGVmaW5lZCA/IF9sb2dnZXIgOiBleHBvcnRzLk51bGxMb2dnZXI7XG4gICAgbGV0IHNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCB1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgY29uc3QgdmVyc2lvbiA9ICcyLjAnO1xuICAgIGxldCBzdGFyUmVxdWVzdEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub3RpZmljYXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9ncmVzc0hhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGxldCB0aW1lcjtcbiAgICBsZXQgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgIGxldCByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIGxldCBrbm93bkNhbmNlbGVkUmVxdWVzdHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IHJlcXVlc3RUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRyYWNlID0gVHJhY2UuT2ZmO1xuICAgIGxldCB0cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgbGV0IHRyYWNlcjtcbiAgICBsZXQgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTmV3O1xuICAgIGNvbnN0IGVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGRpc3Bvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25TdHJhdGVneSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpID8gb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSA6IENhbmNlbGxhdGlvblN0cmF0ZWd5Lk1lc3NhZ2U7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzZW5kIHJlcXVlc3RzIHdpdGggaWQgbnVsbCBzaW5jZSB0aGUgcmVzcG9uc2UgY2FuJ3QgYmUgY29ycmVsYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3JlcS0nICsgaWQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLXVua25vd24tJyArICgrK3Vua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSB7XG4gICAgICAgIHJldHVybiAnbm90LScgKyAoKytub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTWVzc2FnZVRvUXVldWUocXVldWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXF1ZXN0UXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVzcG9uc2VRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkoKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsVW5kaXNwYXRjaGVkKF9tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTGlzdGVuaW5nKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc3Bvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUhhbmRsZXIoKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLk5ldyB8fCBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZykge1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgICAgICAgICAgY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpcyBkaXNwb3NlZCBkb24ndCBzZW50IGNsb3NlIGV2ZW50cy5cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShbZXJyb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRXJyb3JIYW5kbGVyKGRhdGEpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoZGF0YSk7XG4gICAgfVxuICAgIG1lc3NhZ2VSZWFkZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VSZWFkZXIub25FcnJvcihyZWFkRXJyb3JIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlV3JpdGVyLm9uRXJyb3Iod3JpdGVFcnJvckhhbmRsZXIpO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmICh0aW1lciB8fCBtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1Jlc3BvbnNlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdHJhdGVneSA9IG9wdGlvbnM/Lm1lc3NhZ2VTdHJhdGVneTtcbiAgICAgICAgICAgIGlmIChNZXNzYWdlU3RyYXRlZ3kuaXMobWVzc2FnZVN0cmF0ZWd5KSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VTdHJhdGVneS5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgY2FuY2VsbGF0aW9uIG1lc3NhZ2UuIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIHN0aWxsIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgLy8gYW5kIGNhbmNlbCBpdCBpZiBhbGxvd2VkIHRvIGRvIHNvLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc05vdGlmaWNhdGlvbihtZXNzYWdlKSAmJiBtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ2FuY2VsID0gbWVzc2FnZVF1ZXVlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KHRvQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IG9wdGlvbnM/LmNvbm5lY3Rpb25TdHJhdGVneTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoc3RyYXRlZ3kgJiYgc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKSA/IHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCwgY2FuY2VsVW5kaXNwYXRjaGVkKSA6IGNhbmNlbFVuZGlzcGF0Y2hlZCh0b0NhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2UuZXJyb3IgIT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gdG9DYW5jZWwuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShyZXNwb25zZSwgbWVzc2FnZS5tZXRob2QsIERhdGUubm93KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShyZXNwb25zZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZvciBjYW5jZWxlZCBtZXNzYWdlIGZhaWxlZC5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1ZXN0VG9rZW5zLmdldChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBydW5uaW5nLiBDYW5jZWwgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBjYW5jZWwgYnV0IHN0aWxsIHF1ZXVlIHRoZSBtZXNzYWdlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwIHN0YXRlIGluIHByb2Nlc3MgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmFkZChjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkTWVzc2FnZVRvUXVldWUobWVzc2FnZVF1ZXVlLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyaWdnZXJNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBzaWxlbnRseSBzaW5jZSB3ZSBmaXJlZCBhbiBldmVudCB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHkocmVzdWx0T3JFcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0T3JFcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSByZXN1bHRPckVycm9yLnRvSnNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHQgPSByZXN1bHRPckVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogcmVzdWx0T3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlFcnJvcihlcnJvciwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnRvSnNvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseVN1Y2Nlc3MocmVzdWx0LCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gVGhlIEpTT04gUlBDIGRlZmluZXMgdGhhdCBhIHJlc3BvbnNlIG11c3QgZWl0aGVyIGhhdmUgYSByZXN1bHQgb3IgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbid0IHRyZWF0IHVuZGVmaW5lZCBhcyBhIHZhbGlkIHJlc3BvbnNlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZVJlY2VpdmVkUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSByZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3RNZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgcmVxdWVzdEhhbmRsZXI7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyIHx8IHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5LZXkgPSByZXF1ZXN0TWVzc2FnZS5pZCA/PyBTdHJpbmcoRGF0ZS5ub3coKSk7IC8vXG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Tb3VyY2UgPSBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMoY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIpXG4gICAgICAgICAgICAgICAgPyBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSh0b2tlbktleSlcbiAgICAgICAgICAgICAgICA6IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCAmJiBrbm93bkNhbmNlbGVkUmVxdWVzdHMuaGFzKHJlcXVlc3RNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblNvdXJjZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuc2V0KHRva2VuS2V5LCBjYW5jZWxsYXRpb25Tb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0TWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoLi4ucmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSBzdGFyUmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UubWV0aG9kLCByZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlclJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5U3VjY2VzcyhoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdE9yRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5KHJlc3VsdE9yRXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseShoYW5kbGVyUmVzdWx0LCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXBseShlcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgdW5leHBlY3RlZGx5IHdpdGhvdXQgcHJvdmlkaW5nIGFueSBkZXRhaWxzLmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXRob2ROb3RGb3VuZCwgYFVuaGFuZGxlZCBtZXRob2QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZDogRXJyb3IgaXM6IFxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2VNZXNzYWdlLmVycm9yLCB1bmRlZmluZWQsIDQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQuIE5vIGZ1cnRoZXIgZXJyb3IgaW5mb3JtYXRpb24gcHJvdmlkZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZFJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXNwb25zZU1lc3NhZ2UuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBub3RpZmljYXRpb25IYW5kbGVyO1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsSWQgPSBtZXNzYWdlLnBhcmFtcy5pZDtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5kZWxldGUoY2FuY2VsSWQpO1xuICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub3RpZmljYXRpb25IYW5kbGVycy5nZXQobWVzc2FnZS5tZXRob2QpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIgfHwgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyAhPT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCBub25lLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIEpTT04tUlBDIGxpYnJhcmllcyB0aGF0IHNlbmQgcHJvZ3Jlc3MgbWVzc2FnZSBhcyBwb3NpdGlvbmFsIHBhcmFtcyBhbHRob3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGFzIG5hbWVkLiBTbyBjb252ZXJ0IHRoZW0gaWYgdGhpcyBpcyB0aGUgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCAmJiBwYXJhbXMubGVuZ3RoID09PSAyICYmIFByb2dyZXNzVG9rZW4uaXMocGFyYW1zWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoeyB0b2tlbjogcGFyYW1zWzBdLCB2YWx1ZTogcGFyYW1zWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm51bWJlck9mUGFyYW1zICE9PSBtZXNzYWdlLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkICR7cGFyYW1zLmxlbmd0aH0gYXJndW1lbnRzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIuZmlyZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdSZWNlaXZlZCBlbXB0eSBtZXNzYWdlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSB3aGljaCBpcyBuZWl0aGVyIGEgcmVzcG9uc2Ugbm9yIGEgbm90aWZpY2F0aW9uIG1lc3NhZ2U6XFxuJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLCBudWxsLCA0KX1gKTtcbiAgICAgICAgLy8gVGVzdCB3aGV0aGVyIHdlIGZpbmQgYW4gaWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChJcy5zdHJpbmcocmVzcG9uc2VNZXNzYWdlLmlkKSB8fCBJcy5udW1iZXIocmVzcG9uc2VNZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhbmRsZXIucmVqZWN0KG5ldyBFcnJvcignVGhlIHJlY2VpdmVkIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciBwcm9wZXJ0eS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5VHJhY2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cmFjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5WZXJib3NlOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDQpO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXNwb25zZSAnJHttZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy4gUHJvY2Vzc2luZyByZXF1ZXN0IHRvb2sgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpICYmIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlciB8fCBtZXNzYWdlLm1ldGhvZCA9PT0gTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShtZXNzYWdlLCByZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAmJiBtZXNzYWdlLmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBFcnJvciBkYXRhOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UuZXJyb3IuZGF0YSl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBSZXN1bHQ6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5yZXN1bHQpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHJlc3VsdCByZXR1cm5lZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbWVzc2FnZS5lcnJvciA/IGAgUmVxdWVzdCBmYWlsZWQ6ICR7bWVzc2FnZS5lcnJvci5tZXNzYWdlfSAoJHttZXNzYWdlLmVycm9yLmNvZGV9KS5gIDogJyc7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknIGluICR7RGF0ZS5ub3coKSAtIHJlc3BvbnNlUHJvbWlzZS50aW1lclN0YXJ0fW1zLiR7ZXJyb3J9YCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAke21lc3NhZ2UuaWR9IHdpdGhvdXQgYWN0aXZlIHJlc3BvbnNlIHByb21pc2UuYCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdyZWNlaXZlLXJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nTFNQTWVzc2FnZSh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdHJhY2VyIHx8IHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsc3BNZXNzYWdlID0ge1xuICAgICAgICAgICAgaXNMU1BNZXNzYWdlOiB0cnVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgdHJhY2VyLmxvZyhsc3BNZXNzYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKSB7XG4gICAgICAgIGlmIChpc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQ2xvc2VkLCAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkRpc3Bvc2VkLCAnQ29ubmVjdGlvbiBpcyBkaXNwb3NlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkFscmVhZHlMaXN0ZW5pbmcsICdDb25uZWN0aW9uIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZk5vdExpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKCFpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGwgbGlzdGVuKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5kZWZpbmVkVG9OdWxsKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBudWxsVG9VbmRlZmluZWQocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWRQYXJhbShwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gIT09IHVuZGVmaW5lZCAmJiBwYXJhbSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbSkgJiYgdHlwZW9mIHBhcmFtID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtKSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW1ldGVyU3RydWN0dXJlcykge1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bzpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lOlxuICAgICAgICAgICAgICAgIGlmICghaXNOYW1lZFBhcmFtKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcGFyYW0gaXMgbm90IGFuIG9iamVjdCBsaXRlcmFsLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKTtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBzdHJ1Y3R1cmUgJHtwYXJhbWV0ZXJTdHJ1Y3R1cmVzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wdXRlU2luZ2xlUGFyYW0odHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGggJiYgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkVG9OdWxsKHBhcmFtc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8IG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgc2VuZE5vdGlmaWNhdGlvbjogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgbm90aWZpY2F0aW9uIHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZVdyaXRlci53cml0ZShub3RpZmljYXRpb25NZXNzYWdlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgbm90aWZpY2F0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk5vdGlmaWNhdGlvbjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgaWYgKElzLmZ1bmModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZSwgeyB0eXBlOiB1bmRlZmluZWQsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc0hhbmRsZXJzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyZXNzIGhhbmRsZXIgZm9yIHRva2VuICR7dG9rZW59IGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5zZXQodG9rZW4sIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuZGVsZXRlKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUHJvZ3Jlc3M6IChfdHlwZSwgdG9rZW4sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYXdhaXQgYnV0IHNpbXBsZSByZXR1cm4gdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhbm90aGVyXG4gICAgICAgICAgICAvLyBhc3luYyBzY2hlZHVsaW5nLiBPdGhlcndpc2Ugb25lIHNlbmQgY291bGQgb3ZlcnRha2UgYW5vdGhlciBzZW5kLlxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCB7IHRva2VuLCB2YWx1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VbmhhbmRsZWRQcm9ncmVzczogdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmV2ZW50LFxuICAgICAgICBzZW5kUmVxdWVzdDogKHR5cGUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICB0aHJvd0lmTm90TGlzdGVuaW5nKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VQYXJhbXM7XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1FbmQgPSBwYXJhbUVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSBwYXJhbUVuZCAtIHBhcmFtU3RhcnQ7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgYXJnc1twYXJhbVN0YXJ0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCAke251bWJlck9mUGFyYW1zfSBwYXJhbWV0ZXJzIGZvciAnYnkgTmFtZScgcmVxdWVzdCBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW4uaXMocGFyYW1zW251bWJlck9mUGFyYW1zXSkgPyBwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXF1ZW5jZU51bWJlcisrO1xuICAgICAgICAgICAgbGV0IGRpc3Bvc2FibGU7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlID0gdG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLnNlbmRDYW5jZWxsYXRpb24oY29ubmVjdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZWNlaXZlZCBubyBwcm9taXNlIGZyb20gY2FuY2VsbGF0aW9uIHN0cmF0ZWd5IHdoZW4gY2FuY2VsbGluZyBpZCAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgY2FuY2VsbGF0aW9uIG1lc3NhZ2VzIGZvciBpZCAke2lkfSBmYWlsZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IG1lc3NhZ2VQYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmVuYWJsZUNhbmNlbGxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24ocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlV2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlamVjdFdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuY2xlYW51cChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGU/LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHsgbWV0aG9kOiBtZXRob2QsIHRpbWVyU3RhcnQ6IERhdGUubm93KCksIHJlc29sdmU6IHJlc29sdmVXaXRoQ2xlYW51cCwgcmVqZWN0OiByZWplY3RXaXRoQ2xlYW51cCB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lc3NhZ2VXcml0ZXIud3JpdGUocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLnNldChpZCwgcmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXF1ZXN0IGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGluZyB0aGUgbWVzc2FnZSBmYWlsZWQuIFNvIHdlIG5lZWQgdG8gcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yLCBlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIHJlYXNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChTdGFyUmVxdWVzdEhhbmRsZXIuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUsIHsgaGFuZGxlcjogaGFuZGxlciwgdHlwZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUGVuZGluZ1Jlc3BvbnNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcy5zaXplID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2U6IGFzeW5jIChfdmFsdWUsIF90cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgbGV0IF9zZW5kTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgIGlmIChzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChJcy5ib29sZWFuKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdHJhY2VGb3JtYXQgPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMudHJhY2VGb3JtYXQgfHwgVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0ID0gX3RyYWNlRm9ybWF0O1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSBfdHJhY2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSwgeyB2YWx1ZTogVHJhY2UudG9TdHJpbmcoX3ZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZXJyb3JFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkNsb3NlOiBjbG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkRpc3Bvc2U6IGRpc3Bvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQsICdQZW5kaW5nIHJlc3BvbnNlIHJlamVjdGVkIHNpbmNlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgcmVzcG9uc2VQcm9taXNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZkxpc3RlbmluZygpO1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5saXN0ZW4oY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5sb2coJ2luc3BlY3QnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlID0gdHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHZlcmJvc2UgPyBwYXJhbXMudmVyYm9zZSA6IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9ncmVzc0hhbmRsZXJzLmdldChwYXJhbXMudG9rZW4pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmZpcmUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODQ0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZvaWQgMDtcbnZhciBEaXNwb3NhYmxlO1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlIHx8IChleHBvcnRzLkRpc3Bvc2FibGUgPSBEaXNwb3NhYmxlID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjQ3OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0gRXZlbnQgPSB7fSkpO1xuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcbiAgICBhZGQoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Y2tldCkpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzW2ldID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrICYgY29udGV4dCBtYXRjaCA9PiByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gYWRkaW5nIGEgbGlzdGVuZXIgd2l0aCBhIGNvbnRleHQsIHlvdSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggdGhlIHNhbWUgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gW10sIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5zbGljZSgwKSwgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cy5zbGljZSgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dHNbaV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgKi9cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBhZnRlciBlbWl0dGVyIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5yZW1vdmUobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cbiAgICAgKiBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmludm9rZS5jYWxsKHRoaXMuX2NhbGxiYWNrcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuRW1pdHRlci5fbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjYxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTEwOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5MaW5rZWRNYXAgPSBleHBvcnRzLlRvdWNoID0gdm9pZCAwO1xudmFyIFRvdWNoO1xuKGZ1bmN0aW9uIChUb3VjaCkge1xuICAgIFRvdWNoLk5vbmUgPSAwO1xuICAgIFRvdWNoLkZpcnN0ID0gMTtcbiAgICBUb3VjaC5Bc09sZCA9IFRvdWNoLkZpcnN0O1xuICAgIFRvdWNoLkxhc3QgPSAyO1xuICAgIFRvdWNoLkFzTmV3ID0gVG91Y2guTGFzdDtcbn0pKFRvdWNoIHx8IChleHBvcnRzLlRvdWNoID0gVG91Y2ggPSB7fSkpO1xuY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9hID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IFRvdWNoLkZpcnN0ICYmIHRvdWNoICE9PSBUb3VjaC5MYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gVG91Y2guRmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlIGF0IGhlYWRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkxhc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rZWRNYXAgPSBMaW5rZWRNYXA7XG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0IHJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgfVxuICAgIHNldCByYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guQXNOZXcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIFRvdWNoLk5vbmUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgVG91Y2guTGFzdCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODA1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRvQXBwZW5kID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IHRoaXMuZnJvbVN0cmluZyhjaHVuaywgdGhpcy5fZW5jb2RpbmcpIDogY2h1bms7XG4gICAgICAgIHRoaXMuX2NodW5rcy5wdXNoKHRvQXBwZW5kKTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggKz0gdG9BcHBlbmQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ5UmVhZEhlYWRlcnMobG93ZXJDYXNlS2V5cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHJvdzogd2hpbGUgKGNodW5rSW5kZXggPCB0aGlzLl9jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb2x1bW46IHdoaWxlIChvZmZzZXQgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rW29mZnNldF07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rQnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjaHVua0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWZmZXIgY29udGFpbnMgdGhlIHR3byBDUkxGIGF0IHRoZSBlbmQuIFNvIHdlIHdpbGxcbiAgICAgICAgLy8gaGF2ZSB0d28gZW1wdHkgbGluZXMgYWZ0ZXIgdGhlIHNwbGl0IGF0IHRoZSBlbmQgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZChjaHVua0J5dGVzUmVhZCArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMudG9TdHJpbmcoYnVmZmVyLCAnYXNjaWknKS5zcGxpdChDUkxGKTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBoZWFkZXIgbXVzdCBzZXBhcmF0ZSBrZXkgYW5kIHZhbHVlIHVzaW5nICc6J1xcbiR7aGVhZGVyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnN1YnN0cigwLCBpbmRleCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGxvd2VyQ2FzZUtleXMgPyBrZXkudG9Mb3dlckNhc2UoKSA6IGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyeVJlYWRCb2R5KGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fdG90YWxMZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQobGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IG51bWJlck9mQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbExlbmd0aDtcbiAgICB9XG4gICAgX3JlYWQoYnl0ZUNvdW50KSB7XG4gICAgICAgIGlmIChieXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVDb3VudCA+IHRoaXMuX3RvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWFkIHNvIG1hbnkgYnl0ZXMhYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID09PSBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIHN1cGVyIGZhc3QgcGF0aCwgcHJlY2lzZWx5IGZpcnN0IGNodW5rIG11c3QgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc05hdGl2ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBmYXN0IHBhdGgsIHRoZSByZWFkaW5nIGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgZmlyc3QgY2h1bmtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc05hdGl2ZShjaHVuaywgYnl0ZUNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rc1swXSA9IGNodW5rLnNsaWNlKGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb2NOYXRpdmUoYnl0ZUNvdW50KTtcbiAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPiBieXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNodW5rIHdpbGwgc3Vydml2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFydCA9IGNodW5rLnNsaWNlKDAsIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVua1BhcnQsIHJlc3VsdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ICs9IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIGJlIGVudGlyZWx5IHJlYWRcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rLCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IEFic3RyYWN0TWVzc2FnZUJ1ZmZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3Qgc2VtYXBob3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxOCk7XG52YXIgTWVzc2FnZVJlYWRlcjtcbihmdW5jdGlvbiAoTWVzc2FnZVJlYWRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5saXN0ZW4pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpICYmXG4gICAgICAgICAgICBJcy5mdW5jKGNhbmRpZGF0ZS5vbkVycm9yKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vblBhcnRpYWxNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVJlYWRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVJlYWRlciB8fCAoZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gTWVzc2FnZVJlYWRlciA9IHt9KSk7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgZ2V0IG9uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUodGhpcy5hc0Vycm9yKGVycm9yKSk7XG4gICAgfVxuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBnZXQgb25QYXJ0aWFsTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlUGFydGlhbE1lc3NhZ2UoaW5mbykge1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5maXJlKGluZm8pO1xuICAgIH1cbiAgICBhc0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBSZWFkZXIgcmVjZWl2ZWQgZXJyb3IuIFJlYXNvbjogJHtJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBBYnN0cmFjdE1lc3NhZ2VSZWFkZXI7XG52YXIgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucztcbihmdW5jdGlvbiAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNoYXJzZXQ7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGxldCBjb250ZW50RGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudERlY29kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgY29udGVudFR5cGVEZWNvZGVyO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZURlY29kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hhcnNldCA9IG9wdGlvbnMgPz8gJ3V0Zi04JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQgPz8gJ3V0Zi04JztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnREZWNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlciA9IG9wdGlvbnMuY29udGVudERlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChjb250ZW50RGVjb2Rlci5uYW1lLCBjb250ZW50RGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlciBvZiBvcHRpb25zLmNvbnRlbnREZWNvZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXIgPSBvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjb2RlciBvZiBvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoZGVjb2Rlci5uYW1lLCBkZWNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZGVjb2RlcjtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGNvbnRlbnRUeXBlRGVjb2Rlci5uYW1lLCBjb250ZW50VHlwZURlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYXJzZXQsIGNvbnRlbnREZWNvZGVyLCBjb250ZW50RGVjb2RlcnMsIGNvbnRlbnRUeXBlRGVjb2RlciwgY29udGVudFR5cGVEZWNvZGVycyB9O1xuICAgIH1cbiAgICBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zLmZyb21PcHRpb25zID0gZnJvbU9wdGlvbnM7XG59KShSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zIHx8IChSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zID0ge30pKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocmVhZGFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHJlYWRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLm1lc3NhZ2VCdWZmZXIuY3JlYXRlKHRoaXMub3B0aW9ucy5jaGFyc2V0KTtcbiAgICAgICAgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0ID0gMTAwMDA7XG4gICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgdGhpcy5tZXNzYWdlVG9rZW4gPSAwO1xuICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUgPSBuZXcgc2VtYXBob3JlXzEuU2VtYXBob3JlKDEpO1xuICAgIH1cbiAgICBzZXQgcGFydGlhbE1lc3NhZ2VUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgZ2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dDtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgdGhpcy5tZXNzYWdlVG9rZW4gPSAwO1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWFkYWJsZS5vbkRhdGEoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbkVycm9yKChlcnJvcikgPT4gdGhpcy5maXJlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZS5vbkNsb3NlKCgpID0+IHRoaXMuZmlyZUNsb3NlKCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuYnVmZmVyLnRyeVJlYWRIZWFkZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKGBIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuXFxuJHtKU09OLnN0cmluZ2lmeShPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycykpfWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcihgQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4gR290ICR7Y29udGVudExlbmd0aH1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuYnVmZmVyLnRyeVJlYWRCb2R5KHRoaXMubmV4dE1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIFdlIGhhdmVuJ3QgcmVjZWl2ZWQgdGhlIGZ1bGwgbWVzc2FnZSB5ZXQuICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGNvbnZlcnQgb25lIHJlY2VpdmVkIG1lc3NhZ2UgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIuIE90aGVyd2lzZSBpdCBjb3VsZCBoYXBwZW4gdGhhdCBhIGRlY29kaW5nIG9mIGEgc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gc21hbGxlciBtZXNzYWdlIGZpbmlzaGVkIGJlZm9yZSB0aGUgZGVjb2Rpbmcgb2YgYSBmaXJzdCBsYXJnZXJcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGFuZCB0aGVuIHdlIHdvdWxkIGRlbGl2ZXIgdGhlIHNlY29uZCBtZXNzYWdlIGZpcnN0LlxuICAgICAgICAgICAgICAgIHRoaXMucmVhZFNlbWFwaG9yZS5sb2NrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIuZGVjb2RlKGJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyLmRlY29kZShieXRlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRUaW1lb3V0KCh0b2tlbiwgdGltZW91dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSB0aGlzLm1lc3NhZ2VUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBhcnRpYWxNZXNzYWdlKHsgbWVzc2FnZVRva2VuOiB0b2tlbiwgd2FpdGluZ1RpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCwgdGhpcy5tZXNzYWdlVG9rZW4sIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwMzY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuY29uc3Qgc2VtYXBob3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gTWVzc2FnZVdyaXRlciA9IHt9KSk7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvciwgbWVzc2FnZSwgY291bnQpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZmlyZShbdGhpcy5hc0Vycm9yKGVycm9yKSwgbWVzc2FnZSwgY291bnRdKTtcbiAgICB9XG4gICAgZ2V0IG9uQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGFzRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFdyaXRlciByZWNlaXZlZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZVdyaXRlciA9IEFic3RyYWN0TWVzc2FnZVdyaXRlcjtcbnZhciBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zO1xuKGZ1bmN0aW9uIChSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcnNldDogb3B0aW9ucyA/PyAndXRmLTgnLCBjb250ZW50VHlwZUVuY29kZXI6ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5lbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zLmNoYXJzZXQgPz8gJ3V0Zi04JywgY29udGVudEVuY29kZXI6IG9wdGlvbnMuY29udGVudEVuY29kZXIsIGNvbnRlbnRUeXBlRW5jb2Rlcjogb3B0aW9ucy5jb250ZW50VHlwZUVuY29kZXIgPz8gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zID0gZnJvbU9wdGlvbnM7XG59KShSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zIHx8IChSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zID0ge30pKTtcbmNsYXNzIFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyaXRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB3cml0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgdGhpcy53cml0ZVNlbWFwaG9yZSA9IG5ldyBzZW1hcGhvcmVfMS5TZW1hcGhvcmUoMSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICB9XG4gICAgYXN5bmMgd3JpdGUobXNnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlU2VtYXBob3JlLmxvY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMub3B0aW9ucy5jb250ZW50VHlwZUVuY29kZXIuZW5jb2RlKG1zZywgdGhpcy5vcHRpb25zKS50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb250ZW50RW5jb2Rlci5lbmNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gW107XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENvbnRlbnRMZW5ndGgsIGJ1ZmZlci5ieXRlTGVuZ3RoLnRvU3RyaW5nKCksIENSTEYpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChDUkxGKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb1dyaXRlKG1zZywgaGVhZGVycywgYnVmZmVyKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZG9Xcml0ZShtc2csIGhlYWRlcnMsIGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGFibGUud3JpdGUoaGVhZGVycy5qb2luKCcnKSwgJ2FzY2lpJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0YWJsZS53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZS5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MTYyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTcgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTQgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBleHBvcnRzLlJlcXVlc3RUeXBlOCA9IGV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBleHBvcnRzLlJlcXVlc3RUeXBlNSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBleHBvcnRzLlJlcXVlc3RUeXBlMiA9IGV4cG9ydHMuUmVxdWVzdFR5cGUxID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBleHBvcnRzLlBhcmFtZXRlclN0cnVjdHVyZXMgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkVycm9yQ29kZXMgPSB2b2lkIDA7XG5jb25zdCBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG4vKipcbiAqIFByZWRlZmluZWQgZXJyb3IgY29kZXMuXG4gKi9cbnZhciBFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChFcnJvckNvZGVzKSB7XG4gICAgLy8gRGVmaW5lZCBieSBKU09OIFJQQ1xuICAgIEVycm9yQ29kZXMuUGFyc2VFcnJvciA9IC0zMjcwMDtcbiAgICBFcnJvckNvZGVzLkludmFsaWRSZXF1ZXN0ID0gLTMyNjAwO1xuICAgIEVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQgPSAtMzI2MDE7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zID0gLTMyNjAyO1xuICAgIEVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciA9IC0zMjYwMztcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS4gTm8gYXBwbGljYXRpb24gZXJyb3IgY29kZXMgc2hvdWxkXG4gICAgICogYmUgZGVmaW5lZCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHJhbmdlLiBGb3IgYmFja3dhcmRzXG4gICAgICogY29tcGF0aWJpbGl0eSB0aGUgYFNlcnZlck5vdEluaXRpYWxpemVkYCBhbmQgdGhlIGBVbmtub3duRXJyb3JDb2RlYFxuICAgICAqIGFyZSBsZWZ0IGluIHRoZSByYW5nZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JTdGFydCA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHdyaXRlIGEgbWVzc2FnZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVdyaXRlRXJyb3IgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nIGEgbWVzc2FnZSBmcm9tIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlUmVhZEVycm9yID0gLTMyMDk4O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCBvciBsb3N0IGFuZCBhbGwgcGVuZGluZyByZXNwb25zZXMgZ290XG4gICAgICogcmVqZWN0ZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5QZW5kaW5nUmVzcG9uc2VSZWplY3RlZCA9IC0zMjA5NztcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBpbmFjdGl2ZSBhbmQgYSB1c2Ugb2YgaXQgZmFpbGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuQ29ubmVjdGlvbkluYWN0aXZlID0gLTMyMDk2O1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IGEgc2VydmVyIHJlY2VpdmVkIGEgbm90aWZpY2F0aW9uIG9yXG4gICAgICogcmVxdWVzdCBiZWZvcmUgdGhlIHNlcnZlciBoYXMgcmVjZWl2ZWQgdGhlIGBpbml0aWFsaXplYCByZXF1ZXN0LlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuU2VydmVyTm90SW5pdGlhbGl6ZWQgPSAtMzIwMDI7XG4gICAgRXJyb3JDb2Rlcy5Vbmtub3duRXJyb3JDb2RlID0gLTMyMDAxO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjAwMDtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvckVuZCA9IC0zMjAwMDtcbn0pKEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuRXJyb3JDb2RlcyA9IEVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBBbiBlcnJvciBvYmplY3QgcmV0dXJuIGluIGEgcmVzcG9uc2UgaW4gY2FzZSBhIHJlcXVlc3RcbiAqIGhhcyBmYWlsZWQuXG4gKi9cbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gaXMubnVtYmVyKGNvZGUpID8gY29kZSA6IEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJlc3BvbnNlRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IFJlc3BvbnNlRXJyb3I7XG5jbGFzcyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byB8fCB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUgfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQ7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcztcbi8qKlxuICogVGhlIHBhcmFtZXRlciBzdHJ1Y3R1cmUgaXMgYXV0b21hdGljYWxseSBpbmZlcnJlZCBvbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnNcbiAqIGFuZCB0aGUgcGFyYW1ldGVyIHR5cGUgaW4gY2FzZSBvZiBhIHNpbmdsZSBwYXJhbS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2F1dG8nKTtcbi8qKlxuICogRm9yY2VzIGBieVBvc2l0aW9uYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgaGF2ZSBhIHNpbmdsZVxuICogcGFyYW1ldGVyIHdoaWNoIGhhcyBhIGxpdGVyYWwgdHlwZS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5UG9zaXRpb24nKTtcbi8qKlxuICogRm9yY2VzIGBieU5hbWVgIHBhcmFtZXRlciBzdHJ1Y3R1cmUuIFRoaXMgaXMgb25seSB1c2VmdWwgd2hlbiBoYXZpbmcgYSBzaW5nbGVcbiAqIHBhcmFtZXRlci4gVGhlIGxpYnJhcnkgd2lsbCByZXBvcnQgZXJyb3JzIGlmIHVzZWQgd2l0aCBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5TmFtZScpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIE1lc3NhZ2VUeXBlLlxuICovXG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbXMgPSBudW1iZXJPZlBhcmFtcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmU7XG4vKipcbiAqIENsYXNzZXMgdG8gdHlwZSByZXF1ZXN0IHJlc3BvbnNlIHBhaXJzXG4gKi9cbmNsYXNzIFJlcXVlc3RUeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBSZXF1ZXN0VHlwZTA7XG5jbGFzcyBSZXF1ZXN0VHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlID0gUmVxdWVzdFR5cGU7XG5jbGFzcyBSZXF1ZXN0VHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBSZXF1ZXN0VHlwZTE7XG5jbGFzcyBSZXF1ZXN0VHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gUmVxdWVzdFR5cGUyO1xuY2xhc3MgUmVxdWVzdFR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMyA9IFJlcXVlc3RUeXBlMztcbmNsYXNzIFJlcXVlc3RUeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBSZXF1ZXN0VHlwZTQ7XG5jbGFzcyBSZXF1ZXN0VHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gUmVxdWVzdFR5cGU1O1xuY2xhc3MgUmVxdWVzdFR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNiA9IFJlcXVlc3RUeXBlNjtcbmNsYXNzIFJlcXVlc3RUeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBSZXF1ZXN0VHlwZTc7XG5jbGFzcyBSZXF1ZXN0VHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gUmVxdWVzdFR5cGU4O1xuY2xhc3MgUmVxdWVzdFR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOSA9IFJlcXVlc3RUeXBlOTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gTm90aWZpY2F0aW9uVHlwZTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gTm90aWZpY2F0aW9uVHlwZTE7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IE5vdGlmaWNhdGlvblR5cGUyO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBOb3RpZmljYXRpb25UeXBlMztcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU0IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gTm90aWZpY2F0aW9uVHlwZTQ7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IE5vdGlmaWNhdGlvblR5cGU1O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDYpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBOb3RpZmljYXRpb25UeXBlNjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU3IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gTm90aWZpY2F0aW9uVHlwZTc7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IE5vdGlmaWNhdGlvblR5cGU4O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBOb3RpZmljYXRpb25UeXBlOTtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXF1ZXN0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkpO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzUmVxdWVzdCA9IGlzUmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiBtZXNzYWdlLmlkID09PSB2b2lkIDA7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNOb3RpZmljYXRpb24gPSBpc05vdGlmaWNhdGlvbjtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLnJlc3VsdCAhPT0gdm9pZCAwIHx8ICEhY2FuZGlkYXRlLmVycm9yKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkgfHwgY2FuZGlkYXRlLmlkID09PSBudWxsKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1Jlc3BvbnNlID0gaXNSZXNwb25zZTtcbn0pKE1lc3NhZ2UgfHwgKGV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2UgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5sZXQgX3JhbDtcbmZ1bmN0aW9uIFJBTCgpIHtcbiAgICBpZiAoX3JhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBpbnN0YWxsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yYWw7XG59XG4oZnVuY3Rpb24gKFJBTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwocmFsKSB7XG4gICAgICAgIGlmIChyYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgX3JhbCA9IHJhbDtcbiAgICB9XG4gICAgUkFMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUkFMIHx8IChSQUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSQUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hcGhvcmUgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5ID0gMSkge1xuICAgICAgICBpZiAoY2FwYWNpdHkgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5fd2FpdGluZyA9IFtdO1xuICAgIH1cbiAgICBsb2NrKHRodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nLnB1c2goeyB0aHVuaywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICBydW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmRvUnVuTmV4dCgpKTtcbiAgICB9XG4gICAgZG9SdW5OZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fd2FpdGluZy5sZW5ndGggPT09IDAgfHwgdGhpcy5fYWN0aXZlID09PSB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl93YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSsrO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlID4gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG8gbWFueSB0aHVua3MgYWN0aXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQudGh1bmsoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgICAgIG5leHQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS0tO1xuICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZW1hcGhvcmUgPSBTZW1hcGhvcmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0ODk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gdm9pZCAwO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xudmFyIENhbmNlbGxhdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TdGF0ZSkge1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNvbnRpbnVlID0gMDtcbiAgICBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQgPSAxO1xufSkoQ2FuY2VsbGF0aW9uU3RhdGUgfHwgKENhbmNlbGxhdGlvblN0YXRlID0ge30pKTtcbmNsYXNzIFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGVuYWJsZUNhbmNlbGxhdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKDQpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgZGF0YVswXSA9IENhbmNlbGxhdGlvblN0YXRlLkNvbnRpbnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuc2V0KHJlcXVlc3QuaWQsIGJ1ZmZlcik7XG4gICAgICAgIHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGEgPSBidWZmZXI7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRDYW5jZWxsYXRpb24oX2Nvbm4sIGlkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVycy5nZXQoaWQpO1xuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICAgICAgQXRvbWljcy5zdG9yZShkYXRhLCAwLCBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQpO1xuICAgIH1cbiAgICBjbGVhbnVwKGlkKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuY2xlYXIoKTtcbiAgICB9XG59XG5leHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5O1xuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbiB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIEF0b21pY3MubG9hZCh0aGlzLmRhdGEsIDApID09PSBDYW5jZWxsYXRpb25TdGF0ZS5DYW5jZWxsZWQ7XG4gICAgfVxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5jZWxsYXRpb24gb3ZlciBTaGFyZWRBcnJheUJ1ZmZlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsbGF0aW9uIGV2ZW50c2ApO1xuICAgIH1cbn1cbmNsYXNzIFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLnRva2VuID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4oYnVmZmVyKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgIH1cbn1cbmNsYXNzIFNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMua2luZCA9ICdyZXF1ZXN0JztcbiAgICB9XG4gICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSByZXF1ZXN0LiRjYW5jZWxsYXRpb25EYXRhO1xuICAgICAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTUwMTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjA4KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMDgpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNDcpLCBleHBvcnRzKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCBicm93c2VyXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxNDc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxTUEVycm9yQ29kZXMgPSBleHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NTIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MTUpLCBleHBvcnRzKTtcbnZhciBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uOyB9IH0pKTtcbnZhciBMU1BFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChMU1BFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyODk5O1xuICAgIC8qKlxuICAgICAqIEEgcmVxdWVzdCBmYWlsZWQgYnV0IGl0IHdhcyBzeW50YWN0aWNhbGx5IGNvcnJlY3QsIGUuZyB0aGVcbiAgICAgKiBtZXRob2QgbmFtZSB3YXMga25vd24gYW5kIHRoZSBwYXJhbWV0ZXJzIHdlcmUgdmFsaWQuIFRoZSBlcnJvclxuICAgICAqIG1lc3NhZ2Ugc2hvdWxkIGNvbnRhaW4gaHVtYW4gcmVhZGFibGUgaW5mb3JtYXRpb24gYWJvdXQgd2h5XG4gICAgICogdGhlIHJlcXVlc3QgZmFpbGVkLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdEZhaWxlZCA9IC0zMjgwMztcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGNhbmNlbGxlZCB0aGUgcmVxdWVzdC4gVGhpcyBlcnJvciBjb2RlIHNob3VsZFxuICAgICAqIG9ubHkgYmUgdXNlZCBmb3IgcmVxdWVzdHMgdGhhdCBleHBsaWNpdGx5IHN1cHBvcnQgYmVpbmdcbiAgICAgKiBzZXJ2ZXIgY2FuY2VsbGFibGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5TZXJ2ZXJDYW5jZWxsZWQgPSAtMzI4MDI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBkZXRlY3RlZCB0aGF0IHRoZSBjb250ZW50IG9mIGEgZG9jdW1lbnQgZ290XG4gICAgICogbW9kaWZpZWQgb3V0c2lkZSBub3JtYWwgY29uZGl0aW9ucy4gQSBzZXJ2ZXIgc2hvdWxkXG4gICAgICogTk9UIHNlbmQgdGhpcyBlcnJvciBjb2RlIGlmIGl0IGRldGVjdHMgYSBjb250ZW50IGNoYW5nZVxuICAgICAqIGluIGl0IHVucHJvY2Vzc2VkIG1lc3NhZ2VzLiBUaGUgcmVzdWx0IGV2ZW4gY29tcHV0ZWRcbiAgICAgKiBvbiBhbiBvbGRlciBzdGF0ZSBtaWdodCBzdGlsbCBiZSB1c2VmdWwgZm9yIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIGNsaWVudCBkZWNpZGVzIHRoYXQgYSByZXN1bHQgaXMgbm90IG9mIGFueSB1c2UgYW55bW9yZVxuICAgICAqIHRoZSBjbGllbnQgc2hvdWxkIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLkNvbnRlbnRNb2RpZmllZCA9IC0zMjgwMTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IGhhcyBjYW5jZWxlZCBhIHJlcXVlc3QgYW5kIGEgc2VydmVyIGFzIGRldGVjdGVkXG4gICAgICogdGhlIGNhbmNlbC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlJlcXVlc3RDYW5jZWxsZWQgPSAtMzI4MDA7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgTFNQIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgKlxuICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5sc3BSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzI4MDA7XG59KShMU1BFcnJvckNvZGVzIHx8IChleHBvcnRzLkxTUEVycm9yQ29kZXMgPSBMU1BFcnJvckNvZGVzID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKGlucHV0LCBvdXRwdXQsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmICh2c2NvZGVfanNvbnJwY18xLkNvbm5lY3Rpb25TdHJhdGVneS5pcyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBjb25uZWN0aW9uU3RyYXRlZ3k6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCB2c2NvZGVfanNvbnJwY18xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKShpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0MzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xudmFyIE1lc3NhZ2VEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VEaXJlY3Rpb24pIHtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wiY2xpZW50VG9TZXJ2ZXJcIl0gPSBcImNsaWVudFRvU2VydmVyXCI7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcInNlcnZlclRvQ2xpZW50XCJdID0gXCJzZXJ2ZXJUb0NsaWVudFwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJib3RoXCJdID0gXCJib3RoXCI7XG59KShNZXNzYWdlRGlyZWN0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gPSBNZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbmNsYXNzIFJlZ2lzdHJhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBSZWdpc3RyYXRpb25UeXBlO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZTAgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IFByb3RvY29sUmVxdWVzdFR5cGUwO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IFByb3RvY29sUmVxdWVzdFR5cGU7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMDtcbmNsYXNzIFByb3RvY29sTm90aWZpY2F0aW9uVHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgdnNjb2RlX2pzb25ycGNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2MDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXN1bHQgYSBgQ2FsbEhpZXJhcmNoeUl0ZW1gIGluIGEgZG9jdW1lbnQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAqIENhbiBiZSB1c2VkIGFzIGFuIGlucHV0IHRvIGFuIGluY29taW5nIG9yIG91dGdvaW5nIGNhbGwgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZUNhbGxIaWVyYXJjaHknO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW5jb21pbmcgY2FsbHMgZm9yIGEgZ2l2ZW4gYENhbGxIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXRob2QgPSAnY2FsbEhpZXJhcmNoeS9pbmNvbWluZ0NhbGxzJztcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgfHwgKGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0gQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIG91dGdvaW5nIGNhbGxzIGZvciBhIGdpdmVuIGBDYWxsSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QpIHtcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWV0aG9kID0gJ2NhbGxIaWVyYXJjaHkvb3V0Z29pbmdDYWxscyc7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXRob2QpO1xufSkoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3NDc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgY29sb3Igc3ltYm9scyBmb3VuZCBpbiBhIGdpdmVuIHRleHQgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudENvbG9yUGFyYW1zfSB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb24gQ29sb3JJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudENvbG9yUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRDb2xvclJlcXVlc3QpIHtcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50Q29sb3InO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50Q29sb3JSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Q29sb3JSZXF1ZXN0ID0gRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgcHJlc2VudGF0aW9uIGZvciBhIGNvbG9yLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb25QYXJhbXN9IHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbiBDb2xvckluZm9ybWF0aW9uW119IG9yIGEgVGhlbmFibGVcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29sb3JQcmVzZW50YXRpb24nO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjM5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vLy0tLS0gR2V0IENvbmZpZ3VyYXRpb24gcmVxdWVzdCAtLS0tXG4vKipcbiAqIFRoZSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCBhIGNlcnRhaW5cbiAqIGNvbmZpZ3VyYXRpb24gc2V0dGluZy5cbiAqXG4gKiBUaGlzIHB1bGwgbW9kZWwgcmVwbGFjZXMgdGhlIG9sZCBwdXNoIG1vZGVsIHdlcmUgdGhlIGNsaWVudCBzaWduYWxlZCBjb25maWd1cmF0aW9uIGNoYW5nZSB2aWEgYW5cbiAqIGV2ZW50LiBJZiB0aGUgc2VydmVyIHN0aWxsIG5lZWRzIHRvIHJlYWN0IHRvIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyAoc2luY2UgdGhlIHNlcnZlciBjYWNoZXMgdGhlXG4gKiByZXN1bHQgb2YgYHdvcmtzcGFjZS9jb25maWd1cmF0aW9uYCByZXF1ZXN0cykgdGhlIHNlcnZlciBzaG91bGQgcmVnaXN0ZXIgZm9yIGFuIGVtcHR5IGNvbmZpZ3VyYXRpb25cbiAqIGNoYW5nZSBldmVudCBhbmQgZW1wdHkgdGhlIGNhY2hlIGlmIHN1Y2ggYW4gZXZlbnQgaXMgcmVjZWl2ZWQuXG4gKi9cbnZhciBDb25maWd1cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29uZmlndXJhdGlvblJlcXVlc3QpIHtcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nO1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29uZmlndXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbmZpZ3VyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gQ29uZmlndXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlY2xhcmF0aW9ufSBvciBhIHR5cGVkIGFycmF5IG9mIHtAbGluayBEZWNsYXJhdGlvbkxpbmt9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERlY2xhcmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoRGVjbGFyYXRpb25SZXF1ZXN0KSB7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVjbGFyYXRpb24nO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWNsYXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKERlY2xhcmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSBEZWNsYXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDk0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTExMCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUucmV0cmlnZ2VyUmVxdWVzdCk7XG4gICAgfVxuICAgIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhLmlzID0gaXM7XG59KShEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSB8fCAoZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVwb3J0IGtpbmRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIGRpYWdub3N0aWMgcmVwb3J0IHdpdGggYSBmdWxsXG4gICAgICogc2V0IG9mIHByb2JsZW1zLlxuICAgICAqL1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQuRnVsbCA9ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBBIHJlcG9ydCBpbmRpY2F0aW5nIHRoYXQgdGhlIGxhc3RcbiAgICAgKiByZXR1cm5lZCByZXBvcnQgaXMgc3RpbGwgYWNjdXJhdGUuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5VbmNoYW5nZWQgPSAndW5jaGFuZ2VkJztcbn0pKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgfHwgKGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgZGlhZ25vc3RpYyByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCkge1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWFnbm9zdGljJztcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIHdvcmtzcGFjZSBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2RpYWdub3N0aWMnO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgcmVmcmVzaCByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9kaWFnbm9zdGljL3JlZnJlc2hgO1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc4MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSBwYXR0ZXJuIGtpbmQgZGVzY3JpYmluZyBpZiBhIGdsb2IgcGF0dGVybiBtYXRjaGVzIGEgZmlsZSBhIGZvbGRlciBvclxuICogYm90aC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7XG4oZnVuY3Rpb24gKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIG1hdGNoZXMgYSBmaWxlIG9ubHkuXG4gICAgICovXG4gICAgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kLmZpbGUgPSAnZmlsZSc7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdHRlcm4gbWF0Y2hlcyBhIGZvbGRlciBvbmx5LlxuICAgICAqL1xuICAgIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZC5mb2xkZXIgPSAnZm9sZGVyJztcbn0pKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCB8fCAoZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBjcmVhdGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGNyZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY3JlYXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIHJldHVybiBhIGBXb3Jrc3BhY2VFZGl0YCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gd29ya3NwYWNlIGJlZm9yZSB0aGVcbiAqIGZpbGVzIGFyZSBjcmVhdGVkLiBIZW5jZSB0aGUgYFdvcmtzcGFjZUVkaXRgIGNhbiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGUgZmlsZVxuICogdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxDcmVhdGVGaWxlcyc7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgY3JlYXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgY3JlYXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbikge1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ3JlYXRlRmlsZXMnO1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIHJlbmFtZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogcmVuYW1lZCBhcyBsb25nIGFzIHRoZSByZW5hbWUgaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsUmVuYW1lRmlsZXMnO1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIHJlbmFtZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIHJlbmFtZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZFJlbmFtZUZpbGVzJztcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBkZWxldGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGRlbGV0ZWQgYXMgbG9uZyBhcyB0aGUgZGVsZXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWREZWxldGVGaWxlcyc7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCBkZWxldGUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSBkZWxldGVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsRGVsZXRlRmlsZXMnO1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IFdpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgZm9sZGluZyByYW5nZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEZvbGRpbmdSYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlTGlzdH0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRm9sZGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb2xkaW5nUmFuZ2UnO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBGb2xkaW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKEZvbGRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IEZvbGRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xOC4wXG4gKiBAcHJvcG9zZWRcbiAqL1xudmFyIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvZm9sZGluZ1JhbmdlL3JlZnJlc2hgO1xuICAgIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShGb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCA9IEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW1wbGVtZW50YXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW1wbGVtZW50YXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbXBsZW1lbnRhdGlvblJlcXVlc3QpIHtcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbXBsZW1lbnRhdGlvbic7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoSW1wbGVtZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IEltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5sYXkgaGludHMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGF5SGludHNQYXJhbXN9LCB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIElubGF5SGludCBJbmxheUhpbnRbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVxdWVzdCkge1xuICAgIElubGF5SGludFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxheUhpbnQnO1xuICAgIElubGF5SGludFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxheUhpbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IElubGF5SGludFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIGFuIGlubGF5IGhpbnQuXG4gKiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBJbmxheUhpbnR9LCB0aGUgcmVzcG9uc2UgaXNcbiAqIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2lubGF5SGludC9yZXNvbHZlJztcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IElubGF5SGludFJlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlZnJlc2hSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxheUhpbnQvcmVmcmVzaGA7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzIyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lQ29tcGxldGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5saW5lIGNvbXBsZXRpb25zIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBJbmxpbmVDb21wbGV0aW9uUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVDb21wbGV0aW9uIElubGluZUNvbXBsZXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTguMFxuICogQHByb3Bvc2VkXG4gKi9cbnZhciBJbmxpbmVDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBJbmxpbmVDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZUNvbXBsZXRpb24nO1xuICAgIElubGluZUNvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5saW5lQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKElubGluZUNvbXBsZXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLklubGluZUNvbXBsZXRpb25SZXF1ZXN0ID0gSW5saW5lQ29tcGxldGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGluZSB2YWx1ZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGluZVZhbHVlUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVWYWx1ZSBJbmxpbmVWYWx1ZVtdfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZVZhbHVlJztcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lVmFsdWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gSW5saW5lVmFsdWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxpbmVWYWx1ZS9yZWZyZXNoYDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE4MTU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgPSBleHBvcnRzLlJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSBleHBvcnRzLlNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCA9IGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2F0Y2hLaW5kID0gZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5NZXNzYWdlVHlwZSA9IGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRXhpdE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IGV4cG9ydHMuVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciA9IHZvaWQgMDtcbmV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJLaW5kID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgPSBleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gdm9pZCAwO1xuZXhwb3J0cy5JbmxpbmVDb21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSBleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuY29uc3QgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NTIpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2MzMpO1xuY29uc3QgcHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzI4Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBsZW1lbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xLkltcGxlbWVudGF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjY0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVEZWZpbml0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEuVHlwZURlZmluaXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjM5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbmZpZ3VyYXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xLkNvbmZpZ3VyYXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzc0Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb2N1bWVudENvbG9yUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Eb2N1bWVudENvbG9yUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjAzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMS5Gb2xkaW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZGVjbGFyYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTU4MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kZWNsYXJhdGlvbl8xLkRlY2xhcmF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbGVjdGlvblJhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Byb2dyZXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNjYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MDIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbkZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuVG9rZW5Gb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Nob3dEb2N1bWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzMzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNob3dEb2N1bWVudFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zaG93RG9jdW1lbnRfMS5TaG93RG9jdW1lbnRSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQ5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3ODEpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Njg0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzgzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9pbmxpbmVDb21wbGV0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMjIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5saW5lQ29tcGxldGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVDb21wbGV0aW9uXzEuSW5saW5lQ29tcGxldGlvblJlcXVlc3Q7IH0gfSkpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuc2NoZW1lKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnBhdHRlcm4pKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50RmlsdGVyID0gVGV4dERvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tEb2N1bWVudEZpbHRlcn0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tEb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLm5vdGVib29rVHlwZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5zY2hlbWUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUucGF0dGVybikpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50RmlsdGVyIHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBOb3RlYm9va0RvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLm5vdGVib29rKSB8fCBOb3RlYm9va0RvY3VtZW50RmlsdGVyLmlzKGNhbmRpZGF0ZS5ub3RlYm9vaykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmxhbmd1YWdlID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0gRG9jdW1lbnRTZWxlY3RvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBgY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHJlZ2lzdGVyIGEgbmV3IGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgUmVnaXN0cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVnaXN0cmF0aW9uUmVxdWVzdCkge1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC9yZWdpc3RlckNhcGFiaWxpdHknO1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBSZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKFJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCA9IFJlZ2lzdHJhdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYGNsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHVucmVnaXN0ZXIgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBVbnJlZ2lzdHJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKFVucmVnaXN0cmF0aW9uUmVxdWVzdCkge1xuICAgIFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3VucmVnaXN0ZXJDYXBhYmlsaXR5JztcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShVbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCB8fCAoZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBSZXNvdXJjZU9wZXJhdGlvbktpbmQgPSB7fSkpO1xudmFyIEZhaWx1cmVIYW5kbGluZ0tpbmQ7XG4oZnVuY3Rpb24gKEZhaWx1cmVIYW5kbGluZ0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyB0aGUgd29ya3NwYWNlIGNoYW5nZSBpcyBzaW1wbHkgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGNoYW5nZXMgcHJvdmlkZWRcbiAgICAgKiBmYWlscy4gQWxsIG9wZXJhdGlvbnMgZXhlY3V0ZWQgYmVmb3JlIHRoZSBmYWlsaW5nIG9wZXJhdGlvbiBzdGF5IGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuQWJvcnQgPSAnYWJvcnQnO1xuICAgIC8qKlxuICAgICAqIEFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLiBUaGF0IG1lYW5zIHRoZXkgZWl0aGVyIGFsbFxuICAgICAqIHN1Y2NlZWQgb3Igbm8gY2hhbmdlcyBhdCBhbGwgYXJlIGFwcGxpZWQgdG8gdGhlIHdvcmtzcGFjZS5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlRyYW5zYWN0aW9uYWwgPSAndHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHdvcmtzcGFjZSBlZGl0IGNvbnRhaW5zIG9ubHkgdGV4dHVhbCBmaWxlIGNoYW5nZXMgdGhleSBhcmUgZXhlY3V0ZWQgdHJhbnNhY3Rpb25hbC5cbiAgICAgKiBJZiByZXNvdXJjZSBjaGFuZ2VzIChjcmVhdGUsIHJlbmFtZSBvciBkZWxldGUgZmlsZSkgYXJlIHBhcnQgb2YgdGhlIGNoYW5nZSB0aGUgZmFpbHVyZVxuICAgICAqIGhhbmRsaW5nIHN0cmF0ZWd5IGlzIGFib3J0LlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVGV4dE9ubHlUcmFuc2FjdGlvbmFsID0gJ3RleHRPbmx5VHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0cmllcyB0byB1bmRvIHRoZSBvcGVyYXRpb25zIGFscmVhZHkgZXhlY3V0ZWQuIEJ1dCB0aGVyZSBpcyBub1xuICAgICAqIGd1YXJhbnRlZSB0aGF0IHRoaXMgaXMgc3VjY2VlZGluZy5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlVuZG8gPSAndW5kbyc7XG59KShGYWlsdXJlSGFuZGxpbmdLaW5kIHx8IChleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSBGYWlsdXJlSGFuZGxpbmdLaW5kID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBwb3NpdGlvbiBlbmNvZGluZyBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBQb3NpdGlvbkVuY29kaW5nS2luZDtcbihmdW5jdGlvbiAoUG9zaXRpb25FbmNvZGluZ0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtOCBjb2RlIHVuaXRzIChlLmcuIGJ5dGVzKS5cbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEY4ID0gJ3V0Zi04JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMTYgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgYW5kIG11c3QgYWx3YXlzIGJlIHN1cHBvcnRlZFxuICAgICAqIGJ5IHNlcnZlcnNcbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEYxNiA9ICd1dGYtMTYnO1xuICAgIC8qKlxuICAgICAqIENoYXJhY3RlciBvZmZzZXRzIGNvdW50IFVURi0zMiBjb2RlIHVuaXRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50YXRpb24gbm90ZTogdGhlc2UgYXJlIHRoZSBzYW1lIGFzIFVuaWNvZGUgY29kZXBvaW50cyxcbiAgICAgKiBzbyB0aGlzIGBQb3NpdGlvbkVuY29kaW5nS2luZGAgbWF5IGFsc28gYmUgdXNlZCBmb3IgYW5cbiAgICAgKiBlbmNvZGluZy1hZ25vc3RpYyByZXByZXNlbnRhdGlvbiBvZiBjaGFyYWN0ZXIgb2Zmc2V0cy5cbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEYzMiA9ICd1dGYtMzInO1xufSkoUG9zaXRpb25FbmNvZGluZ0tpbmQgfHwgKGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSBQb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5kb2N1bWVudFNlbGVjdG9yID09PSBudWxsIHx8IERvY3VtZW50U2VsZWN0b3IuaXMoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBXb3JrRG9uZVByb2dyZXNzT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLndvcmtEb25lUHJvZ3Jlc3MgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzKSk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmlzID0gaXM7XG4gICAgZnVuY3Rpb24gaGFzV29ya0RvbmVQcm9ncmVzcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzKTtcbiAgICB9XG4gICAgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMuaGFzV29ya0RvbmVQcm9ncmVzcyA9IGhhc1dvcmtEb25lUHJvZ3Jlc3M7XG59KShXb3JrRG9uZVByb2dyZXNzT3B0aW9ucyB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0IHx8IChleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0ID0gSW5pdGlhbGl6ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBLbm93biBlcnJvciBjb2RlcyBmb3IgYW4gYEluaXRpYWxpemVFcnJvckNvZGVzYDtcbiAqL1xudmFyIEluaXRpYWxpemVFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplRXJyb3JDb2Rlcykge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcm90b2NvbCB2ZXJzaW9uIHByb3ZpZGVkIGJ5IHRoZSBjbGllbnQgY2FuJ3QgYmUgaGFuZGxlZCBieSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBpbml0aWFsaXplIGVycm9yIGdvdCByZXBsYWNlZCBieSBjbGllbnQgY2FwYWJpbGl0aWVzLiBUaGVyZSBpc1xuICAgICAqIG5vIHZlcnNpb24gaGFuZHNoYWtlIGluIHZlcnNpb24gMy4weFxuICAgICAqL1xuICAgIEluaXRpYWxpemVFcnJvckNvZGVzLnVua25vd25Qcm90b2NvbFZlcnNpb24gPSAxO1xufSkoSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBJbml0aWFsaXplRXJyb3JDb2RlcyA9IHt9KSk7XG4vKipcbiAqIFRoZSBpbml0aWFsaXplZCBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlXG4gKiBzZXJ2ZXIgYWZ0ZXIgdGhlIGNsaWVudCBpcyBmdWxseSBpbml0aWFsaXplZCBhbmQgdGhlIHNlcnZlclxuICogaXMgYWxsb3dlZCB0byBzZW5kIHJlcXVlc3RzIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LlxuICovXG52YXIgSW5pdGlhbGl6ZWROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEluaXRpYWxpemVkTm90aWZpY2F0aW9uKSB7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWV0aG9kID0gJ2luaXRpYWxpemVkJztcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKEluaXRpYWxpemVkTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uID0gSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgfHwgKGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0gU2h1dGRvd25SZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBFeGl0IE5vdGlmaWNhdGlvbiAtLS0tXG4vKipcbiAqIFRoZSBleGl0IGV2ZW50IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG9cbiAqIGFzayB0aGUgc2VydmVyIHRvIGV4aXQgaXRzIHByb2Nlc3MuXG4gKi9cbnZhciBFeGl0Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChFeGl0Tm90aWZpY2F0aW9uKSB7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnZXhpdCc7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEV4aXROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAoRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRXhpdE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uID0gRXhpdE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlclxuICogd2hlbiB0aGUgY2xpZW50J3MgY29uZmlndXJhdGlvbiBoYXMgY2hhbmdlZC4gVGhlIG5vdGlmaWNhdGlvbiBjb250YWluc1xuICogdGhlIGNoYW5nZWQgY29uZmlndXJhdGlvbiBhcyBkZWZpbmVkIGJ5IHRoZSBsYW5ndWFnZSBjbGllbnQuXG4gKi9cbnZhciBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZENoYW5nZUNvbmZpZ3VyYXRpb24nO1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uID0gRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xuICAgIC8qKlxuICAgICAqIEEgZGVidWcgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE4LjBcbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5EZWJ1ZyA9IDU7XG59KShNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlVHlwZSA9IE1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBTaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBzaG93IG1lc3NhZ2UgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNob3cgYSBtZXNzYWdlXG4gKiBhbmQgYSBzZXQgb2Ygb3B0aW9ucyBhY3Rpb25zIHRvIHRoZSB1c2VyLlxuICovXG52YXIgU2hvd01lc3NhZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZVJlcXVlc3QpIHtcbiAgICBTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93TWVzc2FnZVJlcXVlc3QnO1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dNZXNzYWdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgPSBTaG93TWVzc2FnZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbG9nIG1lc3NhZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyBhIHBhcnRpY3VsYXIgbWVzc2FnZS5cbiAqL1xudmFyIExvZ01lc3NhZ2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKExvZ01lc3NhZ2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvbG9nTWVzc2FnZSc7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShMb2dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShMb2dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24gPSBMb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgaG93IHRoZSBob3N0IChlZGl0b3IpIHNob3VsZCBzeW5jXG4gKiBkb2N1bWVudCBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTeW5jS2luZDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U3luY0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgc2hvdWxkIG5vdCBiZSBzeW5jZWQgYXQgYWxsLlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFN5bmNLaW5kLk5vbmUgPSAwO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBhcmUgc3luY2VkIGJ5IGFsd2F5cyBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnRcbiAgICAgKiBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbCA9IDE7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgc2VuZGluZyB0aGUgZnVsbCBjb250ZW50IG9uIG9wZW4uXG4gICAgICogQWZ0ZXIgdGhhdCBvbmx5IGluY3JlbWVudGFsIHVwZGF0ZXMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgICAqIHNlbmQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgPSAyO1xufSkoVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSBUZXh0RG9jdW1lbnRTeW5jS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBvcGVuIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIHNpZ25hbFxuICogbmV3bHkgb3BlbmVkIHRleHQgZG9jdW1lbnRzLiBUaGUgZG9jdW1lbnQncyB0cnV0aCBpcyBub3cgbWFuYWdlZCBieSB0aGUgY2xpZW50XG4gKiBhbmQgdGhlIHNlcnZlciBtdXN0IG5vdCB0cnkgdG8gcmVhZCB0aGUgZG9jdW1lbnQncyB0cnV0aCB1c2luZyB0aGUgZG9jdW1lbnQnc1xuICogdXJpLiBPcGVuIGluIHRoaXMgc2Vuc2UgbWVhbnMgaXQgaXMgbWFuYWdlZCBieSB0aGUgY2xpZW50LiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5XG4gKiBtZWFuIHRoYXQgaXRzIGNvbnRlbnQgaXMgcHJlc2VudGVkIGluIGFuIGVkaXRvci4gQW4gb3BlbiBub3RpZmljYXRpb24gbXVzdCBub3RcbiAqIGJlIHNlbnQgbW9yZSB0aGFuIG9uY2Ugd2l0aG91dCBhIGNvcnJlc3BvbmRpbmcgY2xvc2Ugbm90aWZpY2F0aW9uIHNlbmQgYmVmb3JlLlxuICogVGhpcyBtZWFucyBvcGVuIGFuZCBjbG9zZSBub3RpZmljYXRpb24gbXVzdCBiZSBiYWxhbmNlZCBhbmQgdGhlIG1heCBvcGVuIGNvdW50XG4gKiBpcyBvbmUuXG4gKi9cbnZhciBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZE9wZW4nO1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IHx8IChleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gc2lnbmFsXG4gKiBjaGFuZ2VzIHRvIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlkQ2hhbmdlJztcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgY2xvc2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogdGhlIGRvY3VtZW50IGdvdCBjbG9zZWQgaW4gdGhlIGNsaWVudC4gVGhlIGRvY3VtZW50J3MgdHJ1dGggbm93IGV4aXN0cyB3aGVyZVxuICogdGhlIGRvY3VtZW50J3MgdXJpIHBvaW50cyB0byAoZS5nLiBpZiB0aGUgZG9jdW1lbnQncyB1cmkgaXMgYSBmaWxlIHVyaSB0aGVcbiAqIHRydXRoIG5vdyBleGlzdHMgb24gZGlzaykuIEFzIHdpdGggdGhlIG9wZW4gbm90aWZpY2F0aW9uIHRoZSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGlzIGFib3V0IG1hbmFnaW5nIHRoZSBkb2N1bWVudCdzIGNvbnRlbnQuIFJlY2VpdmluZyBhIGNsb3NlIG5vdGlmaWNhdGlvblxuICogZG9lc24ndCBtZWFuIHRoYXQgdGhlIGRvY3VtZW50IHdhcyBvcGVuIGluIGFuIGVkaXRvciBiZWZvcmUuIEEgY2xvc2VcbiAqIG5vdGlmaWNhdGlvbiByZXF1aXJlcyBhIHByZXZpb3VzIG9wZW4gbm90aWZpY2F0aW9uIHRvIGJlIHNlbnQuXG4gKi9cbnZhciBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZENsb3NlJztcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgcmVhc29ucyB3aHkgYSB0ZXh0IGRvY3VtZW50IGlzIHNhdmVkLlxuICovXG52YXIgVGV4dERvY3VtZW50U2F2ZVJlYXNvbjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U2F2ZVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHRyaWdnZXJlZCwgZS5nLiBieSB0aGUgdXNlciBwcmVzc2luZyBzYXZlLCBieSBzdGFydGluZyBkZWJ1Z2dpbmcsXG4gICAgICogb3IgYnkgYW4gQVBJIGNhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWwgPSAxO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBhZnRlciBhIGRlbGF5LlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFNhdmVSZWFzb24uQWZ0ZXJEZWxheSA9IDI7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgZWRpdG9yIGxvc3QgZm9jdXMuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5Gb2N1c091dCA9IDM7XG59KShUZXh0RG9jdW1lbnRTYXZlUmVhc29uIHx8IChleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSBUZXh0RG9jdW1lbnRTYXZlUmVhc29uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCB3aWxsIHNhdmUgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuXG4gKi9cbnZhciBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3dpbGxTYXZlJztcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2F0Y2hlZCBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgY2xpZW50IGRldGVjdHMgY2hhbmdlcyB0byBmaWxlIHdhdGNoZWQgYnkgdGhlIGxhbmd1YWdlIGNsaWVudC5cbiAqL1xudmFyIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzJztcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZmlsZSBldmVudCB0eXBlXG4gKi9cbnZhciBGaWxlQ2hhbmdlVHlwZTtcbihmdW5jdGlvbiAoRmlsZUNoYW5nZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5DcmVhdGVkID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5DaGFuZ2VkID0gMjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5EZWxldGVkID0gMztcbn0pKEZpbGVDaGFuZ2VUeXBlIHx8IChleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0gRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gfHwgKGV4cG9ydHMuUmVsYXRpdmVQYXR0ZXJuID0gUmVsYXRpdmVQYXR0ZXJuID0ge30pKTtcbnZhciBXYXRjaEtpbmQ7XG4oZnVuY3Rpb24gKFdhdGNoS2luZCkge1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY3JlYXRlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ3JlYXRlID0gMTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGNoYW5nZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ2hhbmdlID0gMjtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGRlbGV0ZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuRGVsZXRlID0gNDtcbn0pKFdhdGNoS2luZCB8fCAoZXhwb3J0cy5XYXRjaEtpbmQgPSBXYXRjaEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEaWFnbm9zdGljcyBub3RpZmljYXRpb24gYXJlIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2lnbmFsXG4gKiByZXN1bHRzIG9mIHZhbGlkYXRpb24gcnVucy5cbiAqL1xudmFyIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uKSB7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHVibGlzaERpYWdub3N0aWNzJztcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kID0gQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXF1ZXN0IGNvbXBsZXRpb24gYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50UG9zaXRpb259IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0gQ29tcGxldGlvbkl0ZW1bXX0gb3Ige0BsaW5rIENvbXBsZXRpb25MaXN0fVxuICogb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIGRlbGF5IHRoZSBjb21wdXRhdGlvbiBvZiB0aGUge0BsaW5rIENvbXBsZXRpb25JdGVtLmRldGFpbCBgZGV0YWlsYH1cbiAqIGFuZCB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZG9jdW1lbnRhdGlvbiBgZG9jdW1lbnRhdGlvbmB9IHByb3BlcnRpZXMgdG8gdGhlIGBjb21wbGV0aW9uSXRlbS9yZXNvbHZlYFxuICogcmVxdWVzdC4gSG93ZXZlciwgcHJvcGVydGllcyB0aGF0IGFyZSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsIHNvcnRpbmcgYW5kIGZpbHRlcmluZywgbGlrZSBgc29ydFRleHRgLFxuICogYGZpbHRlclRleHRgLCBgaW5zZXJ0VGV4dGAsIGFuZCBgdGV4dEVkaXRgLCBtdXN0IG5vdCBiZSBjaGFuZ2VkIGR1cmluZyByZXNvbHZlLlxuICovXG52YXIgQ29tcGxldGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25SZXF1ZXN0KSB7XG4gICAgQ29tcGxldGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb21wbGV0aW9uJztcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbXBsZXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IENvbXBsZXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gY29tcGxldGlvbiBpdGVtLlRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbX0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCkge1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnY29tcGxldGlvbkl0ZW0vcmVzb2x2ZSc7XG4gICAgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgfHwgKGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0gSG92ZXJSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogSG93IGEgc2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZC5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyBpbnZva2VkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyIG9yIGJ5IGEgY29tbWFuZC5cbiAgICAgKi9cbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZCBieSBhIHRyaWdnZXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5UcmlnZ2VyQ2hhcmFjdGVyID0gMjtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSBjdXJzb3IgbW92aW5nIG9yIGJ5IHRoZSBkb2N1bWVudCBjb250ZW50IGNoYW5naW5nLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5Db250ZW50Q2hhbmdlID0gMztcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSB7fSkpO1xudmFyIFNpZ25hdHVyZUhlbHBSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaWduYXR1cmVIZWxwUmVxdWVzdCkge1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2lnbmF0dXJlSGVscCc7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QpO1xufSkoU2lnbmF0dXJlSGVscFJlcXVlc3QgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSBTaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9ufVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhIHR5cGVkIGFycmF5IG9mXG4gKiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRGVmaW5pdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKERlZmluaXRpb25SZXF1ZXN0KSB7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kZWZpbml0aW9uJztcbiAgICBEZWZpbml0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERlZmluaXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IERlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0IHx8IChleHBvcnRzLlJlZmVyZW5jZXNSZXF1ZXN0ID0gUmVmZXJlbmNlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYSB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGZvciBhIGdpdmVuXG4gKiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn1cbiAqIHRoZSByZXF1ZXN0IHJlc3BvbnNlIGlzIGFuIGFycmF5IG9mIHR5cGUge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fVxuICogb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCkge1xuICAgIERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50SGlnaGxpZ2h0JztcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiB0ZXh0IGRvY3VtZW50IGFuZCByYW5nZS5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVxdWVzdCkge1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29kZUFjdGlvbic7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSBDb2RlQWN0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvZGUgYWN0aW9uLlRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSB0aGUgcmVzcG9uc2VcbiAqIGlzIG9mIHR5cGUge0BsaW5rIENvZGVBY3Rpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVBY3Rpb24vcmVzb2x2ZSc7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0gV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSByYW5nZSBpbnNpZGUgdGhlIHdvcmtzcGFjZVxuICogc3ltYm9sJ3MgbG9jYXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZVN5bWJvbC9yZXNvbHZlJztcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29kZSBsZW5zIGZvciB0aGUgZ2l2ZW4gdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIENvZGVMZW5zUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29kZUxlbnMnO1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVMZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlTGVuc1JlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBDb2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVmcmVzaCBhbGwgY29kZSBhY3Rpb25zXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9jb2RlTGVucy9yZWZyZXNoYDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGRvY3VtZW50IGxpbmtzXG4gKi9cbnZhciBEb2N1bWVudExpbmtSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50TGluayc7XG4gICAgRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBmb3JtYXQgYSB3aG9sZSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBmb3JtYXQgYSByYW5nZSBpbiBhIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yYW5nZUZvcm1hdHRpbmcnO1xuICAgIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IHJhbmdlcyBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG52YXIgRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yYW5nZXNGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QgPSBEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGZvcm1hdCBhIGRvY3VtZW50IG9uIHR5cGUuXG4gKi9cbnZhciBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L29uVHlwZUZvcm1hdHRpbmcnO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIFJlbmFtZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3I7XG4oZnVuY3Rpb24gKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCdzIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gc2VsZWN0IHRoZSBpZGVudGlmaWVyXG4gICAgICogYWNjb3JkaW5nIHRoZSB0byBsYW5ndWFnZSdzIHN5bnRheCBydWxlLlxuICAgICAqL1xuICAgIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yLklkZW50aWZpZXIgPSAxO1xufSkoUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgfHwgKGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgPSBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0gUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byB0ZXN0IGFuZCBwZXJmb3JtIHRoZSBzZXR1cCBuZWNlc3NhcnkgZm9yIGEgcmVuYW1lLlxuICpcbiAqIEBzaW5jZSAzLjE2IC0gc3VwcG9ydCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICovXG52YXIgUHJlcGFyZVJlbmFtZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFByZXBhcmVSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlUmVuYW1lJztcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShQcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHNlbmQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gZXhlY3V0ZSBhIGNvbW1hbmQuIFRoZSByZXF1ZXN0IG1pZ2h0IHJldHVyblxuICogYSB3b3Jrc3BhY2UgZWRpdCB3aGljaCB0aGUgY2xpZW50IHdpbGwgYXBwbHkgdG8gdGhlIHdvcmtzcGFjZS5cbiAqL1xudmFyIEV4ZWN1dGVDb21tYW5kUmVxdWVzdDtcbihmdW5jdGlvbiAoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0KSB7XG4gICAgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvZXhlY3V0ZUNvbW1hbmQnO1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWV0aG9kKTtcbn0pKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0gQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIyNDk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IGNhbiBiZSBlZGl0ZWQgdG9nZXRoZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9saW5rZWRFZGl0aW5nUmFuZ2UnO1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njg0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyS2luZCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIE1vbmlrZXIgdW5pcXVlbmVzcyBsZXZlbCB0byBkZWZpbmUgc2NvcGUgb2YgdGhlIG1vbmlrZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgVW5pcXVlbmVzc0xldmVsO1xuKGZ1bmN0aW9uIChVbmlxdWVuZXNzTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyBvbmx5IHVuaXF1ZSBpbnNpZGUgYSBkb2N1bWVudFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5kb2N1bWVudCA9ICdkb2N1bWVudCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSBhIHByb2plY3QgZm9yIHdoaWNoIGEgZHVtcCBnb3QgY3JlYXRlZFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5wcm9qZWN0ID0gJ3Byb2plY3QnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgdGhlIGdyb3VwIHRvIHdoaWNoIGEgcHJvamVjdCBiZWxvbmdzXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdyb3VwID0gJ2dyb3VwJztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBtb25pa2VyIHNjaGVtZS5cbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuc2NoZW1lID0gJ3NjaGVtZSc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdsb2JhbCA9ICdnbG9iYWwnO1xufSkoVW5pcXVlbmVzc0xldmVsIHx8IChleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IFVuaXF1ZW5lc3NMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBtb25pa2VyIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTW9uaWtlcktpbmQ7XG4oZnVuY3Rpb24gKE1vbmlrZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50IGEgc3ltYm9sIHRoYXQgaXMgaW1wb3J0ZWQgaW50byBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kaW1wb3J0ID0gJ2ltcG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGV4cG9ydGVkIGZyb20gYSBwcm9qZWN0XG4gICAgICovXG4gICAgTW9uaWtlcktpbmQuJGV4cG9ydCA9ICdleHBvcnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIHJlcHJlc2VudHMgYSBzeW1ib2wgdGhhdCBpcyBsb2NhbCB0byBhIHByb2plY3QgKGUuZy4gYSBsb2NhbFxuICAgICAqIHZhcmlhYmxlIG9mIGEgZnVuY3Rpb24sIGEgY2xhc3Mgbm90IHZpc2libGUgb3V0c2lkZSB0aGUgcHJvamVjdCwgLi4uKVxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLmxvY2FsID0gJ2xvY2FsJztcbn0pKE1vbmlrZXJLaW5kIHx8IChleHBvcnRzLk1vbmlrZXJLaW5kID0gTW9uaWtlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZ2V0IHRoZSBtb25pa2VyIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dCBkb2N1bWVudCBwb3NpdGlvbi5cbiAqIFRoZSByZXF1ZXN0IHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc30uXG4gKiBUaGUgcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgTW9uaWtlciBNb25pa2VyW119IG9yIGBudWxsYC5cbiAqL1xudmFyIE1vbmlrZXJSZXF1ZXN0O1xuKGZ1bmN0aW9uIChNb25pa2VyUmVxdWVzdCkge1xuICAgIE1vbmlrZXJSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvbW9uaWtlcic7XG4gICAgTW9uaWtlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBNb25pa2VyUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShNb25pa2VyUmVxdWVzdC5tZXRob2QpO1xufSkoTW9uaWtlclJlcXVlc3QgfHwgKGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBNb25pa2VyUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3OTI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODUyKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjMzKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIG5vdGVib29rIGNlbGwga2luZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxLaW5kO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSBtYXJrdXAtY2VsbCBpcyBmb3JtYXR0ZWQgc291cmNlIHRoYXQgaXMgdXNlZCBmb3IgZGlzcGxheS5cbiAgICAgKi9cbiAgICBOb3RlYm9va0NlbGxLaW5kLk1hcmt1cCA9IDE7XG4gICAgLyoqXG4gICAgICogQSBjb2RlLWNlbGwgaXMgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5Db2RlID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbEtpbmQuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbEtpbmQgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IE5vdGVib29rQ2VsbEtpbmQgPSB7fSkpO1xudmFyIEV4ZWN1dGlvblN1bW1hcnk7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZXhlY3V0aW9uT3JkZXIsIHN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBleGVjdXRpb25PcmRlciB9O1xuICAgICAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSB8fCBzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5leGVjdXRpb25PcmRlcikgJiYgKGNhbmRpZGF0ZS5zdWNjZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuc3VjY2VzcykpO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmUuZXhlY3V0aW9uT3JkZXIgPT09IG90aGVyLmV4ZWN1dGlvbk9yZGVyICYmIG9uZS5zdWNjZXNzID09PSBvdGhlci5zdWNjZXNzO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyA9IGVxdWFscztcbn0pKEV4ZWN1dGlvblN1bW1hcnkgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IEV4ZWN1dGlvblN1bW1hcnkgPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbDtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGtpbmQsIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQsIGRvY3VtZW50IH07XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgTm90ZWJvb2tDZWxsS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuRG9jdW1lbnRVcmkuaXMoY2FuZGlkYXRlLmRvY3VtZW50KSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5tZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlLm1ldGFkYXRhKSk7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGRpZmYob25lLCB0d28pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAob25lLmRvY3VtZW50ICE9PSB0d28uZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2RvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZS5raW5kICE9PSB0d28ua2luZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgna2luZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUuZXhlY3V0aW9uU3VtbWFyeSAhPT0gdHdvLmV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2V4ZWN1dGlvblN1bW1hcnknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9uZS5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkIHx8IHR3by5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSAmJiAhZXF1YWxzTWV0YWRhdGEob25lLm1ldGFkYXRhLCB0d28ubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdtZXRhZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob25lLmV4ZWN1dGlvblN1bW1hcnkgIT09IHVuZGVmaW5lZCB8fCB0d28uZXhlY3V0aW9uU3VtbWFyeSAhPT0gdW5kZWZpbmVkKSAmJiAhRXhlY3V0aW9uU3VtbWFyeS5lcXVhbHMob25lLmV4ZWN1dGlvblN1bW1hcnksIHR3by5leGVjdXRpb25TdW1tYXJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZXhlY3V0aW9uU3VtbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5kaWZmID0gZGlmZjtcbiAgICBmdW5jdGlvbiBlcXVhbHNNZXRhZGF0YShvbmUsIG90aGVyKSB7XG4gICAgICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uZSAhPT0gdHlwZW9mIG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25lQXJyYXkgPSBBcnJheS5pc0FycmF5KG9uZSk7XG4gICAgICAgIGNvbnN0IG90aGVyQXJyYXkgPSBBcnJheS5pc0FycmF5KG90aGVyKTtcbiAgICAgICAgaWYgKG9uZUFycmF5ICE9PSBvdGhlckFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZUFycmF5ICYmIG90aGVyQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lW2ldLCBvdGhlcltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMub2JqZWN0TGl0ZXJhbChvbmUpICYmIElzLm9iamVjdExpdGVyYWwob3RoZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBvbmVLZXlzID0gT2JqZWN0LmtleXMob25lKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKTtcbiAgICAgICAgICAgIGlmIChvbmVLZXlzLmxlbmd0aCAhPT0gb3RoZXJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uZUtleXMuc29ydCgpO1xuICAgICAgICAgICAgb3RoZXJLZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lS2V5cywgb3RoZXJLZXlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBvbmVLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lW3Byb3BdLCBvdGhlcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KShOb3RlYm9va0NlbGwgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsID0gTm90ZWJvb2tDZWxsID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50O1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbm90ZWJvb2tUeXBlLCB2ZXJzaW9uLCBjZWxscykge1xuICAgICAgICByZXR1cm4geyB1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLmludGVnZXIuaXMoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50LmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50IHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBOb3RlYm9va0RvY3VtZW50ID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9zeW5jJztcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0ge30pKTtcbi8qKlxuICogQSBub3RpZmljYXRpb24gc2VudCB3aGVuIGEgbm90ZWJvb2sgb3BlbnMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkT3Blbic7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxBcnJheUNoYW5nZSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5zdGFydCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEudWludGVnZXIuaXMoY2FuZGlkYXRlLmRlbGV0ZUNvdW50KSAmJiAoY2FuZGlkYXRlLmNlbGxzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY2VsbHMsIE5vdGVib29rQ2VsbC5pcykpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydCwgZGVsZXRlQ291bnQsIGNlbGxzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc3RhcnQsIGRlbGV0ZUNvdW50IH07XG4gICAgICAgIGlmIChjZWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2VsbHMgPSBjZWxscztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG59KShOb3RlYm9va0NlbGxBcnJheUNoYW5nZSB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZSA9IE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0ge30pKTtcbnZhciBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBkb2N1bWVudCBpcyBzYXZlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRTYXZlJztcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGNsb3Nlcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE2Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG52YXIgV29ya0RvbmVQcm9ncmVzcztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzcykge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3MudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gV29ya0RvbmVQcm9ncmVzcy50eXBlO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzLmlzID0gaXM7XG59KShXb3JrRG9uZVByb2dyZXNzIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSBXb3JrRG9uZVByb2dyZXNzID0ge30pKTtcbi8qKlxuICogVGhlIGB3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jcmVhdGVgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBpbml0aWF0ZSBwcm9ncmVzc1xuICogcmVwb3J0aW5nIGZyb20gdGhlIHNlcnZlci5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCkge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1ldGhvZCA9ICd3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jcmVhdGUnO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbGAgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSAgdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGNhbmNlbCBhIHByb2dyZXNzXG4gKiBpbml0aWF0ZWQgb24gdGhlIHNlcnZlciBzaWRlLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbikge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbCc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBzZWxlY3Rpb24gcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU2VsZWN0aW9uUmFuZ2UgU2VsZWN0aW9uUmFuZ2VbXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZVJlcXVlc3QpIHtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZWxlY3Rpb25SYW5nZSc7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IFNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIwNjc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vLS0tLS0tLSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zJyAtLS0tLVxudmFyIFRva2VuRm9ybWF0O1xuKGZ1bmN0aW9uIChUb2tlbkZvcm1hdCkge1xuICAgIFRva2VuRm9ybWF0LlJlbGF0aXZlID0gJ3JlbGF0aXZlJztcbn0pKFRva2VuRm9ybWF0IHx8IChleHBvcnRzLlRva2VuRm9ybWF0ID0gVG9rZW5Gb3JtYXQgPSB7fSkpO1xudmFyIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlKSB7XG4gICAgU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnO1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUmVnaXN0cmF0aW9uVHlwZShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc1JlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwvZGVsdGEnO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvcmFuZ2UnO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2Uvc2VtYW50aWNUb2tlbnMvcmVmcmVzaGA7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MzMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHNob3cgYSBkb2N1bWVudC4gVGhpcyByZXF1ZXN0IG1pZ2h0IG9wZW4gYW5cbiAqIGV4dGVybmFsIHByb2dyYW0gZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB0aGUgVVJJIHRvIG9wZW4uXG4gKiBGb3IgZXhhbXBsZSBhIHJlcXVlc3QgdG8gb3BlbiBgaHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vYFxuICogd2lsbCB2ZXJ5IGxpa2VseSBvcGVuIHRoZSBVUkkgaW4gYSBXRUIgYnJvd3Nlci5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4qL1xudmFyIFNob3dEb2N1bWVudFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dEb2N1bWVudFJlcXVlc3QpIHtcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0Lm1ldGhvZCA9ICd3aW5kb3cvc2hvd0RvY3VtZW50JztcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd0RvY3VtZW50UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaG93RG9jdW1lbnRSZXF1ZXN0Lm1ldGhvZCk7XG59KShTaG93RG9jdW1lbnRSZXF1ZXN0IHx8IChleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSBTaG93RG9jdW1lbnRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI2NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgVHlwZURlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlRGVmaW5pdGlvblJlcXVlc3QpIHtcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC90eXBlRGVmaW5pdGlvbic7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZURlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IFR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNjI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzdWx0IGEgYFR5cGVIaWVyYXJjaHlJdGVtYCBpbiBhIGRvY3VtZW50IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gKiBDYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCB0byBhIHN1YnR5cGVzIG9yIHN1cGVydHlwZXMgdHlwZSBoaWVyYXJjaHkuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlVHlwZUhpZXJhcmNoeSc7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdXBlcnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VwZXJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdWJ0eXBlcyBmb3IgYSBnaXZlbiBgVHlwZUhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1ldGhvZCA9ICd0eXBlSGllcmFyY2h5L3N1YnR5cGVzJztcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBUaGUgYHdvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzYCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGZldGNoIHRoZSBvcGVuIHdvcmtzcGFjZSBmb2xkZXJzLlxuICovXG52YXIgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzJztcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd29ya3NwYWNlL2RpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gdGhlIHdvcmtzcGFjZVxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyc7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODYzMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5vYmplY3RMaXRlcmFsID0gZXhwb3J0cy50eXBlZEFycmF5ID0gZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcbmZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGNoZWNrKTtcbn1cbmV4cG9ydHMudHlwZWRBcnJheSA9IHR5cGVkQXJyYXk7XG5mdW5jdGlvbiBvYmplY3RMaXRlcmFsKHZhbHVlKSB7XG4gICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcgY2xhc3MgaW5zdGFuY2VzIHBhc3MgdGhpcyBjaGVjayBhcyB3ZWxsLiBTaW5jZSB0aGUgTFNQXG4gICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAvLyBsaWtlIHRoaXM6IGBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpKSA9PT0gbnVsbGBcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMub2JqZWN0TGl0ZXJhbCA9IG9iamVjdExpdGVyYWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3MzA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDUpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODM0KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODE4KTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoYXJyLnNsaWNlKTtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZCA9ICRzbGljZSh0eXBlZEFycmF5LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG52YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCBuYW1lKSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2V0dGVyKHZhbHVlKTtcblx0XHRcdFx0Zm91bmQgPSAkc2xpY2UobmFtZSwgMSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDgzNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlKHN0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmUsIC4uLmFkZGVkTGluZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhdm9pZCB0b28gbWFueSBhcmd1bWVudHMgZm9yIHNwbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH1cbiAgICBwb3NpdGlvbkF0KG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH1cbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmNoYXJhY3RlciA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldCkge1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gbGluZU9mZnNldCAmJiBpc0VPTCh0aGlzLl9jb250ZW50LmNoYXJDb2RlQXQob2Zmc2V0IC0gMSkpKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgbGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5jcmVtZW50YWwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfVxufVxudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIGluaXRpYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBUZXh0RG9jdW1lbnQgYnkgbW9kaWZ5aW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgY2hhbmdlcyB2ZXJzaW9uIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dERvY3VtZW50LiBOb3RlOiBUaGF0J3MgdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShkb2N1bWVudCwgY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBGdWxsVGV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC51cGRhdGUoY2hhbmdlcywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHREb2N1bWVudC51cGRhdGU6IGRvY3VtZW50IG11c3QgYmUgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERvY3VtZW50LnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cy5tYXAoZ2V0V2VsbGZvcm1lZEVkaXQpLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygc29ydGVkRWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPCBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ID4gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cmluZyhsYXN0TW9kaWZpZWRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5uZXdUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2goZS5uZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHRleHQuc3Vic3RyKGxhc3RNb2RpZmllZE9mZnNldCkpO1xuICAgICAgICByZXR1cm4gc3BhbnMuam9pbignJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbmZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgLy8gc29ydGVkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICBsZXQgbGVmdElkeCA9IDA7XG4gICAgbGV0IHJpZ2h0SWR4ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgfVxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaXNFT0woY2gpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0T2Zmc2V0ICsgaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0VPTChjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IGNoYXIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZFJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKHRleHRFZGl0LnJhbmdlKTtcbiAgICBpZiAocmFuZ2UgIT09IHRleHRFZGl0LnJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IG5ld1RleHQ6IHRleHRFZGl0Lm5ld1RleHQsIHJhbmdlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0RWRpdDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjg1Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0ZWRUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGVkVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDaGFuZ2VBbm5vdGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25Db250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvblRyaWdnZXJLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZURlc2NyaXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlRGVzY3JpcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlTGVuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUxlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvckluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JQcmVzZW50YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9yUHJlc2VudGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tbWFuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tbWFuZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1UYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ3JlYXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ3JlYXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERlbGV0ZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIERlbGV0ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWNTZXZlcml0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1NldmVyaXR5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1RhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1RhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0OiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRIaWdobGlnaHRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRMaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudExpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFVyaTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRVcmkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBFT0w6ICgpID0+ICgvKiBiaW5kaW5nICovIEVPTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvbGRpbmdSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvcm1hdHRpbmdPcHRpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb3JtYXR0aW5nT3B0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEhvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBIb3ZlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50S2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludExhYmVsUGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50TGFiZWxQYXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25Db250ZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25JdGVtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVGV4dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVUZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFJlcGxhY2VFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRSZXBsYWNlRWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFRleHRGb3JtYXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRGb3JtYXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0TW9kZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0VGV4dE1vZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTG9jYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbkxpbms6ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uTGluayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmtlZFN0cmluZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya2VkU3RyaW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTWFya3VwQ29udGVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya3VwQ29udGVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cEtpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBhcmFtZXRlckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXJhbWV0ZXJJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBvc2l0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQb3NpdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJhbmdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJlbmFtZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIFJlbmFtZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZWxlY3RlZENvbXBsZXRpb25JbmZvOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZWxlY3RlZENvbXBsZXRpb25JbmZvKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VsZWN0aW9uUmFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbGVjdGlvblJhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbk1vZGlmaWVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNlbWFudGljVG9rZW5UeXBlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlblR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbWFudGljVG9rZW5zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2lnbmF0dXJlSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFNpZ25hdHVyZUluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3RyaW5nVmFsdWU6ICgpID0+ICgvKiBiaW5kaW5nICovIFN0cmluZ1ZhbHVlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFN5bWJvbEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN5bWJvbFRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRFZGl0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEl0ZW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVUkk6ICgpID0+ICgvKiBiaW5kaW5nICovIFVSSSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VDaGFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUNoYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VGb2xkZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUZvbGRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZVN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlU3ltYm9sKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW50ZWdlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50ZWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyB1aW50ZWdlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRG9jdW1lbnRVcmk7XG4oZnVuY3Rpb24gKERvY3VtZW50VXJpKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xudmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xudmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG52YXIgdWludGVnZXI7XG4oZnVuY3Rpb24gKHVpbnRlZ2VyKSB7XG4gICAgdWludGVnZXIuTUlOX1ZBTFVFID0gMDtcbiAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHVpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIHVpbnRlZ2VyLmlzID0gaXM7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3RlciB9O1xuICAgIH1cbiAgICBQb3NpdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBQb3NpdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmNoYXJhY3Rlcik7XG4gICAgfVxuICAgIFBvc2l0aW9uLmlzID0gaXM7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUmFuZ2V9IGxpdGVyYWxzLlxuICovXG52YXIgUmFuZ2U7XG4oZnVuY3Rpb24gKFJhbmdlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9uZSwgdHdvLCB0aHJlZSwgZm91cikge1xuICAgICAgICBpZiAoSXMudWludGVnZXIob25lKSAmJiBJcy51aW50ZWdlcih0d28pICYmIElzLnVpbnRlZ2VyKHRocmVlKSAmJiBJcy51aW50ZWdlcihmb3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZShvbmUsIHR3byksIGVuZDogUG9zaXRpb24uY3JlYXRlKHRocmVlLCBmb3VyKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBvc2l0aW9uLmlzKG9uZSkgJiYgUG9zaXRpb24uaXModHdvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IG9uZSwgZW5kOiB0d28gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzWyR7b25lfSwgJHt0d299LCAke3RocmVlfSwgJHtmb3VyfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbiBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4geyB1cmksIHJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnVyaSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbi5pcyA9IGlzO1xufSkoTG9jYXRpb24gfHwgKExvY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uTGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbkxpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQsXG4gICAgICAgICAgICBncmVlbixcbiAgICAgICAgICAgIGJsdWUsXG4gICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUucmVkLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmdyZWVuLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmJsdWUsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYWxwaGEsIDAsIDEpO1xuICAgIH1cbiAgICBDb2xvci5pcyA9IGlzO1xufSkoQ29sb3IgfHwgKENvbG9yID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9ySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvckluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBDb2xvci5pcyhjYW5kaWRhdGUuY29sb3IpO1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmlzID0gaXM7XG59KShDb2xvckluZm9ybWF0aW9uIHx8IChDb2xvckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yUHJlc2VudGF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgdGV4dEVkaXQsIGFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsVGV4dEVkaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbClcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRleHRFZGl0KSB8fCBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cykgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cywgVGV4dEVkaXQuaXMpKTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uaXMgPSBpcztcbn0pKENvbG9yUHJlc2VudGF0aW9uIHx8IChDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcmFuZ2Uga2luZHMuXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2VLaW5kO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VLaW5kKSB7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBjb21tZW50XG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5Db21tZW50ID0gJ2NvbW1lbnQnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGFuIGltcG9ydCBvciBpbmNsdWRlXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzID0gJ2ltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiA9ICdyZWdpb24nO1xufSkoRm9sZGluZ1JhbmdlS2luZCB8fCAoRm9sZGluZ1JhbmdlS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBmb2xkaW5nIHJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIEZvbGRpbmdSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2U7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRm9sZGluZ1JhbmdlIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnRDaGFyYWN0ZXIsIGVuZENoYXJhY3Rlciwga2luZCwgY29sbGFwc2VkVGV4dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmUsXG4gICAgICAgICAgICBlbmRMaW5lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHN0YXJ0Q2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0Q2hhcmFjdGVyID0gc3RhcnRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoZW5kQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZENoYXJhY3RlciA9IGVuZENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChraW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvbGxhcHNlZFRleHQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29sbGFwc2VkVGV4dCA9IGNvbGxhcHNlZFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvbGRpbmdSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSk7XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gfHwgKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxuICovXG52YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGVycm9yLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgaGludC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XG59KShEaWFnbm9zdGljU2V2ZXJpdHkgfHwgKERpYWdub3N0aWNTZXZlcml0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgRGlhZ25vc3RpY1RhZztcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1RhZykge1xuICAgIC8qKlxuICAgICAqIFVudXNlZCBvciB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgKiBhbiBlcnJvciBzcXVpZ2dsZS5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG9yIG9ic29sZXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlcmVkIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgc3RyaWtlIHRocm91Z2guXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbn0pKERpYWdub3N0aWNUYWcgfHwgKERpYWdub3N0aWNUYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlRGVzY3JpcHRpb247XG4oZnVuY3Rpb24gKENvZGVEZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaHJlZik7XG4gICAgfVxuICAgIENvZGVEZXNjcmlwdGlvbi5pcyA9IGlzO1xufSkoQ29kZURlc2NyaXB0aW9uIHx8IChDb2RlRGVzY3JpcHRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgRGlhZ25vc3RpYyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEaWFnbm9zdGljfSBsaXRlcmFscy5cbiAqL1xudmFyIERpYWdub3N0aWM7XG4oZnVuY3Rpb24gKERpYWdub3N0aWMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERpYWdub3N0aWMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCBzb3VyY2UsIHJlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSwgbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgdGl0bGUsIGNvbW1hbmQgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb21tYW5kLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbW1hbmR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb21tYW5kKTtcbiAgICB9XG4gICAgQ29tbWFuZC5pcyA9IGlzO1xufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSByZXBsYWNlLFxuICogaW5zZXJ0IGFuZCBkZWxldGUgZWRpdHMgbW9yZSBlYXNpbHkuXG4gKi9cbnZhciBUZXh0RWRpdDtcbihmdW5jdGlvbiAoVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zZXJ0IHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWxldGUgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xuICAgIH1cbiAgICBUZXh0RWRpdC5pcyA9IGlzO1xufSkoVGV4dEVkaXQgfHwgKFRleHRFZGl0ID0ge30pKTtcbnZhciBDaGFuZ2VBbm5vdGF0aW9uO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBuZWVkc0NvbmZpcm1hdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpICYmXG4gICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI7XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyIHx8IChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciA9IHt9KSk7XG52YXIgQW5ub3RhdGVkVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKEFubm90YXRlZFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQ6ICcnLCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSAmJiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmlzID0gaXM7XG59KShBbm5vdGF0ZWRUZXh0RWRpdCB8fCAoQW5ub3RhdGVkVGV4dEVkaXQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZVxuICogYW4gZWRpdCB0aGF0IG1hbmlwdWxhdGVzIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIFRleHREb2N1bWVudEVkaXQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0RG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudCwgZWRpdHMgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XG52YXIgQ3JlYXRlRmlsZTtcbihmdW5jdGlvbiAoQ3JlYXRlRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdjcmVhdGUnLFxuICAgICAgICAgICAgdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuaXMgPSBpcztcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xudmFyIFJlbmFtZUZpbGU7XG4oZnVuY3Rpb24gKFJlbmFtZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdyZW5hbWUnLFxuICAgICAgICAgICAgb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlbmFtZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5vbGRVcmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBSZW5hbWVGaWxlLmlzID0gaXM7XG59KShSZW5hbWVGaWxlIHx8IChSZW5hbWVGaWxlID0ge30pKTtcbnZhciBEZWxldGVGaWxlO1xuKGZ1bmN0aW9uIChEZWxldGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2RlbGV0ZScsXG4gICAgICAgICAgICB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5yZWN1cnNpdmUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xufSkoRGVsZXRlRmlsZSB8fCAoRGVsZXRlRmlsZSA9IHt9KSk7XG52YXIgV29ya3NwYWNlRWRpdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRWRpdC5pcyA9IGlzO1xufSkoV29ya3NwYWNlRWRpdCB8fCAoV29ya3NwYWNlRWRpdCA9IHt9KSk7XG5jbGFzcyBUZXh0RWRpdENoYW5nZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRzLCBjaGFuZ2VBbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLmVkaXRzID0gZWRpdHM7XG4gICAgICAgIHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMgPSBjaGFuZ2VBbm5vdGF0aW9ucztcbiAgICB9XG4gICAgaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LmRlbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZChlZGl0KSB7XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0cztcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZWRpdHMuc3BsaWNlKDAsIHRoaXMuZWRpdHMubGVuZ3RoKTtcbiAgICB9XG4gICAgYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGV4dCBlZGl0IGNoYW5nZSBpcyBub3QgY29uZmlndXJlZCB0byBtYW5hZ2UgY2hhbmdlIGFubm90YXRpb25zLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGhlbHBlciBjbGFzc1xuICovXG5jbGFzcyBDaGFuZ2VBbm5vdGF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIG1hbmFnZShpZE9yQW5ub3RhdGlvbiwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElkICR7aWR9IGlzIGFscmVhZHkgaW4gdXNlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uc1tpZF0gPSBhbm5vdGF0aW9uO1xuICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgbmV4dElkKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbmNsYXNzIFdvcmtzcGFjZUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iod29ya3NwYWNlRWRpdCkge1xuICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAod29ya3NwYWNlRWRpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0gd29ya3NwYWNlRWRpdDtcbiAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGNoYW5nZS5lZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2NoYW5nZS50ZXh0RG9jdW1lbnQudXJpXSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwod29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFdvcmtzcGFjZUVkaXR9IGxpdGVyYWxcbiAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZWRpdCgpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgfVxuICAgIGdldFRleHRFZGl0Q2hhbmdlKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50ID0geyB1cmk6IGtleS51cmksIHZlcnNpb246IGtleS52ZXJzaW9uIH07XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb2N1bWVudENoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlRmlsZSh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5hbWVGaWxlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUZpbGUodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAqL1xudmFyIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCB2ZXJzaW9uIH07XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbik7XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0IH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJdGVtIHx8IChUZXh0RG9jdW1lbnRJdGVtID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIHRoZSBjb250ZW50IHR5cGUgdGhhdCBhIGNsaWVudCBzdXBwb3J0cyBpbiB2YXJpb3VzXG4gKiByZXN1bHQgbGl0ZXJhbHMgbGlrZSBgSG92ZXJgLCBgUGFyYW1ldGVySW5mb2Agb3IgYENvbXBsZXRpb25JdGVtYC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGBNYXJrdXBLaW5kc2AgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIGAkYC4gVGhpcyBraW5kc1xuICogYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZS5cbiAqL1xudmFyIE1hcmt1cEtpbmQ7XG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0IGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5QbGFpblRleHQgPSAncGxhaW50ZXh0JztcbiAgICAvKipcbiAgICAgKiBNYXJrZG93biBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuTWFya2Rvd24gPSAnbWFya2Rvd24nO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbHVlIG9mIHRoZSB7QGxpbmsgTWFya3VwS2luZH0gdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbnZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ID0gMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kID0gMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciA9IDQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkID0gNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyA9IDc7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSA9IDg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID0gMTA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgPSAxMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSA9IDEzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkID0gMTQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgPSAxNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSA9IDE3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyID0gMTk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgPSAyMDtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0ID0gMjI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50ID0gMjM7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNTtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAqIHBsYWluIHRleHQgb3IgYSBzbmlwcGV0LlxuICovXG52YXIgSW5zZXJ0VGV4dEZvcm1hdDtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlBsYWluVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgc25pcHBldC5cbiAgICAgKlxuICAgICAqIEEgc25pcHBldCBjYW4gZGVmaW5lIHRhYiBzdG9wcyBhbmQgcGxhY2Vob2xkZXJzIHdpdGggYCQxYCwgYCQyYFxuICAgICAqIGFuZCBgJHszOmZvb31gLiBgJDBgIGRlZmluZXMgdGhlIGZpbmFsIHRhYiBzdG9wLCBpdCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBlbmQgb2YgdGhlIHNuaXBwZXQuIFBsYWNlaG9sZGVycyB3aXRoIGVxdWFsIGlkZW50aWZpZXJzIGFyZSBsaW5rZWQsXG4gICAgICogdGhhdCBpcyB0eXBpbmcgaW4gb25lIHdpbGwgdXBkYXRlIG90aGVycyB0b28uXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL2xhbmd1YWdlLXNlcnZlci1wcm90b2NvbC9zcGVjaWZpY2F0aW9ucy9zcGVjaWZpY2F0aW9uLWN1cnJlbnQvI3NuaXBwZXRfc3ludGF4XG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0ID0gMjtcbn0pKEluc2VydFRleHRGb3JtYXQgfHwgKEluc2VydFRleHRGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBDb21wbGV0aW9uIGl0ZW0gdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgY29tcGxldGlvblxuICogaXRlbS5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEluc2VydFJlcGxhY2VFZGl0O1xuKGZ1bmN0aW9uIChJbnNlcnRSZXBsYWNlRWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zZXJ0IC8gcmVwbGFjZSBlZGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRUZXh0TW9kZTtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zZXJ0aW9uIG9yIHJlcGxhY2Ugc3RyaW5ncyBpcyB0YWtlbiBhcyBpdCBpcy4gSWYgdGhlXG4gICAgICogdmFsdWUgaXMgbXVsdGkgbGluZSB0aGUgbGluZXMgYmVsb3cgdGhlIGN1cnNvciB3aWxsIGJlXG4gICAgICogaW5zZXJ0ZWQgdXNpbmcgdGhlIGluZGVudGF0aW9uIGRlZmluZWQgaW4gdGhlIHN0cmluZyB2YWx1ZS5cbiAgICAgKiBUaGUgY2xpZW50IHdpbGwgbm90IGFwcGx5IGFueSBraW5kIG9mIGFkanVzdG1lbnRzIHRvIHRoZVxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hc0lzID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGFkanVzdHMgbGVhZGluZyB3aGl0ZXNwYWNlIG9mIG5ldyBsaW5lcyBzbyB0aGF0XG4gICAgICogdGhleSBtYXRjaCB0aGUgaW5kZW50YXRpb24gdXAgdG8gdGhlIGN1cnNvciBvZiB0aGUgbGluZSBmb3JcbiAgICAgKiB3aGljaCB0aGUgaXRlbSBpcyBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIGEgbGluZSBsaWtlIHRoaXM6IDwydGFicz48Y3Vyc29yPjwzdGFicz5mb28uIEFjY2VwdGluZyBhXG4gICAgICogbXVsdGkgbGluZSBjb21wbGV0aW9uIGl0ZW0gaXMgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFuZCBhbGxcbiAgICAgKiBmb2xsb3dpbmcgbGluZXMgaW5zZXJ0ZWQgd2lsbCBiZSBpbmRlbnRlZCB1c2luZyAyIHRhYnMgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hZGp1c3RJbmRlbnRhdGlvbiA9IDI7XG59KShJbnNlcnRUZXh0TW9kZSB8fCAoSW5zZXJ0VGV4dE1vZGUgPSB7fSkpO1xudmFyIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkgfHwgY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMuaXMgPSBpcztcbn0pKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIHx8IChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21wbGV0aW9uSXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICogY29tcGxldGlvbiBpdGVtcy5cbiAqL1xudmFyIENvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBjb21wbGV0aW9uIGl0ZW0ncyBsYWJlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICByZXR1cm4geyBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbnZhciBDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBsZXRpb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cbiAgICAgKiBAcGFyYW0gaXNJbmNvbXBsZXRlIFRoZSBsaXN0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG52YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5pcyA9IGlzO1xufSkoTWFya2VkU3RyaW5nIHx8IChNYXJrZWRTdHJpbmcgPSB7fSkpO1xudmFyIEhvdmVyO1xuKGZ1bmN0aW9uIChIb3Zlcikge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgIE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICB9XG4gICAgSG92ZXIuaXMgPSBpcztcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQYXJhbWV0ZXJJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQYXJhbWV0ZXJJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoUGFyYW1ldGVySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhcmFtZXRlciBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhYmVsIEEgbGFiZWwgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudGF0aW9uIEEgZG9jIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb24gPyB7IGxhYmVsLCBkb2N1bWVudGF0aW9uIH0gOiB7IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24sIC4uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgbGFiZWwgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTaWduYXR1cmVJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTaWduYXR1cmVJbmZvcm1hdGlvbiB8fCAoU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA9IDM7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIERvY3VtZW50SGlnaGxpZ2h0IG5hbWVzcGFjZSB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9jdW1lbnRIaWdobGlnaHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdGhlIGhpZ2hsaWdodCBhcHBsaWVzIHRvLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBoaWdobGlnaHQga2luZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwga2luZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSB9O1xuICAgICAgICBpZiAoSXMubnVtYmVyKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRIaWdobGlnaHQuY3JlYXRlID0gY3JlYXRlO1xufSkoRG9jdW1lbnRIaWdobGlnaHQgfHwgKERvY3VtZW50SGlnaGxpZ2h0ID0ge30pKTtcbi8qKlxuICogQSBzeW1ib2wga2luZC5cbiAqL1xudmFyIFN5bWJvbEtpbmQ7XG4oZnVuY3Rpb24gKFN5bWJvbEtpbmQpIHtcbiAgICBTeW1ib2xLaW5kLkZpbGUgPSAxO1xuICAgIFN5bWJvbEtpbmQuTW9kdWxlID0gMjtcbiAgICBTeW1ib2xLaW5kLk5hbWVzcGFjZSA9IDM7XG4gICAgU3ltYm9sS2luZC5QYWNrYWdlID0gNDtcbiAgICBTeW1ib2xLaW5kLkNsYXNzID0gNTtcbiAgICBTeW1ib2xLaW5kLk1ldGhvZCA9IDY7XG4gICAgU3ltYm9sS2luZC5Qcm9wZXJ0eSA9IDc7XG4gICAgU3ltYm9sS2luZC5GaWVsZCA9IDg7XG4gICAgU3ltYm9sS2luZC5Db25zdHJ1Y3RvciA9IDk7XG4gICAgU3ltYm9sS2luZC5FbnVtID0gMTA7XG4gICAgU3ltYm9sS2luZC5JbnRlcmZhY2UgPSAxMTtcbiAgICBTeW1ib2xLaW5kLkZ1bmN0aW9uID0gMTI7XG4gICAgU3ltYm9sS2luZC5WYXJpYWJsZSA9IDEzO1xuICAgIFN5bWJvbEtpbmQuQ29uc3RhbnQgPSAxNDtcbiAgICBTeW1ib2xLaW5kLlN0cmluZyA9IDE1O1xuICAgIFN5bWJvbEtpbmQuTnVtYmVyID0gMTY7XG4gICAgU3ltYm9sS2luZC5Cb29sZWFuID0gMTc7XG4gICAgU3ltYm9sS2luZC5BcnJheSA9IDE4O1xuICAgIFN5bWJvbEtpbmQuT2JqZWN0ID0gMTk7XG4gICAgU3ltYm9sS2luZC5LZXkgPSAyMDtcbiAgICBTeW1ib2xLaW5kLk51bGwgPSAyMTtcbiAgICBTeW1ib2xLaW5kLkVudW1NZW1iZXIgPSAyMjtcbiAgICBTeW1ib2xLaW5kLlN0cnVjdCA9IDIzO1xuICAgIFN5bWJvbEtpbmQuRXZlbnQgPSAyNDtcbiAgICBTeW1ib2xLaW5kLk9wZXJhdG9yID0gMjU7XG4gICAgU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyID0gMjY7XG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcbi8qKlxuICogU3ltYm9sIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIHN5bWJvbC5cbiAqXG4gKiBAc2luY2UgMy4xNlxuICovXG52YXIgU3ltYm9sVGFnO1xuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBzeW1ib2wgYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIFN5bWJvbFRhZy5EZXByZWNhdGVkID0gMTtcbn0pKFN5bWJvbFRhZyB8fCAoU3ltYm9sVGFnID0ge30pKTtcbnZhciBTeW1ib2xJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU3ltYm9sSW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgcmVzb3VyY2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sIGNvbnRhaW5pbmcgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwga2luZCwgcmFuZ2UsIHVyaSwgY29udGFpbmVyTmFtZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBsb2NhdGlvbjogeyB1cmksIHJhbmdlIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTeW1ib2xJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTeW1ib2xJbmZvcm1hdGlvbiB8fCAoU3ltYm9sSW5mb3JtYXRpb24gPSB7fSkpO1xudmFyIFdvcmtzcGFjZVN5bWJvbDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdvcmtzcGFjZSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgcmVzb3VyY2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIEFuIG9wdGlvbnMgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgV29ya3NwYWNlU3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCB1cmksIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHsgbmFtZSwga2luZCwgbG9jYXRpb246IHsgdXJpLCByYW5nZSB9IH1cbiAgICAgICAgICAgIDogeyBuYW1lLCBraW5kLCBsb2NhdGlvbjogeyB1cmkgfSB9O1xuICAgIH1cbiAgICBXb3Jrc3BhY2VTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xufSkoV29ya3NwYWNlU3ltYm9sIHx8IChXb3Jrc3BhY2VTeW1ib2wgPSB7fSkpO1xudmFyIERvY3VtZW50U3ltYm9sO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25SYW5nZSBUaGUgc2VsZWN0aW9uUmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwgZGV0YWlsLCBraW5kLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50U3ltYm9sfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICBJcy5zdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmIElzLm51bWJlcihjYW5kaWRhdGUua2luZCkgJiZcbiAgICAgICAgICAgIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnNlbGVjdGlvblJhbmdlKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRlcHJlY2F0ZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5kZXByZWNhdGVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5jaGlsZHJlbikpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnRhZ3MgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS50YWdzKSk7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmlzID0gaXM7XG59KShEb2N1bWVudFN5bWJvbCB8fCAoRG9jdW1lbnRTeW1ib2wgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIGNvZGUgYWN0aW9uIGtpbmRzXG4gKi9cbnZhciBDb2RlQWN0aW9uS2luZDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBFbXB0eSBraW5kLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLkVtcHR5ID0gJyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBxdWlja2ZpeCBhY3Rpb25zOiAncXVpY2tmaXgnXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUXVpY2tGaXggPSAncXVpY2tmaXgnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgYWN0aW9uczogJ3JlZmFjdG9yJ1xuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yID0gJ3JlZmFjdG9yJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGV4dHJhY3Rpb24gYWN0aW9uczogJ3JlZmFjdG9yLmV4dHJhY3QnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGV4dHJhY3QgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gRXh0cmFjdCBtZXRob2RcbiAgICAgKiAtIEV4dHJhY3QgZnVuY3Rpb25cbiAgICAgKiAtIEV4dHJhY3QgdmFyaWFibGVcbiAgICAgKiAtIEV4dHJhY3QgaW50ZXJmYWNlIGZyb20gY2xhc3NcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yRXh0cmFjdCA9ICdyZWZhY3Rvci5leHRyYWN0JztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGlubGluZSBhY3Rpb25zOiAncmVmYWN0b3IuaW5saW5lJ1xuICAgICAqXG4gICAgICogRXhhbXBsZSBpbmxpbmUgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gSW5saW5lIGZ1bmN0aW9uXG4gICAgICogLSBJbmxpbmUgdmFyaWFibGVcbiAgICAgKiAtIElubGluZSBjb25zdGFudFxuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JJbmxpbmUgPSAncmVmYWN0b3IuaW5saW5lJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIHJld3JpdGUgYWN0aW9uczogJ3JlZmFjdG9yLnJld3JpdGUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHJld3JpdGUgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gQ29udmVydCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHRvIGNsYXNzXG4gICAgICogLSBBZGQgb3IgcmVtb3ZlIHBhcmFtZXRlclxuICAgICAqIC0gRW5jYXBzdWxhdGUgZmllbGRcbiAgICAgKiAtIE1ha2UgbWV0aG9kIHN0YXRpY1xuICAgICAqIC0gTW92ZSBtZXRob2QgdG8gYmFzZSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JSZXdyaXRlID0gJ3JlZmFjdG9yLnJld3JpdGUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3Igc291cmNlIGFjdGlvbnM6IGBzb3VyY2VgXG4gICAgICpcbiAgICAgKiBTb3VyY2UgY29kZSBhY3Rpb25zIGFwcGx5IHRvIHRoZSBlbnRpcmUgZmlsZS5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2UgPSAnc291cmNlJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGFuIG9yZ2FuaXplIGltcG9ydHMgc291cmNlIGFjdGlvbjogYHNvdXJjZS5vcmdhbml6ZUltcG9ydHNgXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlT3JnYW5pemVJbXBvcnRzID0gJ3NvdXJjZS5vcmdhbml6ZUltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYXV0by1maXggc291cmNlIGFjdGlvbnM6IGBzb3VyY2UuZml4QWxsYC5cbiAgICAgKlxuICAgICAqIEZpeCBhbGwgYWN0aW9ucyBhdXRvbWF0aWNhbGx5IGZpeCBlcnJvcnMgdGhhdCBoYXZlIGEgY2xlYXIgZml4IHRoYXQgZG8gbm90IHJlcXVpcmUgdXNlciBpbnB1dC5cbiAgICAgKiBUaGV5IHNob3VsZCBub3Qgc3VwcHJlc3MgZXJyb3JzIG9yIHBlcmZvcm0gdW5zYWZlIGZpeGVzIHN1Y2ggYXMgZ2VuZXJhdGluZyBuZXcgdHlwZXMgb3IgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE1LjBcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VGaXhBbGwgPSAnc291cmNlLmZpeEFsbCc7XG59KShDb2RlQWN0aW9uS2luZCB8fCAoQ29kZUFjdGlvbktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgcmVhc29uIHdoeSBjb2RlIGFjdGlvbnMgd2VyZSByZXF1ZXN0ZWQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgQ29kZUFjdGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSBleHBsaWNpdGx5IHJlcXVlc3RlZCBieSB0aGUgdXNlciBvciBieSBhbiBleHRlbnNpb24uXG4gICAgICovXG4gICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kLkludm9rZWQgPSAxO1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIGN1cnJlbnQgc2VsZWN0aW9uIGluIGEgZmlsZSBjaGFuZ2VzLCBidXQgY2FuXG4gICAgICogYWxzbyBiZSB0cmlnZ2VyZWQgd2hlbiBmaWxlIGNvbnRlbnQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMjtcbn0pKENvZGVBY3Rpb25UcmlnZ2VyS2luZCB8fCAoQ29kZUFjdGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVBY3Rpb25Db250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBsaXRlcmFscy5cbiAqL1xudmFyIENvZGVBY3Rpb25Db250ZXh0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uQ29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUFjdGlvbkNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZGlhZ25vc3RpY3MsIG9ubHksIHRyaWdnZXJLaW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbnZhciBDb2RlQWN0aW9uO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHRpdGxlIH07XG4gICAgICAgIGxldCBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVja0tpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21tYW5kLmlzKGtpbmRPckNvbW1hbmRPckVkaXQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrS2luZCAmJiBraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCA9PT0gdW5kZWZpbmVkIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2RlTGVuc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUxlbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29kZUxlbnN9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb21tYW5kKSB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIENvZGVMZW5zLmlzID0gaXM7XG59KShDb2RlTGVucyB8fCAoQ29kZUxlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRm9ybWF0dGluZ09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9ybWF0dGluZ09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgRm9ybWF0dGluZ09wdGlvbnM7XG4oZnVuY3Rpb24gKEZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzIH07XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5pcyA9IGlzO1xufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRMaW5rO1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERvY3VtZW50TGluayBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGFyZ2V0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0YXJnZXQsIGRhdGEgfTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50TGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRhcmdldCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50YXJnZXQpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmlzID0gaXM7XG59KShEb2N1bWVudExpbmsgfHwgKERvY3VtZW50TGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBTZWxlY3Rpb25SYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIHdvcmsgd2l0aFxuICogU2VsZWN0aW9uUmFuZ2UgbGl0ZXJhbHMuXG4gKi9cbnZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoY2FuZGlkYXRlLnBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IFNlbGVjdGlvblJhbmdlLmlzKGNhbmRpZGF0ZS5wYXJlbnQpKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuaXMgPSBpcztcbn0pKFNlbGVjdGlvblJhbmdlIHx8IChTZWxlY3Rpb25SYW5nZSA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gdHlwZXMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICogYW4gY2xpZW50cyBjYW4gc3BlY2lmeSBhZGRpdGlvbmFsIHRva2VuIHR5cGVzIHZpYSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5UeXBlcykge1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm5hbWVzcGFjZVwiXSA9IFwibmFtZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGdlbmVyaWMgdHlwZS4gQWN0cyBhcyBhIGZhbGxiYWNrIGZvciB0eXBlcyB3aGljaCBjYW4ndCBiZSBtYXBwZWQgdG9cbiAgICAgKiBhIHNwZWNpZmljIHR5cGUgbGlrZSBjbGFzcyBvciBlbnVtLlxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVcIl0gPSBcInR5cGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiaW50ZXJmYWNlXCJdID0gXCJpbnRlcmZhY2VcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwYXJhbWV0ZXJcIl0gPSBcInBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1NZW1iZXJcIl0gPSBcImVudW1NZW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtZXRob2RcIl0gPSBcIm1ldGhvZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtb2RpZmllclwiXSA9IFwibW9kaWZpZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImRlY29yYXRvclwiXSA9IFwiZGVjb3JhdG9yXCI7XG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbk1vZGlmaWVycztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbk1vZGlmaWVycykge1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWNsYXJhdGlvblwiXSA9IFwiZGVjbGFyYXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmaW5pdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJyZWFkb25seVwiXSA9IFwicmVhZG9ubHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wic3RhdGljXCJdID0gXCJzdGF0aWNcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVwcmVjYXRlZFwiXSA9IFwiZGVwcmVjYXRlZFwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhYnN0cmFjdFwiXSA9IFwiYWJzdHJhY3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYXN5bmNcIl0gPSBcImFzeW5jXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcIm1vZGlmaWNhdGlvblwiXSA9IFwibW9kaWZpY2F0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRvY3VtZW50YXRpb25cIl0gPSBcImRvY3VtZW50YXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmYXVsdExpYnJhcnlcIl0gPSBcImRlZmF1bHRMaWJyYXJ5XCI7XG59KShTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIHx8IChTZW1hbnRpY1Rva2VuTW9kaWZpZXJzID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjYW5kaWRhdGUucmVzdWx0SWQgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZGF0YSkgJiYgKGNhbmRpZGF0ZS5kYXRhLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgY2FuZGlkYXRlLmRhdGFbMF0gPT09ICdudW1iZXInKTtcbiAgICB9XG4gICAgU2VtYW50aWNUb2tlbnMuaXMgPSBpcztcbn0pKFNlbWFudGljVG9rZW5zIHx8IChTZW1hbnRpY1Rva2VucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVUZXh0cy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVRleHQ7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVGV4dCB8fCAoSW5saW5lVmFsdWVUZXh0ID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXApIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cCB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLmNhc2VTZW5zaXRpdmVMb29rdXApXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUpIHx8IGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUgPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgfHwgKElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb247XG4oZnVuY3Rpb24gKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZXhwcmVzc2lvbikgfHwgY2FuZGlkYXRlLmV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiB8fCAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVDb250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVDb250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoSW5saW5lVmFsdWVDb250ZXh0ID0ge30pKTtcbi8qKlxuICogSW5sYXkgaGludCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQW4gaW5sYXkgaGludCB0aGF0IGZvciBhIHR5cGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBJbmxheUhpbnRLaW5kLlR5cGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBpcyBmb3IgYSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5QYXJhbWV0ZXIgPSAyO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSB8fCB2YWx1ZSA9PT0gMjtcbiAgICB9XG4gICAgSW5sYXlIaW50S2luZC5pcyA9IGlzO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG52YXIgSW5sYXlIaW50TGFiZWxQYXJ0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRMYWJlbFBhcnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9XG4gICAgSW5sYXlIaW50TGFiZWxQYXJ0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbnZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBwb3NpdGlvbiwgbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmxhYmVsLCBJbmxheUhpbnRMYWJlbFBhcnQuaXMpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRleHRFZGl0cyA9PT0gdW5kZWZpbmVkKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbnZhciBTdHJpbmdWYWx1ZTtcbihmdW5jdGlvbiAoU3RyaW5nVmFsdWUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVTbmlwcGV0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6ICdzbmlwcGV0JywgdmFsdWUgfTtcbiAgICB9XG4gICAgU3RyaW5nVmFsdWUuY3JlYXRlU25pcHBldCA9IGNyZWF0ZVNuaXBwZXQ7XG59KShTdHJpbmdWYWx1ZSB8fCAoU3RyaW5nVmFsdWUgPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uSXRlbSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCkge1xuICAgICAgICByZXR1cm4geyBpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uSXRlbSB8fCAoSW5saW5lQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uTGlzdCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcykge1xuICAgICAgICByZXR1cm4geyBpdGVtcyB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uTGlzdCB8fCAoSW5saW5lQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IGFuIHtAbGluayBJbmxpbmVDb21wbGV0aW9uSXRlbVByb3ZpZGVyIGlubGluZSBjb21wbGV0aW9uIHByb3ZpZGVyfSB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG52YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDA7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgd2hpbGUgZWRpdGluZy5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMTtcbn0pKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTZWxlY3RlZENvbXBsZXRpb25JbmZvO1xuKGZ1bmN0aW9uIChTZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIFNlbGVjdGVkQ29tcGxldGlvbkluZm8uY3JlYXRlID0gY3JlYXRlO1xufSkoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB8fCAoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyA9IHt9KSk7XG52YXIgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25Db250ZXh0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiB7IHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25Db250ZXh0IHx8IChJbmxpbmVDb21wbGV0aW9uQ29udGV4dCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBVUkkuaXMoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRm9sZGVyLmlzID0gaXM7XG59KShXb3Jrc3BhY2VGb2xkZXIgfHwgKFdvcmtzcGFjZUZvbGRlciA9IHt9KSk7XG5jb25zdCBFT0wgPSBbJ1xcbicsICdcXHJcXG4nLCAnXFxyJ107XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG52YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElUZXh0RG9jdW1lbnQgbGl0ZXJhbCBmcm9tIHRoZSBnaXZlbiB1cmkgYW5kIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJVGV4dERvY3VtZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZUNvdW50KVxuICAgICAgICAgICAgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgbGV0IHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGUubmV3VGV4dCArIHRleHQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAvLyBzb3J0ZWRcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgICAgIG1lcmdlU29ydChsZWZ0LCBjb21wYXJlKTtcbiAgICAgICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgbGV0IGxlZnRJZHggPSAwO1xuICAgICAgICBsZXQgcmlnaHRJZHggPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgdXBkYXRlKGV2ZW50LCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBldmVudC50ZXh0O1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9XG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgbGV0IG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgfVxufVxudmFyIElzO1xuKGZ1bmN0aW9uIChJcykge1xuICAgIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlKTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2dsb2JhbCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRcdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuLyoqKioqKi8gXHRcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKioqKioqLyBcdFx0XHR9IGNhdGNoIChlKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9KSgpO1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuLyoqKioqKi8gXHRcdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIG1vZHVsZTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4oKCkgPT4ge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgTHVhU2VydmljZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTHVhU2VydmljZSlcbn0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2Jhc2Utc2VydmljZS50c1xudmFyIGJhc2Vfc2VydmljZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyNSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy9sdWFwYXJzZS9sdWFwYXJzZS5qc1xudmFyIGx1YXBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItcHJvdG9jb2wvbGliL2Jyb3dzZXIvbWFpbi5qc1xudmFyIG1haW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy50c1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzcwKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9hY2UvcmFuZ2Utc2luZ2xldG9uLnRzXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5jbGFzcyBBY2VSYW5nZSB7XG4gICAgc3RhdGljIGdldENvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICBpZiAoIUFjZVJhbmdlLl9pbnN0YW5jZSAmJiBlZGl0b3IpIHtcbiAgICAgICAgICAgIEFjZVJhbmdlLl9pbnN0YW5jZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpLmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBY2VSYW5nZS5faW5zdGFuY2U7XG4gICAgfVxufVxuX2RlZmluZV9wcm9wZXJ0eShBY2VSYW5nZSwgXCJfaW5zdGFuY2VcIiwgdm9pZCAwKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3R5cGUtY29udmVydGVycy9jb21tb24tY29udmVydGVycy50c1xuXG5cblxudmFyIGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlcjtcbihmdW5jdGlvbihDb21tb25Db252ZXJ0ZXIpIHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemVSYW5nZXMoY29tcGxldGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25zICYmIGNvbXBsZXRpb25zLm1hcCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoZWxbXCJyYW5nZVwiXSkge1xuICAgICAgICAgICAgICAgIGVsW1wicmFuZ2VcIl0gPSB0b1JhbmdlKGVsW1wicmFuZ2VcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLm5vcm1hbGl6ZVJhbmdlcyA9IG5vcm1hbGl6ZVJhbmdlcztcbiAgICBmdW5jdGlvbiBjbGVhbkh0bWwoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88YVxccy8sIFwiPGEgdGFyZ2V0PSdfYmxhbmsnIFwiKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLmNsZWFuSHRtbCA9IGNsZWFuSHRtbDtcbiAgICBmdW5jdGlvbiB0b1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2UgfHwgIXJhbmdlLnN0YXJ0IHx8ICFyYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgUmFuZ2UgPSBBY2VSYW5nZS5nZXRDb25zdHJ1Y3RvcigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIudG9SYW5nZSA9IHRvUmFuZ2U7XG4gICAgZnVuY3Rpb24gY29udmVydEtpbmQoa2luZCkge1xuICAgICAgICBzd2l0Y2goa2luZCl7XG4gICAgICAgICAgICBjYXNlIFwicHJpbWl0aXZlVHlwZVwiOlxuICAgICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZDtcbiAgICAgICAgICAgIGNhc2UgXCJ2YXJpYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImxvY2FsVmFyaWFibGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGU7XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyVmFyaWFibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtZW1iZXJHZXRBY2Nlc3NvclwiOlxuICAgICAgICAgICAgY2FzZSBcIm1lbWJlclNldEFjY2Vzc29yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkO1xuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyRnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RTaWduYXR1cmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsU2lnbmF0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiaW5kZXhTaWduYXR1cmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb247XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5FbnVtO1xuICAgICAgICAgICAgY2FzZSBcIm1vZHVsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLkNvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuQ2xhc3M7XG4gICAgICAgICAgICBjYXNlIFwiaW50ZXJmYWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZTtcbiAgICAgICAgICAgIGNhc2UgXCJ3YXJuaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5O1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIuY29udmVydEtpbmQgPSBjb252ZXJ0S2luZDtcbiAgICBmdW5jdGlvbiBleGNsdWRlQnlFcnJvck1lc3NhZ2UoZGlhZ25vc3RpY3MsIGVycm9yTWVzc2FnZXNUb0lnbm9yZSwgZmllbGROYW1lID0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgaWYgKCFlcnJvck1lc3NhZ2VzVG9JZ25vcmUpIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzLmZpbHRlcigoZWwpPT4hKDAsdXRpbHMvKiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5ICovLlRrKShlbFtmaWVsZE5hbWVdLCBlcnJvck1lc3NhZ2VzVG9JZ25vcmUpKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLmV4Y2x1ZGVCeUVycm9yTWVzc2FnZSA9IGV4Y2x1ZGVCeUVycm9yTWVzc2FnZTtcbn0pKGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlciB8fCAoY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyID0ge30pKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3R5cGUtY29udmVydGVycy9sc3AvbHNwLWNvbnZlcnRlcnMudHNcblxuXG5cblxuZnVuY3Rpb24gZnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGxpbmU6IHJhbmdlLnN0YXJ0LnJvdyxcbiAgICAgICAgICAgIGNoYXJhY3RlcjogcmFuZ2Uuc3RhcnQuY29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgbGluZTogcmFuZ2UuZW5kLnJvdyxcbiAgICAgICAgICAgIGNoYXJhY3RlcjogcmFuZ2UuZW5kLmNvbHVtblxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlRnJvbVBvc2l0aW9ucyhzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHJvdzogcmFuZ2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgcm93OiByYW5nZS5lbmQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogcmFuZ2UuZW5kLmNoYXJhY3RlclxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21Qb2ludChwb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IHBvaW50LnJvdyxcbiAgICAgICAgY2hhcmFjdGVyOiBwb2ludC5jb2x1bW5cbiAgICB9O1xufVxuZnVuY3Rpb24gdG9Qb2ludChwb3NpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvdzogcG9zaXRpb24ubGluZSxcbiAgICAgICAgY29sdW1uOiBwb3NpdGlvbi5jaGFyYWN0ZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9Bbm5vdGF0aW9ucyhkaWFnbm9zdGljcykge1xuICAgIHZhciBfZGlhZ25vc3RpY3M7XG4gICAgcmV0dXJuIChfZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcykgPT09IG51bGwgfHwgX2RpYWdub3N0aWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGlhZ25vc3RpY3MubWFwKChlbCk9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogZWwucmFuZ2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZWwucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyLFxuICAgICAgICAgICAgdGV4dDogZWwubWVzc2FnZSxcbiAgICAgICAgICAgIHR5cGU6IGVsLnNldmVyaXR5ID09PSAxID8gXCJlcnJvclwiIDogZWwuc2V2ZXJpdHkgPT09IDIgPyBcIndhcm5pbmdcIiA6IFwiaW5mb1wiLFxuICAgICAgICAgICAgY29kZTogZWwuY29kZVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZnJvbUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgdmFyIF9hbm5vdGF0aW9ucztcbiAgICByZXR1cm4gKF9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zKSA9PT0gbnVsbCB8fCBfYW5ub3RhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9ucy5tYXAoKGVsKT0+e1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBlbC5yb3csXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogZWwuY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZWwucm93LFxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGVsLmNvbHVtblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiBlbC50ZXh0LFxuICAgICAgICAgICAgc2V2ZXJpdHk6IGVsLnR5cGUgPT09IFwiZXJyb3JcIiA/IDEgOiBlbC50eXBlID09PSBcIndhcm5pbmdcIiA/IDIgOiAzLFxuICAgICAgICAgICAgY29kZTogZWxbXCJjb2RlXCJdXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb24oaXRlbSkge1xuICAgIHZhciBfaXRlbV90ZXh0RWRpdCwgX2l0ZW1fY29tbWFuZDtcbiAgICBsZXQgaXRlbUtpbmQgPSBpdGVtLmtpbmQ7XG4gICAgbGV0IGtpbmQgPSBpdGVtS2luZCA/IE9iamVjdC5rZXlzKENvbXBsZXRpb25JdGVtS2luZClbT2JqZWN0LnZhbHVlcyhDb21wbGV0aW9uSXRlbUtpbmQpLmluZGV4T2YoaXRlbUtpbmQpXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCwgX3JlZjtcbiAgICBsZXQgdGV4dCA9IChfcmVmID0gKF9pdGVtX3RleHRFZGl0X25ld1RleHQgPSAoX2l0ZW1fdGV4dEVkaXQgPSBpdGVtLnRleHRFZGl0KSA9PT0gbnVsbCB8fCBfaXRlbV90ZXh0RWRpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fdGV4dEVkaXQubmV3VGV4dCkgIT09IG51bGwgJiYgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCAhPT0gdm9pZCAwID8gX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCA6IGl0ZW0uaW5zZXJ0VGV4dCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGl0ZW0ubGFiZWw7XG4gICAgbGV0IGZpbHRlclRleHQ7XG4gICAgLy8gZmlsdGVyaW5nIHdvdWxkIGhhcHBlbiBvbiBhY2UgZWRpdG9yIHNpZGVcbiAgICAvL1RPRE86IGlmIGZpbHRlcmluZyBhbmQgc29ydGluZyBhcmUgb24gc2VydmVyIHNpZGUsIHdlIHNob3VsZCBkaXNhYmxlIEZpbHRlcmVkTGlzdCBpbiBhY2UgY29tcGxldGVyXG4gICAgaWYgKGl0ZW0uZmlsdGVyVGV4dCkge1xuICAgICAgICBjb25zdCBmaXJzdFdvcmRNYXRjaCA9IGl0ZW0uZmlsdGVyVGV4dC5tYXRjaCgvXFx3Ky8pO1xuICAgICAgICBjb25zdCBmaXJzdFdvcmQgPSBmaXJzdFdvcmRNYXRjaCA/IGZpcnN0V29yZE1hdGNoWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKGZpcnN0V29yZCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZFJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke2ZpcnN0V29yZH1cXFxcYmAsICdpJyk7XG4gICAgICAgICAgICBpZiAoIXdvcmRSZWdleC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGV4dC5pbmNsdWRlcyhpdGVtLmZpbHRlclRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tbWFuZCA9ICgoX2l0ZW1fY29tbWFuZCA9IGl0ZW0uY29tbWFuZCkgPT09IG51bGwgfHwgX2l0ZW1fY29tbWFuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fY29tbWFuZC5jb21tYW5kKSA9PSBcImVkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3RcIiA/IFwic3RhcnRBdXRvY29tcGxldGVcIiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcmFuZ2UgPSBpdGVtLnRleHRFZGl0ID8gZ2V0VGV4dEVkaXRSYW5nZShpdGVtLnRleHRFZGl0LCBmaWx0ZXJUZXh0KSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY29tcGxldGlvbiA9IHtcbiAgICAgICAgbWV0YToga2luZCxcbiAgICAgICAgY2FwdGlvbjogaXRlbS5sYWJlbCxcbiAgICAgICAgc2NvcmU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgY29tcGxldGlvbltcImNvbW1hbmRcIl0gPSBjb21tYW5kO1xuICAgIGNvbXBsZXRpb25bXCJyYW5nZVwiXSA9IHJhbmdlO1xuICAgIGNvbXBsZXRpb25bXCJpdGVtXCJdID0gaXRlbTtcbiAgICBpZiAoaXRlbS5pbnNlcnRUZXh0Rm9ybWF0ID09IEluc2VydFRleHRGb3JtYXQuU25pcHBldCkge1xuICAgICAgICBjb21wbGV0aW9uW1wic25pcHBldFwiXSA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGlvbltcInZhbHVlXCJdID0gdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogXCJcIjtcbiAgICB9XG4gICAgY29tcGxldGlvbltcImRvY3VtZW50YXRpb25cIl0gPSBpdGVtLmRvY3VtZW50YXRpb247IC8vVE9ETzogdGhpcyBpcyB3b3JrYXJvdW5kIGZvciBzZXJ2aWNlcyB3aXRoIGluc3RhbnQgY29tcGxldGlvblxuICAgIGNvbXBsZXRpb25bXCJwb3NpdGlvblwiXSA9IGl0ZW1bXCJwb3NpdGlvblwiXTtcbiAgICBjb21wbGV0aW9uW1wic2VydmljZVwiXSA9IGl0ZW1bXCJzZXJ2aWNlXCJdOyAvL1RPRE86IHNpbmNlIHdlIGhhdmUgbXVsdGlwbGUgc2VydmVycywgd2UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAvLyBzZXJ2ZXIgdG8gdXNlIGZvciByZXNvbHZpbmdcbiAgICByZXR1cm4gY29tcGxldGlvbjtcbn1cbmZ1bmN0aW9uIHRvQ29tcGxldGlvbnMoY29tcGxldGlvbnMpIHtcbiAgICBpZiAoY29tcGxldGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgY29tYmluZWRDb21wbGV0aW9ucyA9IGdldENvbXBsZXRpb25JdGVtcyhjb21wbGV0aW9ucyk7XG4gICAgICAgIHJldHVybiBjb21iaW5lZENvbXBsZXRpb25zLm1hcCgoaXRlbSk9PnRvQ29tcGxldGlvbihpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGdldENvbXBsZXRpb25JdGVtcyhjb21wbGV0aW9ucykge1xuICAgIHJldHVybiBjb21wbGV0aW9ucy5tYXAoKGVsKT0+e1xuICAgICAgICBpZiAoIWVsLmNvbXBsZXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsbENvbXBsZXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbC5jb21wbGV0aW9ucykpIHtcbiAgICAgICAgICAgIGFsbENvbXBsZXRpb25zID0gZWwuY29tcGxldGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxDb21wbGV0aW9ucyA9IGVsLmNvbXBsZXRpb25zLml0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxDb21wbGV0aW9ucy5tYXAoKGl0ZW0pPT57XG4gICAgICAgICAgICBpdGVtW1wic2VydmljZVwiXSA9IGVsLnNlcnZpY2U7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfSkuZmxhdCgpO1xufVxuZnVuY3Rpb24gdG9JbmxpbmVDb21wbGV0aW9uKGl0ZW0pIHtcbiAgICB2YXIgX2l0ZW1fY29tbWFuZDtcbiAgICBsZXQgdGV4dCA9IHR5cGVvZiBpdGVtLmluc2VydFRleHQgPT09IFwic3RyaW5nXCIgPyBpdGVtLmluc2VydFRleHQgOiBpdGVtLmluc2VydFRleHQudmFsdWU7XG4gICAgbGV0IGZpbHRlclRleHQ7XG4gICAgLy8gZmlsdGVyaW5nIHdvdWxkIGhhcHBlbiBvbiBhY2UgZWRpdG9yIHNpZGVcbiAgICAvL1RPRE86IGlmIGZpbHRlcmluZyBhbmQgc29ydGluZyBhcmUgb24gc2VydmVyIHNpZGUsIHdlIHNob3VsZCBkaXNhYmxlIEZpbHRlcmVkTGlzdCBpbiBhY2UgY29tcGxldGVyXG4gICAgaWYgKGl0ZW0uZmlsdGVyVGV4dCkge1xuICAgICAgICBjb25zdCBmaXJzdFdvcmRNYXRjaCA9IGl0ZW0uZmlsdGVyVGV4dC5tYXRjaCgvXFx3Ky8pO1xuICAgICAgICBjb25zdCBmaXJzdFdvcmQgPSBmaXJzdFdvcmRNYXRjaCA/IGZpcnN0V29yZE1hdGNoWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKGZpcnN0V29yZCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZFJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke2ZpcnN0V29yZH1cXFxcYmAsICdpJyk7XG4gICAgICAgICAgICBpZiAoIXdvcmRSZWdleC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGV4dC5pbmNsdWRlcyhpdGVtLmZpbHRlclRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tbWFuZCA9ICgoX2l0ZW1fY29tbWFuZCA9IGl0ZW0uY29tbWFuZCkgPT09IG51bGwgfHwgX2l0ZW1fY29tbWFuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fY29tbWFuZC5jb21tYW5kKSA9PSBcImVkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3RcIiA/IFwic3RhcnRBdXRvY29tcGxldGVcIiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcmFuZ2UgPSBpdGVtLnJhbmdlID8gZ2V0SW5saW5lQ29tcGxldGlvblJhbmdlKGl0ZW0ucmFuZ2UsIGZpbHRlclRleHQpIDogdW5kZWZpbmVkO1xuICAgIGxldCBjb21wbGV0aW9uID0ge307XG4gICAgY29tcGxldGlvbltcImNvbW1hbmRcIl0gPSBjb21tYW5kO1xuICAgIGNvbXBsZXRpb25bXCJyYW5nZVwiXSA9IHJhbmdlO1xuICAgIGNvbXBsZXRpb25bXCJpdGVtXCJdID0gaXRlbTtcbiAgICBpZiAodHlwZW9mIGl0ZW0uaW5zZXJ0VGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb21wbGV0aW9uW1wic25pcHBldFwiXSA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGlvbltcInZhbHVlXCJdID0gdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogXCJcIjtcbiAgICB9XG4gICAgY29tcGxldGlvbltcInBvc2l0aW9uXCJdID0gaXRlbVtcInBvc2l0aW9uXCJdO1xuICAgIGNvbXBsZXRpb25bXCJzZXJ2aWNlXCJdID0gaXRlbVtcInNlcnZpY2VcIl07IC8vVE9ETzogc2luY2Ugd2UgaGF2ZSBtdWx0aXBsZSBzZXJ2ZXJzLCB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgIC8vIHNlcnZlciB0byB1c2UgZm9yIHJlc29sdmluZ1xuICAgIHJldHVybiBjb21wbGV0aW9uO1xufVxuZnVuY3Rpb24gdG9JbmxpbmVDb21wbGV0aW9ucyhjb21wbGV0aW9ucykge1xuICAgIGlmIChjb21wbGV0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBjb21iaW5lZENvbXBsZXRpb25zID0gZ2V0Q29tcGxldGlvbkl0ZW1zKGNvbXBsZXRpb25zKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkQ29tcGxldGlvbnMubWFwKChpdGVtKT0+dG9JbmxpbmVDb21wbGV0aW9uKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gdG9SZXNvbHZlZENvbXBsZXRpb24oY29tcGxldGlvbiwgaXRlbSkge1xuICAgIGNvbXBsZXRpb25bXCJkb2NNYXJrZG93blwiXSA9IGZyb21NYXJrdXBDb250ZW50KGl0ZW0uZG9jdW1lbnRhdGlvbik7XG4gICAgcmV0dXJuIGNvbXBsZXRpb247XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb25JdGVtKGNvbXBsZXRpb24pIHtcbiAgICBsZXQgY29tbWFuZDtcbiAgICBpZiAoY29tcGxldGlvbltcImNvbW1hbmRcIl0pIHtcbiAgICAgICAgY29tbWFuZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcInRyaWdnZXJTdWdnZXN0XCIsXG4gICAgICAgICAgICBjb21tYW5kOiBjb21wbGV0aW9uW1wiY29tbWFuZFwiXVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgX2NvbXBsZXRpb25fY2FwdGlvbjtcbiAgICBsZXQgY29tcGxldGlvbkl0ZW0gPSB7XG4gICAgICAgIGxhYmVsOiAoX2NvbXBsZXRpb25fY2FwdGlvbiA9IGNvbXBsZXRpb24uY2FwdGlvbikgIT09IG51bGwgJiYgX2NvbXBsZXRpb25fY2FwdGlvbiAhPT0gdm9pZCAwID8gX2NvbXBsZXRpb25fY2FwdGlvbiA6IFwiXCIsXG4gICAgICAgIGtpbmQ6IENvbW1vbkNvbnZlcnRlci5jb252ZXJ0S2luZChjb21wbGV0aW9uLm1ldGEpLFxuICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBjb21wbGV0aW9uW1wic25pcHBldFwiXSA/IEluc2VydFRleHRGb3JtYXQuU25pcHBldCA6IEluc2VydFRleHRGb3JtYXQuUGxhaW5UZXh0LFxuICAgICAgICBkb2N1bWVudGF0aW9uOiBjb21wbGV0aW9uW1wiZG9jdW1lbnRhdGlvblwiXVxuICAgIH07XG4gICAgaWYgKGNvbXBsZXRpb25bXCJyYW5nZVwiXSkge1xuICAgICAgICB2YXIgX2NvbXBsZXRpb25fc25pcHBldDtcbiAgICAgICAgY29tcGxldGlvbkl0ZW0udGV4dEVkaXQgPSB7XG4gICAgICAgICAgICByYW5nZTogZnJvbVJhbmdlKGNvbXBsZXRpb25bXCJyYW5nZVwiXSksXG4gICAgICAgICAgICBuZXdUZXh0OiAoX2NvbXBsZXRpb25fc25pcHBldCA9IGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdKSAhPT0gbnVsbCAmJiBfY29tcGxldGlvbl9zbmlwcGV0ICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9zbmlwcGV0IDogY29tcGxldGlvbltcInZhbHVlXCJdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb21wbGV0aW9uX3NuaXBwZXQxO1xuICAgICAgICBjb21wbGV0aW9uSXRlbS5pbnNlcnRUZXh0ID0gKF9jb21wbGV0aW9uX3NuaXBwZXQxID0gY29tcGxldGlvbltcInNuaXBwZXRcIl0pICE9PSBudWxsICYmIF9jb21wbGV0aW9uX3NuaXBwZXQxICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9zbmlwcGV0MSA6IGNvbXBsZXRpb25bXCJ2YWx1ZVwiXTtcbiAgICB9XG4gICAgY29tcGxldGlvbkl0ZW1bXCJmaWxlTmFtZVwiXSA9IGNvbXBsZXRpb25bXCJmaWxlTmFtZVwiXTtcbiAgICBjb21wbGV0aW9uSXRlbVtcInBvc2l0aW9uXCJdID0gY29tcGxldGlvbltcInBvc2l0aW9uXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wiaXRlbVwiXSA9IGNvbXBsZXRpb25bXCJpdGVtXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wic2VydmljZVwiXSA9IGNvbXBsZXRpb25bXCJzZXJ2aWNlXCJdOyAvL1RPRE86XG4gICAgcmV0dXJuIGNvbXBsZXRpb25JdGVtO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEVkaXRSYW5nZSh0ZXh0RWRpdCwgZmlsdGVyVGV4dCkge1xuICAgIGNvbnN0IGZpbHRlckxlbmd0aCA9IGZpbHRlclRleHQgPyBmaWx0ZXJUZXh0Lmxlbmd0aCA6IDA7XG4gICAgaWYgKFwiaW5zZXJ0XCIgaW4gdGV4dEVkaXQgJiYgXCJyZXBsYWNlXCIgaW4gdGV4dEVkaXQpIHtcbiAgICAgICAgbGV0IG1lcmdlZFJhbmdlcyA9IG1lcmdlUmFuZ2VzKFtcbiAgICAgICAgICAgIHRvUmFuZ2UodGV4dEVkaXQuaW5zZXJ0KSxcbiAgICAgICAgICAgIHRvUmFuZ2UodGV4dEVkaXQucmVwbGFjZSlcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBtZXJnZWRSYW5nZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dEVkaXQucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC09IGZpbHRlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRvUmFuZ2UodGV4dEVkaXQucmFuZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldElubGluZUNvbXBsZXRpb25SYW5nZShyYW5nZSwgZmlsdGVyVGV4dCkge1xuICAgIGNvbnN0IGZpbHRlckxlbmd0aCA9IGZpbHRlclRleHQgPyBmaWx0ZXJUZXh0Lmxlbmd0aCA6IDA7XG4gICAgcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC09IGZpbHRlckxlbmd0aDtcbiAgICByZXR1cm4gdG9SYW5nZShyYW5nZSk7XG59XG5mdW5jdGlvbiB0b1Rvb2x0aXAoaG92ZXIpIHtcbiAgICB2YXIgX2hvdmVyX2ZpbmQ7XG4gICAgaWYgKCFob3ZlcikgcmV0dXJuO1xuICAgIGxldCBjb250ZW50ID0gaG92ZXIubWFwKChlbCk9PntcbiAgICAgICAgaWYgKCFlbCB8fCAhZWwuY29udGVudHMpIHJldHVybjtcbiAgICAgICAgaWYgKE1hcmt1cENvbnRlbnQuaXMoZWwuY29udGVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU1hcmt1cENvbnRlbnQoZWwuY29udGVudHMpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hcmtlZFN0cmluZy5pcyhlbC5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwuY29udGVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY29udGVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJgYGBcIiArIGVsLmNvbnRlbnRzLnZhbHVlICsgXCJgYGBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50cyA9IGVsLmNvbnRlbnRzLm1hcCgoZWwpPT57XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcYFxcYFxcYCR7ZWwudmFsdWV9XFxgXFxgXFxgYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudHMuam9pbihcIlxcblxcblwiKTtcbiAgICAgICAgfVxuICAgIH0pLmZpbHRlcihub3RFbXB0eSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgLy9UT0RPOiBpdCBjb3VsZCBiZSBtZXJnZWQgd2l0aGluIGFsbCByYW5nZXMgaW4gZnV0dXJlXG4gICAgbGV0IGxzcFJhbmdlID0gKF9ob3Zlcl9maW5kID0gaG92ZXIuZmluZCgoZWwpPT57XG4gICAgICAgIHZhciBfZWw7XG4gICAgICAgIHJldHVybiAoX2VsID0gZWwpID09PSBudWxsIHx8IF9lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsLnJhbmdlO1xuICAgIH0pKSA9PT0gbnVsbCB8fCBfaG92ZXJfZmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hvdmVyX2ZpbmQucmFuZ2U7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChsc3BSYW5nZSkgcmFuZ2UgPSB0b1JhbmdlKGxzcFJhbmdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgICB0ZXh0OiBjb250ZW50LmpvaW4oXCJcXG5cXG5cIilcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21TaWduYXR1cmVIZWxwKHNpZ25hdHVyZUhlbHApIHtcbiAgICBpZiAoIXNpZ25hdHVyZUhlbHApIHJldHVybjtcbiAgICBsZXQgY29udGVudCA9IHNpZ25hdHVyZUhlbHAubWFwKChlbCk9PntcbiAgICAgICAgdmFyIF9lbCwgX2VsMTtcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc2lnbmF0dXJlSW5kZXggPSAoKF9lbCA9IGVsKSA9PT0gbnVsbCB8fCBfZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbC5hY3RpdmVTaWduYXR1cmUpIHx8IDA7XG4gICAgICAgIGxldCBhY3RpdmVTaWduYXR1cmUgPSBlbC5zaWduYXR1cmVzW3NpZ25hdHVyZUluZGV4XTtcbiAgICAgICAgaWYgKCFhY3RpdmVTaWduYXR1cmUpIHJldHVybjtcbiAgICAgICAgbGV0IGFjdGl2ZVBhcmFtID0gKF9lbDEgPSBlbCkgPT09IG51bGwgfHwgX2VsMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsMS5hY3RpdmVQYXJhbWV0ZXI7XG4gICAgICAgIGxldCBjb250ZW50cyA9IGFjdGl2ZVNpZ25hdHVyZS5sYWJlbDtcbiAgICAgICAgaWYgKGFjdGl2ZVBhcmFtICE9IHVuZGVmaW5lZCAmJiBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVycyAmJiBhY3RpdmVTaWduYXR1cmUucGFyYW1ldGVyc1thY3RpdmVQYXJhbV0pIHtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IGFjdGl2ZVNpZ25hdHVyZS5wYXJhbWV0ZXJzW2FjdGl2ZVBhcmFtXS5sYWJlbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMucmVwbGFjZShwYXJhbSwgYCoqJHtwYXJhbX0qKmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbikge1xuICAgICAgICAgICAgaWYgKE1hcmt1cENvbnRlbnQuaXMoYWN0aXZlU2lnbmF0dXJlLmRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzICsgXCJcXG5cXG5cIiArIGZyb21NYXJrdXBDb250ZW50KGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgKz0gXCJcXG5cXG5cIiArIGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50cztcbiAgICAgICAgfVxuICAgIH0pLmZpbHRlcihub3RFbXB0eSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgdHlwZTogXCJtYXJrZG93blwiLFxuICAgICAgICAgICAgdGV4dDogY29udGVudC5qb2luKFwiXFxuXFxuXCIpXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbU1hcmt1cENvbnRlbnQoY29udGVudCkge1xuICAgIGlmICghY29udGVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudC52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmcm9tQWNlRGVsdGEoZGVsdGEsIGVvbCkge1xuICAgIGNvbnN0IHRleHQgPSBkZWx0YS5saW5lcy5sZW5ndGggPiAxID8gZGVsdGEubGluZXMuam9pbihlb2wpIDogZGVsdGEubGluZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2U6IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHJhbmdlRnJvbVBvc2l0aW9ucyhmcm9tUG9pbnQoZGVsdGEuc3RhcnQpLCBmcm9tUG9pbnQoZGVsdGEuc3RhcnQpKSA6IHJhbmdlRnJvbVBvc2l0aW9ucyhmcm9tUG9pbnQoZGVsdGEuc3RhcnQpLCBmcm9tUG9pbnQoZGVsdGEuZW5kKSksXG4gICAgICAgIHRleHQ6IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRcIiA/IHRleHQgOiBcIlwiXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckRpYWdub3N0aWNzKGRpYWdub3N0aWNzLCBmaWx0ZXJFcnJvcnMpIHtcbiAgICByZXR1cm4gY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyLmV4Y2x1ZGVCeUVycm9yTWVzc2FnZShkaWFnbm9zdGljcywgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkubWFwKChlbCk9PntcbiAgICAgICAgaWYgKCgwLHV0aWxzLyogY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSAqLy5UaykoZWwubWVzc2FnZSwgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nKSkge1xuICAgICAgICAgICAgZWwuc2V2ZXJpdHkgPSBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKCgwLHV0aWxzLyogY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSAqLy5UaykoZWwubWVzc2FnZSwgZmlsdGVyRXJyb3JzLmVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvKSkge1xuICAgICAgICAgICAgZWwuc2V2ZXJpdHkgPSBtYWluLkRpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRIaWdobGlnaHRzKGRvY3VtZW50SGlnaGxpZ2h0cykge1xuICAgIHJldHVybiBkb2N1bWVudEhpZ2hsaWdodHMubWFwKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSBlbC5raW5kID09IDIgPyBcImxhbmd1YWdlX2hpZ2hsaWdodF9yZWFkXCIgOiBlbC5raW5kID09IDMgPyBcImxhbmd1YWdlX2hpZ2hsaWdodF93cml0ZVwiIDogXCJsYW5ndWFnZV9oaWdobGlnaHRfdGV4dFwiO1xuICAgICAgICByZXR1cm4gdG9NYXJrZXJHcm91cEl0ZW0oQ29tbW9uQ29udmVydGVyLnRvUmFuZ2UodG9SYW5nZShlbC5yYW5nZSkpLCBjbGFzc05hbWUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9NYXJrZXJHcm91cEl0ZW0ocmFuZ2UsIGNsYXNzTmFtZSwgdG9vbHRpcFRleHQpIHtcbiAgICBsZXQgbWFya2VyR3JvdXBJdGVtID0ge1xuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfTtcbiAgICBpZiAodG9vbHRpcFRleHQpIHtcbiAgICAgICAgbWFya2VyR3JvdXBJdGVtW1widG9vbHRpcFRleHRcIl0gPSB0b29sdGlwVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlckdyb3VwSXRlbTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2x1YS9sdWEtc2VydmljZS50c1xuZnVuY3Rpb24gbHVhX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cblxuXG5jbGFzcyBMdWFTZXJ2aWNlIGV4dGVuZHMgYmFzZV9zZXJ2aWNlLkJhc2VTZXJ2aWNlIHtcbiAgICBhc3luYyBkb1ZhbGlkYXRpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXREb2N1bWVudFZhbHVlKGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGVycm9ycyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kc2VydmljZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgdGhpcy4kc2VydmljZS5TeW50YXhFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGUuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGUuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyRGlhZ25vc3RpY3MoZXJyb3JzLCB0aGlzLm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobW9kZSl7XG4gICAgICAgIHN1cGVyKG1vZGUpO1xuICAgICAgICBsdWFfc2VydmljZV9kZWZpbmVfcHJvcGVydHkodGhpcywgXCIkc2VydmljZVwiLCB2b2lkIDApO1xuICAgICAgICBsdWFfc2VydmljZV9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHtcbiAgICAgICAgICAgIGRpYWdub3N0aWNQcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIGludGVyRmlsZURlcGVuZGVuY2llczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VEaWFnbm9zdGljczogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kc2VydmljZSA9IGx1YXBhcnNlO1xuICAgIH1cbn1cblxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImEiLCJpIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJwcm9jZXNzIiwiY29uc29sZSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9yZXF1aXJlIiwiX3JlcXVpcmUkY29kZXMiLCJjb2RlcyIsIkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9JTlZBTElEX0FSR19WQUxVRSIsIkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSIsIkVSUl9NSVNTSU5HX0FSR1MiLCJBc3NlcnRpb25FcnJvciIsIl9yZXF1aXJlMiIsImluc3BlY3QiLCJfcmVxdWlyZSR0eXBlcyIsInR5cGVzIiwiaXNQcm9taXNlIiwiaXNSZWdFeHAiLCJvYmplY3RBc3NpZ24iLCJPYmplY3QiLCJhc3NpZ24iLCJvYmplY3RJcyIsImlzIiwiZXJyb3JDYWNoZSIsIk1hcCIsImlzRGVlcEVxdWFsIiwiaXNEZWVwU3RyaWN0RXF1YWwiLCJwYXJzZUV4cHJlc3Npb25BdCIsImZpbmROb2RlQXJvdW5kIiwiZGVjb2RlciIsImxhenlMb2FkQ29tcGFyaXNvbiIsImNvbXBhcmlzb24iLCJlc2NhcGVTZXF1ZW5jZXNSZWdFeHAiLCJtZXRhIiwiZXNjYXBlRm4iLCJzdHIiLCJjaGFyQ29kZUF0Iiwid2FybmVkIiwiYXNzZXJ0Iiwib2siLCJOT19FWENFUFRJT05fU0VOVElORUwiLCJpbm5lckZhaWwiLCJtZXNzYWdlIiwiRXJyb3IiLCJmYWlsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcGVyYXRvciIsInN0YWNrU3RhcnRGbiIsImFyZ3NMZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpbnRlcm5hbE1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJ3YXJuIiwiZW1pdFdhcm5pbmciLCJiaW5kIiwiZXJyQXJncyIsImVyciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJpbm5lck9rIiwiZm4iLCJhcmdMZW4iLCJ2YWx1ZSIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiYXBwbHkiLCJjb25jYXQiLCJlcXVhbCIsIm5vdEVxdWFsIiwiZGVlcEVxdWFsIiwibm90RGVlcEVxdWFsIiwiZGVlcFN0cmljdEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsIkNvbXBhcmlzb24iLCJrZXlzIiwiX3RoaXMiLCJmb3JFYWNoIiwia2V5IiwidGVzdCIsImNvbXBhcmVFeGNlcHRpb25LZXkiLCJiIiwibmFtZSIsImV4cGVjdGVkRXhjZXB0aW9uIiwibXNnIiwicHVzaCIsImlzUHJvdG90eXBlT2YiLCJjYWxsIiwiZ2V0QWN0dWFsIiwiZSIsImNoZWNrSXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwid2FpdEZvckFjdHVhbCIsInByb21pc2VGbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzdWx0UHJvbWlzZSIsImV4cGVjdHNFcnJvciIsImVycm9yIiwiZGV0YWlscyIsImZuVHlwZSIsImV4cGVjdHNOb0Vycm9yIiwidGhyb3dzIiwiX2xlbjIiLCJfa2V5MiIsInJlamVjdHMiLCJfbGVuMyIsIl9rZXkzIiwicmVzdWx0IiwiZG9lc05vdFRocm93IiwiX2xlbjQiLCJfa2V5NCIsImRvZXNOb3RSZWplY3QiLCJfbGVuNSIsIl9rZXk1IiwiaWZFcnJvciIsIm5ld0VyciIsIm9yaWdTdGFjayIsInN0YWNrIiwidG1wMiIsInNwbGl0Iiwic2hpZnQiLCJ0bXAxIiwicG9zIiwiaW5kZXhPZiIsInNsaWNlIiwiam9pbiIsInN0cmljdCIsIl9sZW42IiwiX2tleTYiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0Iiwic291cmNlIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiQ2xhc3MiLCJfY2FjaGUiLCJfaXNOYXRpdmVGdW5jdGlvbiIsImhhcyIsImdldCIsInNldCIsIldyYXBwZXIiLCJfY29uc3RydWN0IiwiX2dldFByb3RvdHlwZU9mIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkRhdGUiLCJ0b1N0cmluZyIsIlBhcmVudCIsIkZ1bmN0aW9uIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImdldFByb3RvdHlwZU9mIiwiZW5kc1dpdGgiLCJzZWFyY2giLCJ0aGlzX2xlbiIsInN1YnN0cmluZyIsInJlcGVhdCIsImNvdW50IiwiTWF0aCIsImZsb29yIiwibWF4Q291bnQiLCJsb2ciLCJibHVlIiwiZ3JlZW4iLCJyZWQiLCJ3aGl0ZSIsImtSZWFkYWJsZU9wZXJhdG9yIiwic3RyaWN0RXF1YWxPYmplY3QiLCJub3RTdHJpY3RFcXVhbE9iamVjdCIsIm5vdElkZW50aWNhbCIsImtNYXhTaG9ydExlbmd0aCIsImNvcHlFcnJvciIsImluc3BlY3RWYWx1ZSIsInZhbCIsImNvbXBhY3QiLCJjdXN0b21JbnNwZWN0IiwiZGVwdGgiLCJtYXhBcnJheUxlbmd0aCIsIkluZmluaXR5Iiwic2hvd0hpZGRlbiIsImJyZWFrTGVuZ3RoIiwic2hvd1Byb3h5Iiwic29ydGVkIiwiZ2V0dGVycyIsImNyZWF0ZUVyckRpZmYiLCJvdGhlciIsInJlcyIsImxhc3RQb3MiLCJlbmQiLCJza2lwcGVkIiwiYWN0dWFsSW5zcGVjdGVkIiwiYWN0dWFsTGluZXMiLCJleHBlY3RlZExpbmVzIiwiaW5kaWNhdG9yIiwiaW5wdXRMZW5ndGgiLCJtYXhMZW5ndGgiLCJzdGRlcnIiLCJpc1RUWSIsImNvbHVtbnMiLCJwb3AiLCJtYXhMaW5lcyIsIm1heCIsIl9hY3R1YWxMaW5lcyIsInByaW50ZWRMaW5lcyIsInNraXBwZWRNc2ciLCJjdXIiLCJleHBlY3RlZExpbmUiLCJhY3R1YWxMaW5lIiwiZGl2ZXJnaW5nTGluZXMiLCJfRXJyb3IiLCJvcHRpb25zIiwibGltaXQiLCJzdGFja1RyYWNlTGltaXQiLCJTdHJpbmciLCJnZXRDb2xvckRlcHRoIiwiYmFzZSIsIl9yZXMiLCJrbm93bk9wZXJhdG9ycyIsImNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImN1c3RvbSIsInJlY3Vyc2VUaW1lcyIsImN0eCIsInV0aWwiLCJjcmVhdGVFcnJvclR5cGUiLCJCYXNlIiwiZ2V0TWVzc2FnZSIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIk5vZGVFcnJvciIsIl9CYXNlIiwib25lT2YiLCJ0aGluZyIsImlzQXJyYXkiLCJsZW4iLCJtYXAiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwiaW5jbHVkZXMiLCJzdGFydCIsImRldGVybWluZXIiLCJyZXBsYWNlIiwidHlwZSIsInJlYXNvbiIsImluc3BlY3RlZCIsIlJhbmdlRXJyb3IiLCJpbnB1dCIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIl9zIiwibmV4dCIsImRvbmUiLCJyZWdleEZsYWdzU3VwcG9ydGVkIiwiZmxhZ3MiLCJhcnJheUZyb21TZXQiLCJhcnJheSIsImFycmF5RnJvbU1hcCIsIm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyIsIm51bWJlcklzTmFOIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmN1cnJ5VGhpcyIsImYiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwib2JqZWN0VG9TdHJpbmciLCJpc0FueUFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc0RhdGUiLCJpc01hcCIsImlzU2V0IiwiaXNOYXRpdmVFcnJvciIsImlzQm94ZWRQcmltaXRpdmUiLCJpc051bWJlck9iamVjdCIsImlzU3RyaW5nT2JqZWN0IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCaWdJbnRPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc05vbkluZGV4IiwicG93IiwiZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzIiwiY29tcGFyZSIsIngiLCJ5IiwibWluIiwiT05MWV9FTlVNRVJBQkxFIiwia1N0cmljdCIsImtMb29zZSIsImtOb0l0ZXJhdG9yIiwia0lzQXJyYXkiLCJrSXNTZXQiLCJrSXNNYXAiLCJhcmVTaW1pbGFyUmVnRXhwcyIsIlJlZ0V4cCIsImFyZVNpbWlsYXJGbG9hdEFycmF5cyIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJhcmVTaW1pbGFyVHlwZWRBcnJheXMiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImFyZUVxdWFsQXJyYXlCdWZmZXJzIiwiYnVmMSIsImJ1ZjIiLCJpc0VxdWFsQm94ZWRQcmltaXRpdmUiLCJ2YWwxIiwidmFsMiIsInZhbHVlT2YiLCJCb29sZWFuIiwiQmlnSW50IiwiaW5uZXJEZWVwRXF1YWwiLCJtZW1vcyIsInZhbDFUYWciLCJ2YWwyVGFnIiwia2V5czEiLCJrZXlzMiIsImtleUNoZWNrIiwiZ2V0VGltZSIsIl9rZXlzIiwiX2tleXMyIiwic2l6ZSIsImdldEVudW1lcmFibGVzIiwiayIsIml0ZXJhdGlvblR5cGUiLCJhS2V5cyIsImJLZXlzIiwic3ltYm9sS2V5c0EiLCJzeW1ib2xLZXlzQiIsIl9zeW1ib2xLZXlzQiIsInBvc2l0aW9uIiwidmFsMk1lbW9BIiwidmFsMk1lbW9CIiwiYXJlRXEiLCJvYmpFcXVpdiIsImRlbGV0ZSIsInNldEhhc0VxdWFsRWxlbWVudCIsIm1lbW8iLCJzZXRWYWx1ZXMiLCJmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMiLCJwcmltIiwic2V0TWlnaHRIYXZlTG9vc2VQcmltIiwiYWx0VmFsdWUiLCJtYXBNaWdodEhhdmVMb29zZVByaW0iLCJpdGVtIiwiY3VyQiIsInNldEVxdWl2IiwiYVZhbHVlcyIsIlNldCIsImFkZCIsImJWYWx1ZXMiLCJfdmFsIiwibWFwSGFzRXF1YWxFbnRyeSIsImtleTEiLCJpdGVtMSIsImtleTIiLCJtYXBFcXVpdiIsImFFbnRyaWVzIiwiX2FFbnRyaWVzJGkiLCJpdGVtMiIsImJFbnRyaWVzIiwiX2kyIiwiX2JFbnRyaWVzJF9pIiwia2V5c0EiLCJHZXRJbnRyaW5zaWMiLCJjYWxsQmluZCIsIiRpbmRleE9mIiwiY2FsbEJvdW5kSW50cmluc2ljIiwiYWxsb3dNaXNzaW5nIiwiaW50cmluc2ljIiwic2V0RnVuY3Rpb25MZW5ndGgiLCIkVHlwZUVycm9yIiwiJGFwcGx5IiwiJGNhbGwiLCIkcmVmbGVjdEFwcGx5IiwiJGRlZmluZVByb3BlcnR5IiwiJG1heCIsIm9yaWdpbmFsRnVuY3Rpb24iLCJmdW5jIiwiYXBwbHlCaW5kIiwibm93IiwidGltZXMiLCJnIiwid2luZG93IiwiZnVuY3Rpb25zIiwiaW5mbyIsInRpbWUiLCJ0aW1lRW5kIiwidHJhY2UiLCJkaXIiLCJjb25zb2xlQXNzZXJ0IiwidHVwbGUiLCJsYWJlbCIsImR1cmF0aW9uIiwiZm9ybWF0Iiwib2JqZWN0IiwiZXhwcmVzc2lvbiIsIiRTeW50YXhFcnJvciIsImdvcGQiLCJkZWZpbmVEYXRhUHJvcGVydHkiLCJwcm9wZXJ0eSIsIm5vbkVudW1lcmFibGUiLCJub25Xcml0YWJsZSIsIm5vbkNvbmZpZ3VyYWJsZSIsImxvb3NlIiwiZGVzYyIsImhhc1N5bWJvbHMiLCJ0b1N0ciIsImlzRnVuY3Rpb24iLCJzdXBwb3J0c0Rlc2NyaXB0b3JzIiwicHJlZGljYXRlIiwiZGVmaW5lUHJvcGVydGllcyIsInByZWRpY2F0ZXMiLCJFdmFsRXJyb3IiLCJTeW50YXhFcnJvciIsIlVSSUVycm9yIiwiZmlyc3RTb3VyY2UiLCJ0byIsIm5leHRTb3VyY2UiLCJrZXlzQXJyYXkiLCJuZXh0SW5kZXgiLCJuZXh0S2V5IiwicG9seWZpbGwiLCJpc0NhbGxhYmxlIiwiZm9yRWFjaEFycmF5IiwicmVjZWl2ZXIiLCJmb3JFYWNoU3RyaW5nIiwic3RyaW5nIiwiY2hhckF0IiwiZm9yRWFjaE9iamVjdCIsImxpc3QiLCJ0aGlzQXJnIiwiRVJST1JfTUVTU0FHRSIsImZ1bmNUeXBlIiwiY29uY2F0dHkiLCJqIiwic2xpY3kiLCJhcnJMaWtlIiwiam9pbnkiLCJqb2luZXIiLCJ0aGF0IiwiYm91bmQiLCJiaW5kZXIiLCJib3VuZExlbmd0aCIsImJvdW5kQXJncyIsIkVtcHR5IiwiaW1wbGVtZW50YXRpb24iLCIkRXJyb3IiLCIkRXZhbEVycm9yIiwiJFJhbmdlRXJyb3IiLCIkUmVmZXJlbmNlRXJyb3IiLCIkVVJJRXJyb3IiLCIkRnVuY3Rpb24iLCJnZXRFdmFsbGVkQ29uc3RydWN0b3IiLCJleHByZXNzaW9uU3ludGF4IiwiJGdPUEQiLCJ0aHJvd1R5cGVFcnJvciIsIlRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiY2FsbGVlVGhyb3dzIiwiZ09QRHRocm93cyIsImhhc1Byb3RvIiwiZ2V0UHJvdG8iLCJuZWVkc0V2YWwiLCJUeXBlZEFycmF5IiwiSU5UUklOU0lDUyIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXJyYXlCdWZmZXIiLCJBdG9taWNzIiwiQmlnSW50NjRBcnJheSIsIkJpZ1VpbnQ2NEFycmF5IiwiRGF0YVZpZXciLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJldmFsIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImlzRmluaXRlIiwiSlNPTiIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlNoYXJlZEFycmF5QnVmZmVyIiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiV2Vha01hcCIsIldlYWtSZWYiLCJXZWFrU2V0IiwiZXJyb3JQcm90byIsImRvRXZhbCIsImdlbiIsIkxFR0FDWV9BTElBU0VTIiwiaGFzT3duIiwiJGNvbmNhdCIsIiRzcGxpY2VBcHBseSIsInNwbGljZSIsIiRyZXBsYWNlIiwiJHN0clNsaWNlIiwiJGV4ZWMiLCJleGVjIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImZpcnN0IiwibGFzdCIsIm1hdGNoIiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJnZXRCYXNlSW50cmluc2ljIiwiaW50cmluc2ljTmFtZSIsImFsaWFzIiwicGFydHMiLCJpbnRyaW5zaWNCYXNlTmFtZSIsImludHJpbnNpY1JlYWxOYW1lIiwic2tpcEZ1cnRoZXJDYWNoaW5nIiwiaXNPd24iLCJwYXJ0IiwiaGFzUHJvcGVydHlEZXNjcmlwdG9ycyIsImhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnIiwiZm9vIiwiJE9iamVjdCIsIm9yaWdTeW1ib2wiLCJoYXNTeW1ib2xTaGFtIiwiaGFzTmF0aXZlU3ltYm9scyIsInN5bU9iaiIsInN5bVZhbCIsImdldE93blByb3BlcnR5TmFtZXMiLCJzeW1zIiwiaGFzVG9TdHJpbmdUYWdTaGFtcyIsInRvU3RyaW5nVGFnIiwiJGhhc093biIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaGFzVG9TdHJpbmdUYWciLCJjYWxsQm91bmQiLCIkdG9TdHJpbmciLCJpc1N0YW5kYXJkQXJndW1lbnRzIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsInN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMiLCJmblRvU3RyIiwicmVmbGVjdEFwcGx5IiwiYmFkQXJyYXlMaWtlIiwiaXNDYWxsYWJsZU1hcmtlciIsIl8iLCJjb25zdHJ1Y3RvclJlZ2V4IiwiaXNFUzZDbGFzc0ZuIiwiaXNFUzZDbGFzc0Z1bmN0aW9uIiwiZm5TdHIiLCJ0cnlGdW5jdGlvbk9iamVjdCIsInRyeUZ1bmN0aW9uVG9TdHIiLCJvYmplY3RDbGFzcyIsImZuQ2xhc3MiLCJnZW5DbGFzcyIsImRkYUNsYXNzIiwiZGRhQ2xhc3MyIiwiZGRhQ2xhc3MzIiwiaXNJRTY4IiwiaXNEREEiLCJpc0RvY3VtZW50RG90QWxsIiwiZG9jdW1lbnQiLCJhbGwiLCJzdHJDbGFzcyIsImlzRm5SZWdleCIsImdldEdlbmVyYXRvckZ1bmMiLCJHZW5lcmF0b3JGdW5jdGlvbiIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5lcmF0b3JGdW5jIiwiZ2V0UG9seWZpbGwiLCJzaGltIiwiTmFOIiwic2hpbU51bWJlcklzTmFOIiwidGVzdElzTmFOIiwid2hpY2hUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwibm1kIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyIsIl9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fIiwib2JqZWN0VHlwZXMiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtb2R1bGVFeHBvcnRzIiwiZ2xvYmFsIiwidmVyc2lvbiIsImZlYXR1cmVzIiwiZW5jb2RpbmdNb2RlIiwiZGVmYXVsdE9wdGlvbnMiLCJ3YWl0IiwiY29tbWVudHMiLCJzY29wZSIsImxvY2F0aW9ucyIsInJhbmdlcyIsIm9uQ3JlYXRlTm9kZSIsIm9uQ3JlYXRlU2NvcGUiLCJvbkRlc3Ryb3lTY29wZSIsIm9uTG9jYWxEZWNsYXJhdGlvbiIsImx1YVZlcnNpb24iLCJlbmNvZGVVVEY4IiwiY29kZXBvaW50IiwiaGlnaE1hc2siLCJmcm9tQ2hhckNvZGUiLCJ0b0hleCIsIm51bSIsImRpZ2l0cyIsImNoZWNrQ2hhcnMiLCJyeCIsInMiLCJtIiwicmFpc2UiLCJlcnJvcnMiLCJpbnZhbGlkQ29kZVVuaXQiLCJ0b1VwcGVyQ2FzZSIsImVuY29kaW5nTW9kZXMiLCJmaXh1cCIsImVuY29kZUJ5dGUiLCJkaXNjYXJkU3RyaW5ncyIsIkVPRiIsIlN0cmluZ0xpdGVyYWwiLCJLZXl3b3JkIiwiSWRlbnRpZmllciIsIk51bWVyaWNMaXRlcmFsIiwiUHVuY3R1YXRvciIsIkJvb2xlYW5MaXRlcmFsIiwiTmlsTGl0ZXJhbCIsIlZhcmFyZ0xpdGVyYWwiLCJ0b2tlblR5cGVzIiwidW5leHBlY3RlZCIsInVuZXhwZWN0ZWRFT0YiLCJleHBlY3RlZFRva2VuIiwidW5maW5pc2hlZFN0cmluZyIsIm1hbGZvcm1lZE51bWJlciIsImRlY2ltYWxFc2NhcGVUb29MYXJnZSIsImludmFsaWRFc2NhcGUiLCJoZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQiLCJicmFjZUV4cGVjdGVkIiwidG9vTGFyZ2VDb2RlcG9pbnQiLCJ1bmZpbmlzaGVkTG9uZ1N0cmluZyIsInVuZmluaXNoZWRMb25nQ29tbWVudCIsImFtYmlndW91c1N5bnRheCIsIm5vTG9vcFRvQnJlYWsiLCJsYWJlbEFscmVhZHlEZWZpbmVkIiwibGFiZWxOb3RWaXNpYmxlIiwiZ290b0p1bXBJbkxvY2FsU2NvcGUiLCJjYW5ub3RVc2VWYXJhcmciLCJhc3QiLCJsYWJlbFN0YXRlbWVudCIsImJyZWFrU3RhdGVtZW50IiwiZ290b1N0YXRlbWVudCIsInJldHVyblN0YXRlbWVudCIsImlmU3RhdGVtZW50IiwiY2xhdXNlcyIsImlmQ2xhdXNlIiwiY29uZGl0aW9uIiwiYm9keSIsImVsc2VpZkNsYXVzZSIsImVsc2VDbGF1c2UiLCJ3aGlsZVN0YXRlbWVudCIsImRvU3RhdGVtZW50IiwicmVwZWF0U3RhdGVtZW50IiwibG9jYWxTdGF0ZW1lbnQiLCJ2YXJpYWJsZXMiLCJpbml0IiwiYXNzaWdubWVudFN0YXRlbWVudCIsImNhbGxTdGF0ZW1lbnQiLCJmdW5jdGlvblN0YXRlbWVudCIsImlkZW50aWZpZXIiLCJwYXJhbWV0ZXJzIiwiaXNMb2NhbCIsImZvck51bWVyaWNTdGF0ZW1lbnQiLCJ2YXJpYWJsZSIsInN0ZXAiLCJmb3JHZW5lcmljU3RhdGVtZW50IiwiaXRlcmF0b3JzIiwiY2h1bmsiLCJsaXRlcmFsIiwicmF3IiwidGFibGVLZXkiLCJ0YWJsZUtleVN0cmluZyIsInRhYmxlVmFsdWUiLCJ0YWJsZUNvbnN0cnVjdG9yRXhwcmVzc2lvbiIsImZpZWxkcyIsImJpbmFyeUV4cHJlc3Npb24iLCJsZWZ0IiwicmlnaHQiLCJ1bmFyeUV4cHJlc3Npb24iLCJhcmd1bWVudCIsIm1lbWJlckV4cHJlc3Npb24iLCJpbmRleGVyIiwiaW5kZXhFeHByZXNzaW9uIiwiaW5kZXgiLCJjYWxsRXhwcmVzc2lvbiIsInRhYmxlQ2FsbEV4cHJlc3Npb24iLCJzdHJpbmdDYWxsRXhwcmVzc2lvbiIsImNvbW1lbnQiLCJmaW5pc2hOb2RlIiwibm9kZSIsInRyYWNrTG9jYXRpb25zIiwibG9jYXRpb24iLCJjb21wbGV0ZSIsImJsZXNzIiwiZWxlbWVudCIsImluZGV4T2ZPYmplY3QiLCJzcHJpbnRmIiwiZGVzdCIsInNyYyIsInByb3AiLCJmaXh1cEVycm9yIiwibGluZSIsImNvbHVtbiIsInRva2VuIiwiY29sIiwibGluZVN0YXJ0IiwicmFuZ2UiLCJ0b2tlblZhbHVlIiwicmFpc2VVbmV4cGVjdGVkVG9rZW4iLCJmb3VuZCIsIm5lYXIiLCJsb29rYWhlYWQiLCJwcmV2aW91c1Rva2VuIiwidG9rZW5TdGFydCIsImxleCIsInNraXBXaGl0ZVNwYWNlIiwic2NhbkNvbW1lbnQiLCJjaGFyQ29kZSIsImlzSWRlbnRpZmllclN0YXJ0Iiwic2NhbklkZW50aWZpZXJPcktleXdvcmQiLCJzY2FuU3RyaW5nTGl0ZXJhbCIsInNjYW5OdW1lcmljTGl0ZXJhbCIsImlzRGVjRGlnaXQiLCJzY2FuVmFyYXJnTGl0ZXJhbCIsInNjYW5QdW5jdHVhdG9yIiwiYml0d2lzZU9wZXJhdG9ycyIsImxhYmVscyIsInNjYW5Mb25nU3RyaW5nTGl0ZXJhbCIsImludGVnZXJEaXZpc2lvbiIsImNvbnN1bWVFT0wiLCJwZWVrQ2hhckNvZGUiLCJpc0xpbmVUZXJtaW5hdG9yIiwiaXNXaGl0ZVNwYWNlIiwiaXNJZGVudGlmaWVyUGFydCIsImlzS2V5d29yZCIsImRlbGltaXRlciIsImJlZ2luTGluZSIsImJlZ2luTGluZVN0YXJ0Iiwic3RyaW5nU3RhcnQiLCJiZWZvcmVFc2NhcGUiLCJlc2NhcGVWYWx1ZSIsInJlYWRFc2NhcGVTZXF1ZW5jZSIsImxhc3RMaW5lIiwibGFzdExpbmVTdGFydCIsInJlYWRMb25nU3RyaW5nIiwiY2hhcmFjdGVyIiwicmVhZEhleExpdGVyYWwiLCJyZWFkRGVjTGl0ZXJhbCIsImZvdW5kSW1hZ2luYXJ5VW5pdCIsInJlYWRJbWFnaW5hcnlVbml0U3VmZml4IiwiZm91bmRJbnQ2NFN1ZmZpeCIsInJlYWRJbnQ2NFN1ZmZpeCIsImhhc0ZyYWN0aW9uUGFydCIsImltYWdpbmFyeU51bWJlcnMiLCJpbnRlZ2VyU3VmZml4ZXMiLCJmcmFjdGlvbiIsImJpbmFyeUV4cG9uZW50IiwiYmluYXJ5U2lnbiIsImRpZ2l0IiwiZnJhY3Rpb25TdGFydCIsImV4cG9uZW50U3RhcnQiLCJkaWdpdFN0YXJ0IiwiaXNIZXhEaWdpdCIsImZvdW5kRnJhY3Rpb24iLCJmb3VuZEJpbmFyeUV4cG9uZW50IiwiZm91bmRFeHBvbmVudCIsInJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2UiLCJzZXF1ZW5jZVN0YXJ0IiwiZXNjU3RhcnQiLCJmcmFnIiwiZGRkIiwic2tpcFdoaXRlc3BhY2VFc2NhcGUiLCJoZXhFc2NhcGVzIiwidW5pY29kZUVzY2FwZXMiLCJzdHJpY3RFc2NhcGVzIiwiY29udGVudCIsImlzTG9uZyIsImNvbW1lbnRTdGFydCIsImxpbmVTdGFydENvbW1lbnQiLCJsaW5lQ29tbWVudCIsImxvYyIsImlzQ29tbWVudCIsImxldmVsIiwidGVybWluYXRvciIsImZpcnN0TGluZSIsImNvbnN1bWUiLCJleHBlY3QiLCJleHRlbmRlZElkZW50aWZpZXJzIiwiaWQiLCJjb250ZXh0dWFsR290byIsImlzVW5hcnkiLCJpc0Jsb2NrRm9sbG93Iiwic2NvcGVzIiwic2NvcGVEZXB0aCIsImdsb2JhbHMiLCJjcmVhdGVTY29wZSIsImRlc3Ryb3lTY29wZSIsInNjb3BlSWRlbnRpZmllck5hbWUiLCJzY29wZUlkZW50aWZpZXIiLCJhdHRhY2hTY29wZSIsInNjb3BlSGFzTmFtZSIsImNyZWF0ZUxvY2F0aW9uTWFya2VyIiwiTWFya2VyIiwibWFya0xvY2F0aW9uIiwicHVzaExvY2F0aW9uIiwibWFya2VyIiwiRnVsbEZsb3dDb250ZXh0IiwicGVuZGluZ0dvdG9zIiwiaXNJbkxvb3AiLCJpc0xvb3AiLCJwdXNoU2NvcGUiLCJsb2NhbHMiLCJkZWZlcnJlZEdvdG9zIiwicG9wU2NvcGUiLCJ0aGVHb3RvIiwibWF4RGVwdGgiLCJhZGRHb3RvIiwibG9jYWxDb3VudHMiLCJhZGRMYWJlbCIsImN1cnJlbnRTY29wZSIsIm5ld0dvdG9zIiwibG9jYWxDb3VudCIsImFkZExvY2FsIiwicmFpc2VEZWZlcnJlZEVycm9ycyIsImJhZHMiLCJMb29wRmxvd0NvbnRleHQiLCJsb29wTGV2ZWxzIiwibGV2ZWxzIiwibGV2bGVuIiwibWFrZUZsb3dDb250ZXh0IiwicGFyc2VDaHVuayIsImZsb3dDb250ZXh0IiwiYWxsb3dWYXJhcmciLCJwYXJzZUJsb2NrIiwiYmxvY2siLCJzdGF0ZW1lbnQiLCJyZWxheGVkQnJlYWsiLCJwYXJzZVN0YXRlbWVudCIsInBhcnNlTGFiZWxTdGF0ZW1lbnQiLCJlbXB0eVN0YXRlbWVudCIsInBhcnNlTG9jYWxTdGF0ZW1lbnQiLCJwYXJzZUlmU3RhdGVtZW50IiwicGFyc2VSZXR1cm5TdGF0ZW1lbnQiLCJwYXJzZUZ1bmN0aW9uTmFtZSIsInBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsInBhcnNlUmVwZWF0U3RhdGVtZW50IiwicGFyc2VCcmVha1N0YXRlbWVudCIsInBhcnNlRG9TdGF0ZW1lbnQiLCJwYXJzZUdvdG9TdGF0ZW1lbnQiLCJwYXJzZUFzc2lnbm1lbnRPckNhbGxTdGF0ZW1lbnQiLCJuYW1lVG9rZW4iLCJwYXJzZUlkZW50aWZpZXIiLCJnb3RvVG9rZW4iLCJwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbiIsImV4cHJlc3Npb25zIiwicGFyc2VFeHByZXNzaW9uIiwiZGVjbFRva2VuIiwibCIsInByZXZpb3VzIiwic3RhcnRNYXJrZXIiLCJsdmFsdWUiLCJ0YXJnZXRzIiwiYm90aCIsIm5ld0Jhc2UiLCJwYXJzZVByZWZpeEV4cHJlc3Npb25QYXJ0IiwidmFsdWVzIiwicGFyYW1ldGVyIiwicGFyc2VQcmltYXJ5RXhwcmVzc2lvbiIsInBhcnNlVGFibGVDb25zdHJ1Y3RvciIsInBhcnNlU3ViRXhwcmVzc2lvbiIsImJpbmFyeVByZWNlZGVuY2UiLCJtaW5QcmVjZWRlbmNlIiwicGFyc2VQcmVmaXhFeHByZXNzaW9uIiwicHJlY2VkZW5jZSIsInBhcnNlQ2FsbEV4cHJlc3Npb24iLCJ0YWJsZSIsImxpdGVyYWxzIiwicGFyc2UiLCJ2ZXJzaW9uRmVhdHVyZXMiLCJfaW5wdXQiLCJfb3B0aW9ucyIsIndyaXRlIiwic2hpbU9iamVjdElzIiwidGVzdE9iamVjdElzIiwia2V5c1NoaW0iLCJpc0FyZ3MiLCJpc0VudW1lcmFibGUiLCJoYXNEb250RW51bUJ1ZyIsImhhc1Byb3RvRW51bUJ1ZyIsImRvbnRFbnVtcyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhjbHVkZWRLZXlzIiwiJGFwcGxpY2F0aW9uQ2FjaGUiLCIkY29uc29sZSIsIiRleHRlcm5hbCIsIiRmcmFtZSIsIiRmcmFtZUVsZW1lbnQiLCIkZnJhbWVzIiwiJGlubmVySGVpZ2h0IiwiJGlubmVyV2lkdGgiLCIkb25tb3pmdWxsc2NyZWVuY2hhbmdlIiwiJG9ubW96ZnVsbHNjcmVlbmVycm9yIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkcGFyZW50IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJpc09iamVjdCIsImlzU3RyaW5nIiwidGhlS2V5cyIsInNraXBQcm90byIsInNraXBDb25zdHJ1Y3RvciIsIm9yaWdLZXlzIiwib3JpZ2luYWxLZXlzIiwic2hpbU9iamVjdEtleXMiLCJrZXlzV29ya3NXaXRoQXJndW1lbnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibmV4dFRpY2siLCJJdGVtIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiaGFzRGVzY3JpcHRvcnMiLCJnT1BEIiwiJGZsb29yIiwiZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSIsImZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImQiLCJCYXNlU2VydmljZSIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIm4iLCJfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9kZWZpbmVfcHJvcGVydHkiLCJhZGREb2N1bWVudCIsImRvY3VtZW50cyIsInVyaSIsIlYiLCJsYW5ndWFnZUlkIiwidGV4dCIsImdldERvY3VtZW50IiwicmVtb3ZlRG9jdW1lbnQiLCJyZW5hbWVEb2N1bWVudCIsIm5ld0RvY3VtZW50VXJpIiwicHJldmlvdXNEb2N1bWVudCIsImdldFRleHQiLCJnZXREb2N1bWVudFZhbHVlIiwiX3RoaXNfZ2V0RG9jdW1lbnQiLCJzZXRWYWx1ZSIsInNldEdsb2JhbE9wdGlvbnMiLCJnbG9iYWxPcHRpb25zIiwic2V0V29ya3NwYWNlIiwid29ya3NwYWNlVXJpIiwic2V0T3B0aW9ucyIsImRvY3VtZW50VXJpIiwibWVyZ2UiLCJyTCIsImdldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJhcHBseURlbHRhcyIsImRlbHRhcyIsInVwZGF0ZSIsImRvQ29tcGxldGUiLCJkb0lubGluZUNvbXBsZXRlIiwiZG9Ib3ZlciIsImRvUmVzb2x2ZSIsImRvVmFsaWRhdGlvbiIsInByb3ZpZGVTaWduYXR1cmVIZWxwIiwiZmluZERvY3VtZW50SGlnaGxpZ2h0cyIsIm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUiLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJlcnJvckNvZGVzVG9JZ25vcmUiLCJlcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsImVycm9yQ29kZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyIsImdldFNlbWFudGljVG9rZW5zIiwiZGlzcG9zZSIsImNsb3NlQ29ubmVjdGlvbiIsImdldENvZGVBY3Rpb25zIiwiY29udGV4dCIsImV4ZWN1dGVDb21tYW5kIiwiY29tbWFuZCIsInNlbmRBcHBsaWVkUmVzdWx0IiwiY2FsbGJhY2tJZCIsInNlbmRSZXF1ZXN0Iiwic2VuZFJlc3BvbnNlIiwibW9kZSIsInRleHREb2N1bWVudCIsImRpYWdub3N0aWMiLCJkeW5hbWljUmVnaXN0cmF0aW9uIiwicmVsYXRlZERvY3VtZW50U3VwcG9ydCIsInB1Ymxpc2hEaWFnbm9zdGljcyIsInJlbGF0ZWRJbmZvcm1hdGlvbiIsInZlcnNpb25TdXBwb3J0IiwidGFnU3VwcG9ydCIsInZhbHVlU2V0IiwiRGlhZ25vc3RpY1RhZyIsIlVubmVjZXNzYXJ5IiwiRGVwcmVjYXRlZCIsImhvdmVyIiwiY29udGVudEZvcm1hdCIsInN5bmNocm9uaXphdGlvbiIsIndpbGxTYXZlIiwiZGlkU2F2ZSIsIndpbGxTYXZlV2FpdFVudGlsIiwiZm9ybWF0dGluZyIsImNvbXBsZXRpb24iLCJjb21wbGV0aW9uSXRlbSIsInNuaXBwZXRTdXBwb3J0IiwiY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQiLCJkb2N1bWVudGF0aW9uRm9ybWF0IiwiZGVwcmVjYXRlZFN1cHBvcnQiLCJwcmVzZWxlY3RTdXBwb3J0IiwiY29udGV4dFN1cHBvcnQiLCJzaWduYXR1cmVIZWxwIiwic2lnbmF0dXJlSW5mb3JtYXRpb24iLCJhY3RpdmVQYXJhbWV0ZXJTdXBwb3J0IiwiZG9jdW1lbnRIaWdobGlnaHQiLCJzZW1hbnRpY1Rva2VucyIsIm11bHRpbGluZVRva2VuU3VwcG9ydCIsIm92ZXJsYXBwaW5nVG9rZW5TdXBwb3J0IiwidG9rZW5Nb2RpZmllcnMiLCJmb3JtYXRzIiwicmVxdWVzdHMiLCJmdWxsIiwiZGVsdGEiLCJhdWdtZW50c1N5bnRheFRva2VucyIsImNvZGVBY3Rpb24iLCJpbmxpbmVDb21wbGV0aW9uIiwic2hvd0RvY3VtZW50Iiwic3VwcG9ydCIsIndvcmtzcGFjZSIsImRpZENoYW5nZUNvbmZpZ3VyYXRpb24iLCJhcHBseUVkaXQiLCJ3b3Jrc3BhY2VFZGl0IiwiZmFpbHVyZUhhbmRsaW5nIiwibm9ybWFsaXplc0xpbmVFbmRpbmdzIiwiZG9jdW1lbnRDaGFuZ2VzIiwic2VydmljZU5hbWUiLCJzZXJ2aWNlRGF0YSIsImNsYXNzTmFtZSIsIm1vZGVzIiwiVGsiLCJjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5IiwibWVyZ2VPYmplY3RzIiwib2JqMSIsIm9iajIiLCJleGNsdWRlVW5kZWZpbmVkIiwiZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyIsIm1lcmdlZE9iamVjdHMiLCJmaWx0ZXJlZEVudHJpZXMiLCJlbnRyaWVzIiwiZnJvbUVudHJpZXMiLCJub3RFbXB0eSIsImlzRW1wdHlSYW5nZSIsInJvdyIsIm1lcmdlUmFuZ2VzIiwic29ydCIsImNvbXBhcmVQb2ludHMiLCJjbXAiLCJwMSIsInAyIiwicmVnZXhwQXJyYXkiLCJjb252ZXJ0VG9VcmkiLCJmaWxlUGF0aCIsImpvaW5Xb3Jrc3BhY2VVUkkiLCJpc0Z1bGxVcmkiLCJub3JtYWxpemVkUGF0aCIsIlVSSSIsImZpbGUiLCJ3b3Jrc3BhY2VVcmlQYXJzZWQiLCJVdGlscyIsImpvaW5QYXRoIiwicGF0aCIsImlzQnVmZmVyIiwiYXJnIiwiY29weSIsImZpbGwiLCJyZWFkVUludDgiLCJpc0FyZ3VtZW50c09iamVjdCIsIkJpZ0ludFN1cHBvcnRlZCIsIlN5bWJvbFN1cHBvcnRlZCIsIk9iamVjdFRvU3RyaW5nIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xlYW5WYWx1ZSIsImJpZ0ludFZhbHVlIiwic3ltYm9sVmFsdWUiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwicHJvdG90eXBlVmFsdWVPZiIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc01hcFRvU3RyaW5nIiwid29ya2luZyIsImlzU2V0VG9TdHJpbmciLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsIlNoYXJlZEFycmF5QnVmZmVyQ29weSIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwibWV0aG9kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZm9ybWF0UmVnRXhwIiwib2JqZWN0cyIsInN0cmluZ2lmeSIsImlzTnVsbCIsImRlcHJlY2F0ZSIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0VudlJlZ2V4IiwiTk9ERV9ERUJVRyIsImRlYnVnRW52IiwiZGVidWdsb2ciLCJwaWQiLCJvcHRzIiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImNvbG9ycyIsImlzQm9vbGVhbiIsIl9leHRlbmQiLCJpc1VuZGVmaW5lZCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsInN0eWxlcyIsInN0eWxlVHlwZSIsInN0eWxlIiwiYXJyYXlUb0hhc2giLCJoYXNoIiwiaWR4IiwicmV0IiwicHJpbWl0aXZlIiwiZm9ybWF0UHJpbWl0aXZlIiwidmlzaWJsZUtleXMiLCJpc0Vycm9yIiwiZm9ybWF0RXJyb3IiLCJicmFjZXMiLCJ0b1VUQ1N0cmluZyIsIm91dHB1dCIsImZvcm1hdEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsImlzTnVtYmVyIiwibnVtTGluZXNFc3QiLCJyZWR1Y2UiLCJwcmV2IiwiYXIiLCJpc051bGxPclVuZGVmaW5lZCIsImlzU3ltYm9sIiwicmUiLCJpc1ByaW1pdGl2ZSIsInBhZCIsIm1vbnRocyIsInRpbWVzdGFtcCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJvcmlnaW4iLCJrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wiLCJwcm9taXNpZnkiLCJvcmlnaW5hbCIsInByb21pc2VSZXNvbHZlIiwicHJvbWlzZVJlamVjdCIsInByb21pc2UiLCJyZWplY3QiLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJjYiIsIm5ld1JlYXNvbiIsImNhbGxiYWNraWZ5IiwiY2FsbGJhY2tpZmllZCIsIm1heWJlQ2IiLCJyZWoiLCJfX2NyZWF0ZUJpbmRpbmciLCJrMiIsIl9fZXNNb2R1bGUiLCJfX2V4cG9ydFN0YXIiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIkJyb3dzZXJNZXNzYWdlV3JpdGVyIiwiQnJvd3Nlck1lc3NhZ2VSZWFkZXIiLCJyaWxfMSIsImRlZmF1bHQiLCJpbnN0YWxsIiwiYXBpXzEiLCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXIiLCJsaXN0ZW4iLCJjYWxsYmFjayIsIl9vbkRhdGEiLCJldmVudCIsInBvcnQiLCJFbWl0dGVyIiwiX21lc3NhZ2VMaXN0ZW5lciIsImZpcmUiLCJkYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVFcnJvciIsIm9ubWVzc2FnZSIsIkFic3RyYWN0TWVzc2FnZVdyaXRlciIsInBvc3RNZXNzYWdlIiwiaGFuZGxlRXJyb3IiLCJlcnJvckNvdW50IiwicmVhZGVyIiwid3JpdGVyIiwibG9nZ2VyIiwiTnVsbExvZ2dlciIsIkNvbm5lY3Rpb25TdHJhdGVneSIsImNvbm5lY3Rpb25TdHJhdGVneSIsIk1lc3NhZ2VCdWZmZXIiLCJBYnN0cmFjdE1lc3NhZ2VCdWZmZXIiLCJlbXB0eUJ1ZmZlciIsImZyb21TdHJpbmciLCJfZW5jb2RpbmciLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImVuY29kaW5nIiwiYXNjaWlEZWNvZGVyIiwiZGVjb2RlIiwiVGV4dERlY29kZXIiLCJhc05hdGl2ZSIsImFsbG9jTmF0aXZlIiwiUmVhZGFibGVTdHJlYW1XcmFwcGVyIiwib25DbG9zZSIsImxpc3RlbmVyIiwic29ja2V0IiwiRGlzcG9zYWJsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbkVycm9yIiwib25FbmQiLCJvbkRhdGEiLCJibG9iIiwiYXJyYXlCdWZmZXIiLCJSQUwiLCJXcml0YWJsZVN0cmVhbVdyYXBwZXIiLCJzZW5kIiwiY2xvc2UiLCJfdGV4dEVuY29kZXIiLCJfcmlsIiwiZnJlZXplIiwibWVzc2FnZUJ1ZmZlciIsImFwcGxpY2F0aW9uSnNvbiIsImVuY29kZXIiLCJjaGFyc2V0Iiwic3RyZWFtIiwiYXNSZWFkYWJsZVN0cmVhbSIsImFzV3JpdGFibGVTdHJlYW0iLCJ0aW1lciIsIm1zIiwiaGFuZGxlIiwic2V0SW1tZWRpYXRlIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiUklMIiwiUHJvZ3Jlc3NUeXBlIiwiUHJvZ3Jlc3NUb2tlbiIsIkNvbm5lY3Rpb25PcHRpb25zIiwiV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlciIsIk1lc3NhZ2VXcml0ZXIiLCJSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIiLCJNZXNzYWdlUmVhZGVyIiwiU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IiwiU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblRva2VuIiwiQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJFdmVudCIsIkxSVUNhY2hlIiwiVG91Y2giLCJMaW5rZWRNYXAiLCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzIiwiTm90aWZpY2F0aW9uVHlwZTkiLCJOb3RpZmljYXRpb25UeXBlOCIsIk5vdGlmaWNhdGlvblR5cGU3IiwiTm90aWZpY2F0aW9uVHlwZTYiLCJOb3RpZmljYXRpb25UeXBlNSIsIk5vdGlmaWNhdGlvblR5cGU0IiwiTm90aWZpY2F0aW9uVHlwZTMiLCJOb3RpZmljYXRpb25UeXBlMiIsIk5vdGlmaWNhdGlvblR5cGUxIiwiTm90aWZpY2F0aW9uVHlwZTAiLCJOb3RpZmljYXRpb25UeXBlIiwiRXJyb3JDb2RlcyIsIlJlc3BvbnNlRXJyb3IiLCJSZXF1ZXN0VHlwZTkiLCJSZXF1ZXN0VHlwZTgiLCJSZXF1ZXN0VHlwZTciLCJSZXF1ZXN0VHlwZTYiLCJSZXF1ZXN0VHlwZTUiLCJSZXF1ZXN0VHlwZTQiLCJSZXF1ZXN0VHlwZTMiLCJSZXF1ZXN0VHlwZTIiLCJSZXF1ZXN0VHlwZTEiLCJSZXF1ZXN0VHlwZTAiLCJSZXF1ZXN0VHlwZSIsIk1lc3NhZ2UiLCJNZXNzYWdlU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TdHJhdGVneSIsIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSIsIkNvbm5lY3Rpb25FcnJvciIsIkNvbm5lY3Rpb25FcnJvcnMiLCJMb2dUcmFjZU5vdGlmaWNhdGlvbiIsIlNldFRyYWNlTm90aWZpY2F0aW9uIiwiVHJhY2VGb3JtYXQiLCJUcmFjZVZhbHVlcyIsIlRyYWNlIiwibWVzc2FnZXNfMSIsImxpbmtlZE1hcF8xIiwiZGlzcG9zYWJsZV8xIiwiZXZlbnRzXzEiLCJjYW5jZWxsYXRpb25fMSIsInNoYXJlZEFycmF5Q2FuY2VsbGF0aW9uXzEiLCJtZXNzYWdlUmVhZGVyXzEiLCJtZXNzYWdlV3JpdGVyXzEiLCJtZXNzYWdlQnVmZmVyXzEiLCJjb25uZWN0aW9uXzEiLCJyYWxfMSIsIklzIiwiTm9uZSIsImlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwib25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJDYW5jZWxsZWQiLCJjYW5kaWRhdGUiLCJib29sZWFuIiwic2hvcnRjdXRFdmVudCIsIk11dGFibGVUb2tlbiIsImNhbmNlbCIsIl9pc0NhbmNlbGxlZCIsIl9lbWl0dGVyIiwiX3Rva2VuIiwiUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDYW5jZWxOb3RpZmljYXRpb24iLCJQcm9ncmVzc05vdGlmaWNhdGlvbiIsIlN0YXJSZXF1ZXN0SGFuZGxlciIsIk9mZiIsIk1lc3NhZ2VzIiwiQ29tcGFjdCIsIlZlcmJvc2UiLCJ0b0xvd2VyQ2FzZSIsIlRleHQiLCJjYW5jZWxVbmRpc3BhdGNoZWQiLCJraW5kIiwiY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJzZW5kQ2FuY2VsbGF0aW9uIiwiY29ubiIsInNlbmROb3RpZmljYXRpb24iLCJjbGVhbnVwIiwic2VuZGVyIiwiaGFuZGxlTWVzc2FnZSIsImNhbmNlbGxhdGlvblN0cmF0ZWd5IiwibWVzc2FnZVN0cmF0ZWd5IiwiQ29ubmVjdGlvblN0YXRlIiwibWVzc2FnZVJlYWRlciIsIm1lc3NhZ2VXcml0ZXIiLCJfbG9nZ2VyIiwic2VxdWVuY2VOdW1iZXIiLCJub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlciIsInVua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyIiwic3RhclJlcXVlc3RIYW5kbGVyIiwicmVxdWVzdEhhbmRsZXJzIiwic3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIiLCJub3RpZmljYXRpb25IYW5kbGVycyIsInByb2dyZXNzSGFuZGxlcnMiLCJtZXNzYWdlUXVldWUiLCJyZXNwb25zZVByb21pc2VzIiwia25vd25DYW5jZWxlZFJlcXVlc3RzIiwicmVxdWVzdFRva2VucyIsInRyYWNlRm9ybWF0IiwidHJhY2VyIiwic3RhdGUiLCJOZXciLCJlcnJvckVtaXR0ZXIiLCJjbG9zZUVtaXR0ZXIiLCJ1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyIiwidW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyIiwiZGlzcG9zZUVtaXR0ZXIiLCJjcmVhdGVSZXF1ZXN0UXVldWVLZXkiLCJjcmVhdGVSZXNwb25zZVF1ZXVlS2V5IiwiY3JlYXRlTm90aWZpY2F0aW9uUXVldWVLZXkiLCJhZGRNZXNzYWdlVG9RdWV1ZSIsImlzUmVxdWVzdCIsImlzUmVzcG9uc2UiLCJfbWVzc2FnZSIsImlzTGlzdGVuaW5nIiwiTGlzdGVuaW5nIiwiaXNDbG9zZWQiLCJDbG9zZWQiLCJpc0Rpc3Bvc2VkIiwiRGlzcG9zZWQiLCJjbG9zZUhhbmRsZXIiLCJyZWFkRXJyb3JIYW5kbGVyIiwid3JpdGVFcnJvckhhbmRsZXIiLCJ0cmlnZ2VyTWVzc2FnZVF1ZXVlIiwicHJvY2Vzc01lc3NhZ2VRdWV1ZSIsImhhbmRsZVJlcXVlc3QiLCJpc05vdGlmaWNhdGlvbiIsImhhbmRsZU5vdGlmaWNhdGlvbiIsImhhbmRsZVJlc3BvbnNlIiwiaGFuZGxlSW52YWxpZE1lc3NhZ2UiLCJjYW5jZWxJZCIsInBhcmFtcyIsInRvQ2FuY2VsIiwic3RyYXRlZ3kiLCJyZXNwb25zZSIsInRyYWNlU2VuZGluZ1Jlc3BvbnNlIiwiY2FuY2VsbGF0aW9uVG9rZW4iLCJ0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uIiwicmVxdWVzdE1lc3NhZ2UiLCJyZXBseSIsInJlc3VsdE9yRXJyb3IiLCJzdGFydFRpbWUiLCJqc29ucnBjIiwidG9Kc29uIiwicmVwbHlFcnJvciIsInJlcGx5U3VjY2VzcyIsInRyYWNlUmVjZWl2ZWRSZXF1ZXN0IiwicmVxdWVzdEhhbmRsZXIiLCJoYW5kbGVyIiwidG9rZW5LZXkiLCJjYW5jZWxsYXRpb25Tb3VyY2UiLCJoYW5kbGVyUmVzdWx0IiwibnVtYmVyT2ZQYXJhbXMiLCJJbnZhbGlkUGFyYW1zIiwicGFyYW1ldGVyU3RydWN0dXJlcyIsImJ5TmFtZSIsImJ5UG9zaXRpb24iLCJJbnRlcm5hbEVycm9yIiwiTWV0aG9kTm90Rm91bmQiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZXNwb25zZVByb21pc2UiLCJ0cmFjZVJlY2VpdmVkUmVzcG9uc2UiLCJub3RpZmljYXRpb25IYW5kbGVyIiwicmVzcG9uc2VIYW5kbGVyIiwic3RyaW5naWZ5VHJhY2UiLCJ0cmFjZVNlbmRpbmdSZXF1ZXN0IiwibG9nTFNQTWVzc2FnZSIsInRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbiIsInRpbWVyU3RhcnQiLCJsc3BNZXNzYWdlIiwiaXNMU1BNZXNzYWdlIiwidGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQiLCJ0aHJvd0lmTGlzdGVuaW5nIiwiQWxyZWFkeUxpc3RlbmluZyIsInRocm93SWZOb3RMaXN0ZW5pbmciLCJ1bmRlZmluZWRUb051bGwiLCJwYXJhbSIsIm51bGxUb1VuZGVmaW5lZCIsImlzTmFtZWRQYXJhbSIsImNvbXB1dGVTaW5nbGVQYXJhbSIsImF1dG8iLCJjb21wdXRlTWVzc2FnZVBhcmFtcyIsImNvbm5lY3Rpb24iLCJtZXNzYWdlUGFyYW1zIiwicGFyYW1TdGFydCIsInBhcmFtRW5kIiwibm90aWZpY2F0aW9uTWVzc2FnZSIsIm9uTm90aWZpY2F0aW9uIiwib25Qcm9ncmVzcyIsIl90eXBlIiwic2VuZFByb2dyZXNzIiwib25VbmhhbmRsZWRQcm9ncmVzcyIsImRpc3Bvc2FibGUiLCJlbmFibGVDYW5jZWxsYXRpb24iLCJyZXNvbHZlV2l0aENsZWFudXAiLCJyIiwicmVqZWN0V2l0aENsZWFudXAiLCJNZXNzYWdlV3JpdGVFcnJvciIsIm9uUmVxdWVzdCIsImhhc1BlbmRpbmdSZXNwb25zZSIsIl92YWx1ZSIsIl90cmFjZXIiLCJzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMiLCJfc2VuZE5vdGlmaWNhdGlvbiIsIl90cmFjZUZvcm1hdCIsIm9uVW5oYW5kbGVkTm90aWZpY2F0aW9uIiwib25EaXNwb3NlIiwiUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQiLCJ2ZXJib3NlIiwiX2Rpc3Bvc2FibGUiLCJDYWxsYmFja0xpc3QiLCJidWNrZXQiLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwicmVtb3ZlIiwiZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0IiwiaW52b2tlIiwiY2FsbGJhY2tzIiwiY29udGV4dHMiLCJpc0VtcHR5IiwiX2V2ZW50IiwidGhpc0FyZ3MiLCJkaXNwb3NhYmxlcyIsIm9uRmlyc3RMaXN0ZW5lckFkZCIsIl9ub29wIiwib25MYXN0TGlzdGVuZXJSZW1vdmUiLCJzdHJpbmdBcnJheSIsImV2ZXJ5IiwiZWxlbSIsIl9hIiwiRmlyc3QiLCJBc09sZCIsIkxhc3QiLCJBc05ldyIsImNsZWFyIiwiX21hcCIsIl9oZWFkIiwiX3RhaWwiLCJfc2l6ZSIsIl9zdGF0ZSIsInRvdWNoIiwiYWRkSXRlbUxhc3QiLCJhZGRJdGVtRmlyc3QiLCJyZW1vdmVJdGVtIiwiY2FsbGJhY2tmbiIsImN1cnJlbnQiLCJ0cmltT2xkIiwibmV3U2l6ZSIsImN1cnJlbnRTaXplIiwidG9KU09OIiwiZnJvbUpTT04iLCJfbGltaXQiLCJjaGVja1RyaW0iLCJyYXRpbyIsIl9yYXRpbyIsInBlZWsiLCJyb3VuZCIsIkNSIiwiTEYiLCJDUkxGIiwiYXBwZW5kIiwidG9BcHBlbmQiLCJfY2h1bmtzIiwiX3RvdGFsTGVuZ3RoIiwidHJ5UmVhZEhlYWRlcnMiLCJsb3dlckNhc2VLZXlzIiwiY2h1bmtJbmRleCIsImNodW5rQnl0ZXNSZWFkIiwiX3JlYWQiLCJoZWFkZXJzIiwiaGVhZGVyIiwidHJpbSIsInRyeVJlYWRCb2R5IiwibnVtYmVyT2ZCeXRlcyIsImJ5dGVDb3VudCIsInJlc3VsdE9mZnNldCIsImNodW5rUGFydCIsInNlbWFwaG9yZV8xIiwib25QYXJ0aWFsTWVzc2FnZSIsImFzRXJyb3IiLCJmaXJlQ2xvc2UiLCJwYXJ0aWFsTWVzc2FnZUVtaXR0ZXIiLCJmaXJlUGFydGlhbE1lc3NhZ2UiLCJSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zIiwiZnJvbU9wdGlvbnMiLCJjb250ZW50RGVjb2RlciIsImNvbnRlbnREZWNvZGVycyIsImNvbnRlbnRUeXBlRGVjb2RlciIsImNvbnRlbnRUeXBlRGVjb2RlcnMiLCJwYXJ0aWFsTWVzc2FnZVRpbWVvdXQiLCJfcGFydGlhbE1lc3NhZ2VUaW1lb3V0IiwibmV4dE1lc3NhZ2VMZW5ndGgiLCJtZXNzYWdlVG9rZW4iLCJwYXJ0aWFsTWVzc2FnZVRpbWVyIiwicmVhZGFibGUiLCJjb250ZW50TGVuZ3RoIiwic2V0UGFydGlhbE1lc3NhZ2VUaW1lciIsImNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lciIsInJlYWRTZW1hcGhvcmUiLCJsb2NrIiwiYnl0ZXMiLCJ3YWl0aW5nVGltZSIsIlNlbWFwaG9yZSIsIkNvbnRlbnRMZW5ndGgiLCJSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zIiwiY29udGVudFR5cGVFbmNvZGVyIiwiY29udGVudEVuY29kZXIiLCJ3cml0ZVNlbWFwaG9yZSIsInBheWxvYWQiLCJkb1dyaXRlIiwiQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIiwiUGFyc2VFcnJvciIsIkludmFsaWRSZXF1ZXN0IiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0Iiwic2VydmVyRXJyb3JTdGFydCIsIk1lc3NhZ2VSZWFkRXJyb3IiLCJDb25uZWN0aW9uSW5hY3RpdmUiLCJTZXJ2ZXJOb3RJbml0aWFsaXplZCIsIlVua25vd25FcnJvckNvZGUiLCJqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kIiwic2VydmVyRXJyb3JFbmQiLCJfcGFyYW1ldGVyU3RydWN0dXJlcyIsIl9yYWwiLCJyYWwiLCJ0aHVuayIsIl93YWl0aW5nIiwicnVuTmV4dCIsImFjdGl2ZSIsIl9hY3RpdmUiLCJfY2FwYWNpdHkiLCJkb1J1bk5leHQiLCJjYXBhY2l0eSIsIkNhbmNlbGxhdGlvblN0YXRlIiwiQ29udGludWUiLCJyZXF1ZXN0IiwiYnVmZmVycyIsIiRjYW5jZWxsYXRpb25EYXRhIiwiX2Nvbm4iLCJzdG9yZSIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4iLCJsb2FkIiwiU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSIsImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiIsImJyb3dzZXJfMSIsIkxTUEVycm9yQ29kZXMiLCJsc3BSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsIlJlcXVlc3RGYWlsZWQiLCJTZXJ2ZXJDYW5jZWxsZWQiLCJDb250ZW50TW9kaWZpZWQiLCJSZXF1ZXN0Q2FuY2VsbGVkIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlRW5kIiwidnNjb2RlX2pzb25ycGNfMSIsIlByb3RvY29sTm90aWZpY2F0aW9uVHlwZSIsIlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAiLCJQcm90b2NvbFJlcXVlc3RUeXBlIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZTAiLCJSZWdpc3RyYXRpb25UeXBlIiwiTWVzc2FnZURpcmVjdGlvbiIsIkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCIsIkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCIsIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCIsIm1lc3NhZ2VEaXJlY3Rpb24iLCJjbGllbnRUb1NlcnZlciIsIkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCIsIkRvY3VtZW50Q29sb3JSZXF1ZXN0IiwiQ29uZmlndXJhdGlvblJlcXVlc3QiLCJzZXJ2ZXJUb0NsaWVudCIsIkRlY2xhcmF0aW9uUmVxdWVzdCIsIl9fbm9EeW5hbWljSW1wb3J0IiwiRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0IiwiV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QiLCJEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCIsIkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhIiwicmV0cmlnZ2VyUmVxdWVzdCIsIkZ1bGwiLCJVbmNoYW5nZWQiLCJwYXJ0aWFsUmVzdWx0IiwiV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCIsIkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uIiwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24iLCJXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0IiwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24iLCJXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0IiwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kIiwiZm9sZGVyIiwiRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QiLCJGb2xkaW5nUmFuZ2VSZXF1ZXN0IiwiSW1wbGVtZW50YXRpb25SZXF1ZXN0IiwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QiLCJJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCIsIklubGF5SGludFJlcXVlc3QiLCJJbmxpbmVDb21wbGV0aW9uUmVxdWVzdCIsIklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0IiwiQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IiwiQ29kZUFjdGlvblJlcXVlc3QiLCJEb2N1bWVudFN5bWJvbFJlcXVlc3QiLCJEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QiLCJSZWZlcmVuY2VzUmVxdWVzdCIsIkRlZmluaXRpb25SZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFJlcXVlc3QiLCJTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQiLCJIb3ZlclJlcXVlc3QiLCJDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QiLCJDb21wbGV0aW9uUmVxdWVzdCIsIkNvbXBsZXRpb25UcmlnZ2VyS2luZCIsIlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiIsIldhdGNoS2luZCIsIlJlbGF0aXZlUGF0dGVybiIsIkZpbGVDaGFuZ2VUeXBlIiwiRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IiwiV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTYXZlUmVhc29uIiwiRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IiwiRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudFN5bmNLaW5kIiwiVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24iLCJMb2dNZXNzYWdlTm90aWZpY2F0aW9uIiwiU2hvd01lc3NhZ2VSZXF1ZXN0IiwiU2hvd01lc3NhZ2VOb3RpZmljYXRpb24iLCJNZXNzYWdlVHlwZSIsIkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24iLCJFeGl0Tm90aWZpY2F0aW9uIiwiU2h1dGRvd25SZXF1ZXN0IiwiSW5pdGlhbGl6ZWROb3RpZmljYXRpb24iLCJJbml0aWFsaXplRXJyb3JDb2RlcyIsIkluaXRpYWxpemVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzc09wdGlvbnMiLCJUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIiwiU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyIsIlBvc2l0aW9uRW5jb2RpbmdLaW5kIiwiRmFpbHVyZUhhbmRsaW5nS2luZCIsIlJlc291cmNlT3BlcmF0aW9uS2luZCIsIlVucmVnaXN0cmF0aW9uUmVxdWVzdCIsIlJlZ2lzdHJhdGlvblJlcXVlc3QiLCJEb2N1bWVudFNlbGVjdG9yIiwiTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyIiwiTm90ZWJvb2tEb2N1bWVudEZpbHRlciIsIlRleHREb2N1bWVudEZpbHRlciIsIk1vbmlrZXJSZXF1ZXN0IiwiTW9uaWtlcktpbmQiLCJVbmlxdWVuZXNzTGV2ZWwiLCJMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0IiwiU2hvd0RvY3VtZW50UmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSIsIlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0IiwiVG9rZW5Gb3JtYXQiLCJXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIiwiV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QiLCJXb3JrRG9uZVByb2dyZXNzIiwiU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0IiwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiIsIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0IiwiVHlwZURlZmluaXRpb25SZXF1ZXN0IiwiQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCIsIkV4ZWN1dGVDb21tYW5kUmVxdWVzdCIsIlByZXBhcmVSZW5hbWVSZXF1ZXN0IiwiUmVuYW1lUmVxdWVzdCIsIlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yIiwiRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCIsIkRvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QiLCJEb2N1bWVudExpbmtSZXF1ZXN0IiwiQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCIsIkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QiLCJDb2RlTGVuc1JlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCIsIkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIiwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUiLCJOb3RlYm9va0RvY3VtZW50IiwiTm90ZWJvb2tDZWxsIiwiRXhlY3V0aW9uU3VtbWFyeSIsIk5vdGVib29rQ2VsbEtpbmQiLCJUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QiLCJUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0IiwiVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEiLCJwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xIiwicHJvdG9jb2xfdHlwZURlZmluaXRpb25fMSIsInByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xIiwicHJvdG9jb2xfY29uZmlndXJhdGlvbl8xIiwicHJvdG9jb2xfY29sb3JQcm92aWRlcl8xIiwicHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEiLCJwcm90b2NvbF9kZWNsYXJhdGlvbl8xIiwicHJvdG9jb2xfc2VsZWN0aW9uUmFuZ2VfMSIsInByb3RvY29sX3Byb2dyZXNzXzEiLCJwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEiLCJwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xIiwicHJvdG9jb2xfc2hvd0RvY3VtZW50XzEiLCJwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMSIsInByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEiLCJwcm90b2NvbF9tb25pa2VyXzEiLCJwcm90b2NvbF90eXBlSGllcmFyY2h5XzEiLCJwcm90b2NvbF9pbmxpbmVWYWx1ZV8xIiwicHJvdG9jb2xfaW5sYXlIaW50XzEiLCJwcm90b2NvbF9kaWFnbm9zdGljXzEiLCJwcm90b2NvbF9ub3RlYm9va18xIiwicHJvdG9jb2xfaW5saW5lQ29tcGxldGlvbl8xIiwibGFuZ3VhZ2UiLCJzY2hlbWUiLCJwYXR0ZXJuIiwib2JqZWN0TGl0ZXJhbCIsIm5vdGVib29rVHlwZSIsIm5vdGVib29rIiwiQ3JlYXRlIiwiUmVuYW1lIiwiRGVsZXRlIiwiQWJvcnQiLCJUcmFuc2FjdGlvbmFsIiwiVGV4dE9ubHlUcmFuc2FjdGlvbmFsIiwiVW5kbyIsIlVURjgiLCJVVEYxNiIsIlVURjMyIiwiaGFzSWQiLCJkb2N1bWVudFNlbGVjdG9yIiwid29ya0RvbmVQcm9ncmVzcyIsImhhc1dvcmtEb25lUHJvZ3Jlc3MiLCJ1bmtub3duUHJvdG9jb2xWZXJzaW9uIiwiV2FybmluZyIsIkluZm8iLCJMb2ciLCJEZWJ1ZyIsIkluY3JlbWVudGFsIiwiaXNJbmNyZW1lbnRhbCIsInJhbmdlTGVuZ3RoIiwiaXNGdWxsIiwiTWFudWFsIiwiQWZ0ZXJEZWxheSIsIkZvY3VzT3V0IiwiQ3JlYXRlZCIsIkNoYW5nZWQiLCJEZWxldGVkIiwiYmFzZVVyaSIsIldvcmtzcGFjZUZvbGRlciIsIkNoYW5nZSIsIkludm9rZWQiLCJUcmlnZ2VyQ2hhcmFjdGVyIiwiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyIsIkNvbnRlbnRDaGFuZ2UiLCJwcm9qZWN0IiwiZ3JvdXAiLCIkaW1wb3J0IiwiJGV4cG9ydCIsImxvY2FsIiwiTWFya3VwIiwiQ29kZSIsImV4ZWN1dGlvbk9yZGVyIiwic3VjY2VzcyIsInVpbnRlZ2VyIiwiZXF1YWxzIiwib25lIiwiRG9jdW1lbnRVcmkiLCJtZXRhZGF0YSIsImRpZmYiLCJ0d28iLCJleGVjdXRpb25TdW1tYXJ5IiwiZXF1YWxzTWV0YWRhdGEiLCJvbmVBcnJheSIsIm90aGVyQXJyYXkiLCJvbmVLZXlzIiwib3RoZXJLZXlzIiwiY2VsbHMiLCJpbnRlZ2VyIiwidHlwZWRBcnJheSIsInJlZ2lzdHJhdGlvbk1ldGhvZCIsImRlbGV0ZUNvdW50IiwiUmVsYXRpdmUiLCJjaGVjayIsImF2YWlsYWJsZVR5cGVkQXJyYXlzIiwiZ2xvYmFsVGhpcyIsInR5cGVkQXJyYXlzIiwiJHNsaWNlIiwiY2FjaGUiLCJwcm90byIsInN1cGVyUHJvdG8iLCJ0cnlUeXBlZEFycmF5cyIsInRyeUFsbFR5cGVkQXJyYXlzIiwiZ2V0dGVyIiwidHJ5U2xpY2VzIiwidHJ5QWxsU2xpY2VzIiwidGFnIiwicG9zc2libGVOYW1lcyIsIm91dCIsIl9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fIiwiVGV4dERvY3VtZW50IiwiRnVsbFRleHREb2N1bWVudCIsIl91cmkiLCJfbGFuZ3VhZ2VJZCIsIl92ZXJzaW9uIiwib2Zmc2V0QXQiLCJfY29udGVudCIsImNoYW5nZXMiLCJjaGFuZ2UiLCJnZXRXZWxsZm9ybWVkUmFuZ2UiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJsaW5lT2Zmc2V0cyIsIl9saW5lT2Zmc2V0cyIsImFkZGVkTGluZU9mZnNldHMiLCJjb21wdXRlTGluZU9mZnNldHMiLCJnZXRMaW5lT2Zmc2V0cyIsInBvc2l0aW9uQXQiLCJsb3ciLCJoaWdoIiwibWlkIiwiZW5zdXJlQmVmb3JlRU9MIiwibGluZU9mZnNldCIsIm5leHRMaW5lT2Zmc2V0IiwiaXNFT0wiLCJsaW5lQ291bnQiLCJhcHBseUVkaXRzIiwiZWRpdHMiLCJzb3J0ZWRFZGl0cyIsIm1lcmdlU29ydCIsImdldFdlbGxmb3JtZWRFZGl0IiwibGFzdE1vZGlmaWVkT2Zmc2V0Iiwic3BhbnMiLCJuZXdUZXh0IiwibGVmdElkeCIsInJpZ2h0SWR4IiwiaXNBdExpbmVTdGFydCIsInRleHRPZmZzZXQiLCJjaCIsImNoYXIiLCJ0ZXh0RWRpdCIsIkFubm90YXRlZFRleHRFZGl0IiwiQ2hhbmdlQW5ub3RhdGlvbiIsIkNoYW5nZUFubm90YXRpb25JZGVudGlmaWVyIiwiQ29kZUFjdGlvbiIsIkNvZGVBY3Rpb25Db250ZXh0IiwiQ29kZUFjdGlvbktpbmQiLCJDb2RlQWN0aW9uVHJpZ2dlcktpbmQiLCJDb2RlRGVzY3JpcHRpb24iLCJDb2RlTGVucyIsIkNvbG9yIiwiQ29sb3JJbmZvcm1hdGlvbiIsIkNvbG9yUHJlc2VudGF0aW9uIiwiQ29tbWFuZCIsIkNvbXBsZXRpb25JdGVtIiwiQ29tcGxldGlvbkl0ZW1LaW5kIiwiQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMiLCJDb21wbGV0aW9uSXRlbVRhZyIsIkNvbXBsZXRpb25MaXN0IiwiQ3JlYXRlRmlsZSIsIkRlbGV0ZUZpbGUiLCJEaWFnbm9zdGljIiwiRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiIsIkRpYWdub3N0aWNTZXZlcml0eSIsIkRvY3VtZW50SGlnaGxpZ2h0IiwiRG9jdW1lbnRIaWdobGlnaHRLaW5kIiwiRG9jdW1lbnRMaW5rIiwiRG9jdW1lbnRTeW1ib2wiLCJFT0wiLCJGb2xkaW5nUmFuZ2UiLCJGb2xkaW5nUmFuZ2VLaW5kIiwiRm9ybWF0dGluZ09wdGlvbnMiLCJIb3ZlciIsIklubGF5SGludCIsIklubGF5SGludEtpbmQiLCJJbmxheUhpbnRMYWJlbFBhcnQiLCJJbmxpbmVDb21wbGV0aW9uQ29udGV4dCIsIklubGluZUNvbXBsZXRpb25JdGVtIiwiSW5saW5lQ29tcGxldGlvbkxpc3QiLCJJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQiLCJJbmxpbmVWYWx1ZUNvbnRleHQiLCJJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiIsIklubGluZVZhbHVlVGV4dCIsIklubGluZVZhbHVlVmFyaWFibGVMb29rdXAiLCJJbnNlcnRSZXBsYWNlRWRpdCIsIkluc2VydFRleHRGb3JtYXQiLCJJbnNlcnRUZXh0TW9kZSIsIkxvY2F0aW9uIiwiTG9jYXRpb25MaW5rIiwiTWFya2VkU3RyaW5nIiwiTWFya3VwQ29udGVudCIsIk1hcmt1cEtpbmQiLCJPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJQYXJhbWV0ZXJJbmZvcm1hdGlvbiIsIlBvc2l0aW9uIiwiUmFuZ2UiLCJSZW5hbWVGaWxlIiwiU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyIsIlNlbGVjdGlvblJhbmdlIiwiU2VtYW50aWNUb2tlbk1vZGlmaWVycyIsIlNlbWFudGljVG9rZW5UeXBlcyIsIlNlbWFudGljVG9rZW5zIiwiU2lnbmF0dXJlSW5mb3JtYXRpb24iLCJTdHJpbmdWYWx1ZSIsIlN5bWJvbEluZm9ybWF0aW9uIiwiU3ltYm9sS2luZCIsIlN5bWJvbFRhZyIsIlRleHREb2N1bWVudEVkaXQiLCJUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiVGV4dERvY3VtZW50SXRlbSIsIlRleHRFZGl0IiwiVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciIsIldvcmtzcGFjZUNoYW5nZSIsIldvcmtzcGFjZUVkaXQiLCJXb3Jrc3BhY2VTeW1ib2wiLCJNSU5fVkFMVUUiLCJNQVhfVkFMVUUiLCJ0aHJlZSIsImZvdXIiLCJ0YXJnZXRVcmkiLCJ0YXJnZXRSYW5nZSIsInRhcmdldFNlbGVjdGlvblJhbmdlIiwib3JpZ2luU2VsZWN0aW9uUmFuZ2UiLCJhbHBoYSIsIm51bWJlclJhbmdlIiwiY29sb3IiLCJhZGRpdGlvbmFsVGV4dEVkaXRzIiwiQ29tbWVudCIsIkltcG9ydHMiLCJSZWdpb24iLCJzdGFydENoYXJhY3RlciIsImVuZENoYXJhY3RlciIsImNvbGxhcHNlZFRleHQiLCJkZWZpbmVkIiwiSW5mb3JtYXRpb24iLCJIaW50IiwiaHJlZiIsInNldmVyaXR5IiwiY29kZURlc2NyaXB0aW9uIiwiaW5zZXJ0IiwiZGVsIiwibmVlZHNDb25maXJtYXRpb24iLCJkZXNjcmlwdGlvbiIsImFubm90YXRpb24iLCJhbm5vdGF0aW9uSWQiLCJvdmVyd3JpdGUiLCJpZ25vcmVJZkV4aXN0cyIsIm9sZFVyaSIsIm5ld1VyaSIsInJlY3Vyc2l2ZSIsImlnbm9yZUlmTm90RXhpc3RzIiwiVGV4dEVkaXRDaGFuZ2VJbXBsIiwiZWRpdCIsImFzc2VydENoYW5nZUFubm90YXRpb25zIiwiY2hhbmdlQW5ub3RhdGlvbnMiLCJtYW5hZ2UiLCJDaGFuZ2VBbm5vdGF0aW9ucyIsIl9hbm5vdGF0aW9ucyIsImlkT3JBbm5vdGF0aW9uIiwibmV4dElkIiwiX2NvdW50ZXIiLCJhbm5vdGF0aW9ucyIsImluaXREb2N1bWVudENoYW5nZXMiLCJfY2hhbmdlQW5ub3RhdGlvbnMiLCJfd29ya3NwYWNlRWRpdCIsImdldFRleHRFZGl0Q2hhbmdlIiwiX3RleHRFZGl0Q2hhbmdlcyIsInRleHREb2N1bWVudEVkaXQiLCJpbml0Q2hhbmdlcyIsImNyZWF0ZUZpbGUiLCJvcHRpb25zT3JBbm5vdGF0aW9uIiwib3BlcmF0aW9uIiwicmVuYW1lRmlsZSIsImRlbGV0ZUZpbGUiLCJ0ZXh0RWRpdENoYW5nZSIsIlBsYWluVGV4dCIsIk1hcmtkb3duIiwiTWV0aG9kIiwiRmllbGQiLCJWYXJpYWJsZSIsIkludGVyZmFjZSIsIk1vZHVsZSIsIlByb3BlcnR5IiwiVW5pdCIsIlZhbHVlIiwiRW51bSIsIlNuaXBwZXQiLCJGaWxlIiwiUmVmZXJlbmNlIiwiRm9sZGVyIiwiRW51bU1lbWJlciIsIkNvbnN0YW50IiwiU3RydWN0IiwiT3BlcmF0b3IiLCJUeXBlUGFyYW1ldGVyIiwiYXNJcyIsImFkanVzdEluZGVudGF0aW9uIiwiZGV0YWlsIiwiaXRlbXMiLCJpc0luY29tcGxldGUiLCJmcm9tUGxhaW5UZXh0IiwicGxhaW5UZXh0IiwiY29udGVudHMiLCJkb2N1bWVudGF0aW9uIiwiUmVhZCIsIldyaXRlIiwiTmFtZXNwYWNlIiwiUGFja2FnZSIsIktleSIsIk51bGwiLCJjb250YWluZXJOYW1lIiwic2VsZWN0aW9uUmFuZ2UiLCJjaGlsZHJlbiIsInRhZ3MiLCJRdWlja0ZpeCIsIlJlZmFjdG9yIiwiUmVmYWN0b3JFeHRyYWN0IiwiUmVmYWN0b3JJbmxpbmUiLCJSZWZhY3RvclJld3JpdGUiLCJTb3VyY2UiLCJTb3VyY2VPcmdhbml6ZUltcG9ydHMiLCJTb3VyY2VGaXhBbGwiLCJBdXRvbWF0aWMiLCJkaWFnbm9zdGljcyIsIm9ubHkiLCJ0cmlnZ2VyS2luZCIsImtpbmRPckNvbW1hbmRPckVkaXQiLCJjaGVja0tpbmQiLCJpc1ByZWZlcnJlZCIsInRhYlNpemUiLCJpbnNlcnRTcGFjZXMiLCJwYXJlbnQiLCJyZXN1bHRJZCIsInZhcmlhYmxlTmFtZSIsImNhc2VTZW5zaXRpdmVMb29rdXAiLCJmcmFtZUlkIiwic3RvcHBlZExvY2F0aW9uIiwiVHlwZSIsIlBhcmFtZXRlciIsInRvb2x0aXAiLCJ0ZXh0RWRpdHMiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImNyZWF0ZVNuaXBwZXQiLCJpbnNlcnRUZXh0IiwiZmlsdGVyVGV4dCIsInNlbGVjdGVkQ29tcGxldGlvbkluZm8iLCJpc0xpbmVTdGFydCIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwibG9hZGVkIiwiZGVmaW5pdGlvbiIsInBhdGhzIiwiTHVhU2VydmljZSIsImJhc2Vfc2VydmljZSIsImx1YXBhcnNlIiwibWFpbiIsInV0aWxzIiwiQWNlUmFuZ2UiLCJnZXRDb25zdHJ1Y3RvciIsImVkaXRvciIsIl9pbnN0YW5jZSIsImdldFNlbGVjdGlvblJhbmdlIiwiY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyIiwiQ29tbW9uQ29udmVydGVyIiwibm9ybWFsaXplUmFuZ2VzIiwiY29tcGxldGlvbnMiLCJlbCIsInRvUmFuZ2UiLCJjbGVhbkh0bWwiLCJodG1sIiwiZnJvbVBvaW50cyIsImNvbnZlcnRLaW5kIiwiZXhjbHVkZUJ5RXJyb3JNZXNzYWdlIiwiZmllbGROYW1lIiwiZnJvbVJhbmdlIiwicmFuZ2VGcm9tUG9zaXRpb25zIiwiZnJvbVBvaW50IiwicG9pbnQiLCJ0b1BvaW50IiwidG9Bbm5vdGF0aW9ucyIsIl9kaWFnbm9zdGljcyIsImZyb21Bbm5vdGF0aW9ucyIsInRvQ29tcGxldGlvbiIsIl9pdGVtX3RleHRFZGl0IiwiX2l0ZW1fY29tbWFuZCIsIml0ZW1LaW5kIiwiX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCIsIl9yZWYiLCJmaXJzdFdvcmRNYXRjaCIsImZpcnN0V29yZCIsIndvcmRSZWdleCIsImdldFRleHRFZGl0UmFuZ2UiLCJjYXB0aW9uIiwic2NvcmUiLCJpbnNlcnRUZXh0Rm9ybWF0IiwidG9Db21wbGV0aW9ucyIsImNvbWJpbmVkQ29tcGxldGlvbnMiLCJnZXRDb21wbGV0aW9uSXRlbXMiLCJhbGxDb21wbGV0aW9ucyIsInNlcnZpY2UiLCJmbGF0IiwidG9JbmxpbmVDb21wbGV0aW9uIiwiZ2V0SW5saW5lQ29tcGxldGlvblJhbmdlIiwidG9JbmxpbmVDb21wbGV0aW9ucyIsInRvUmVzb2x2ZWRDb21wbGV0aW9uIiwiZnJvbU1hcmt1cENvbnRlbnQiLCJ0b0NvbXBsZXRpb25JdGVtIiwiX2NvbXBsZXRpb25fY2FwdGlvbiIsIl9jb21wbGV0aW9uX3NuaXBwZXQiLCJfY29tcGxldGlvbl9zbmlwcGV0MSIsImZpbHRlckxlbmd0aCIsIm1lcmdlZFJhbmdlcyIsInRvVG9vbHRpcCIsIl9ob3Zlcl9maW5kIiwibHNwUmFuZ2UiLCJmaW5kIiwiX2VsIiwiZnJvbVNpZ25hdHVyZUhlbHAiLCJfZWwxIiwic2lnbmF0dXJlSW5kZXgiLCJhY3RpdmVTaWduYXR1cmUiLCJzaWduYXR1cmVzIiwiYWN0aXZlUGFyYW0iLCJhY3RpdmVQYXJhbWV0ZXIiLCJmcm9tQWNlRGVsdGEiLCJlb2wiLCJsaW5lcyIsImFjdGlvbiIsImZpbHRlckRpYWdub3N0aWNzIiwiZmlsdGVyRXJyb3JzIiwiZnJvbURvY3VtZW50SGlnaGxpZ2h0cyIsImRvY3VtZW50SGlnaGxpZ2h0cyIsInRvTWFya2VyR3JvdXBJdGVtIiwidG9vbHRpcFRleHQiLCJtYXJrZXJHcm91cEl0ZW0iLCJsdWFfc2VydmljZV9kZWZpbmVfcHJvcGVydHkiLCIkc2VydmljZSIsImRpYWdub3N0aWNQcm92aWRlciIsImludGVyRmlsZURlcGVuZGVuY2llcyIsIndvcmtzcGFjZURpYWdub3N0aWNzIl0sInNvdXJjZVJvb3QiOiIifQ==