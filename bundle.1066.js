(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[1066],{

/***/ 21066:
/***/ (function(module) {

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 6093: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_810__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_810__(9907);
                /* provided dependency */ var console = __nested_webpack_require_810__(4364);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_810__(1342), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_810__(9801);
                var _require2 = __nested_webpack_require_810__(6827), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_810__(6827).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_810__(3046).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_810__(5968);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_810__(5656);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 9801: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_32028__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_32028__(9907);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_32028__(6827), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_32028__(1342), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 1342: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65617__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65617__(6093);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65617__(6827);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65617__(6093);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 5656: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76678__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76678__(5968);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76678__(7838);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76678__(6827).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 9818: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108232__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_108232__(528);
                var callBind = __nested_webpack_require_108232__(8498);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 8498: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108959__)=>{
                "use strict";
                var bind = __nested_webpack_require_108959__(9138);
                var GetIntrinsic = __nested_webpack_require_108959__(528);
                var setFunctionLength = __nested_webpack_require_108959__(6108);
                var $TypeError = __nested_webpack_require_108959__(3468);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $defineProperty = __nested_webpack_require_108959__(4940);
                var $max = GetIntrinsic('%Math.max%');
                module1.exports = function callBind(originalFunction) {
                    if (typeof originalFunction !== 'function') {
                        throw new $TypeError('a function is required');
                    }
                    var func = $reflectApply(bind, $call, arguments);
                    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 4364: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110558__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110558__(6827);
                var assert = __nested_webpack_require_110558__(6093);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110558__.g !== "undefined" && __nested_webpack_require_110558__.g.console) {
                    console = __nested_webpack_require_110558__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 686: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114240__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_114240__(4940);
                var $SyntaxError = __nested_webpack_require_114240__(5731);
                var $TypeError = __nested_webpack_require_114240__(3468);
                var gopd = __nested_webpack_require_114240__(9336);
                /** @type {import('.')} */ module1.exports = function defineDataProperty(obj, property, value) {
                    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
                        throw new $TypeError('`obj` must be an object or a function`');
                    }
                    if (typeof property !== 'string' && typeof property !== 'symbol') {
                        throw new $TypeError('`property` must be a string or a symbol`');
                    }
                    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
                        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
                        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
                        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
                        throw new $TypeError('`loose`, if provided, must be a boolean');
                    }
                    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                    var nonWritable = arguments.length > 4 ? arguments[4] : null;
                    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                    var loose = arguments.length > 6 ? arguments[6] : false;
                    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
                    if ($defineProperty) {
                        $defineProperty(obj, property, {
                            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                            value: value,
                            writable: nonWritable === null && desc ? desc.writable : !nonWritable
                        });
                    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
                        obj[property] = value; // eslint-disable-line no-param-reassign
                    } else {
                        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
                    }
                };
            /***/ },
            /***/ 1857: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_117528__)=>{
                "use strict";
                var keys = __nested_webpack_require_117528__(9228);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var defineDataProperty = __nested_webpack_require_117528__(686);
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var supportsDescriptors = __nested_webpack_require_117528__(7239)();
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        defineDataProperty(object, name, value, true);
                    } else {
                        defineDataProperty(object, name, value);
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4940: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_119605__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_119605__(528);
                /** @type {import('.')} */ var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = false;
                    }
                }
                module1.exports = $defineProperty;
            /***/ },
            /***/ 6729: /***/ (module1)=>{
                "use strict";
                /** @type {import('./eval')} */ module1.exports = EvalError;
            /***/ },
            /***/ 9838: /***/ (module1)=>{
                "use strict";
                /** @type {import('.')} */ module1.exports = Error;
            /***/ },
            /***/ 1155: /***/ (module1)=>{
                "use strict";
                /** @type {import('./range')} */ module1.exports = RangeError;
            /***/ },
            /***/ 4943: /***/ (module1)=>{
                "use strict";
                /** @type {import('./ref')} */ module1.exports = ReferenceError;
            /***/ },
            /***/ 5731: /***/ (module1)=>{
                "use strict";
                /** @type {import('./syntax')} */ module1.exports = SyntaxError;
            /***/ },
            /***/ 3468: /***/ (module1)=>{
                "use strict";
                /** @type {import('./type')} */ module1.exports = TypeError;
            /***/ },
            /***/ 2140: /***/ (module1)=>{
                "use strict";
                /** @type {import('./uri')} */ module1.exports = URIError;
            /***/ },
            /***/ 3046: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 705: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123451__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_123451__(9617);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 8794: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var toStr = Object.prototype.toString;
                var max = Math.max;
                var funcType = '[object Function]';
                var concatty = function concatty(a, b) {
                    var arr = [];
                    for(var i = 0; i < a.length; i += 1){
                        arr[i] = a[i];
                    }
                    for(var j = 0; j < b.length; j += 1){
                        arr[j + a.length] = b[j];
                    }
                    return arr;
                };
                var slicy = function slicy(arrLike, offset) {
                    var arr = [];
                    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
                        arr[j] = arrLike[i];
                    }
                    return arr;
                };
                var joiny = function(arr, joiner) {
                    var str = '';
                    for(var i = 0; i < arr.length; i += 1){
                        str += arr[i];
                        if (i + 1 < arr.length) {
                            str += joiner;
                        }
                    }
                    return str;
                };
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, concatty(args, arguments));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        }
                        return target.apply(that, concatty(args, arguments));
                    };
                    var boundLength = max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs[i] = '$' + i;
                    }
                    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 9138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129170__)=>{
                "use strict";
                var implementation = __nested_webpack_require_129170__(8794);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 528: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129451__)=>{
                "use strict";
                var undefined1;
                var $Error = __nested_webpack_require_129451__(9838);
                var $EvalError = __nested_webpack_require_129451__(6729);
                var $RangeError = __nested_webpack_require_129451__(1155);
                var $ReferenceError = __nested_webpack_require_129451__(4943);
                var $SyntaxError = __nested_webpack_require_129451__(5731);
                var $TypeError = __nested_webpack_require_129451__(3468);
                var $URIError = __nested_webpack_require_129451__(2140);
                var $Function = Function;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_129451__(3558)();
                var hasProto = __nested_webpack_require_129451__(6869)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    __proto__: null,
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': $Error,
                    '%eval%': eval,
                    '%EvalError%': $EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': $RangeError,
                    '%ReferenceError%': $ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': $URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    __proto__: null,
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_129451__(9138);
                var hasOwn = __nested_webpack_require_129451__(8554);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 9336: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153329__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_153329__(528);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 7239: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153919__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_153919__(4940);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    return !!$defineProperty;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!$defineProperty) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 6869: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 3558: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155481__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_155481__(2908);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 2908: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 1913: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159240__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_159240__(2908);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 8554: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159592__)=>{
                "use strict";
                var call = Function.prototype.call;
                var $hasOwn = Object.prototype.hasOwnProperty;
                var bind = __nested_webpack_require_159592__(9138);
                /** @type {import('.')} */ module1.exports = bind.call(call, $hasOwn);
            /***/ },
            /***/ 5615: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 5387: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_161379__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_161379__(1913)();
                var callBound = __nested_webpack_require_161379__(9818);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9617: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 2625: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168439__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_168439__(1913)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 8006: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 7838: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170408__)=>{
                "use strict";
                var callBind = __nested_webpack_require_170408__(8498);
                var define1 = __nested_webpack_require_170408__(1857);
                var implementation = __nested_webpack_require_170408__(8006);
                var getPolyfill = __nested_webpack_require_170408__(1591);
                var shim = __nested_webpack_require_170408__(1641);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1591: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171207__)=>{
                "use strict";
                var implementation = __nested_webpack_require_171207__(8006);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 1641: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171683__)=>{
                "use strict";
                var define1 = __nested_webpack_require_171683__(1857);
                var getPolyfill = __nested_webpack_require_171683__(1591);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5943: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_172451__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_172451__(2730);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 2372: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 5968: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_173439__)=>{
                "use strict";
                var define1 = __nested_webpack_require_173439__(1857);
                var callBind = __nested_webpack_require_173439__(8498);
                var implementation = __nested_webpack_require_173439__(2372);
                var getPolyfill = __nested_webpack_require_173439__(1937);
                var shim = __nested_webpack_require_173439__(5087);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1937: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_174167__)=>{
                "use strict";
                var implementation = __nested_webpack_require_174167__(2372);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 5087: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_174539__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_174539__(1937);
                var define1 = __nested_webpack_require_174539__(1857);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 8160: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_175227__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_175227__(968); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 9228: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_181196__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_181196__(968);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_181196__(8160);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 968: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 9907: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 6108: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_191560__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_191560__(528);
                var define1 = __nested_webpack_require_191560__(686);
                var hasDescriptors = __nested_webpack_require_191560__(7239)();
                var gOPD = __nested_webpack_require_191560__(9336);
                var $TypeError = __nested_webpack_require_191560__(3468);
                var $floor = GetIntrinsic('%Math.floor%');
                /** @type {import('.')} */ module1.exports = function setFunctionLength(fn, length) {
                    if (typeof fn !== 'function') {
                        throw new $TypeError('`fn` is not a function');
                    }
                    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
                        throw new $TypeError('`length` must be a positive 32-bit integer');
                    }
                    var loose = arguments.length > 2 && !!arguments[2];
                    var functionLengthIsConfigurable = true;
                    var functionLengthIsWritable = true;
                    if ('length' in fn && gOPD) {
                        var desc = gOPD(fn, 'length');
                        if (desc && !desc.configurable) {
                            functionLengthIsConfigurable = false;
                        }
                        if (desc && !desc.writable) {
                            functionLengthIsWritable = false;
                        }
                    }
                    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                        if (hasDescriptors) {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length, true, true);
                        } else {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length);
                        }
                    }
                    return fn;
                };
            /***/ },
            /***/ 2125: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_193634__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_193634__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_193634__(5501);
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_193634__.n(vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__);
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_193634__(7770);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_193634__(8041);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, document1.text);
                    }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    renameDocument(document1, newDocumentUri) {
                        const previousDocument = this.getDocument(document1.uri);
                        this.addDocument({
                            uri: newDocumentUri,
                            version: previousDocument.version,
                            languageId: previousDocument.languageId,
                            text: previousDocument.getText()
                        });
                        this.options[newDocumentUri] = this.options[document1.uri];
                        this.removeDocument(document1);
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setWorkspace(workspaceUri) {
                        this.workspaceUri = workspaceUri;
                    }
                    setOptions(documentUri, options, merge = false) {
                        this.options[documentUri] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_2__ /* .mergeObjects */ .rL)(options, this.options[documentUri]) : options;
                    }
                    getOption(documentUri, optionName) {
                        if (this.options[documentUri] && this.options[documentUri][optionName]) {
                            return this.options[documentUri][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doInlineComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    getSemanticTokens(document1, range) {
                        return Promise.resolve(null);
                    }
                    dispose() {
                        return Promise.resolve();
                    }
                    closeConnection() {
                        return Promise.resolve();
                    }
                    getCodeActions(document1, range, context) {
                        return Promise.resolve(null);
                    }
                    executeCommand(command, args) {
                        return Promise.resolve(null);
                    }
                    sendAppliedResult(result, callbackId) {}
                    sendRequest(name, args) {
                        return Promise.resolve(null);
                    }
                    sendResponse(callbackId, args) {
                        return;
                    }
                    constructor(mode, workspaceUri){
                        _define_property(this, "serviceName", void 0);
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        _define_property(this, "workspaceUri", void 0);
                        _define_property(this, "clientCapabilities", {
                            textDocument: {
                                diagnostic: {
                                    dynamicRegistration: true,
                                    relatedDocumentSupport: true
                                },
                                publishDiagnostics: {
                                    relatedInformation: true,
                                    versionSupport: false,
                                    tagSupport: {
                                        valueSet: [
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Unnecessary,
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Deprecated
                                        ]
                                    }
                                },
                                hover: {
                                    dynamicRegistration: true,
                                    contentFormat: [
                                        'markdown',
                                        'plaintext'
                                    ]
                                },
                                synchronization: {
                                    dynamicRegistration: true,
                                    willSave: false,
                                    didSave: false,
                                    willSaveWaitUntil: false
                                },
                                formatting: {
                                    dynamicRegistration: true
                                },
                                completion: {
                                    dynamicRegistration: true,
                                    completionItem: {
                                        snippetSupport: true,
                                        commitCharactersSupport: false,
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        deprecatedSupport: false,
                                        preselectSupport: false
                                    },
                                    contextSupport: false
                                },
                                signatureHelp: {
                                    signatureInformation: {
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        activeParameterSupport: true
                                    }
                                },
                                documentHighlight: {
                                    dynamicRegistration: true
                                },
                                semanticTokens: {
                                    multilineTokenSupport: false,
                                    overlappingTokenSupport: false,
                                    tokenTypes: [],
                                    tokenModifiers: [],
                                    formats: [
                                        "relative"
                                    ],
                                    requests: {
                                        full: {
                                            delta: false
                                        },
                                        range: true
                                    },
                                    augmentsSyntaxTokens: true
                                },
                                codeAction: {
                                    dynamicRegistration: true
                                },
                                inlineCompletion: {
                                    dynamicRegistration: true
                                }
                            },
                            window: {
                                showDocument: {
                                    support: true
                                }
                            },
                            workspace: {
                                didChangeConfiguration: {
                                    dynamicRegistration: true
                                },
                                executeCommand: {
                                    dynamicRegistration: true
                                },
                                applyEdit: true,
                                workspaceEdit: {
                                    failureHandling: "abort",
                                    normalizesLineEndings: false,
                                    documentChanges: false
                                }
                            }
                        });
                        this.mode = mode;
                        this.workspaceUri = workspaceUri;
                        this.serviceName = "BaseService";
                        this.serviceData = {
                            className: "BaseService",
                            modes: "",
                            module: ()=>{}
                        };
                    }
                }
            /***/ },
            /***/ 7770: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_208553__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_208553__.d(__nested_webpack_exports__, {
                    /* harmony export */ rL: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, isEmptyRange, mergeRanges, checkValueAgainstRegexpArray, convertToUri */ function mergeObjects(obj1, obj2, excludeUndefined = false) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    if (excludeUndefined) {
                        obj1 = excludeUndefinedValues(obj1);
                        obj2 = excludeUndefinedValues(obj2);
                    }
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function excludeUndefinedValues(obj) {
                    const filteredEntries = Object.entries(obj).filter(([_, value])=>value !== undefined);
                    return Object.fromEntries(filteredEntries);
                }
                function notEmpty(value) {
                    return value !== null && value !== undefined;
                }
                function isEmptyRange(range) {
                    return range.start.row === range.end.row && range.start.column === range.end.column;
                }
                //taken with small changes from ace-code
                function mergeRanges(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !isEmptyRange(range) && !isEmptyRange(next)) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
                function convertToUri(filePath) {
                    //already URI
                    if (filePath.startsWith("file:///")) {
                        return filePath;
                    }
                    return URI.file(filePath).toString();
                }
            /***/ },
            /***/ 5272: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 1531: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_213068__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_213068__(5387);
                var isGeneratorFunction = __nested_webpack_require_213068__(2625);
                var whichTypedArray = __nested_webpack_require_213068__(2730);
                var isTypedArray = __nested_webpack_require_213068__(5943);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 6827: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_225545__)=>{
                /* provided dependency */ var process = __nested_webpack_require_225545__(9907);
                /* provided dependency */ var console = __nested_webpack_require_225545__(4364);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_225545__(1531);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_225545__(5272);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_225545__(5615);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 9208: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_257143__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_257143__(9110);
            /***/ },
            /***/ 9110: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_257702__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_257702__(3312);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_257702__(7672);
                __exportStar(__nested_webpack_require_257702__(7672), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3312: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_262117__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_262117__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_262117__(7672);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 7672: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_270496__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_270496__(7162);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_270496__(1109);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_270496__(8844);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_270496__(2479);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_270496__(6957);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_270496__(3489);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_270496__(656);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_270496__(9036);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_270496__(9805);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_270496__(4054);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_270496__(5091);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 6957: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_288560__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_288560__(5091);
                const Is = __nested_webpack_require_288560__(6618);
                const events_1 = __nested_webpack_require_288560__(2479);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken || (exports1.CancellationToken = CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 4054: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_293485__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_293485__(5091);
                const Is = __nested_webpack_require_293485__(6618);
                const messages_1 = __nested_webpack_require_293485__(7162);
                const linkedMap_1 = __nested_webpack_require_293485__(1109);
                const events_1 = __nested_webpack_require_293485__(2479);
                const cancellation_1 = __nested_webpack_require_293485__(6957);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken || (exports1.ProgressToken = ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues || (exports1.TraceValues = TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification || (exports1.SetTraceNotification = SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification || (exports1.LogTraceNotification = LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors || (exports1.ConnectionErrors = ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy || (exports1.ConnectionStrategy = ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy || (exports1.CancellationSenderStrategy = CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy || (exports1.CancellationStrategy = CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy || (exports1.MessageStrategy = MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions || (exports1.ConnectionOptions = ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8844: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable || (exports1.Disposable = Disposable = {}));
            /***/ },
            /***/ 2479: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_364415__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_364415__(5091);
                var Event1;
                (function(Event1) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event1.None = function() {
                        return _disposable;
                    };
                })(Event1 || (exports1.Event = Event1 = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 6618: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 1109: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch || (exports1.Touch = Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 9805: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error(`Message header must separate key and value using ':'\n${header}`);
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 656: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_400107__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_400107__(5091);
                const Is = __nested_webpack_require_400107__(6618);
                const events_1 = __nested_webpack_require_400107__(2479);
                const semaphore_1 = __nested_webpack_require_400107__(418);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader || (exports1.MessageReader = MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        try {
                            this.buffer.append(data);
                            while(true){
                                if (this.nextMessageLength === -1) {
                                    const headers = this.buffer.tryReadHeaders(true);
                                    if (!headers) {
                                        return;
                                    }
                                    const contentLength = headers.get('content-length');
                                    if (!contentLength) {
                                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
                                        return;
                                    }
                                    const length = parseInt(contentLength);
                                    if (isNaN(length)) {
                                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                                        return;
                                    }
                                    this.nextMessageLength = length;
                                }
                                const body = this.buffer.tryReadBody(this.nextMessageLength);
                                if (body === undefined) {
                                    /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                    return;
                                }
                                this.clearPartialMessageTimer();
                                this.nextMessageLength = -1;
                                // Make sure that we convert one received message after the
                                // other. Otherwise it could happen that a decoding of a second
                                // smaller message finished before the decoding of a first larger
                                // message and then we would deliver the second message first.
                                this.readSemaphore.lock(async ()=>{
                                    const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                    this.callback(message);
                                }).catch((error)=>{
                                    this.fireError(error);
                                });
                            }
                        } catch (error) {
                            this.fireError(error);
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 9036: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_411729__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_411729__(5091);
                const Is = __nested_webpack_require_411729__(6618);
                const semaphore_1 = __nested_webpack_require_411729__(418);
                const events_1 = __nested_webpack_require_411729__(2479);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter || (exports1.MessageWriter = MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 7162: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_418605__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_418605__(6618);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes || (exports1.ErrorCodes = ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message || (exports1.Message = Message = {}));
            /***/ },
            /***/ 5091: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 418: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_434094__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_434094__(5091);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 3489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_437537__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_437537__(6957);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 8713: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_441434__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_441434__(5501);
            /***/ },
            /***/ 5501: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_441993__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_441993__(9208);
                __exportStar(__nested_webpack_require_441993__(9208), exports1);
                __exportStar(__nested_webpack_require_441993__(3147), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 3147: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_444182__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_444182__(9110), exports1);
                __exportStar(__nested_webpack_require_444182__(2852), exports1);
                __exportStar(__nested_webpack_require_444182__(8431), exports1);
                __exportStar(__nested_webpack_require_444182__(1815), exports1);
                var connection_1 = __nested_webpack_require_444182__(291);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes || (exports1.LSPErrorCodes = LSPErrorCodes = {}));
            /***/ },
            /***/ 291: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_448322__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_448322__(9110);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8431: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_449559__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_449559__(9110);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection || (exports1.MessageDirection = MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 7602: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_452276__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_452276__(8431);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 3747: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_455280__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_455280__(8431);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest || (exports1.DocumentColorRequest = DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest || (exports1.ColorPresentationRequest = ColorPresentationRequest = {}));
            /***/ },
            /***/ 7639: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_457565__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_457565__(8431);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest || (exports1.ConfigurationRequest = ConfigurationRequest = {}));
            /***/ },
            /***/ 5581: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_459338__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_459338__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}
 * or a Thenable that resolves to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest || (exports1.DeclarationRequest = DeclarationRequest = {}));
            /***/ },
            /***/ 1494: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_460967__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_460967__(9110);
                const Is = __nested_webpack_require_460967__(8633);
                const messages_1 = __nested_webpack_require_460967__(8431);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 4781: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_465166__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_465166__(8431);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind || (exports1.FileOperationPatternKind = FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest || (exports1.WillCreateFilesRequest = WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification || (exports1.DidCreateFilesNotification = DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest || (exports1.WillRenameFilesRequest = WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification || (exports1.DidRenameFilesNotification = DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 1203: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_471108__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRefreshRequest = exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_471108__(8431);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest || (exports1.FoldingRangeRequest = FoldingRangeRequest = {}));
                /**
 * @since 3.18.0
 * @proposed
 */ var FoldingRangeRefreshRequest;
                (function(FoldingRangeRefreshRequest) {
                    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;
                    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);
                })(FoldingRangeRefreshRequest || (exports1.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
            /***/ },
            /***/ 7287: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_473167__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_473167__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest || (exports1.ImplementationRequest = ImplementationRequest = {}));
            /***/ },
            /***/ 9383: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_474780__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_474780__(8431);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest || (exports1.InlayHintRequest = InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest || (exports1.InlayHintResolveRequest = InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 2322: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_477556__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineCompletionRequest = void 0;
                const messages_1 = __nested_webpack_require_477556__(8431);
                /**
 * A request to provide inline completions in a document. The request's parameter is of
 * type {@link InlineCompletionParams}, the response is of type
 * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.
 *
 * @since 3.18.0
 * @proposed
 */ var InlineCompletionRequest;
                (function(InlineCompletionRequest) {
                    InlineCompletionRequest.method = 'textDocument/inlineCompletion';
                    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);
                })(InlineCompletionRequest || (exports1.InlineCompletionRequest = InlineCompletionRequest = {}));
            /***/ },
            /***/ 3491: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_479087__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_479087__(8431);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest || (exports1.InlineValueRequest = InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 1815: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_481135__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRefreshRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangesFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.InlineCompletionRequest = exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_481135__(8431);
                const vscode_languageserver_types_1 = __nested_webpack_require_481135__(2852);
                const Is = __nested_webpack_require_481135__(8633);
                const protocol_implementation_1 = __nested_webpack_require_481135__(7287);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_481135__(9264);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_481135__(6860);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_481135__(7639);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_481135__(3747);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_481135__(1203);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "FoldingRangeRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRefreshRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_481135__(5581);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_481135__(1530);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_481135__(4166);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_481135__(7602);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_481135__(2067);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_481135__(4333);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_481135__(2249);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_481135__(4781);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_481135__(7684);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_481135__(7062);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_481135__(3491);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_481135__(9383);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_481135__(1494);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_481135__(4792);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                const protocol_inlineCompletion_1 = __nested_webpack_require_481135__(2322);
                Object.defineProperty(exports1, "InlineCompletionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineCompletion_1.InlineCompletionRequest;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate) || Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter || (exports1.TextDocumentFilter = TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter || (exports1.NotebookDocumentFilter = NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector || (exports1.DocumentSelector = DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest || (exports1.RegistrationRequest = RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest || (exports1.UnregistrationRequest = UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind || (exports1.ResourceOperationKind = ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind || (exports1.FailureHandlingKind = FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind || (exports1.PositionEncodingKind = PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions || (exports1.StaticRegistrationOptions = StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest || (exports1.InitializeRequest = InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes || (exports1.InitializeErrorCodes = InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification || (exports1.InitializedNotification = InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest || (exports1.ShutdownRequest = ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification || (exports1.ExitNotification = ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                    /**
     * A debug message.
     *
     * @since 3.18.0
     */ MessageType.Debug = 5;
                })(MessageType || (exports1.MessageType = MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification || (exports1.ShowMessageNotification = ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest || (exports1.ShowMessageRequest = ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification || (exports1.LogMessageNotification = LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification || (exports1.TelemetryEventNotification = TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind || (exports1.TextDocumentSyncKind = TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason || (exports1.TextDocumentSaveReason = TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType || (exports1.FileChangeType = FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern || (exports1.RelativePattern = RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind || (exports1.WatchKind = WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind || (exports1.CompletionTriggerKind = CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest || (exports1.CompletionRequest = CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest || (exports1.CompletionResolveRequest = CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest || (exports1.HoverRequest = HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest || (exports1.SignatureHelpRequest = SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPosition}
 * the response is of either type {@link Definition} or a typed array of
 * {@link DefinitionLink} or a Thenable that resolves to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest || (exports1.DefinitionRequest = DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest || (exports1.ReferencesRequest = ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type {@link TextDocumentPosition}
 * the request response is an array of type {@link DocumentHighlight}
 * or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest || (exports1.DocumentHighlightRequest = DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest || (exports1.DocumentSymbolRequest = DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest || (exports1.CodeActionRequest = CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest || (exports1.CodeActionResolveRequest = CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest || (exports1.CodeLensRequest = CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest || (exports1.CodeLensResolveRequest = CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest || (exports1.DocumentLinkRequest = DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
                /**
 * A request to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest || (exports1.DocumentFormattingRequest = DocumentFormattingRequest = {}));
                /**
 * A request to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
                /**
 * A request to format ranges in a document.
 *
 * @since 3.18.0
 * @proposed
 */ var DocumentRangesFormattingRequest;
                (function(DocumentRangesFormattingRequest) {
                    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';
                    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);
                })(DocumentRangesFormattingRequest || (exports1.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest || (exports1.RenameRequest = RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest || (exports1.PrepareRenameRequest = PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest || (exports1.ExecuteCommandRequest = ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 2249: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_551190__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_551190__(8431);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 7684: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_552554__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_552554__(8431);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel || (exports1.UniquenessLevel = UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind || (exports1.MonikerKind = MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest || (exports1.MonikerRequest = MonikerRequest = {}));
            /***/ },
            /***/ 4792: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_555561__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_555561__(2852);
                const Is = __nested_webpack_require_555561__(8633);
                const messages_1 = __nested_webpack_require_555561__(8431);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind || (exports1.NotebookCellKind = NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary || (exports1.ExecutionSummary = ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell || (exports1.NotebookCell = NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument || (exports1.NotebookDocument = NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange || (exports1.NotebookCellArrayChange = NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 4166: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_569048__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_569048__(9110);
                const messages_1 = __nested_webpack_require_569048__(8431);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress || (exports1.WorkDoneProgress = WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 1530: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_571862__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_571862__(8431);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest || (exports1.SelectionRangeRequest = SelectionRangeRequest = {}));
            /***/ },
            /***/ 2067: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_573333__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_573333__(8431);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat || (exports1.TokenFormat = TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest || (exports1.SemanticTokensRequest = SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 4333: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_577590__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_577590__(8431);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest || (exports1.ShowDocumentRequest = ShowDocumentRequest = {}));
            /***/ },
            /***/ 9264: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_579059__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_579059__(8431);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type {@link TextDocumentPositionParams}
 * the response is of type {@link Definition} or a Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest || (exports1.TypeDefinitionRequest = TypeDefinitionRequest = {}));
            /***/ },
            /***/ 7062: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_580672__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_580672__(8431);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 6860: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_583579__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_583579__(8431);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 8633: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 4879: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_588453__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_588453__(8927);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_588453__(8969);
                __exportStar(__nested_webpack_require_588453__(8969), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8927: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_592868__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_592868__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_592868__(8969);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 8969: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_601247__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_601247__(4313);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_601247__(6176);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_601247__(7963);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_601247__(6780);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_601247__(3106);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_601247__(6492);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_601247__(9813);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_601247__(7745);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_601247__(2180);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_601247__(4630);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_601247__(4254);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 3106: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_619312__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_619312__(4254);
                const Is = __nested_webpack_require_619312__(6145);
                const events_1 = __nested_webpack_require_619312__(6780);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken || (exports1.CancellationToken = CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 4630: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_624237__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_624237__(4254);
                const Is = __nested_webpack_require_624237__(6145);
                const messages_1 = __nested_webpack_require_624237__(4313);
                const linkedMap_1 = __nested_webpack_require_624237__(6176);
                const events_1 = __nested_webpack_require_624237__(6780);
                const cancellation_1 = __nested_webpack_require_624237__(3106);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken || (exports1.ProgressToken = ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues || (exports1.TraceValues = TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace || (exports1.Trace = Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat || (exports1.TraceFormat = TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification || (exports1.SetTraceNotification = SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification || (exports1.LogTraceNotification = LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors || (exports1.ConnectionErrors = ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy || (exports1.ConnectionStrategy = ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy || (exports1.CancellationSenderStrategy = CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy || (exports1.CancellationStrategy = CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy || (exports1.MessageStrategy = MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions || (exports1.ConnectionOptions = ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    responsePromises.set(id, responsePromise);
                                    await messageWriter.write(requestMessage);
                                } catch (error) {
                                    // Writing the message failed. So we need to delete it from the response promises and
                                    // reject it.
                                    responsePromises.delete(id);
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    logger.error(`Sending request failed.`);
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 7963: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable || (exports1.Disposable = Disposable = {}));
            /***/ },
            /***/ 6780: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_695303__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_695303__(4254);
                var Event1;
                (function(Event1) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event1.None = function() {
                        return _disposable;
                    };
                })(Event1 || (exports1.Event = Event1 = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 6145: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 6176: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch || (exports1.Touch = Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 2180: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error(`Message header must separate key and value using ':'\n${header}`);
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 9813: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_730996__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_730996__(4254);
                const Is = __nested_webpack_require_730996__(6145);
                const events_1 = __nested_webpack_require_730996__(6780);
                const semaphore_1 = __nested_webpack_require_730996__(9931);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader || (exports1.MessageReader = MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        try {
                            this.buffer.append(data);
                            while(true){
                                if (this.nextMessageLength === -1) {
                                    const headers = this.buffer.tryReadHeaders(true);
                                    if (!headers) {
                                        return;
                                    }
                                    const contentLength = headers.get('content-length');
                                    if (!contentLength) {
                                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
                                        return;
                                    }
                                    const length = parseInt(contentLength);
                                    if (isNaN(length)) {
                                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                                        return;
                                    }
                                    this.nextMessageLength = length;
                                }
                                const body = this.buffer.tryReadBody(this.nextMessageLength);
                                if (body === undefined) {
                                    /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                    return;
                                }
                                this.clearPartialMessageTimer();
                                this.nextMessageLength = -1;
                                // Make sure that we convert one received message after the
                                // other. Otherwise it could happen that a decoding of a second
                                // smaller message finished before the decoding of a first larger
                                // message and then we would deliver the second message first.
                                this.readSemaphore.lock(async ()=>{
                                    const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                    this.callback(message);
                                }).catch((error)=>{
                                    this.fireError(error);
                                });
                            }
                        } catch (error) {
                            this.fireError(error);
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 7745: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_742619__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_742619__(4254);
                const Is = __nested_webpack_require_742619__(6145);
                const semaphore_1 = __nested_webpack_require_742619__(9931);
                const events_1 = __nested_webpack_require_742619__(6780);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter || (exports1.MessageWriter = MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 4313: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_749496__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_749496__(6145);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes || (exports1.ErrorCodes = ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message || (exports1.Message = Message = {}));
            /***/ },
            /***/ 4254: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 9931: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_764986__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_764986__(4254);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 6492: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_768429__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_768429__(3106);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 2730: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_772326__)=>{
                "use strict";
                var forEach = __nested_webpack_require_772326__(705);
                var availableTypedArrays = __nested_webpack_require_772326__(4834);
                var callBind = __nested_webpack_require_772326__(8498);
                var callBound = __nested_webpack_require_772326__(9818);
                var gOPD = __nested_webpack_require_772326__(9336);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_772326__(1913)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_772326__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 4834: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_776573__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_776573__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ },
            /***/ 8041: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_777687__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_777687__.d(__nested_webpack_exports__, {
                    /* harmony export */ V: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            const start = this.offsetAt(range.start);
                            const end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(changes, version) {
                        for (const change of changes){
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                const range = getWellformedRange(change.range);
                                // update content
                                const startOffset = this.offsetAt(range.start);
                                const endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                const startLine = Math.max(range.start.line, 0);
                                const endLine = Math.max(range.end.line, 0);
                                let lineOffsets = this._lineOffsets;
                                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(let i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                const diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        const lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            const mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        const line = low - 1;
                        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
                        return {
                            line,
                            character: offset - lineOffsets[line]
                        };
                    }
                    offsetAt(position) {
                        const lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        const lineOffset = lineOffsets[position.line];
                        if (position.character <= 0) {
                            return lineOffset;
                        }
                        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        const offset = Math.min(lineOffset + position.character, nextLineOffset);
                        return this.ensureBeforeEOL(offset, lineOffset);
                    }
                    ensureBeforeEOL(offset, lineOffset) {
                        while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))){
                            offset--;
                        }
                        return offset;
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    static isIncremental(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    static isFull(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        const text = document1.getText();
                        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b)=>{
                            const diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = 0;
                        const spans = [];
                        for (const e of sortedEdits){
                            const startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    const p = data.length / 2 | 0;
                    const left = data.slice(0, p);
                    const right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    let leftIdx = 0;
                    let rightIdx = 0;
                    let i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        const ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
                    const result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(let i = 0; i < text.length; i++){
                        const ch = text.charCodeAt(i);
                        if (isEOL(ch)) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function isEOL(char) {
                    return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;
                }
                function getWellformedRange(range) {
                    const start = range.start;
                    const end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    const range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range
                        };
                    }
                    return textEdit;
                }
            /***/ },
            /***/ 2852: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_792053__)=>{
                "use strict";
                __nested_webpack_require_792053__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_792053__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineCompletionContext: ()=>/* binding */ InlineCompletionContext,
                    /* harmony export */ InlineCompletionItem: ()=>/* binding */ InlineCompletionItem,
                    /* harmony export */ InlineCompletionList: ()=>/* binding */ InlineCompletionList,
                    /* harmony export */ InlineCompletionTriggerKind: ()=>/* binding */ InlineCompletionTriggerKind,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectedCompletionInfo: ()=>/* binding */ SelectedCompletionInfo,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ StringValue: ()=>/* binding */ StringValue,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI1,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI1;
                (function(URI1) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI1.is = is;
                })(URI1 || (URI1 = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line,
                            character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri,
                            range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri,
                            targetRange,
                            targetSelectionRange,
                            originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red,
                            green,
                            blue,
                            alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range,
                            color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label,
                            textEdit,
                            additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        const result = {
                            startLine,
                            endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location,
                            message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        let result = {
                            range,
                            message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command, ...args) {
                        let result = {
                            title,
                            command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range,
                            newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        const result = {
                            label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range,
                            newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        const candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument,
                            edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        let result = {
                            kind: 'create',
                            uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        let result = {
                            kind: 'rename',
                            oldUri,
                            newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        let result = {
                            kind: 'delete',
                            uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        let candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every((change)=>{
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                class TextEditChangeImpl {
                    insert(position, newText, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    replace(range, newText, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    delete(range, annotation) {
                        let edit;
                        let id;
                        if (annotation === undefined) {
                            edit = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    add(edit) {
                        this.edits.push(edit);
                    }
                    all() {
                        return this.edits;
                    }
                    clear() {
                        this.edits.splice(0, this.edits.length);
                    }
                    assertChangeAnnotations(value) {
                        if (value === undefined) {
                            throw new Error(`Text edit change is not configured to manage change annotations.`);
                        }
                    }
                    constructor(edits, changeAnnotations){
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                }
                /**
 * A helper class
 */ class ChangeAnnotations {
                    all() {
                        return this._annotations;
                    }
                    get size() {
                        return this._size;
                    }
                    manage(idOrAnnotation, annotation) {
                        let id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error(`Id ${id} is already in use.`);
                        }
                        if (annotation === undefined) {
                            throw new Error(`No annotation provided for id ${id}`);
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    }
                    nextId() {
                        this._counter++;
                        return this._counter.toString();
                    }
                    constructor(annotations){
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                }
                /**
 * A workspace change helps constructing changes to a workspace.
 */ class WorkspaceChange {
                    /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */ get edit() {
                        this.initDocumentChanges();
                        if (this._changeAnnotations !== undefined) {
                            if (this._changeAnnotations.size === 0) {
                                this._workspaceEdit.changeAnnotations = undefined;
                            } else {
                                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                            }
                        }
                        return this._workspaceEdit;
                    }
                    getTextEditChange(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            const textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            let result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                const edits = [];
                                const textDocumentEdit = {
                                    textDocument,
                                    edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            let result = this._textEditChanges[key];
                            if (!result) {
                                let edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    }
                    initDocumentChanges() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    }
                    initChanges() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    }
                    createFile(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    renameFile(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    deleteFile(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        let annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        let operation;
                        let id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    }
                    constructor(workspaceEdit){
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach((change)=>{
                                    if (TextDocumentEdit.is(change)) {
                                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                                        this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach((key)=>{
                                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                }
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri,
                            version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri,
                            version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri,
                            languageId,
                            version,
                            text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        const candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent;
                (function(MarkupContent) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent.is = is;
                })(MarkupContent || (MarkupContent = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind;
                (function(CompletionItemKind) {
                    CompletionItemKind.Text = 1;
                    CompletionItemKind.Method = 2;
                    CompletionItemKind.Function = 3;
                    CompletionItemKind.Constructor = 4;
                    CompletionItemKind.Field = 5;
                    CompletionItemKind.Variable = 6;
                    CompletionItemKind.Class = 7;
                    CompletionItemKind.Interface = 8;
                    CompletionItemKind.Module = 9;
                    CompletionItemKind.Property = 10;
                    CompletionItemKind.Unit = 11;
                    CompletionItemKind.Value = 12;
                    CompletionItemKind.Enum = 13;
                    CompletionItemKind.Keyword = 14;
                    CompletionItemKind.Snippet = 15;
                    CompletionItemKind.Color = 16;
                    CompletionItemKind.File = 17;
                    CompletionItemKind.Reference = 18;
                    CompletionItemKind.Folder = 19;
                    CompletionItemKind.EnumMember = 20;
                    CompletionItemKind.Constant = 21;
                    CompletionItemKind.Struct = 22;
                    CompletionItemKind.Event = 23;
                    CompletionItemKind.Operator = 24;
                    CompletionItemKind.TypeParameter = 25;
                })(CompletionItemKind || (CompletionItemKind = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat;
                (function(InsertTextFormat) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat.Snippet = 2;
                })(InsertTextFormat || (InsertTextFormat = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText,
                            insert,
                            replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString;
                (function(MarkedString) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        const candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString.is = is;
                })(MarkedString || (MarkedString = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        let candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label,
                            documentation
                        } : {
                            label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation, ...parameters) {
                        let result = {
                            label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        let result = {
                            range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        let result = {
                            name,
                            kind,
                            location: {
                                uri,
                                range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name,
                            kind,
                            location: {
                                uri,
                                range
                            }
                        } : {
                            name,
                            kind,
                            location: {
                                uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        let result = {
                            name,
                            detail,
                            kind,
                            range,
                            selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        let candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        let result = {
                            diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        let result = {
                            title
                        };
                        let checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        let result = {
                            range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize,
                            insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range,
                            target,
                            data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range,
                            parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        let candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range,
                            text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range,
                            variableName,
                            caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range,
                            expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        const candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId,
                            stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        const candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        const result = {
                            position,
                            label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var StringValue;
                (function(StringValue) {
                    function createSnippet(value) {
                        return {
                            kind: 'snippet',
                            value
                        };
                    }
                    StringValue.createSnippet = createSnippet;
                })(StringValue || (StringValue = {}));
                var InlineCompletionItem;
                (function(InlineCompletionItem) {
                    function create(insertText, filterText, range, command) {
                        return {
                            insertText,
                            filterText,
                            range,
                            command
                        };
                    }
                    InlineCompletionItem.create = create;
                })(InlineCompletionItem || (InlineCompletionItem = {}));
                var InlineCompletionList;
                (function(InlineCompletionList) {
                    function create(items) {
                        return {
                            items
                        };
                    }
                    InlineCompletionList.create = create;
                })(InlineCompletionList || (InlineCompletionList = {}));
                /**
 * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
 *
 * @since 3.18.0
 * @proposed
 */ var InlineCompletionTriggerKind;
                (function(InlineCompletionTriggerKind) {
                    /**
     * Completion was triggered explicitly by a user gesture.
     */ InlineCompletionTriggerKind.Invoked = 0;
                    /**
     * Completion was triggered automatically while editing.
     */ InlineCompletionTriggerKind.Automatic = 1;
                })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
                var SelectedCompletionInfo;
                (function(SelectedCompletionInfo) {
                    function create(range, text) {
                        return {
                            range,
                            text
                        };
                    }
                    SelectedCompletionInfo.create = create;
                })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
                var InlineCompletionContext;
                (function(InlineCompletionContext) {
                    function create(triggerKind, selectedCompletionInfo) {
                        return {
                            triggerKind,
                            selectedCompletionInfo
                        };
                    }
                    InlineCompletionContext.create = create;
                })(InlineCompletionContext || (InlineCompletionContext = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && URI1.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                const EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        let candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        let text = document1.getText();
                        let sortedEdits = mergeSort(edits, (a, b)=>{
                            let diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = text.length;
                        for(let i = sortedEdits.length - 1; i >= 0; i--){
                            let e = sortedEdits[i];
                            let startOffset = document1.offsetAt(e.range.start);
                            let endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        const p = data.length / 2 | 0;
                        const left = data.slice(0, p);
                        const right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        let leftIdx = 0;
                        let rightIdx = 0;
                        let i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            let ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            let start = this.offsetAt(range.start);
                            let end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            let lineOffsets = [];
                            let text = this._content;
                            let isLineStart = true;
                            for(let i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                let ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        let lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            let mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        let line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    }
                    offsetAt(position) {
                        let lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        let lineOffset = lineOffsets[position.line];
                        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var Is;
                (function(Is) {
                    const toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_902995__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_902995__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __nested_webpack_require_902995__.n = (module1)=>{
                /******/ var getter = module1 && module1.__esModule ? /******/ ()=>module1['default'] : /******/ ()=>module1;
                /******/ __nested_webpack_require_902995__.d(getter, {
                    a: getter
                });
                /******/ return getter;
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_902995__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_902995__.o(definition, key) && !__nested_webpack_require_902995__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_902995__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_902995__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_902995__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_902995__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_902995__.d(__nested_webpack_exports__, {
                LanguageClient: ()=>/* binding */ LanguageClient
            });
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messageReader.js
            var messageReader = __nested_webpack_require_902995__(9813);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/reader.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2024 TypeFox and others.
 * Licensed under the MIT License. See LICENSE in the package root for license information.
 * ------------------------------------------------------------------------------------------ */ class WebSocketMessageReader extends messageReader.AbstractMessageReader {
                listen(callback) {
                    if (this.state === 'initial') {
                        this.state = 'listening';
                        this.callback = callback;
                        while(this.events.length !== 0){
                            const event = this.events.pop();
                            if (event.message !== undefined) {
                                this.readMessage(event.message);
                            } else if (event.error !== undefined) {
                                this.fireError(event.error);
                            } else {
                                this.fireClose();
                            }
                        }
                    }
                    return {
                        dispose: ()=>{
                            if (this.callback === callback) {
                                this.state = 'initial';
                                this.callback = undefined;
                            }
                        }
                    };
                }
                dispose() {
                    super.dispose();
                    this.state = 'initial';
                    this.callback = undefined;
                    this.events.splice(0, this.events.length);
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                readMessage(message) {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {
                            message
                        });
                    } else if (this.state === 'listening') {
                        try {
                            const data = JSON.parse(message);
                            this.callback(data);
                        } catch (err) {
                            const error = {
                                name: '' + 400,
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                message: `Error during message parsing, reason = ${typeof err === 'object' ? err.message : 'unknown'}`
                            };
                            this.fireError(error);
                        }
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                fireError(error) {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {
                            error
                        });
                    } else if (this.state === 'listening') {
                        super.fireError(error);
                    }
                }
                fireClose() {
                    if (this.state === 'initial') {
                        this.events.splice(0, 0, {});
                    } else if (this.state === 'listening') {
                        super.fireClose();
                    }
                    this.state = 'closed';
                }
                constructor(socket){
                    super();
                    _define_property(this, "socket", void 0);
                    _define_property(this, "state", 'initial');
                    _define_property(this, "callback", void 0);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    _define_property(this, "events", []);
                    this.socket = socket;
                    this.socket.onMessage((message)=>this.readMessage(message));
                    this.socket.onError((error)=>this.fireError(error));
                    this.socket.onClose((code, reason)=>{
                        if (code !== 1000) {
                            const error = {
                                name: '' + code,
                                message: `Error during socket reconnect: code = ${code}, reason = ${reason}`
                            };
                            this.fireError(error);
                        }
                        this.fireClose();
                    });
                }
            }
            //# sourceMappingURL=reader.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
            var messageWriter = __nested_webpack_require_902995__(7745);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/writer.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2024 TypeFox and others.
 * Licensed under the MIT License. See LICENSE in the package root for license information.
 * ------------------------------------------------------------------------------------------ */ class WebSocketMessageWriter extends messageWriter.AbstractMessageWriter {
                end() {}
                async write(msg) {
                    try {
                        const content = JSON.stringify(msg);
                        this.socket.send(content);
                    } catch (e) {
                        this.errorCount++;
                        this.fireError(e, msg, this.errorCount);
                    }
                }
                constructor(socket){
                    super();
                    _define_property(this, "errorCount", 0);
                    _define_property(this, "socket", void 0);
                    this.socket = socket;
                }
            }
            //# sourceMappingURL=writer.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-ws-jsonrpc/node_modules/vscode-jsonrpc/lib/browser/main.js
            var main = __nested_webpack_require_902995__(4879);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/connection.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2024 TypeFox and others.
 * Licensed under the MIT License. See LICENSE in the package root for license information.
 * ------------------------------------------------------------------------------------------ */ function createWebSocketConnection(socket, logger) {
                const messageReader = new WebSocketMessageReader(socket);
                const messageWriter = new WebSocketMessageWriter(socket);
                const connection = (0, main.createMessageConnection)(messageReader, messageWriter, logger);
                connection.onClose(()=>connection.dispose());
                return connection;
            }
            //# sourceMappingURL=connection.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/socket/index.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2024 TypeFox and others.
 * Licensed under the MIT License. See LICENSE in the package root for license information.
 * ------------------------------------------------------------------------------------------ */ //# sourceMappingURL=index.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/logger.js
            /* provided dependency */ var console = __nested_webpack_require_902995__(4364);
            class ConsoleLogger {
                error(message) {
                    console.error(message);
                }
                warn(message) {
                    console.warn(message);
                }
                info(message) {
                    console.info(message);
                }
                log(message) {
                    console.log(message);
                }
                debug(message) {
                    console.debug(message);
                }
            }
            //# sourceMappingURL=logger.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/connection.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2024 TypeFox and others.
 * Licensed under the MIT License. See LICENSE in the package root for license information.
 * ------------------------------------------------------------------------------------------ */ function listen(options) {
                const { webSocket, onConnection } = options;
                const logger = options.logger || new ConsoleLogger();
                webSocket.onopen = ()=>{
                    const socket = toSocket(webSocket);
                    const connection = createWebSocketConnection(socket, logger);
                    onConnection(connection);
                };
            }
            function toSocket(webSocket) {
                return {
                    send: (content)=>webSocket.send(content),
                    onMessage: (cb)=>{
                        webSocket.onmessage = (event)=>cb(event.data);
                    },
                    onError: (cb)=>{
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        webSocket.onerror = (event)=>{
                            if (Object.hasOwn(event, 'message')) {
                                cb(event.message);
                            }
                        };
                    },
                    onClose: (cb)=>{
                        webSocket.onclose = (event)=>cb(event.code, event.reason);
                    },
                    dispose: ()=>webSocket.close()
                };
            }
            //# sourceMappingURL=connection.js.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-ws-jsonrpc/lib/index.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) 2024 TypeFox and others.
 * Licensed under the MIT License. See LICENSE in the package root for license information.
 * ------------------------------------------------------------------------------------------ */ //# sourceMappingURL=index.js.map
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var browser_main = __nested_webpack_require_902995__(5501);
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/browser.js
            var browser = __nested_webpack_require_902995__(8713);
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_902995__(2125);
            ; // CONCATENATED MODULE: ./src/message-types.ts
            function _define_property1(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class BaseMessage {
                constructor(documentIdentifier, callbackId){
                    _define_property1(this, "sessionId", void 0);
                    _define_property1(this, "documentUri", void 0);
                    _define_property1(this, "version", void 0);
                    _define_property1(this, "callbackId", void 0);
                    this.sessionId = documentIdentifier.sessionId;
                    this.documentUri = documentIdentifier.documentUri;
                    this.callbackId = callbackId;
                }
            }
            class InitMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version, mode, options){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.init);
                    _define_property1(this, "mode", void 0);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.version = version;
                    this.options = options;
                    this.mode = mode;
                    this.value = value;
                }
            }
            class FormatMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, format){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.format);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "format", void 0);
                    this.value = value;
                    this.format = format;
                }
            }
            class CompleteMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.complete);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class InlineCompleteMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.inlineComplete);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ResolveCompletionMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.resolveCompletion);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class HoverMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.hover);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ValidateMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.validate);
                }
            }
            class ChangeMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.change);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.version = version;
                }
            }
            class DeltasMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.applyDelta);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.version = version;
                }
            }
            class ChangeModeMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version, mode){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.changeMode);
                    _define_property1(this, "mode", void 0);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.mode = mode;
                    this.version = version;
                }
            }
            class ChangeOptionsMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, options, merge = false){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.changeOptions);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "merge", void 0);
                    this.options = options;
                    this.merge = merge;
                }
            }
            class CloseDocumentMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.closeDocument);
                }
            }
            class CloseConnectionMessage {
                constructor(callbackId){
                    _define_property1(this, "type", MessageType.closeConnection);
                    _define_property1(this, "callbackId", void 0);
                    this.callbackId = callbackId;
                }
            }
            class GlobalOptionsMessage {
                constructor(serviceName, options, merge){
                    _define_property1(this, "type", MessageType.globalOptions);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "options", void 0);
                    _define_property1(this, "merge", void 0);
                    this.serviceName = serviceName;
                    this.options = options;
                    this.merge = merge;
                }
            }
            class ConfigureFeaturesMessage {
                constructor(serviceName, options){
                    _define_property1(this, "type", MessageType.configureFeatures);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "options", void 0);
                    this.serviceName = serviceName;
                    this.options = options;
                }
            }
            class SignatureHelpMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.signatureHelp);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class DocumentHighlightMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.documentHighlight);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class GetSemanticTokensMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.getSemanticTokens);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class GetCodeActionsMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, context){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.getCodeActions);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "context", void 0);
                    this.value = value;
                    this.context = context;
                }
            }
            class SetWorkspaceMessage {
                constructor(value){
                    _define_property1(this, "type", MessageType.setWorkspace);
                    _define_property1(this, "value", void 0);
                    this.value = value;
                }
            }
            class ExecuteCommandMessage {
                constructor(serviceName, callbackId, command, args){
                    _define_property1(this, "callbackId", void 0);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "type", MessageType.executeCommand);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "args", void 0);
                    this.serviceName = serviceName;
                    this.callbackId = callbackId;
                    this.value = command;
                    this.args = args;
                }
            }
            class AppliedEditMessage {
                constructor(value, serviceName, callbackId){
                    _define_property1(this, "callbackId", void 0);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "type", MessageType.appliedEdit);
                    _define_property1(this, "value", void 0);
                    this.serviceName = serviceName;
                    this.callbackId = callbackId;
                    this.value = value;
                }
            }
            class RenameDocumentMessage extends BaseMessage {
                constructor(documentIdentifier, callbackId, value, version){
                    super(documentIdentifier, callbackId);
                    _define_property1(this, "type", MessageType.renameDocument);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "version", void 0);
                    this.value = value;
                    this.version = version;
                }
            }
            class SendRequestMessage {
                constructor(serviceName, callbackId, requestName, args){
                    _define_property1(this, "callbackId", void 0);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "type", MessageType.sendRequest);
                    _define_property1(this, "value", void 0);
                    _define_property1(this, "args", void 0);
                    this.serviceName = serviceName;
                    this.callbackId = callbackId;
                    this.value = requestName;
                    this.args = args;
                }
            }
            class SendResponseMessage {
                constructor(serviceName, callbackId, args){
                    _define_property1(this, "callbackId", void 0);
                    _define_property1(this, "serviceName", void 0);
                    _define_property1(this, "type", MessageType.sendResponse);
                    _define_property1(this, "args", void 0);
                    this.serviceName = serviceName;
                    this.callbackId = callbackId;
                    this.args = args;
                }
            }
            var MessageType;
            (function(MessageType) {
                MessageType[MessageType["init"] = 0] = "init";
                MessageType[MessageType["format"] = 1] = "format";
                MessageType[MessageType["complete"] = 2] = "complete";
                MessageType[MessageType["resolveCompletion"] = 3] = "resolveCompletion";
                MessageType[MessageType["change"] = 4] = "change";
                MessageType[MessageType["hover"] = 5] = "hover";
                MessageType[MessageType["validate"] = 6] = "validate";
                MessageType[MessageType["applyDelta"] = 7] = "applyDelta";
                MessageType[MessageType["changeMode"] = 8] = "changeMode";
                MessageType[MessageType["changeOptions"] = 9] = "changeOptions";
                MessageType[MessageType["closeDocument"] = 10] = "closeDocument";
                MessageType[MessageType["globalOptions"] = 11] = "globalOptions";
                MessageType[MessageType["configureFeatures"] = 12] = "configureFeatures";
                MessageType[MessageType["signatureHelp"] = 13] = "signatureHelp";
                MessageType[MessageType["documentHighlight"] = 14] = "documentHighlight";
                MessageType[MessageType["closeConnection"] = 15] = "closeConnection";
                MessageType[MessageType["capabilitiesChange"] = 16] = "capabilitiesChange";
                MessageType[MessageType["getSemanticTokens"] = 17] = "getSemanticTokens";
                MessageType[MessageType["getCodeActions"] = 18] = "getCodeActions";
                MessageType[MessageType["executeCommand"] = 19] = "executeCommand";
                MessageType[MessageType["applyEdit"] = 20] = "applyEdit";
                MessageType[MessageType["appliedEdit"] = 21] = "appliedEdit";
                MessageType[MessageType["setWorkspace"] = 22] = "setWorkspace";
                MessageType[MessageType["renameDocument"] = 23] = "renameDocument";
                MessageType[MessageType["sendRequest"] = 24] = "sendRequest";
                MessageType[MessageType["showDocument"] = 25] = "showDocument";
                MessageType[MessageType["sendResponse"] = 26] = "sendResponse";
                MessageType[MessageType["inlineComplete"] = 27] = "inlineComplete";
            })(MessageType || (MessageType = {}));
            ; // CONCATENATED MODULE: ../../node_modules/vscode-uri/lib/esm/index.mjs
            /* provided dependency */ var process = __nested_webpack_require_902995__(9907);
            var LIB;
            (()=>{
                "use strict";
                var t = {
                    975: (t)=>{
                        function e(t) {
                            if ("string" != typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
                        }
                        function r(t, e) {
                            for(var r, n = "", i = 0, o = -1, s = 0, h = 0; h <= t.length; ++h){
                                if (h < t.length) r = t.charCodeAt(h);
                                else {
                                    if (47 === r) break;
                                    r = 47;
                                }
                                if (47 === r) {
                                    if (o === h - 1 || 1 === s) ;
                                    else if (o !== h - 1 && 2 === s) {
                                        if (n.length < 2 || 2 !== i || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2)) {
                                            if (n.length > 2) {
                                                var a = n.lastIndexOf("/");
                                                if (a !== n.length - 1) {
                                                    -1 === a ? (n = "", i = 0) : i = (n = n.slice(0, a)).length - 1 - n.lastIndexOf("/"), o = h, s = 0;
                                                    continue;
                                                }
                                            } else if (2 === n.length || 1 === n.length) {
                                                n = "", i = 0, o = h, s = 0;
                                                continue;
                                            }
                                        }
                                        e && (n.length > 0 ? n += "/.." : n = "..", i = 2);
                                    } else n.length > 0 ? n += "/" + t.slice(o + 1, h) : n = t.slice(o + 1, h), i = h - o - 1;
                                    o = h, s = 0;
                                } else 46 === r && -1 !== s ? ++s : s = -1;
                            }
                            return n;
                        }
                        var n = {
                            resolve: function() {
                                for(var t, n = "", i = !1, o = arguments.length - 1; o >= -1 && !i; o--){
                                    var s;
                                    o >= 0 ? s = arguments[o] : (void 0 === t && (t = process.cwd()), s = t), e(s), 0 !== s.length && (n = s + "/" + n, i = 47 === s.charCodeAt(0));
                                }
                                return n = r(n, !i), i ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
                            },
                            normalize: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                var n = 47 === t.charCodeAt(0), i = 47 === t.charCodeAt(t.length - 1);
                                return 0 !== (t = r(t, !n)).length || n || (t = "."), t.length > 0 && i && (t += "/"), n ? "/" + t : t;
                            },
                            isAbsolute: function(t) {
                                return e(t), t.length > 0 && 47 === t.charCodeAt(0);
                            },
                            join: function() {
                                if (0 === arguments.length) return ".";
                                for(var t, r = 0; r < arguments.length; ++r){
                                    var i = arguments[r];
                                    e(i), i.length > 0 && (void 0 === t ? t = i : t += "/" + i);
                                }
                                return void 0 === t ? "." : n.normalize(t);
                            },
                            relative: function(t, r) {
                                if (e(t), e(r), t === r) return "";
                                if ((t = n.resolve(t)) === (r = n.resolve(r))) return "";
                                for(var i = 1; i < t.length && 47 === t.charCodeAt(i); ++i);
                                for(var o = t.length, s = o - i, h = 1; h < r.length && 47 === r.charCodeAt(h); ++h);
                                for(var a = r.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u){
                                    if (u === c) {
                                        if (a > c) {
                                            if (47 === r.charCodeAt(h + u)) return r.slice(h + u + 1);
                                            if (0 === u) return r.slice(h + u);
                                        } else s > c && (47 === t.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
                                        break;
                                    }
                                    var l = t.charCodeAt(i + u);
                                    if (l !== r.charCodeAt(h + u)) break;
                                    47 === l && (f = u);
                                }
                                var g = "";
                                for(u = i + f + 1; u <= o; ++u)u !== o && 47 !== t.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
                                return g.length > 0 ? g + r.slice(h + f) : (h += f, 47 === r.charCodeAt(h) && ++h, r.slice(h));
                            },
                            _makeLong: function(t) {
                                return t;
                            },
                            dirname: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                for(var r = t.charCodeAt(0), n = 47 === r, i = -1, o = !0, s = t.length - 1; s >= 1; --s)if (47 === (r = t.charCodeAt(s))) {
                                    if (!o) {
                                        i = s;
                                        break;
                                    }
                                } else o = !1;
                                return -1 === i ? n ? "/" : "." : n && 1 === i ? "//" : t.slice(0, i);
                            },
                            basename: function(t, r) {
                                if (void 0 !== r && "string" != typeof r) throw new TypeError('"ext" argument must be a string');
                                e(t);
                                var n, i = 0, o = -1, s = !0;
                                if (void 0 !== r && r.length > 0 && r.length <= t.length) {
                                    if (r.length === t.length && r === t) return "";
                                    var h = r.length - 1, a = -1;
                                    for(n = t.length - 1; n >= 0; --n){
                                        var c = t.charCodeAt(n);
                                        if (47 === c) {
                                            if (!s) {
                                                i = n + 1;
                                                break;
                                            }
                                        } else -1 === a && (s = !1, a = n + 1), h >= 0 && (c === r.charCodeAt(h) ? -1 == --h && (o = n) : (h = -1, o = a));
                                    }
                                    return i === o ? o = a : -1 === o && (o = t.length), t.slice(i, o);
                                }
                                for(n = t.length - 1; n >= 0; --n)if (47 === t.charCodeAt(n)) {
                                    if (!s) {
                                        i = n + 1;
                                        break;
                                    }
                                } else -1 === o && (s = !1, o = n + 1);
                                return -1 === o ? "" : t.slice(i, o);
                            },
                            extname: function(t) {
                                e(t);
                                for(var r = -1, n = 0, i = -1, o = !0, s = 0, h = t.length - 1; h >= 0; --h){
                                    var a = t.charCodeAt(h);
                                    if (47 !== a) -1 === i && (o = !1, i = h + 1), 46 === a ? -1 === r ? r = h : 1 !== s && (s = 1) : -1 !== r && (s = -1);
                                    else if (!o) {
                                        n = h + 1;
                                        break;
                                    }
                                }
                                return -1 === r || -1 === i || 0 === s || 1 === s && r === i - 1 && r === n + 1 ? "" : t.slice(r, i);
                            },
                            format: function(t) {
                                if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
                                return function(t, e) {
                                    var r = e.dir || e.root, n = e.base || (e.name || "") + (e.ext || "");
                                    return r ? r === e.root ? r + n : r + "/" + n : n;
                                }(0, t);
                            },
                            parse: function(t) {
                                e(t);
                                var r = {
                                    root: "",
                                    dir: "",
                                    base: "",
                                    ext: "",
                                    name: ""
                                };
                                if (0 === t.length) return r;
                                var n, i = t.charCodeAt(0), o = 47 === i;
                                o ? (r.root = "/", n = 1) : n = 0;
                                for(var s = -1, h = 0, a = -1, c = !0, f = t.length - 1, u = 0; f >= n; --f)if (47 !== (i = t.charCodeAt(f))) -1 === a && (c = !1, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
                                else if (!c) {
                                    h = f + 1;
                                    break;
                                }
                                return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r.base = r.name = 0 === h && o ? t.slice(1, a) : t.slice(h, a)) : (0 === h && o ? (r.name = t.slice(1, s), r.base = t.slice(1, a)) : (r.name = t.slice(h, s), r.base = t.slice(h, a)), r.ext = t.slice(s, a)), h > 0 ? r.dir = t.slice(0, h - 1) : o && (r.dir = "/"), r;
                            },
                            sep: "/",
                            delimiter: ":",
                            win32: null,
                            posix: null
                        };
                        n.posix = n, t.exports = n;
                    }
                }, e = {};
                function r(n) {
                    var i = e[n];
                    if (void 0 !== i) return i.exports;
                    var o = e[n] = {
                        exports: {}
                    };
                    return t[n](o, o.exports, r), o.exports;
                }
                r.d = (t, e)=>{
                    for(var n in e)r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                        enumerable: !0,
                        get: e[n]
                    });
                }, r.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), r.r = (t)=>{
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                };
                var n = {};
                let i;
                if (r.r(n), r.d(n, {
                    URI: ()=>l,
                    Utils: ()=>I
                }), "object" == typeof process) i = "win32" === process.platform;
                else if ("object" == typeof navigator) {
                    let t = navigator.userAgent;
                    i = t.indexOf("Windows") >= 0;
                }
                const o = /^\w[\w\d+.-]*$/, s = /^\//, h = /^\/\//;
                function a(t, e) {
                    if (!t.scheme && e) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
                    if (t.scheme && !o.test(t.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                    if (t.path) {
                        if (t.authority) {
                            if (!s.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                        } else if (h.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                    }
                }
                const c = "", f = "/", u = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
                class l {
                    static isUri(t) {
                        return t instanceof l || !!t && "string" == typeof t.authority && "string" == typeof t.fragment && "string" == typeof t.path && "string" == typeof t.query && "string" == typeof t.scheme && "string" == typeof t.fsPath && "function" == typeof t.with && "function" == typeof t.toString;
                    }
                    get fsPath() {
                        return v(this, !1);
                    }
                    with(t) {
                        if (!t) return this;
                        let { scheme: e, authority: r, path: n, query: i, fragment: o } = t;
                        return void 0 === e ? e = this.scheme : null === e && (e = c), void 0 === r ? r = this.authority : null === r && (r = c), void 0 === n ? n = this.path : null === n && (n = c), void 0 === i ? i = this.query : null === i && (i = c), void 0 === o ? o = this.fragment : null === o && (o = c), e === this.scheme && r === this.authority && n === this.path && i === this.query && o === this.fragment ? this : new d(e, r, n, i, o);
                    }
                    static parse(t, e = !1) {
                        const r = u.exec(t);
                        return r ? new d(r[2] || c, w(r[4] || c), w(r[5] || c), w(r[7] || c), w(r[9] || c), e) : new d(c, c, c, c, c);
                    }
                    static file(t) {
                        let e = c;
                        if (i && (t = t.replace(/\\/g, f)), t[0] === f && t[1] === f) {
                            const r = t.indexOf(f, 2);
                            -1 === r ? (e = t.substring(2), t = f) : (e = t.substring(2, r), t = t.substring(r) || f);
                        }
                        return new d("file", e, t, c, c);
                    }
                    static from(t) {
                        const e = new d(t.scheme, t.authority, t.path, t.query, t.fragment);
                        return a(e, !0), e;
                    }
                    toString(t = !1) {
                        return b(this, t);
                    }
                    toJSON() {
                        return this;
                    }
                    static revive(t) {
                        if (t) {
                            if (t instanceof l) return t;
                            {
                                const e = new d(t);
                                return e._formatted = t.external, e._fsPath = t._sep === g ? t.fsPath : null, e;
                            }
                        }
                        return t;
                    }
                    constructor(t, e, r, n, i, o = !1){
                        _define_property(this, "scheme", void 0);
                        _define_property(this, "authority", void 0);
                        _define_property(this, "path", void 0);
                        _define_property(this, "query", void 0);
                        _define_property(this, "fragment", void 0);
                        "object" == typeof t ? (this.scheme = t.scheme || c, this.authority = t.authority || c, this.path = t.path || c, this.query = t.query || c, this.fragment = t.fragment || c) : (this.scheme = function(t, e) {
                            return t || e ? t : "file";
                        }(t, o), this.authority = e || c, this.path = function(t, e) {
                            switch(t){
                                case "https":
                                case "http":
                                case "file":
                                    e ? e[0] !== f && (e = f + e) : e = f;
                            }
                            return e;
                        }(this.scheme, r || c), this.query = n || c, this.fragment = i || c, a(this, o));
                    }
                }
                const g = i ? 1 : void 0;
                class d extends l {
                    get fsPath() {
                        return this._fsPath || (this._fsPath = v(this, !1)), this._fsPath;
                    }
                    toString(t = !1) {
                        return t ? b(this, !0) : (this._formatted || (this._formatted = b(this, !1)), this._formatted);
                    }
                    toJSON() {
                        const t = {
                            $mid: 1
                        };
                        return this._fsPath && (t.fsPath = this._fsPath, t._sep = g), this._formatted && (t.external = this._formatted), this.path && (t.path = this.path), this.scheme && (t.scheme = this.scheme), this.authority && (t.authority = this.authority), this.query && (t.query = this.query), this.fragment && (t.fragment = this.fragment), t;
                    }
                    constructor(...args){
                        super(...args);
                        _define_property(this, "_formatted", null);
                        _define_property(this, "_fsPath", null);
                    }
                }
                const p = {
                    58: "%3A",
                    47: "%2F",
                    63: "%3F",
                    35: "%23",
                    91: "%5B",
                    93: "%5D",
                    64: "%40",
                    33: "%21",
                    36: "%24",
                    38: "%26",
                    39: "%27",
                    40: "%28",
                    41: "%29",
                    42: "%2A",
                    43: "%2B",
                    44: "%2C",
                    59: "%3B",
                    61: "%3D",
                    32: "%20"
                };
                function m(t, e, r) {
                    let n, i = -1;
                    for(let o = 0; o < t.length; o++){
                        const s = t.charCodeAt(o);
                        if (s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 45 === s || 46 === s || 95 === s || 126 === s || e && 47 === s || r && 91 === s || r && 93 === s || r && 58 === s) -1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), void 0 !== n && (n += t.charAt(o));
                        else {
                            void 0 === n && (n = t.substr(0, o));
                            const e = p[s];
                            void 0 !== e ? (-1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), n += e) : -1 === i && (i = o);
                        }
                    }
                    return -1 !== i && (n += encodeURIComponent(t.substring(i))), void 0 !== n ? n : t;
                }
                function y(t) {
                    let e;
                    for(let r = 0; r < t.length; r++){
                        const n = t.charCodeAt(r);
                        35 === n || 63 === n ? (void 0 === e && (e = t.substr(0, r)), e += p[n]) : void 0 !== e && (e += t[r]);
                    }
                    return void 0 !== e ? e : t;
                }
                function v(t, e) {
                    let r;
                    return r = t.authority && t.path.length > 1 && "file" === t.scheme ? `//${t.authority}${t.path}` : 47 === t.path.charCodeAt(0) && (t.path.charCodeAt(1) >= 65 && t.path.charCodeAt(1) <= 90 || t.path.charCodeAt(1) >= 97 && t.path.charCodeAt(1) <= 122) && 58 === t.path.charCodeAt(2) ? e ? t.path.substr(1) : t.path[1].toLowerCase() + t.path.substr(2) : t.path, i && (r = r.replace(/\//g, "\\")), r;
                }
                function b(t, e) {
                    const r = e ? y : m;
                    let n = "", { scheme: i, authority: o, path: s, query: h, fragment: a } = t;
                    if (i && (n += i, n += ":"), (o || "file" === i) && (n += f, n += f), o) {
                        let t = o.indexOf("@");
                        if (-1 !== t) {
                            const e = o.substr(0, t);
                            o = o.substr(t + 1), t = e.lastIndexOf(":"), -1 === t ? n += r(e, !1, !1) : (n += r(e.substr(0, t), !1, !1), n += ":", n += r(e.substr(t + 1), !1, !0)), n += "@";
                        }
                        o = o.toLowerCase(), t = o.lastIndexOf(":"), -1 === t ? n += r(o, !1, !0) : (n += r(o.substr(0, t), !1, !0), n += o.substr(t));
                    }
                    if (s) {
                        if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2)) {
                            const t = s.charCodeAt(1);
                            t >= 65 && t <= 90 && (s = `/${String.fromCharCode(t + 32)}:${s.substr(3)}`);
                        } else if (s.length >= 2 && 58 === s.charCodeAt(1)) {
                            const t = s.charCodeAt(0);
                            t >= 65 && t <= 90 && (s = `${String.fromCharCode(t + 32)}:${s.substr(2)}`);
                        }
                        n += r(s, !0, !1);
                    }
                    return h && (n += "?", n += r(h, !1, !1)), a && (n += "#", n += e ? a : m(a, !1, !1)), n;
                }
                function C(t) {
                    try {
                        return decodeURIComponent(t);
                    } catch  {
                        return t.length > 3 ? t.substr(0, 3) + C(t.substr(3)) : t;
                    }
                }
                const A = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
                function w(t) {
                    return t.match(A) ? t.replace(A, (t)=>C(t)) : t;
                }
                var x = r(975);
                const P = x.posix || x, _ = "/";
                var I;
                !function(t) {
                    t.joinPath = function(t, ...e) {
                        return t.with({
                            path: P.join(t.path, ...e)
                        });
                    }, t.resolvePath = function(t, ...e) {
                        let r = t.path, n = !1;
                        r[0] !== _ && (r = _ + r, n = !0);
                        let i = P.resolve(r, ...e);
                        return n && i[0] === _ && !t.authority && (i = i.substring(1)), t.with({
                            path: i
                        });
                    }, t.dirname = function(t) {
                        if (0 === t.path.length || t.path === _) return t;
                        let e = P.dirname(t.path);
                        return 1 === e.length && 46 === e.charCodeAt(0) && (e = ""), t.with({
                            path: e
                        });
                    }, t.basename = function(t) {
                        return P.basename(t.path);
                    }, t.extname = function(t) {
                        return P.extname(t.path);
                    };
                }(I || (I = {})), LIB = n;
            })();
            const { URI: language_client_URI, Utils } = LIB;
            //# sourceMappingURL=index.mjs.map
            ; // CONCATENATED MODULE: ./src/services/language-client.ts
            /* provided dependency */ var language_client_console = __nested_webpack_require_902995__(4364);
            function language_client_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class LanguageClient extends base_service.BaseService {
                $connect() {
                    switch(this.serverData.type){
                        case "webworker":
                            if ('worker' in this.serverData) {
                                this.$connectWorker(this.serverData.worker, this.serverData.initializationOptions);
                            } else {
                                throw new Error("No worker provided");
                            }
                            break;
                        case "socket":
                            if ('socket' in this.serverData) {
                                this.socket = this.serverData.socket;
                                this.$connectSocket(this.serverData.initializationOptions);
                            } else {
                                throw new Error("No socketUrl provided");
                            }
                            break;
                        default:
                            throw new Error("Unknown server type: " + this.serverData.type);
                    }
                }
                $connectSocket(initializationOptions) {
                    listen({
                        webSocket: this.socket,
                        onConnection: (connection)=>{
                            this.$initConnection(connection, initializationOptions);
                        }
                    });
                    if (this.socket.readyState === WebSocket.OPEN) this.socket.dispatchEvent(new Event('open'));
                }
                $connectWorker(worker, initializationOptions) {
                    const connection = (0, browser.createProtocolConnection)(new browser.BrowserMessageReader(worker), new browser.BrowserMessageWriter(worker));
                    this.$initConnection(connection, initializationOptions);
                }
                $initConnection(connection, initializationOptions) {
                    connection.listen();
                    this.isConnected = true;
                    this.connection = connection;
                    this.sendInitialize(initializationOptions);
                    this.connection.onNotification('textDocument/publishDiagnostics', (result)=>{
                        let postMessage = {
                            "type": MessageType.validate,
                            "documentUri": result.uri,
                            "value": result.diagnostics
                        };
                        this.ctx.postMessage(postMessage);
                    });
                    this.connection.onNotification('window/showMessage', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onNotification('window/logMessage', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onNotification('$/logTrace', (params)=>{
                        this.showTrace(params);
                    });
                    this.connection.onRequest('window/showMessageRequest', (params)=>{
                        this.showLog(params);
                    });
                    this.connection.onRequest('workspace/configuration', (params)=>{
                        language_client_console.log(params);
                    });
                    this.connection.onRequest('client/registerCapability', (params)=>{
                        language_client_console.log(params);
                    });
                    this.connection.onRequest('workspace/applyEdit', async (params)=>{
                        return new Promise((resolve, reject)=>{
                            const callbackId = this.callbackId++;
                            this.callbacks[callbackId] = (result)=>{
                                if (result.applied) {
                                    resolve(result);
                                } else {
                                    reject(new Error(result.failureReason));
                                }
                            };
                            let postMessage = {
                                "type": MessageType.applyEdit,
                                "serviceName": this.serviceName,
                                "value": params.edit,
                                "callbackId": callbackId
                            };
                            this.ctx.postMessage(postMessage);
                        });
                    });
                    this.connection.onRequest('window/showDocument', (params)=>{
                        return new Promise((resolve, reject)=>{
                            const callbackId = this.callbackId++;
                            this.callbacks[callbackId] = (result)=>{
                                resolve(result);
                            };
                            let postMessage = {
                                "type": MessageType.showDocument,
                                "serviceName": this.serviceName,
                                ...params
                            };
                            this.ctx.postMessage(postMessage);
                        });
                    });
                    this.connection.onError((e)=>{
                        throw e;
                    });
                    this.connection.onClose(()=>{
                        this.isConnected = false;
                    });
                }
                async $reconnect() {
                    Object.values(this.documents).forEach((document1)=>this.removeDocument(document1));
                    await this.dispose();
                    this.$connect();
                }
                sendAppliedResult(result, callbackId) {
                    if (!this.isConnected || !this.callbacks[callbackId]) {
                        return;
                    }
                    this.callbacks[callbackId](result);
                }
                sendResponse(callbackId, args) {
                    if (!this.isConnected || !this.callbacks[callbackId]) {
                        return;
                    }
                    this.callbacks[callbackId](args);
                }
                showLog(params) {
                    switch(params.type){
                        case 1:
                            language_client_console.error(params.message);
                            break;
                        case 2:
                            language_client_console.warn(params.message);
                            break;
                        case 3:
                            language_client_console.info(params.message);
                            break;
                        case 4:
                        default:
                            language_client_console.log(params.message);
                            break;
                    }
                }
                showTrace(params) {
                    language_client_console.log(params.message);
                    if (params.verbose) {
                        language_client_console.log(params.verbose);
                    }
                }
                addDocument(document1) {
                    super.addDocument(document1);
                    const textDocumentMessage = {
                        textDocument: document1
                    };
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('textDocument/didOpen', textDocumentMessage));
                }
                enqueueIfNotConnected(callback) {
                    if (!this.isConnected || !this.isInitialized) {
                        this.requestsQueue.push(callback);
                    } else {
                        callback();
                    }
                }
                removeDocument(document1) {
                    super.removeDocument(document1);
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('textDocument/didClose', {
                            textDocument: {
                                uri: document1.uri
                            }
                        }));
                }
                async dispose() {
                    var _this_connection;
                    (_this_connection = this.connection) === null || _this_connection === void 0 ? void 0 : _this_connection.dispose();
                }
                async closeConnection() {
                    if (!this.connection) return;
                    await this.dispose();
                    await this.connection.sendRequest("shutdown");
                    await this.connection.sendNotification('exit');
                    if (this.socket) this.socket.close();
                    this.isConnected = false;
                }
                sendInitialize(initializationOptions) {
                    if (!this.isConnected) return;
                    const message = {
                        capabilities: this.clientCapabilities,
                        initializationOptions: initializationOptions,
                        processId: null,
                        rootUri: null
                    };
                    if (this.workspaceUri) {
                        message.workspaceFolders = [
                            this.workspaceFolder
                        ];
                    }
                    this.connection.sendRequest("initialize", message).then((params)=>{
                        this.isInitialized = true;
                        this.serviceCapabilities = params.capabilities;
                        const serviceName = this.serviceName;
                        Object.keys(this.documents).forEach((documentUri)=>{
                            const postMessage = {
                                "type": MessageType.capabilitiesChange,
                                "value": {
                                    [serviceName]: this.serviceCapabilities
                                },
                                documentUri: documentUri
                            };
                            this.ctx.postMessage(postMessage);
                        });
                        this.connection.sendNotification('initialized').then(()=>{
                            this.connection.sendNotification('workspace/didChangeConfiguration', {
                                settings: {}
                            });
                            this.requestsQueue.forEach((requestCallback)=>requestCallback());
                            this.requestsQueue = [];
                        });
                    });
                }
                applyDeltas(identifier, deltas) {
                    var _this_serviceCapabilities, _this_serviceCapabilities1;
                    super.applyDeltas(identifier, deltas);
                    if (!this.isConnected || !this.serviceCapabilities) {
                        return;
                    }
                    if (((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.textDocumentSync) === browser_main.TextDocumentSyncKind.None) {
                        return;
                    }
                    if (((_this_serviceCapabilities1 = this.serviceCapabilities) === null || _this_serviceCapabilities1 === void 0 ? void 0 : _this_serviceCapabilities1.textDocumentSync) !== browser_main.TextDocumentSyncKind.Incremental) {
                        return this.setValue(identifier, this.getDocument(identifier.uri).getText());
                    }
                    const textDocumentChange = {
                        textDocument: {
                            uri: identifier.uri,
                            version: identifier.version
                        },
                        contentChanges: deltas
                    };
                    this.connection.sendNotification('textDocument/didChange', textDocumentChange);
                }
                setValue(identifier, value) {
                    var _this_serviceCapabilities;
                    super.setValue(identifier, value);
                    if (!this.isConnected) {
                        return;
                    }
                    if (((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.textDocumentSync) === browser_main.TextDocumentSyncKind.None) {
                        return;
                    }
                    const textDocumentChange = {
                        textDocument: {
                            uri: identifier.uri,
                            version: identifier.version
                        },
                        contentChanges: [
                            {
                                text: value
                            }
                        ]
                    };
                    this.connection.sendNotification('textDocument/didChange', textDocumentChange);
                }
                async doHover(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) {
                        return null;
                    }
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.hoverProvider)) {
                        return null;
                    }
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/hover', options);
                }
                async doComplete(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) {
                        return null;
                    }
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.completionProvider)) {
                        return null;
                    }
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/completion', options);
                }
                async doInlineComplete(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) {
                        return null;
                    }
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.inlineCompletionProvider)) {
                        return null;
                    }
                    let options = {
                        textDocument: {
                            uri: document1.uri,
                            // @ts-ignore
                            version: document1.version
                        },
                        position: position,
                        context: {
                            triggerKind: 1
                        }
                    };
                    return this.connection.sendRequest('textDocument/inlineCompletion', options);
                }
                async doResolve(item) {
                    var _this_serviceCapabilities_completionProvider, _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : (_this_serviceCapabilities_completionProvider = _this_serviceCapabilities.completionProvider) === null || _this_serviceCapabilities_completionProvider === void 0 ? void 0 : _this_serviceCapabilities_completionProvider.resolveProvider)) return null;
                    return this.connection.sendRequest('completionItem/resolve', item["item"]);
                }
                async doValidation(document1) {
                    //TODO: textDocument/diagnostic capability
                    return [];
                }
                async format(document1, range, format) {
                    if (!this.isInitialized) {
                        return [];
                    }
                    if (!(this.serviceCapabilities && (this.serviceCapabilities.documentRangeFormattingProvider || this.serviceCapabilities.documentFormattingProvider))) {
                        return [];
                    }
                    if (!this.serviceCapabilities.documentRangeFormattingProvider) {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            options: format
                        };
                        return this.connection.sendRequest('textDocument/formatting', options);
                    } else {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            options: format,
                            range: range
                        };
                        return this.connection.sendRequest('textDocument/rangeFormatting', options);
                    }
                }
                setGlobalOptions(options) {
                    super.setGlobalOptions(options);
                    const configChanges = {
                        settings: options
                    };
                    this.enqueueIfNotConnected(()=>this.connection.sendNotification('workspace/didChangeConfiguration', configChanges));
                }
                setWorkspace(workspaceUri) {
                    var _this_serviceCapabilities_workspace_workspaceFolders, _this_serviceCapabilities_workspace, _this_serviceCapabilities;
                    super.setWorkspace(workspaceUri);
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : (_this_serviceCapabilities_workspace = _this_serviceCapabilities.workspace) === null || _this_serviceCapabilities_workspace === void 0 ? void 0 : (_this_serviceCapabilities_workspace_workspaceFolders = _this_serviceCapabilities_workspace.workspaceFolders) === null || _this_serviceCapabilities_workspace_workspaceFolders === void 0 ? void 0 : _this_serviceCapabilities_workspace_workspaceFolders.changeNotifications)) {
                        return this.$reconnect();
                    }
                    const message = {
                        added: [
                            this.workspaceFolder
                        ],
                        removed: []
                    };
                    return this.connection.sendRequest('workspace/didChangeWorkspaceFolders', message);
                }
                get workspaceFolder() {
                    let workspaceUri = this.workspaceUri;
                    return {
                        uri: language_client_URI.file(workspaceUri).toString(),
                        name: workspaceUri.split("/").pop()
                    };
                }
                async findDocumentHighlights(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return [];
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.documentHighlightProvider)) return [];
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/documentHighlight', options);
                }
                async provideSignatureHelp(document1, position) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.signatureHelpProvider)) return null;
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        position: position
                    };
                    return this.connection.sendRequest('textDocument/signatureHelp', options);
                }
                async getSemanticTokens(document1, range) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.semanticTokensProvider)) return null;
                    if (!this.serviceCapabilities.semanticTokensProvider.range) {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            }
                        };
                        return this.connection.sendRequest('textDocument/semanticTokens/full', options);
                    } else {
                        let options = {
                            textDocument: {
                                uri: document1.uri
                            },
                            range: range
                        };
                        return this.connection.sendRequest('textDocument/semanticTokens/range', options);
                    }
                }
                async getCodeActions(document1, range, context) {
                    var _this_serviceCapabilities;
                    if (!this.isInitialized) return null;
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.codeActionProvider)) return null;
                    let options = {
                        textDocument: {
                            uri: document1.uri
                        },
                        range: range,
                        context: context
                    };
                    return this.connection.sendRequest('textDocument/codeAction', options);
                }
                executeCommand(command, args) {
                    var _this_serviceCapabilities, _this_serviceCapabilities1;
                    if (!this.isInitialized) return Promise.resolve(null);
                    if (!((_this_serviceCapabilities = this.serviceCapabilities) === null || _this_serviceCapabilities === void 0 ? void 0 : _this_serviceCapabilities.executeCommandProvider) || !((_this_serviceCapabilities1 = this.serviceCapabilities) === null || _this_serviceCapabilities1 === void 0 ? void 0 : _this_serviceCapabilities1.executeCommandProvider.commands.includes(command))) return Promise.resolve(null);
                    let options = {
                        command,
                        arguments: args
                    };
                    return this.connection.sendRequest('workspace/executeCommand', options);
                }
                /**
     * Send a custom request to the server.
     * @param name
     * @param args
     */ sendRequest(name, args) {
                    if (args === undefined || args === null) {
                        return this.connection.sendRequest(name);
                    }
                    return this.connection.sendRequest(name, args);
                }
                constructor(serverData, ctx, workspaceUri){
                    super(serverData.modes, workspaceUri);
                    language_client_define_property(this, "$service", void 0);
                    language_client_define_property(this, "isConnected", false);
                    language_client_define_property(this, "isInitialized", false);
                    language_client_define_property(this, "socket", void 0);
                    language_client_define_property(this, "connection", void 0);
                    language_client_define_property(this, "requestsQueue", []);
                    language_client_define_property(this, "callbackId", 0);
                    language_client_define_property(this, "callbacks", {});
                    language_client_define_property(this, "serverData", void 0);
                    language_client_define_property(this, "ctx", void 0);
                    this.ctx = ctx;
                    this.serverData = serverData;
                    this.$connect();
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBSyxFQUFFbEc7b0JBQ3hCa3pDLGdDQUFnQyxJQUFJLEVBQUUsWUFBWSxLQUFLO29CQUN2REEsZ0NBQWdDLElBQUksRUFBRSxlQUFlO29CQUNyREEsZ0NBQWdDLElBQUksRUFBRSxpQkFBaUI7b0JBQ3ZEQSxnQ0FBZ0MsSUFBSSxFQUFFLFVBQVUsS0FBSztvQkFDckRBLGdDQUFnQyxJQUFJLEVBQUUsY0FBYyxLQUFLO29CQUN6REEsZ0NBQWdDLElBQUksRUFBRSxpQkFBaUIsRUFBRTtvQkFDekRBLGdDQUFnQyxJQUFJLEVBQUUsY0FBYztvQkFDcERBLGdDQUFnQyxJQUFJLEVBQUUsYUFBYSxDQUFDO29CQUNwREEsZ0NBQWdDLElBQUksRUFBRSxjQUFjLEtBQUs7b0JBQ3pEQSxnQ0FBZ0MsSUFBSSxFQUFFLE9BQU8sS0FBSztvQkFDbEQsSUFBSSxDQUFDOXhELEdBQUcsR0FBR0E7b0JBQ1gsSUFBSSxDQUFDZ3lELFVBQVUsR0FBR0E7b0JBQ2xCLElBQUksQ0FBQ0QsUUFBUTtnQkFDakI7WUFDSjtRQUVBO1FBRUEsTUFBTSxHQUFJLE9BQU8vMEMsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL2FjZS1saW50ZXJzLXJvb3QvLi9wYWNrYWdlcy9hY2UtbGludGVycy9idWlsZC9sYW5ndWFnZS1jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNjA5Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9hc3NlcnQuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMmE1MWFlNDI0YTUxM2VjOWE2YWEzNDY2YmFhMGNjMWQ1NWRkNGYzYlxuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTM0MiksXG4gICAgX3JlcXVpcmUkY29kZXMgPSBfcmVxdWlyZS5jb2RlcyxcbiAgICBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX0FNQklHVU9VU19BUkdVTUVOVCxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9JTlZBTElEX0FSR19WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19WQUxVRSxcbiAgICBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1M7XG5cbnZhciBBc3NlcnRpb25FcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTgwMSk7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gKF9fd2VicGFja19yZXF1aXJlX18oNjgyNykudHlwZXMpLFxuICAgIGlzUHJvbWlzZSA9IF9yZXF1aXJlJHR5cGVzLmlzUHJvbWlzZSxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwO1xuXG52YXIgb2JqZWN0QXNzaWduID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24gOiAoX193ZWJwYWNrX3JlcXVpcmVfXygzMDQ2KS5hc3NpZ24pO1xudmFyIG9iamVjdElzID0gT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogX193ZWJwYWNrX3JlcXVpcmVfXyg1OTY4KTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2NTYpO1xuXG4gIGlzRGVlcEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBFcXVhbDtcbiAgaXNEZWVwU3RyaWN0RXF1YWwgPSBjb21wYXJpc29uLmlzRGVlcFN0cmljdEVxdWFsO1xufSAvLyBFc2NhcGUgY29udHJvbCBjaGFyYWN0ZXJzIGJ1dCBub3QgXFxuIGFuZCBcXHQgdG8ga2VlcCB0aGUgbGluZSBicmVha3MgYW5kXG4vLyBpbmRlbnRhdGlvbiBpbnRhY3QuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG5cbnZhciBlc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xceDAwLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXS9nO1xudmFyIG1ldGEgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbXCJcXFxcdTAwMDBcIiwgXCJcXFxcdTAwMDFcIiwgXCJcXFxcdTAwMDJcIiwgXCJcXFxcdTAwMDNcIiwgXCJcXFxcdTAwMDRcIiwgXCJcXFxcdTAwMDVcIiwgXCJcXFxcdTAwMDZcIiwgXCJcXFxcdTAwMDdcIiwgJ1xcXFxiJywgJycsICcnLCBcIlxcXFx1MDAwYlwiLCAnXFxcXGYnLCAnJywgXCJcXFxcdTAwMGVcIiwgXCJcXFxcdTAwMGZcIiwgXCJcXFxcdTAwMTBcIiwgXCJcXFxcdTAwMTFcIiwgXCJcXFxcdTAwMTJcIiwgXCJcXFxcdTAwMTNcIiwgXCJcXFxcdTAwMTRcIiwgXCJcXFxcdTAwMTVcIiwgXCJcXFxcdTAwMTZcIiwgXCJcXFxcdTAwMTdcIiwgXCJcXFxcdTAwMThcIiwgXCJcXFxcdTAwMTlcIiwgXCJcXFxcdTAwMWFcIiwgXCJcXFxcdTAwMWJcIiwgXCJcXFxcdTAwMWNcIiwgXCJcXFxcdTAwMWRcIiwgXCJcXFxcdTAwMWVcIiwgXCJcXFxcdTAwMWZcIl0pKTtcblxudmFyIGVzY2FwZUZuID0gZnVuY3Rpb24gZXNjYXBlRm4oc3RyKSB7XG4gIHJldHVybiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTtcbn07XG5cbnZhciB3YXJuZWQgPSBmYWxzZTsgLy8gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xudmFyIE5PX0VYQ0VQVElPTl9TRU5USU5FTCA9IHt9OyAvLyBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGlubmVyRmFpbChvYmopIHtcbiAgaWYgKG9iai5tZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG9iai5tZXNzYWdlO1xuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZuKSB7XG4gIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGludGVybmFsTWVzc2FnZTtcblxuICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgIGludGVybmFsTWVzc2FnZSA9ICdGYWlsZWQnO1xuICB9IGVsc2UgaWYgKGFyZ3NMZW4gPT09IDEpIHtcbiAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAod2FybmVkID09PSBmYWxzZSkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHZhciB3YXJuID0gcHJvY2Vzcy5lbWl0V2FybmluZyA/IHByb2Nlc3MuZW1pdFdhcm5pbmcgOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgIHdhcm4oJ2Fzc2VydC5mYWlsKCkgd2l0aCBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGlzIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSBhc3NlcnQuc3RyaWN0RXF1YWwoKSBpbnN0ZWFkIG9yIG9ubHkgcGFzcyBhIG1lc3NhZ2UuJywgJ0RlcHJlY2F0aW9uV2FybmluZycsICdERVAwMDk0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3NMZW4gPT09IDIpIG9wZXJhdG9yID0gJyE9JztcbiAgfVxuXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IG1lc3NhZ2U7XG4gIHZhciBlcnJBcmdzID0ge1xuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdmYWlsJyA6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuIHx8IGZhaWxcbiAgfTtcblxuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyQXJncy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyQXJncyk7XG5cbiAgaWYgKGludGVybmFsTWVzc2FnZSkge1xuICAgIGVyci5tZXNzYWdlID0gaW50ZXJuYWxNZXNzYWdlO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuXG4gIHRocm93IGVycjtcbn1cblxuYXNzZXJ0LmZhaWwgPSBmYWlsOyAvLyBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBpbnRlcm5hbC9lcnJvci5cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbmZ1bmN0aW9uIGlubmVyT2soZm4sIGFyZ0xlbiwgdmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHZhciBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG5cbiAgICBpZiAoYXJnTGVuID09PSAwKSB7XG4gICAgICBnZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgIG1lc3NhZ2UgPSAnTm8gdmFsdWUgYXJndW1lbnQgcGFzc2VkIHRvIGBhc3NlcnQub2soKWAnO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cblxuICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiB2YWx1ZSxcbiAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICAgIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn0gLy8gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISF2YWx1ZS5cblxuXG5mdW5jdGlvbiBvaygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbb2ssIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQub2sgPSBvazsgLy8gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoID09LlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXMgKi9cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdFxuLy8gZXF1YWwgd2l0aCAhPS5cblxuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnIT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cblxuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG5cblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwRXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwRXF1YWxcbiAgICB9KTtcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmICghaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBkZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcblxuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKCFvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ3N0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAob2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBDb21wYXJpc29uID0gZnVuY3Rpb24gQ29tcGFyaXNvbihvYmosIGtleXMsIGFjdHVhbCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wYXJpc29uKTtcblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoYWN0dWFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChvYmpba2V5XSkgJiYgb2JqW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IGFjdHVhbFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbWVzc2FnZSwga2V5cywgZm4pIHtcbiAgaWYgKCEoa2V5IGluIGFjdHVhbCkgfHwgIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbFtrZXldLCBleHBlY3RlZFtrZXldKSkge1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIG9iamVjdHMgdG8gY3JlYXRlIGEgbmljZSBvdXRwdXQuXG4gICAgICB2YXIgYSA9IG5ldyBDb21wYXJpc29uKGFjdHVhbCwga2V5cyk7XG4gICAgICB2YXIgYiA9IG5ldyBDb21wYXJpc29uKGV4cGVjdGVkLCBrZXlzLCBhY3R1YWwpO1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYSxcbiAgICAgICAgZXhwZWN0ZWQ6IGIsXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIuYWN0dWFsID0gYWN0dWFsO1xuICAgICAgZXJyLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogZm4ubmFtZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBtc2csIGZuKSB7XG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoaXNSZWdFeHAoZXhwZWN0ZWQpKSByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBhc3NlcnQuZG9lc05vdFRocm93IGRvZXMgbm90IGFjY2VwdCBvYmplY3RzLlxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXhwZWN0ZWQnLCBbJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBleHBlY3RlZCk7XG4gICAgfSAvLyBIYW5kbGUgcHJpbWl0aXZlcyBwcm9wZXJseS5cblxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTsgLy8gU3BlY2lhbCBoYW5kbGUgZXJyb3JzIHRvIG1ha2Ugc3VyZSB0aGUgbmFtZSBhbmQgdGhlIG1lc3NhZ2UgYXJlIGNvbXBhcmVkXG4gICAgLy8gYXMgd2VsbC5cblxuICAgIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBrZXlzLnB1c2goJ25hbWUnLCAnbWVzc2FnZScpO1xuICAgIH0gZWxzZSBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoJ2Vycm9yJywgZXhwZWN0ZWQsICdtYXkgbm90IGJlIGFuIGVtcHR5IG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAoZXhwZWN0ZWRba2V5XSkgJiYgZXhwZWN0ZWRba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtc2csIGtleXMsIGZuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBHdWFyZCBpbnN0YW5jZW9mIGFnYWluc3QgYXJyb3cgZnVuY3Rpb25zIGFzIHRoZXkgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZS5cblxuXG4gIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT09IHVuZGVmaW5lZCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEFjdHVhbChmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsICdGdW5jdGlvbicsIGZuKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbn1cblxuZnVuY3Rpb24gY2hlY2tJc1Byb21pc2Uob2JqKSB7XG4gIC8vIEFjY2VwdCBuYXRpdmUgRVM2IHByb21pc2VzIGFuZCBwcm9taXNlcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBpbiBhIHNpbWlsYXJcbiAgLy8gd2F5LiBEbyBub3QgYWNjZXB0IHRoZW5hYmxlcyB0aGF0IHVzZSBhIGZ1bmN0aW9uIGFzIGBvYmpgIGFuZCB0aGF0IGhhdmUgbm9cbiAgLy8gYGNhdGNoYCBoYW5kbGVyLlxuICAvLyBUT0RPOiB0aGVuYWJsZXMgYXJlIGNoZWNrZWQgdXAgdW50aWwgdGhleSBoYXZlIHRoZSBjb3JyZWN0IG1ldGhvZHMsXG4gIC8vIGJ1dCBhY2NvcmRpbmcgdG8gZG9jdW1lbnRhdGlvbiwgdGhlIGB0aGVuYCBtZXRob2Qgc2hvdWxkIHJlY2VpdmVcbiAgLy8gdGhlIGBmdWxmaWxsYCBhbmQgYHJlamVjdGAgYXJndW1lbnRzIGFzIHdlbGwgb3IgaXQgbWF5IGJlIG5ldmVyIHJlc29sdmVkLlxuICByZXR1cm4gaXNQcm9taXNlKG9iaikgfHwgb2JqICE9PSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY2F0Y2ggPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0UHJvbWlzZTtcblxuICAgIGlmICh0eXBlb2YgcHJvbWlzZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBSZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGlmIGBwcm9taXNlRm5gIHRocm93cyBzeW5jaHJvbm91c2x5LlxuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbigpOyAvLyBGYWlsIGluIGNhc2Ugbm8gcHJvbWlzZSBpcyByZXR1cm5lZC5cblxuICAgICAgaWYgKCFjaGVja0lzUHJvbWlzZShyZXN1bHRQcm9taXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdpbnN0YW5jZSBvZiBQcm9taXNlJywgJ3Byb21pc2VGbicsIHJlc3VsdFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hlY2tJc1Byb21pc2UocHJvbWlzZUZuKSkge1xuICAgICAgcmVzdWx0UHJvbWlzZSA9IHByb21pc2VGbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdwcm9taXNlRm4nLCBbJ0Z1bmN0aW9uJywgJ1Byb21pc2UnXSwgcHJvbWlzZUZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZXhwZWN0c0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChhY3R1YWwubWVzc2FnZSA9PT0gZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBtZXNzYWdlIFxcXCJcIi5jb25jYXQoYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFjdHVhbCA9PT0gZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgXFxcIlwiLmNvbmNhdChhY3R1YWwsIFwiXFxcIiBpcyBpZGVudGljYWwgdG8gdGhlIG1lc3NhZ2UuXCIpKTtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZXJyb3IgIT0gbnVsbCAmJiBfdHlwZW9mKGVycm9yKSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gIH1cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHtcbiAgICB2YXIgZGV0YWlscyA9ICcnO1xuXG4gICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUpIHtcbiAgICAgIGRldGFpbHMgKz0gXCIgKFwiLmNvbmNhdChlcnJvci5uYW1lLCBcIilcIik7XG4gICAgfVxuXG4gICAgZGV0YWlscyArPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdyZWplY3RzJyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIGV4cGVjdGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZXJyb3IgJiYgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UsIHN0YWNrU3RhcnRGbikpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0c05vRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFlcnJvciB8fCBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yKSkge1xuICAgIHZhciBkZXRhaWxzID0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAnZG9lc05vdFJlamVjdCcgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiR290IHVud2FudGVkIFwiLmNvbmNhdChmblR5cGUpLmNvbmNhdChkZXRhaWxzLCBcIlxcblwiKSArIFwiQWN0dWFsIG1lc3NhZ2U6IFxcXCJcIi5jb25jYXQoYWN0dWFsICYmIGFjdHVhbC5tZXNzYWdlLCBcIlxcXCJcIiksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgYWN0dWFsO1xufVxuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gdGhyb3dzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbdGhyb3dzLCBnZXRBY3R1YWwocHJvbWlzZUZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5yZWplY3RzID0gZnVuY3Rpb24gcmVqZWN0cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwocHJvbWlzZUZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3JlamVjdHMsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gZG9lc05vdFRocm93KGZuKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgfVxuXG4gIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RUaHJvdywgZ2V0QWN0dWFsKGZuKV0uY29uY2F0KGFyZ3MpKTtcbn07XG5cbmFzc2VydC5kb2VzTm90UmVqZWN0ID0gZnVuY3Rpb24gZG9lc05vdFJlamVjdChmbikge1xuICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChmbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNOb0Vycm9yLmFwcGx5KHZvaWQgMCwgW2RvZXNOb3RSZWplY3QsIHJlc3VsdF0uY29uY2F0KGFyZ3MpKTtcbiAgfSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uIGlmRXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgIT09IG51bGwgJiYgZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdpZkVycm9yIGdvdCB1bndhbnRlZCBleGNlcHRpb246ICc7XG5cbiAgICBpZiAoX3R5cGVvZihlcnIpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UubGVuZ3RoID09PSAwICYmIGVyci5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSBpbnNwZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIG5ld0VyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IGVycixcbiAgICAgIGV4cGVjdGVkOiBudWxsLFxuICAgICAgb3BlcmF0b3I6ICdpZkVycm9yJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBzdGFja1N0YXJ0Rm46IGlmRXJyb3JcbiAgICB9KTsgLy8gTWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzdGFjayB0cmFjZSFcblxuICAgIHZhciBvcmlnU3RhY2sgPSBlcnIuc3RhY2s7XG5cbiAgICBpZiAodHlwZW9mIG9yaWdTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZW1vdmUgYW55IGR1cGxpY2F0ZWQgZnJhbWVzIGZyb20gdGhlIGVycm9yIGZyYW1lcyB0YWtlblxuICAgICAgLy8gZnJvbSB3aXRoaW4gYGlmRXJyb3JgIGFuZCBhZGQgdGhlIG9yaWdpbmFsIGVycm9yIGZyYW1lcyB0byB0aGUgbmV3bHlcbiAgICAgIC8vIGNyZWF0ZWQgb25lcy5cbiAgICAgIHZhciB0bXAyID0gb3JpZ1N0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHRtcDIuc2hpZnQoKTsgLy8gRmlsdGVyIGFsbCBmcmFtZXMgZXhpc3RpbmcgaW4gZXJyLnN0YWNrLlxuXG4gICAgICB2YXIgdG1wMSA9IG5ld0Vyci5zdGFjay5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG1wMi5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHRoZSBmcmFtZS5cbiAgICAgICAgdmFyIHBvcyA9IHRtcDEuaW5kZXhPZih0bXAyW2ldKTtcblxuICAgICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAgIC8vIE9ubHkga2VlcCBuZXcgZnJhbWVzLlxuICAgICAgICAgIHRtcDEgPSB0bXAxLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3RXJyLnN0YWNrID0gXCJcIi5jb25jYXQodG1wMS5qb2luKCdcXG4nKSwgXCJcXG5cIikuY29uY2F0KHRtcDIuam9pbignXFxuJykpO1xuICAgIH1cblxuICAgIHRocm93IG5ld0VycjtcbiAgfVxufTsgLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcblxuXG5mdW5jdGlvbiBzdHJpY3QoKSB7XG4gIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgIGFyZ3NbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgfVxuXG4gIGlubmVyT2suYXBwbHkodm9pZCAwLCBbc3RyaWN0LCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODAxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MDcpO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzA4MTc4NDBmNzc1MDMyMTY5ZGRkNzBjODVhYzA1OWYxOGZmY2M4MWNcblxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTM0MiksXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZTIuY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEU7IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCB8fCBjb3VudCA9PSAwKSByZXR1cm4gJyc7XG4gIHZhciBtYXhDb3VudCA9IHN0ci5sZW5ndGggKiBjb3VudDtcbiAgY291bnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKGNvdW50KSAvIE1hdGgubG9nKDIpKTtcblxuICB3aGlsZSAoY291bnQpIHtcbiAgICBzdHIgKz0gc3RyO1xuICAgIGNvdW50LS07XG4gIH1cblxuICBzdHIgKz0gc3RyLnN1YnN0cmluZygwLCBtYXhDb3VudCAtIHN0ci5sZW5ndGgpO1xuICByZXR1cm4gc3RyO1xufVxuXG52YXIgYmx1ZSA9ICcnO1xudmFyIGdyZWVuID0gJyc7XG52YXIgcmVkID0gJyc7XG52YXIgd2hpdGUgPSAnJztcbnZhciBrUmVhZGFibGVPcGVyYXRvciA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHJlZmVyZW5jZS1lcXVhbCB0byBcImV4cGVjdGVkXCI6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWxPYmplY3Q6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIG5vdERlZXBFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgbG9vc2VseSB1bmVxdWFsIHRvOicsXG4gIG5vdElkZW50aWNhbDogJ1ZhbHVlcyBpZGVudGljYWwgYnV0IG5vdCByZWZlcmVuY2UtZXF1YWw6J1xufTsgLy8gQ29tcGFyaW5nIHNob3J0IHByaW1pdGl2ZXMgc2hvdWxkIGp1c3Qgc2hvdyA9PT0gLyAhPT0gaW5zdGVhZCBvZiB1c2luZyB0aGVcbi8vIGRpZmYuXG5cbnZhciBrTWF4U2hvcnRMZW5ndGggPSAxMDtcblxuZnVuY3Rpb24gY29weUVycm9yKHNvdXJjZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ21lc3NhZ2UnLCB7XG4gICAgdmFsdWU6IHNvdXJjZS5tZXNzYWdlXG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0VmFsdWUodmFsKSB7XG4gIC8vIFRoZSB1dGlsLmluc3BlY3QgZGVmYXVsdCB2YWx1ZXMgY291bGQgYmUgY2hhbmdlZC4gVGhpcyBtYWtlcyBzdXJlIHRoZVxuICAvLyBlcnJvciBtZXNzYWdlcyBjb250YWluIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gbmV2ZXJ0aGVsZXNzLlxuICByZXR1cm4gaW5zcGVjdCh2YWwsIHtcbiAgICBjb21wYWN0OiBmYWxzZSxcbiAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICBkZXB0aDogMTAwMCxcbiAgICBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGNvbXBhcmVzIG9ubHkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzICh3aXRoIGEgZmV3IGV4Y2VwdGlvbnMpLlxuICAgIHNob3dIaWRkZW46IGZhbHNlLFxuICAgIC8vIEhhdmluZyBhIGxvbmcgbGluZSBhcyBlcnJvciBpcyBiZXR0ZXIgdGhhbiB3cmFwcGluZyB0aGUgbGluZSBmb3JcbiAgICAvLyBjb21wYXJpc29uIGZvciBub3cuXG4gICAgLy8gVE9ETyhCcmlkZ2VBUik6IGBicmVha0xlbmd0aGAgc2hvdWxkIGJlIGxpbWl0ZWQgYXMgc29vbiBhcyBzb29uIGFzIHdlXG4gICAgLy8gaGF2ZSBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnNwZWN0ZWQgcHJvcGVydGllcyAoaS5lLiwga25vdyB3aGVyZVxuICAgIC8vIGluIHdoYXQgbGluZSB0aGUgcHJvcGVydHkgc3RhcnRzIGFuZCBlbmRzKS5cbiAgICBicmVha0xlbmd0aDogSW5maW5pdHksXG4gICAgLy8gQXNzZXJ0IGRvZXMgbm90IGRldGVjdCBwcm94aWVzIGN1cnJlbnRseS5cbiAgICBzaG93UHJveHk6IGZhbHNlLFxuICAgIHNvcnRlZDogdHJ1ZSxcbiAgICAvLyBJbnNwZWN0IGdldHRlcnMgYXMgd2UgYWxzbyBjaGVjayB0aGVtIHdoZW4gY29tcGFyaW5nIGVudHJpZXMuXG4gICAgZ2V0dGVyczogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikge1xuICB2YXIgb3RoZXIgPSAnJztcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbGFzdFBvcyA9IDA7XG4gIHZhciBlbmQgPSAnJztcbiAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgdmFyIGFjdHVhbEluc3BlY3RlZCA9IGluc3BlY3RWYWx1ZShhY3R1YWwpO1xuICB2YXIgYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpO1xuICB2YXIgZXhwZWN0ZWRMaW5lcyA9IGluc3BlY3RWYWx1ZShleHBlY3RlZCkuc3BsaXQoJ1xcbicpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBpbmRpY2F0b3IgPSAnJzsgLy8gSW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgb2JqZWN0cyBleHBsaWNpdGx5IG1hcmsgdGhlbSBhcyBub3QgcmVmZXJlbmNlIGVxdWFsXG4gIC8vIGZvciB0aGUgYHN0cmljdEVxdWFsYCBvcGVyYXRvci5cblxuICBpZiAob3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcgJiYgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsICYmIGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgb3BlcmF0b3IgPSAnc3RyaWN0RXF1YWxPYmplY3QnO1xuICB9IC8vIElmIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiBmaXQgb24gYSBzaW5nbGUgbGluZSBhbmQgdGhleSBhcmUgbm90IHN0cmljdGx5XG4gIC8vIGVxdWFsLCBjaGVjayBmdXJ0aGVyIHNwZWNpYWwgaGFuZGxpbmcuXG5cblxuICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAxICYmIGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAxICYmIGFjdHVhbExpbmVzWzBdICE9PSBleHBlY3RlZExpbmVzWzBdKSB7XG4gICAgdmFyIGlucHV0TGVuZ3RoID0gYWN0dWFsTGluZXNbMF0ubGVuZ3RoICsgZXhwZWN0ZWRMaW5lc1swXS5sZW5ndGg7IC8vIElmIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIFwiYWN0dWFsXCIgYW5kIFwiZXhwZWN0ZWRcIiB0b2dldGhlciBpcyBsZXNzIHRoYW5cbiAgICAvLyBrTWF4U2hvcnRMZW5ndGggYW5kIGlmIG5laXRoZXIgaXMgYW4gb2JqZWN0IGFuZCBhdCBsZWFzdCBvbmUgb2YgdGhlbSBpc1xuICAgIC8vIG5vdCBgemVyb2AsIHVzZSB0aGUgc3RyaWN0IGVxdWFsIGNvbXBhcmlzb24gdG8gdmlzdWFsaXplIHRoZSBvdXRwdXQuXG5cbiAgICBpZiAoaW5wdXRMZW5ndGggPD0ga01heFNob3J0TGVuZ3RoKSB7XG4gICAgICBpZiAoKF90eXBlb2YoYWN0dWFsKSAhPT0gJ29iamVjdCcgfHwgYWN0dWFsID09PSBudWxsKSAmJiAoX3R5cGVvZihleHBlY3RlZCkgIT09ICdvYmplY3QnIHx8IGV4cGVjdGVkID09PSBudWxsKSAmJiAoYWN0dWFsICE9PSAwIHx8IGV4cGVjdGVkICE9PSAwKSkge1xuICAgICAgICAvLyAtMCA9PT0gKzBcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikgKyBcIlwiLmNvbmNhdChhY3R1YWxMaW5lc1swXSwgXCIgIT09IFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lc1swXSwgXCJcXG5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciAhPT0gJ3N0cmljdEVxdWFsT2JqZWN0Jykge1xuICAgICAgLy8gSWYgdGhlIHN0ZGVyciBpcyBhIHR0eSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsb3dlciB0aGFuIHRoZSBjdXJyZW50XG4gICAgICAvLyBjb2x1bW5zIHBlciBsaW5lLCBhZGQgYSBtaXNtYXRjaCBpbmRpY2F0b3IgYmVsb3cgdGhlIG91dHB1dC4gSWYgaXQgaXNcbiAgICAgIC8vIG5vdCBhIHR0eSwgdXNlIGEgZGVmYXVsdCB2YWx1ZSBvZiA4MCBjaGFyYWN0ZXJzLlxuICAgICAgdmFyIG1heExlbmd0aCA9IHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZID8gcHJvY2Vzcy5zdGRlcnIuY29sdW1ucyA6IDgwO1xuXG4gICAgICBpZiAoaW5wdXRMZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKGFjdHVhbExpbmVzWzBdW2ldID09PSBleHBlY3RlZExpbmVzWzBdW2ldKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IC8vIElnbm9yZSB0aGUgZmlyc3QgY2hhcmFjdGVycy5cblxuXG4gICAgICAgIGlmIChpID4gMikge1xuICAgICAgICAgIC8vIEFkZCBwb3NpdGlvbiBpbmRpY2F0b3IgZm9yIHRoZSBmaXJzdCBtaXNtYXRjaCBpbiBjYXNlIGl0IGlzIGFcbiAgICAgICAgICAvLyBzaW5nbGUgbGluZSBhbmQgdGhlIGlucHV0IGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIGNvbHVtbiBsZW5ndGguXG4gICAgICAgICAgaW5kaWNhdG9yID0gXCJcXG4gIFwiLmNvbmNhdChyZXBlYXQoJyAnLCBpKSwgXCJeXCIpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlbW92ZSBhbGwgZW5kaW5nIGxpbmVzIHRoYXQgbWF0Y2ggKHRoaXMgb3B0aW1pemVzIHRoZSBvdXRwdXQgZm9yXG4gIC8vIHJlYWRhYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBudW1iZXIgb2YgdG90YWwgY2hhbmdlZCBsaW5lcykuXG5cblxuICB2YXIgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICB2YXIgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcblxuICB3aGlsZSAoYSA9PT0gYikge1xuICAgIGlmIChpKysgPCAyKSB7XG4gICAgICBlbmQgPSBcIlxcbiAgXCIuY29uY2F0KGEpLmNvbmNhdChlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlciA9IGE7XG4gICAgfVxuXG4gICAgYWN0dWFsTGluZXMucG9wKCk7XG4gICAgZXhwZWN0ZWRMaW5lcy5wb3AoKTtcbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoID09PSAwIHx8IGV4cGVjdGVkTGluZXMubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICBhID0gYWN0dWFsTGluZXNbYWN0dWFsTGluZXMubGVuZ3RoIC0gMV07XG4gICAgYiA9IGV4cGVjdGVkTGluZXNbZXhwZWN0ZWRMaW5lcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHZhciBtYXhMaW5lcyA9IE1hdGgubWF4KGFjdHVhbExpbmVzLmxlbmd0aCwgZXhwZWN0ZWRMaW5lcy5sZW5ndGgpOyAvLyBTdHJpY3QgZXF1YWwgd2l0aCBpZGVudGljYWwgb2JqZWN0cyB0aGF0IGFyZSBub3QgaWRlbnRpY2FsIGJ5IHJlZmVyZW5jZS5cbiAgLy8gRS5nLiwgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCh7IGE6IFN5bWJvbCgpIH0sIHsgYTogU3ltYm9sKCkgfSlcblxuICBpZiAobWF4TGluZXMgPT09IDApIHtcbiAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcmVzdWx0IGFnYWluLiBUaGUgbGluZXMgd2VyZSBhbGwgcmVtb3ZlZCBiZWZvcmUuXG4gICAgdmFyIF9hY3R1YWxMaW5lcyA9IGFjdHVhbEluc3BlY3RlZC5zcGxpdCgnXFxuJyk7IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cblxuXG4gICAgaWYgKF9hY3R1YWxMaW5lcy5sZW5ndGggPiAzMCkge1xuICAgICAgX2FjdHVhbExpbmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgIHdoaWxlIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgX2FjdHVhbExpbmVzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvci5ub3RJZGVudGljYWwsIFwiXFxuXFxuXCIpLmNvbmNhdChfYWN0dWFsTGluZXMuam9pbignXFxuJyksIFwiXFxuXCIpO1xuICB9XG5cbiAgaWYgKGkgPiAzKSB7XG4gICAgZW5kID0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKS5jb25jYXQoZW5kKTtcbiAgICBza2lwcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvdGhlciAhPT0gJycpIHtcbiAgICBlbmQgPSBcIlxcbiAgXCIuY29uY2F0KG90aGVyKS5jb25jYXQoZW5kKTtcbiAgICBvdGhlciA9ICcnO1xuICB9XG5cbiAgdmFyIHByaW50ZWRMaW5lcyA9IDA7XG4gIHZhciBtc2cgPSBrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0gKyBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrIGFjdHVhbFwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQocmVkLCBcIi0gZXhwZWN0ZWRcIikuY29uY2F0KHdoaXRlKTtcbiAgdmFyIHNraXBwZWRNc2cgPSBcIiBcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlLCBcIiBMaW5lcyBza2lwcGVkXCIpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXhMaW5lczsgaSsrKSB7XG4gICAgLy8gT25seSBleHRyYSBleHBlY3RlZCBsaW5lcyBleGlzdFxuICAgIHZhciBjdXIgPSBpIC0gbGFzdFBvcztcblxuICAgIGlmIChhY3R1YWxMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChleHBlY3RlZExpbmVzW2kgLSAxXSk7XG4gICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICBsYXN0UG9zID0gaTsgLy8gQWRkIHRoZSBleHBlY3RlZCBsaW5lIHRvIHRoZSBjYWNoZS5cblxuICAgICAgb3RoZXIgKz0gXCJcXG5cIi5jb25jYXQocmVkLCBcIi1cIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbaV0pO1xuICAgICAgcHJpbnRlZExpbmVzKys7IC8vIE9ubHkgZXh0cmEgYWN0dWFsIGxpbmVzIGV4aXN0XG4gICAgfSBlbHNlIGlmIChleHBlY3RlZExpbmVzLmxlbmd0aCA8IGkgKyAxKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBsaW5lIGlzIGF0IGxlYXN0IGxpbmUgdGhyZWUsIGFkZCBzb21lIG9mIHRoZSBmb3JtZXIgbGluZXMgYW5kXG4gICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgIGlmIChjdXIgPiA0KSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID4gMykge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdC5cblxuICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBMaW5lcyBkaXZlcmdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBleHBlY3RlZExpbmUgPSBleHBlY3RlZExpbmVzW2ldO1xuICAgICAgdmFyIGFjdHVhbExpbmUgPSBhY3R1YWxMaW5lc1tpXTsgLy8gSWYgdGhlIGxpbmVzIGRpdmVyZ2UsIHNwZWNpZmljYWxseSBjaGVjayBmb3IgbGluZXMgdGhhdCBvbmx5IGRpdmVyZ2UgYnlcbiAgICAgIC8vIGEgdHJhaWxpbmcgY29tbWEuIEluIHRoYXQgY2FzZSBpdCBpcyBhY3R1YWxseSBpZGVudGljYWwgYW5kIHdlIHNob3VsZFxuICAgICAgLy8gbWFyayBpdCBhcyBzdWNoLlxuXG4gICAgICB2YXIgZGl2ZXJnaW5nTGluZXMgPSBhY3R1YWxMaW5lICE9PSBleHBlY3RlZExpbmUgJiYgKCFlbmRzV2l0aChhY3R1YWxMaW5lLCAnLCcpIHx8IGFjdHVhbExpbmUuc2xpY2UoMCwgLTEpICE9PSBleHBlY3RlZExpbmUpOyAvLyBJZiB0aGUgZXhwZWN0ZWQgbGluZSBoYXMgYSB0cmFpbGluZyBjb21tYSBidXQgaXMgb3RoZXJ3aXNlIGlkZW50aWNhbCxcbiAgICAgIC8vIGFkZCBhIGNvbW1hIGF0IHRoZSBlbmQgb2YgdGhlIGFjdHVhbCBsaW5lLiBPdGhlcndpc2UgdGhlIG91dHB1dCBjb3VsZFxuICAgICAgLy8gbG9vayB3ZWlyZCBhcyBpbjpcbiAgICAgIC8vXG4gICAgICAvLyAgIFtcbiAgICAgIC8vICAgICAxICAgICAgICAgLy8gTm8gY29tbWEgYXQgdGhlIGVuZCFcbiAgICAgIC8vICsgICAyXG4gICAgICAvLyAgIF1cbiAgICAgIC8vXG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcyAmJiBlbmRzV2l0aChleHBlY3RlZExpbmUsICcsJykgJiYgZXhwZWN0ZWRMaW5lLnNsaWNlKDAsIC0xKSA9PT0gYWN0dWFsTGluZSkge1xuICAgICAgICBkaXZlcmdpbmdMaW5lcyA9IGZhbHNlO1xuICAgICAgICBhY3R1YWxMaW5lICs9ICcsJztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpdmVyZ2luZ0xpbmVzKSB7XG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgICAvLyBhbHNvIGFkZCBkb3RzIHRvIGluZGljYXRlIHNraXBwZWQgZW50cmllcy5cbiAgICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmVzW2kgLSAyXSk7XG4gICAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMV0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgYWN0dWFsIGxpbmUgdG8gdGhlIHJlc3VsdCBhbmQgY2FjaGUgdGhlIGV4cGVjdGVkIGRpdmVyZ2luZ1xuICAgICAgICAvLyBsaW5lIHNvIGNvbnNlY3V0aXZlIGRpdmVyZ2luZyBsaW5lcyBzaG93IHVwIGFzICsrKy0tLSBhbmQgbm90ICstKy0rLS5cblxuICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiK1wiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoYWN0dWFsTGluZSk7XG4gICAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmUpO1xuICAgICAgICBwcmludGVkTGluZXMgKz0gMjsgLy8gTGluZXMgYXJlIGlkZW50aWNhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIGFsbCBjYWNoZWQgaW5mb3JtYXRpb24gdG8gdGhlIHJlc3VsdCBiZWZvcmUgYWRkaW5nIG90aGVyIHRoaW5nc1xuICAgICAgICAvLyBhbmQgcmVzZXQgdGhlIGNhY2hlLlxuICAgICAgICByZXMgKz0gb3RoZXI7XG4gICAgICAgIG90aGVyID0gJyc7IC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIGV4YWN0bHkgb25lIGxpbmUgYWJvdmUgb3IgaWYgaXQgaXMgdGhlXG4gICAgICAgIC8vIHZlcnkgZmlyc3QgbGluZSwgYWRkIHRoZSBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgICAgaWYgKGN1ciA9PT0gMSB8fCBpID09PSAwKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZSk7XG4gICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEluc3BlY3RlZCBvYmplY3QgdG8gYmlnIChTaG93IH4yMCByb3dzIG1heClcblxuXG4gICAgaWYgKHByaW50ZWRMaW5lcyA+IDIwICYmIGkgPCBtYXhMaW5lcyAtIDIpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChtc2cpLmNvbmNhdChza2lwcGVkTXNnLCBcIlxcblwiKS5jb25jYXQocmVzLCBcIlxcblwiKS5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKS5jb25jYXQob3RoZXIsIFwiXFxuXCIpICsgXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZCA/IHNraXBwZWRNc2cgOiAnJywgXCJcXG5cIikuY29uY2F0KHJlcykuY29uY2F0KG90aGVyKS5jb25jYXQoZW5kKS5jb25jYXQoaW5kaWNhdG9yKTtcbn1cblxudmFyIEFzc2VydGlvbkVycm9yID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKEFzc2VydGlvbkVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNzZXJ0aW9uRXJyb3IpO1xuXG4gICAgaWYgKF90eXBlb2Yob3B0aW9ucykgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgb3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yLFxuICAgICAgICBzdGFja1N0YXJ0Rm4gPSBvcHRpb25zLnN0YWNrU3RhcnRGbjtcbiAgICB2YXIgYWN0dWFsID0gb3B0aW9ucy5hY3R1YWwsXG4gICAgICAgIGV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcblxuICAgIGlmIChtZXNzYWdlICE9IG51bGwpIHtcbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFN0cmluZyhtZXNzYWdlKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICAgICAgLy8gUmVzZXQgb24gZWFjaCBjYWxsIHRvIG1ha2Ugc3VyZSB3ZSBoYW5kbGUgZHluYW1pY2FsbHkgc2V0IGVudmlyb25tZW50XG4gICAgICAgIC8vIHZhcmlhYmxlcyBjb3JyZWN0LlxuICAgICAgICBpZiAocHJvY2Vzcy5zdGRlcnIgJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCAmJiBwcm9jZXNzLnN0ZGVyci5nZXRDb2xvckRlcHRoKCkgIT09IDEpIHtcbiAgICAgICAgICBibHVlID0gXCJcXHgxQlszNG1cIjtcbiAgICAgICAgICBncmVlbiA9IFwiXFx4MUJbMzJtXCI7XG4gICAgICAgICAgd2hpdGUgPSBcIlxceDFCWzM5bVwiO1xuICAgICAgICAgIHJlZCA9IFwiXFx4MUJbMzFtXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmx1ZSA9ICcnO1xuICAgICAgICAgIGdyZWVuID0gJyc7XG4gICAgICAgICAgd2hpdGUgPSAnJztcbiAgICAgICAgICByZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQcmV2ZW50IHRoZSBlcnJvciBzdGFjayBmcm9tIGJlaW5nIHZpc2libGUgYnkgZHVwbGljYXRpbmcgdGhlIGVycm9yXG4gICAgICAvLyBpbiBhIHZlcnkgY2xvc2Ugd2F5IHRvIHRoZSBvcmlnaW5hbCBpbiBjYXNlIGJvdGggc2lkZXMgYXJlIGFjdHVhbGx5XG4gICAgICAvLyBpbnN0YW5jZXMgb2YgRXJyb3IuXG5cblxuICAgICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsICYmIF90eXBlb2YoZXhwZWN0ZWQpID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZCAhPT0gbnVsbCAmJiAnc3RhY2snIGluIGFjdHVhbCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBFcnJvciAmJiAnc3RhY2snIGluIGV4cGVjdGVkICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgYWN0dWFsID0gY29weUVycm9yKGFjdHVhbCk7XG4gICAgICAgIGV4cGVjdGVkID0gY29weUVycm9yKGV4cGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcFN0cmljdEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ3N0cmljdEVxdWFsJykge1xuICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBjcmVhdGVFcnJEaWZmKGFjdHVhbCwgZXhwZWN0ZWQsIG9wZXJhdG9yKSkpO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ25vdERlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdub3RTdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgYnV0IHRoZSBvcGVyYXRvciByZXF1aXJlcyB1bmVxdWFsLCBzaG93XG4gICAgICAgIC8vIHRoZSBmaXJzdCBvYmplY3QgYW5kIHNheSBBIGVxdWFscyBCXG4gICAgICAgIHZhciBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdO1xuICAgICAgICB2YXIgcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCkuc3BsaXQoJ1xcbicpOyAvLyBJbiBjYXNlIFwiYWN0dWFsXCIgaXMgYW4gb2JqZWN0LCBpdCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZSBlcXVhbC5cblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3RTdHJpY3RFcXVhbCcgJiYgX3R5cGVvZihhY3R1YWwpID09PSAnb2JqZWN0JyAmJiBhY3R1YWwgIT09IG51bGwpIHtcbiAgICAgICAgICBiYXNlID0ga1JlYWRhYmxlT3BlcmF0b3Iubm90U3RyaWN0RXF1YWxPYmplY3Q7XG4gICAgICAgIH0gLy8gT25seSByZW1vdmUgbGluZXMgaW4gY2FzZSBpdCBtYWtlcyBzZW5zZSB0byBjb2xsYXBzZSB0aG9zZS5cbiAgICAgICAgLy8gVE9ETzogQWNjZXB0IGVudiB0byBhbHdheXMgc2hvdyB0aGUgZnVsbCBlcnJvci5cblxuXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICByZXNbMjZdID0gXCJcIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcblxuICAgICAgICAgIHdoaWxlIChyZXMubGVuZ3RoID4gMjcpIHtcbiAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gT25seSBwcmludCBhIHNpbmdsZSBpbnB1dC5cblxuXG4gICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCIgXCIpLmNvbmNhdChyZXNbMF0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoYmFzZSwgXCJcXG5cXG5cIikuY29uY2F0KHJlcy5qb2luKCdcXG4nKSwgXCJcXG5cIikpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9yZXMgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcblxuICAgICAgICB2YXIgb3RoZXIgPSAnJztcbiAgICAgICAgdmFyIGtub3duT3BlcmF0b3JzID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdO1xuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ25vdERlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdub3RFcXVhbCcpIHtcbiAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdLCBcIlxcblxcblwiKS5jb25jYXQoX3Jlcyk7XG5cbiAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCAxMDIxKSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQoaW5zcGVjdFZhbHVlKGV4cGVjdGVkKSk7XG5cbiAgICAgICAgICBpZiAoX3Jlcy5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChfcmVzLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlci5sZW5ndGggPiA1MTIpIHtcbiAgICAgICAgICAgIG90aGVyID0gXCJcIi5jb25jYXQob3RoZXIuc2xpY2UoMCwgNTA5KSwgXCIuLi5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnZGVlcEVxdWFsJyB8fCBvcGVyYXRvciA9PT0gJ2VxdWFsJykge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtub3duT3BlcmF0b3JzLCBcIlxcblxcblwiKS5jb25jYXQoX3JlcywgXCJcXG5cXG5zaG91bGQgZXF1YWxcXG5cXG5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG90aGVyID0gXCIgXCIuY29uY2F0KG9wZXJhdG9yLCBcIiBcIikuY29uY2F0KG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChfcmVzKS5jb25jYXQob3RoZXIpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gICAgX3RoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogJ0Fzc2VydGlvbkVycm9yIFtFUlJfQVNTRVJUSU9OXScsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICBfdGhpcy5hY3R1YWwgPSBhY3R1YWw7XG4gICAgX3RoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICBfdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBzdGFja1N0YXJ0Rm4pO1xuICAgIH0gLy8gQ3JlYXRlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlIGluIHRoZSBuYW1lLlxuXG5cbiAgICBfdGhpcy5zdGFjazsgLy8gUmVzZXQgdGhlIG5hbWUuXG5cbiAgICBfdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFzc2VydGlvbkVycm9yLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiIFtcIikuY29uY2F0KHRoaXMuY29kZSwgXCJdOiBcIikuY29uY2F0KHRoaXMubWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBpbnNwZWN0LmN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVjdXJzZVRpbWVzLCBjdHgpIHtcbiAgICAgIC8vIFRoaXMgbGltaXRzIHRoZSBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYCBwcm9wZXJ0eSBkZWZhdWx0IGluc3BlY3Rpb24gdG9cbiAgICAgIC8vIHRoZSBtaW5pbXVtIGRlcHRoLiBPdGhlcndpc2UgdGhvc2UgdmFsdWVzIHdvdWxkIGJlIHRvbyB2ZXJib3NlIGNvbXBhcmVkXG4gICAgICAvLyB0byB0aGUgYWN0dWFsIGVycm9yIG1lc3NhZ2Ugd2hpY2ggY29udGFpbnMgYSBjb21iaW5lZCB2aWV3IG9mIHRoZXNlIHR3b1xuICAgICAgLy8gaW5wdXQgdmFsdWVzLlxuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgY3R4LCB7XG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlLFxuICAgICAgICBkZXB0aDogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBc3NlcnRpb25FcnJvcjtcbn0oX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTM0Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4gLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4vLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcbi8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3Jcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgY29kZXMgPSB7fTsgLy8gTGF6eSBsb2FkZWRcblxudmFyIGFzc2VydDtcbnZhciB1dGlsO1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVFcnJvcik7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE5vZGVFcnJvcikuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSk7XG4gICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfQU1CSUdVT1VTX0FSR1VNRU5UJywgJ1RoZSBcIiVzXCIgYXJndW1lbnQgaXMgYW1iaWd1b3VzLiAlcycsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwOTMpO1xuICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCBcIiduYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIpOyAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IC8vIFRPRE8oQnJpZGdlQVIpOiBJbXByb3ZlIHRoZSBvdXRwdXQgYnkgc2hvd2luZyBgbnVsbGAgYW5kIHNpbWlsYXIuXG5cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KF90eXBlb2YoYWN0dWFsKSk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2lzIGludmFsaWQnO1xuICBpZiAodXRpbCA9PT0gdW5kZWZpbmVkKSB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KTtcbiAgdmFyIGluc3BlY3RlZCA9IHV0aWwuaW5zcGVjdCh2YWx1ZSk7XG5cbiAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAxMjgpIHtcbiAgICBpbnNwZWN0ZWQgPSBcIlwiLmNvbmNhdChpbnNwZWN0ZWQuc2xpY2UoMCwgMTI4KSwgXCIuLi5cIik7XG4gIH1cblxuICByZXR1cm4gXCJUaGUgYXJndW1lbnQgJ1wiLmNvbmNhdChuYW1lLCBcIicgXCIpLmNvbmNhdChyZWFzb24sIFwiLiBSZWNlaXZlZCBcIikuY29uY2F0KGluc3BlY3RlZCk7XG59LCBUeXBlRXJyb3IsIFJhbmdlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnLCBmdW5jdGlvbiAoaW5wdXQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0eXBlO1xuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgdHlwZSA9IFwiaW5zdGFuY2Ugb2YgXCIuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBcInR5cGUgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiLmNvbmNhdChpbnB1dCwgXCIgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgXFxcIlwiKS5jb25jYXQobmFtZSwgXCJcXFwiXCIpICsgXCIgZnVuY3Rpb24gYnV0IGdvdCBcIi5jb25jYXQodHlwZSwgXCIuXCIpO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01JU1NJTkdfQVJHUycsIGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkzKTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYW5kIFwiKS5jb25jYXQoYXJnc1sxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjU2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC9jb21wYXJpc29ucy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xuXG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IF9fd2VicGFja19yZXF1aXJlX18oNTk2OCk7XG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXTtcbn07XG52YXIgbnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gPyBOdW1iZXIuaXNOYU4gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4MzgpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBvYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgX3JlcXVpcmUkdHlwZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KS50eXBlcyksXG4gICAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1NykgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cblxuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoaXNOb25JbmRleCkuY29uY2F0KG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkuZmlsdGVyKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSkpKTtcbn0gLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIE9OTFlfRU5VTUVSQUJMRSA9IHVuZGVmaW5lZDtcbnZhciBrU3RyaWN0ID0gdHJ1ZTtcbnZhciBrTG9vc2UgPSBmYWxzZTtcbnZhciBrTm9JdGVyYXRvciA9IDA7XG52YXIga0lzQXJyYXkgPSAxO1xudmFyIGtJc1NldCA9IDI7XG52YXIga0lzTWFwID0gMzsgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcbi8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbi8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG4vLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4vLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXG4vL1xuLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXG4vLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4vLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxuLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbi8vXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcbi8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cblxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcblxuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXG4gICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XG4gIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgLy8gd2FuJ3QgdG8gZWFybHkgcmV0dXJuIG91dCBvZiB0aGUgcmVzdCBvZiB0aGUgY2hlY2tzLiBIb3dldmVyIHdlIGNhbiBjaGVja1xuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEYXRlKHZhbDEpKSB7XG4gICAgaWYgKCFpc0RhdGUodmFsMikgfHwgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDEpICE9PSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgIC8vIGlzIG90aGVyd2lzZSBpZGVudGljYWwuXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XG4gICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cblxuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoX2tleXMubGVuZ3RoICE9PSBfa2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcCk7XG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgIGlmICghYXJlRXF1YWxBcnJheUJ1ZmZlcnModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWwxKSAmJiAhaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcbiAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcblxuICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBVc2UgbWVtb3MgdG8gaGFuZGxlIGN5Y2xlcy5cblxuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG5cbiAgICBpZiAodmFsMk1lbW9BICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcblxuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG5cbiAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pO1xuICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbik7XG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcbiAgbWVtb3MudmFsMS5kZWxldGUodmFsMSk7XG4gIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpO1xuICByZXR1cm4gYXJlRXE7XG59XG5cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG5cbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XG4gIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwcmltID0gK3ByaW07XG4gICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG5cbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYWx0VmFsdWU7XG4gIH1cblxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcblxuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXG4gICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuXG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAhYS5oYXMoX3ZhbCkgJiYgIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRvIGJlIGFibGUgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAga2V5ID0gX2FFbnRyaWVzJGlbMF0sXG4gICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG5cbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlIHdlIHByZXZlbnQgYW5vdGhlciBiLmhhcyhrZXkpIGNoZWNrIGluXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KTtcblxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KGtleSksIGl0ZW0sIGZhbHNlLCBtZW1vKSkgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG5cbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzQVtpXTtcblxuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gIGlzRGVlcFN0cmljdEVxdWFsOiBpc0RlZXBTdHJpY3RFcXVhbFxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDk4MTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG5cbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODQ5ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMzgpO1xudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcbnZhciBzZXRGdW5jdGlvbkxlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEwOCk7XG5cbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NDApO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ2luYWxGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdhIGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XG5cdH1cblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRyZXR1cm4gc2V0RnVuY3Rpb25MZW5ndGgoXG5cdFx0ZnVuYyxcblx0XHQxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpLFxuXHRcdHRydWVcblx0KTtcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDM2NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpXG52YXIgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkzKVxuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgfVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbnZhciBjb25zb2xlXG52YXIgdGltZXMgPSB7fVxuXG5pZiAodHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18uZyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuY29uc29sZVxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlKSB7XG4gICAgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlXG59IGVsc2Uge1xuICAgIGNvbnNvbGUgPSB7fVxufVxuXG52YXIgZnVuY3Rpb25zID0gW1xuICAgIFtsb2csIFwibG9nXCJdLFxuICAgIFtpbmZvLCBcImluZm9cIl0sXG4gICAgW3dhcm4sIFwid2FyblwiXSxcbiAgICBbZXJyb3IsIFwiZXJyb3JcIl0sXG4gICAgW3RpbWUsIFwidGltZVwiXSxcbiAgICBbdGltZUVuZCwgXCJ0aW1lRW5kXCJdLFxuICAgIFt0cmFjZSwgXCJ0cmFjZVwiXSxcbiAgICBbZGlyLCBcImRpclwiXSxcbiAgICBbY29uc29sZUFzc2VydCwgXCJhc3NlcnRcIl1cbl1cblxuZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBmdW5jdGlvbnNbaV1cbiAgICB2YXIgZiA9IHR1cGxlWzBdXG4gICAgdmFyIG5hbWUgPSB0dXBsZVsxXVxuXG4gICAgaWYgKCFjb25zb2xlW25hbWVdKSB7XG4gICAgICAgIGNvbnNvbGVbbmFtZV0gPSBmXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVcblxuZnVuY3Rpb24gbG9nKCkge31cblxuZnVuY3Rpb24gaW5mbygpIHtcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB0aW1lKGxhYmVsKSB7XG4gICAgdGltZXNbbGFiZWxdID0gbm93KClcbn1cblxuZnVuY3Rpb24gdGltZUVuZChsYWJlbCkge1xuICAgIHZhciB0aW1lID0gdGltZXNbbGFiZWxdXG4gICAgaWYgKCF0aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggbGFiZWw6IFwiICsgbGFiZWwpXG4gICAgfVxuXG4gICAgZGVsZXRlIHRpbWVzW2xhYmVsXVxuICAgIHZhciBkdXJhdGlvbiA9IG5vdygpIC0gdGltZVxuICAgIGNvbnNvbGUubG9nKGxhYmVsICsgXCI6IFwiICsgZHVyYXRpb24gKyBcIm1zXCIpXG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKVxuICAgIGVyci5uYW1lID0gXCJUcmFjZVwiXG4gICAgZXJyLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spXG59XG5cbmZ1bmN0aW9uIGRpcihvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qob2JqZWN0KSArIFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVBc3NlcnQoZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgYXJyID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJyKSlcbiAgICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0MCk7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3MzEpO1xudmFyICRUeXBlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjgpO1xuXG52YXIgZ29wZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMzNik7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZURhdGFQcm9wZXJ0eShcblx0b2JqLFxuXHRwcm9wZXJ0eSxcblx0dmFsdWVcbikge1xuXHRpZiAoIW9iaiB8fCAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG9iamAgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbmAnKTtcblx0fVxuXHRpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcGVydHkgIT09ICdzeW1ib2wnKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bwcm9wZXJ0eWAgbXVzdCBiZSBhIHN0cmluZyBvciBhIHN5bWJvbGAnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1szXSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uRW51bWVyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIHR5cGVvZiBhcmd1bWVudHNbNF0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNF0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbldyaXRhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgdHlwZW9mIGFyZ3VtZW50c1s1XSAhPT0gJ2Jvb2xlYW4nICYmIGFyZ3VtZW50c1s1XSAhPT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbm9uQ29uZmlndXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGwnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgdHlwZW9mIGFyZ3VtZW50c1s2XSAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bsb29zZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIG5vbkVudW1lcmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cdHZhciBub25Xcml0YWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblx0dmFyIG5vbkNvbmZpZ3VyYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogbnVsbDtcblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgPyBhcmd1bWVudHNbNl0gOiBmYWxzZTtcblxuXHQvKiBAdHlwZSB7ZmFsc2UgfCBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjx1bmtub3duPn0gKi9cblx0dmFyIGRlc2MgPSAhIWdvcGQgJiYgZ29wZChvYmosIHByb3BlcnR5KTtcblxuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcGVydHksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogbm9uQ29uZmlndXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmNvbmZpZ3VyYWJsZSA6ICFub25Db25maWd1cmFibGUsXG5cdFx0XHRlbnVtZXJhYmxlOiBub25FbnVtZXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmVudW1lcmFibGUgOiAhbm9uRW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiBub25Xcml0YWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy53cml0YWJsZSA6ICFub25Xcml0YWJsZVxuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGxvb3NlIHx8ICghbm9uRW51bWVyYWJsZSAmJiAhbm9uV3JpdGFibGUgJiYgIW5vbkNvbmZpZ3VyYWJsZSkpIHtcblx0XHQvLyBtdXN0IGZhbGwgYmFjayB0byBbW1NldF1dLCBhbmQgd2FzIG5vdCBleHBsaWNpdGx5IGFza2VkIHRvIG1ha2Ugbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWNvbmZpZ3VyYWJsZVxuXHRcdG9ialtwcm9wZXJ0eV0gPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBkZWZpbmluZyBhIHByb3BlcnR5IGFzIG5vbi1jb25maWd1cmFibGUsIG5vbi13cml0YWJsZSwgb3Igbm9uLWVudW1lcmFibGUuJyk7XG5cdH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE4NTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjI4KTtcbnZhciBoYXNTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sKCdmb28nKSA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBkZWZpbmVEYXRhUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4Nik7XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIzOSkoKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUsIHByZWRpY2F0ZSkge1xuXHRpZiAobmFtZSBpbiBvYmplY3QpIHtcblx0XHRpZiAocHJlZGljYXRlID09PSB0cnVlKSB7XG5cdFx0XHRpZiAob2JqZWN0W25hbWVdID09PSB2YWx1ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaXNGdW5jdGlvbihwcmVkaWNhdGUpIHx8ICFwcmVkaWNhdGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0ZGVmaW5lRGF0YVByb3BlcnR5KG9iamVjdCwgbmFtZSwgdmFsdWUsIHRydWUpO1xuXHR9IGVsc2Uge1xuXHRcdGRlZmluZURhdGFQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHZhbHVlKTtcblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDk0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NzI5OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZXZhbCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFdmFsRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4Mzg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE1NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5NDM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWYnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU3MzE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zeW50YXgnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gU3ludGF4RXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjE0MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VyaScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBVUklFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzA0Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGFzc2lnblxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnbixcbiAgcG9seWZpbGw6IHBvbHlmaWxsXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjE3KTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc5NDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbnZhciBjb25jYXR0eSA9IGZ1bmN0aW9uIGNvbmNhdHR5KGEsIGIpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGFycltqICsgYS5sZW5ndGhdID0gYltqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIHNsaWN5ID0gZnVuY3Rpb24gc2xpY3koYXJyTGlrZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQgfHwgMCwgaiA9IDA7IGkgPCBhcnJMaWtlLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgICAgYXJyW2pdID0gYXJyTGlrZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBqb2lueSA9IGZ1bmN0aW9uIChhcnIsIGpvaW5lcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYXJyW2ldO1xuICAgICAgICBpZiAoaSArIDEgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHIgKz0gam9pbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmFwcGx5KHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY3koYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICApO1xuXG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzW2ldID0gJyQnICsgaTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgam9pbnkoYm91bmRBcmdzLCAnLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODc5NCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTgzOCk7XG52YXIgJEV2YWxFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcyOSk7XG52YXIgJFJhbmdlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNTUpO1xudmFyICRSZWZlcmVuY2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0Myk7XG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcbnZhciAkVVJJRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNDApO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1NTgpKCk7XG52YXIgaGFzUHJvdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NjkpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogJEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6ICRFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogJFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogJFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiAkVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTQpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTMzNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzIzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0MCk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0cmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1NTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MDgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTA4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTEzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkwOCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1NTQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgJGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEzOCk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChjYWxsLCAkaGFzT3duKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYxNTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xudmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxOCk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2MTc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgZGRhQ2xhc3MgPSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nOyAvLyBJRSAxMVxudmFyIGRkYUNsYXNzMiA9ICdbb2JqZWN0IEhUTUwgZG9jdW1lbnQuYWxsIGNsYXNzXSc7XG52YXIgZGRhQ2xhc3MzID0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJzsgLy8gSUUgOS0xMFxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2BcblxudmFyIGlzSUU2OCA9ICEoMCBpbiBbLF0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNwYXJzZS1hcnJheXMsIGNvbW1hLXNwYWNpbmdcblxudmFyIGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcpIHtcblx0Ly8gRmlyZWZveCAzIGNhbm9uaWNhbGl6ZXMgRERBIHRvIHVuZGVmaW5lZCB3aGVuIGl0J3Mgbm90IGFjY2Vzc2VkIGRpcmVjdGx5XG5cdHZhciBhbGwgPSBkb2N1bWVudC5hbGw7XG5cdGlmICh0b1N0ci5jYWxsKGFsbCkgPT09IHRvU3RyLmNhbGwoZG9jdW1lbnQuYWxsKSkge1xuXHRcdGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCh2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFscyBkb2N1bWVudDogZmFsc2UgKi9cblx0XHRcdC8vIGluIElFIDYtOCwgdHlwZW9mIGRvY3VtZW50LmFsbCBpcyBcIm9iamVjdFwiIGFuZCBpdCdzIHRydXRoeVxuXHRcdFx0aWYgKChpc0lFNjggfHwgIXZhbHVlKSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0c3RyID09PSBkZGFDbGFzc1xuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczJcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MzIC8vIG9wZXJhIDEyLjE2XG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IG9iamVjdENsYXNzIC8vIElFIDYtOFxuXHRcdFx0XHRcdCkgJiYgdmFsdWUoJycpID09IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJlZmxlY3RBcHBseSh2YWx1ZSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpICYmIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRpZiAoc3RyQ2xhc3MgIT09IGZuQ2xhc3MgJiYgc3RyQ2xhc3MgIT09IGdlbkNsYXNzICYmICEoL15cXFtvYmplY3QgSFRNTC8pLnRlc3Qoc3RyQ2xhc3MpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODAwNjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzgzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDk4KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkxKTtcbnZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQxKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY0MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1Nyk7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OTEpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5NDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MzApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRyZXR1cm4gISF3aGljaFR5cGVkQXJyYXkodmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjM3Mjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTY4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODU3KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjM3Mik7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MzcpO1xudmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwODcpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTM3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNzIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTA4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTM3KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTYwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTIyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oOTY4KTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNjApO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk5MDc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTA4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjg2KTtcbnZhciBoYXNEZXNjcmlwdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIzOSkoKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICRUeXBlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjgpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldEZ1bmN0aW9uTGVuZ3RoKGZuLCBsZW5ndGgpIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gMHhGRkZGRkZGRiB8fCAkZmxvb3IobGVuZ3RoKSAhPT0gbGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BsZW5ndGhgIG11c3QgYmUgYSBwb3NpdGl2ZSAzMi1iaXQgaW50ZWdlcicpO1xuXHR9XG5cblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgISFhcmd1bWVudHNbMl07XG5cblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSB0cnVlO1xuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gdHJ1ZTtcblx0aWYgKCdsZW5ndGgnIGluIGZuICYmIGdPUEQpIHtcblx0XHR2YXIgZGVzYyA9IGdPUEQoZm4sICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2Mud3JpdGFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlIHx8IGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSB8fCAhbG9vc2UpIHtcblx0XHRpZiAoaGFzRGVzY3JpcHRvcnMpIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxMjU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZVNlcnZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VTZXJ2aWNlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzc3MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDQxKTtcbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5cbmNsYXNzIEJhc2VTZXJ2aWNlIHtcbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCBkb2N1bWVudC50ZXh0KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50c1t1cmldO1xuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuYW1lRG9jdW1lbnQoZG9jdW1lbnQsIG5ld0RvY3VtZW50VXJpKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGRvY3VtZW50LnVyaSk7XG4gICAgICAgIHRoaXMuYWRkRG9jdW1lbnQoe1xuICAgICAgICAgICAgdXJpOiBuZXdEb2N1bWVudFVyaSxcbiAgICAgICAgICAgIHZlcnNpb246IHByZXZpb3VzRG9jdW1lbnQudmVyc2lvbixcbiAgICAgICAgICAgIGxhbmd1YWdlSWQ6IHByZXZpb3VzRG9jdW1lbnQubGFuZ3VhZ2VJZCxcbiAgICAgICAgICAgIHRleHQ6IHByZXZpb3VzRG9jdW1lbnQuZ2V0VGV4dCgpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnNbbmV3RG9jdW1lbnRVcmldID0gdGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV07XG4gICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudFZhbHVlKHVyaSkge1xuICAgICAgICB2YXIgX3RoaXNfZ2V0RG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiAoX3RoaXNfZ2V0RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KHVyaSkpID09PSBudWxsIHx8IF90aGlzX2dldERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19nZXREb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgfVxuICAgIHNldFZhbHVlKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50ID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgIH1cbiAgICBzZXRXb3Jrc3BhY2Uod29ya3NwYWNlVXJpKSB7XG4gICAgICAgIHRoaXMud29ya3NwYWNlVXJpID0gd29ya3NwYWNlVXJpO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKGRvY3VtZW50VXJpLCBvcHRpb25zLCBtZXJnZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1tkb2N1bWVudFVyaV0gPSBtZXJnZSA/ICgwLF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLyogLm1lcmdlT2JqZWN0cyAqLyAuckwpKG9wdGlvbnMsIHRoaXMub3B0aW9uc1tkb2N1bWVudFVyaV0pIDogb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0T3B0aW9uKGRvY3VtZW50VXJpLCBvcHRpb25OYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldICYmIHRoaXMub3B0aW9uc1tkb2N1bWVudFVyaV1bb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldW29wdGlvbk5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseURlbHRhcyhpZGVudGlmaWVyLCBkZWx0YXMpIHtcbiAgICAgICAgbGV0IGRvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudChpZGVudGlmaWVyLnVyaSk7XG4gICAgICAgIGlmIChkb2N1bWVudCkgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi51cGRhdGUoZG9jdW1lbnQsIGRlbHRhcywgaWRlbnRpZmllci52ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvSW5saW5lQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZmluZERvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MoKSB7XG4gICAgICAgIHZhciBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSwgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvckNvZGVzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvckNvZGVzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb0lnbm9yZTogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNlbWFudGljVG9rZW5zKGRvY3VtZW50LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRDb2RlQWN0aW9ucyhkb2N1bWVudCwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgZXhlY3V0ZUNvbW1hbmQoY29tbWFuZCwgYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBzZW5kQXBwbGllZFJlc3VsdChyZXN1bHQsIGNhbGxiYWNrSWQpIHt9XG4gICAgc2VuZFJlcXVlc3QobmFtZSwgYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBzZW5kUmVzcG9uc2UoY2FsbGJhY2tJZCwgYXJncykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1vZGUsIHdvcmtzcGFjZVVyaSl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlTmFtZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwibW9kZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiZG9jdW1lbnRzXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiZ2xvYmFsT3B0aW9uc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlRGF0YVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZUNhcGFiaWxpdGllc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ3b3Jrc3BhY2VVcmlcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNsaWVudENhcGFiaWxpdGllc1wiLCB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICBkaWFnbm9zdGljOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWREb2N1bWVudFN1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHB1Ymxpc2hEaWFnbm9zdGljczoge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGVkSW5mb3JtYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25TdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnU3VwcG9ydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5EaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkRpYWdub3N0aWNUYWcuRGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50Rm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWludGV4dCdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3luY2hyb25pemF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbGxTYXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGlkU2F2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdpbGxTYXZlV2FpdFVudGlsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZzoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25JdGVtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbmlwcGV0U3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdENoYXJhY3RlcnNTdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb25Gb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFpbnRleHQnXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlZFN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VsZWN0U3VwcG9ydDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFN1cHBvcnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVIZWxwOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUluZm9ybWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uRm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGxhaW50ZXh0J1xuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVBhcmFtZXRlclN1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRIaWdobGlnaHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VtYW50aWNUb2tlbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lVG9rZW5TdXBwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdUb2tlblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5Nb2RpZmllcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhdWdtZW50c1N5bnRheFRva2VuczogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29kZUFjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmxpbmVDb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2luZG93OiB7XG4gICAgICAgICAgICAgICAgc2hvd0RvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICAgICAgZGlkQ2hhbmdlQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGVjdXRlQ29tbWFuZDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcHBseUVkaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdDoge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlSGFuZGxpbmc6IFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplc0xpbmVFbmRpbmdzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMud29ya3NwYWNlVXJpID0gd29ya3NwYWNlVXJpO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gXCJCYXNlU2VydmljZVwiO1xuICAgICAgICB0aGlzLnNlcnZpY2VEYXRhID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhc2VTZXJ2aWNlXCIsXG4gICAgICAgICAgICBtb2RlczogXCJcIixcbiAgICAgICAgICAgIG1vZHVsZTogKCk9Pnt9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NzcwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJMOiAoKSA9PiAoLyogYmluZGluZyAqLyBtZXJnZU9iamVjdHMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydHMgbm90RW1wdHksIGlzRW1wdHlSYW5nZSwgbWVyZ2VSYW5nZXMsIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXksIGNvbnZlcnRUb1VyaSAqL1xuXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMob2JqMSwgb2JqMiwgZXhjbHVkZVVuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgaWYgKCFvYmoxKSByZXR1cm4gb2JqMjtcbiAgICBpZiAoIW9iajIpIHJldHVybiBvYmoxO1xuICAgIGlmIChleGNsdWRlVW5kZWZpbmVkKSB7XG4gICAgICAgIG9iajEgPSBleGNsdWRlVW5kZWZpbmVkVmFsdWVzKG9iajEpO1xuICAgICAgICBvYmoyID0gZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyhvYmoyKTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkT2JqZWN0cyA9IHtcbiAgICAgICAgLi4ub2JqMixcbiAgICAgICAgLi4ub2JqMVxuICAgIH07IC8vIEdpdmUgcHJpb3JpdHkgdG8gb2JqMSB2YWx1ZXMgYnkgc3ByZWFkaW5nIG9iajIgZmlyc3QsIHRoZW4gb2JqMVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1lcmdlZE9iamVjdHMpKXtcbiAgICAgICAgaWYgKG9iajFba2V5XSAmJiBvYmoyW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iajFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBvYmoxW2tleV0uY29uY2F0KG9iajJba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqMltrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9iamVjdHNba2V5XSA9IG9iajJba2V5XS5jb25jYXQob2JqMVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iajFba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajJba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBtZXJnZU9iamVjdHMob2JqMVtrZXldLCBvYmoyW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRPYmplY3RzO1xufVxuZnVuY3Rpb24gZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyhvYmopIHtcbiAgICBjb25zdCBmaWx0ZXJlZEVudHJpZXMgPSBPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW18sIHZhbHVlXSk9PnZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZmlsdGVyZWRFbnRyaWVzKTtcbn1cbmZ1bmN0aW9uIG5vdEVtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0VtcHR5UmFuZ2UocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2Uuc3RhcnQucm93ID09PSByYW5nZS5lbmQucm93ICYmIHJhbmdlLnN0YXJ0LmNvbHVtbiA9PT0gcmFuZ2UuZW5kLmNvbHVtbjtcbn1cbi8vdGFrZW4gd2l0aCBzbWFsbCBjaGFuZ2VzIGZyb20gYWNlLWNvZGVcbmZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHJhbmdlcykge1xuICAgIHZhciBsaXN0ID0gcmFuZ2VzO1xuICAgIGxpc3QgPSBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgICB9KTtcbiAgICB2YXIgbmV4dCA9IGxpc3RbMF0sIHJhbmdlO1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmFuZ2UgPSBuZXh0O1xuICAgICAgICBuZXh0ID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LnN0YXJ0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY21wID09IDAgJiYgIWlzRW1wdHlSYW5nZShyYW5nZSkgJiYgIWlzRW1wdHlSYW5nZShuZXh0KSkgY29udGludWU7XG4gICAgICAgIGlmIChjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5lbmQpIDwgMCkge1xuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IG5leHQuZW5kLnJvdztcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBuZXh0LmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG5leHQgPSByYW5nZTtcbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVQb2ludHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyAtIHAyLnJvdyB8fCBwMS5jb2x1bW4gLSBwMi5jb2x1bW47XG59XG5mdW5jdGlvbiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5KHZhbHVlLCByZWdleHBBcnJheSkge1xuICAgIGlmICghcmVnZXhwQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcmVnZXhwQXJyYXkubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAocmVnZXhwQXJyYXlbaV0udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1VyaShmaWxlUGF0aCkge1xuICAgIC8vYWxyZWFkeSBVUklcbiAgICBpZiAoZmlsZVBhdGguc3RhcnRzV2l0aChcImZpbGU6Ly8vXCIpKSB7XG4gICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIFVSSS5maWxlKGZpbGVQYXRoKS50b1N0cmluZygpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjcyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mzg3KTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjI1KTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MzApO1xudmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk0Myk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG4vLyBTdG9yZSBhIGNvcHkgb2YgU2hhcmVkQXJyYXlCdWZmZXIgaW4gY2FzZSBpdCdzIGRlbGV0ZWQgZWxzZXdoZXJlXG52YXIgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IFNoYXJlZEFycmF5QnVmZmVyIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODI3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zbGljZSgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMxKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTI3Mik7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYxNSk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MjA4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMTA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMxMik7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcyKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzIpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMzEyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcyKTtcbmNsYXNzIE1lc3NhZ2VCdWZmZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuYXNjaWlEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICAgIH1cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXI7XG4gICAgfVxuICAgIGZyb21TdHJpbmcodmFsdWUsIF9lbmNvZGluZykge1xuICAgICAgICByZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc2NpaURlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc05hdGl2ZShidWZmZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NOYXRpdmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH1cbn1cbk1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBhcGlfMS5SQUwpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgYXBpXzEuUkFMLmluc3RhbGwoX3JpbCk7XG4gICAgfVxuICAgIFJJTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJJTCB8fCAoUklMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUklMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjcyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvdGhlbmFibGUuZC50c1wiIC8+XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5Ub3VjaCA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuUkFMID0gdm9pZCAwO1xuZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk1lc3NhZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNlRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2Rlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuRXJyb3JDb2RlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzOyB9IH0pKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTA5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZE1hcFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxpbmtlZE1hcDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMUlVDYWNoZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxSVUNhY2hlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvdWNoXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuVG91Y2g7IH0gfSkpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODQ0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3Bvc2FibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZTsgfSB9KSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkV2ZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtaXR0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FbWl0dGVyOyB9IH0pKTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuU291cmNlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KSk7XG5jb25zdCBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDg5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVJlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5NZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5BYnN0cmFjdE1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlV3JpdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5NZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VCdWZmZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTgwNSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VCdWZmZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlQnVmZmVyXzEuQWJzdHJhY3RNZXNzYWdlQnVmZmVyOyB9IH0pKTtcbmNvbnN0IGNvbm5lY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDA1NCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25PcHRpb25zXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25PcHRpb25zOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxMb2dnZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTnVsbExvZ2dlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc1Rva2VuXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlByb2dyZXNzVG9rZW47IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlByb2dyZXNzVHlwZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZVZhbHVlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZVZhbHVlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZUZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZUZvcm1hdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXRUcmFjZU5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5TZXRUcmFjZU5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dUcmFjZU5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Mb2dUcmFjZU5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uRXJyb3JzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25FcnJvcnM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25FcnJvcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk1lc3NhZ2VTdHJhdGVneTsgfSB9KSk7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5leHBvcnRzLlJBTCA9IHJhbF8xLmRlZmF1bHQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5NTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmVcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXG4gICAgICAgICAgICB8fCAoSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpICYmICEhY2FuZGlkYXRlLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25Ub2tlbiB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IENhbmNlbGxhdGlvblRva2VuID0ge30pKTtcbmNvbnN0IHNob3J0Y3V0RXZlbnQgPSBPYmplY3QuZnJlZXplKGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGNvbnN0IGhhbmRsZSA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoY2FsbGJhY2suYmluZChjb250ZXh0KSwgMCk7XG4gICAgcmV0dXJuIHsgZGlzcG9zZSgpIHsgaGFuZGxlLmRpc3Bvc2UoKTsgfSB9O1xufSk7XG5jbGFzcyBNdXRhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDYW5jZWxsZWQ7XG4gICAgfVxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvcnRjdXRFdmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGdldCB0b2tlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gYmUgbGF6eSBhbmQgY3JlYXRlIHRoZSB0b2tlbiBvbmx5IHdoZW5cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IG5lZWRlZFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gY2FuY2VsbGVkIHRva2VuIHdoZW4gY2FuY2VsbGF0aW9uIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGJlZm9yZSBzb21lb25lIGFza3MgZm9yIHRoZSB0b2tlblxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2tlbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdG8gaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHRva2VuIGlmIHdlIGhhZCBub25lXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpc3Bvc2VcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDA1NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLk1lc3NhZ2VTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyA9IGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNldFRyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5UcmFjZUZvcm1hdCA9IGV4cG9ydHMuVHJhY2VWYWx1ZXMgPSBleHBvcnRzLlRyYWNlID0gZXhwb3J0cy5OdWxsTG9nZ2VyID0gZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBleHBvcnRzLlByb2dyZXNzVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTYyKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTA5KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU3KTtcbnZhciBDYW5jZWxOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKENhbmNlbE5vdGlmaWNhdGlvbikge1xuICAgIENhbmNlbE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9jYW5jZWxSZXF1ZXN0Jyk7XG59KShDYW5jZWxOb3RpZmljYXRpb24gfHwgKENhbmNlbE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgUHJvZ3Jlc3NUb2tlbjtcbihmdW5jdGlvbiAoUHJvZ3Jlc3NUb2tlbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuICAgIFByb2dyZXNzVG9rZW4uaXMgPSBpcztcbn0pKFByb2dyZXNzVG9rZW4gfHwgKGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IFByb2dyZXNzVG9rZW4gPSB7fSkpO1xudmFyIFByb2dyZXNzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChQcm9ncmVzc05vdGlmaWNhdGlvbikge1xuICAgIFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL3Byb2dyZXNzJyk7XG59KShQcm9ncmVzc05vdGlmaWNhdGlvbiB8fCAoUHJvZ3Jlc3NOb3RpZmljYXRpb24gPSB7fSkpO1xuY2xhc3MgUHJvZ3Jlc3NUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzVHlwZSA9IFByb2dyZXNzVHlwZTtcbnZhciBTdGFyUmVxdWVzdEhhbmRsZXI7XG4oZnVuY3Rpb24gKFN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJcy5mdW5jKHZhbHVlKTtcbiAgICB9XG4gICAgU3RhclJlcXVlc3RIYW5kbGVyLmlzID0gaXM7XG59KShTdGFyUmVxdWVzdEhhbmRsZXIgfHwgKFN0YXJSZXF1ZXN0SGFuZGxlciA9IHt9KSk7XG5leHBvcnRzLk51bGxMb2dnZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogKCkgPT4geyB9LFxuICAgIHdhcm46ICgpID0+IHsgfSxcbiAgICBpbmZvOiAoKSA9PiB7IH0sXG4gICAgbG9nOiAoKSA9PiB7IH1cbn0pO1xudmFyIFRyYWNlO1xuKGZ1bmN0aW9uIChUcmFjZSkge1xuICAgIFRyYWNlW1RyYWNlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xuICAgIFRyYWNlW1RyYWNlW1wiTWVzc2FnZXNcIl0gPSAxXSA9IFwiTWVzc2FnZXNcIjtcbiAgICBUcmFjZVtUcmFjZVtcIkNvbXBhY3RcIl0gPSAyXSA9IFwiQ29tcGFjdFwiO1xuICAgIFRyYWNlW1RyYWNlW1wiVmVyYm9zZVwiXSA9IDNdID0gXCJWZXJib3NlXCI7XG59KShUcmFjZSB8fCAoZXhwb3J0cy5UcmFjZSA9IFRyYWNlID0ge30pKTtcbnZhciBUcmFjZVZhbHVlcztcbihmdW5jdGlvbiAoVHJhY2VWYWx1ZXMpIHtcbiAgICAvKipcbiAgICAgKiBUdXJuIHRyYWNpbmcgb2ZmLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLk9mZiA9ICdvZmYnO1xuICAgIC8qKlxuICAgICAqIFRyYWNlIG1lc3NhZ2VzIG9ubHkuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuTWVzc2FnZXMgPSAnbWVzc2FnZXMnO1xuICAgIC8qKlxuICAgICAqIENvbXBhY3QgbWVzc2FnZSB0cmFjaW5nLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLkNvbXBhY3QgPSAnY29tcGFjdCc7XG4gICAgLyoqXG4gICAgICogVmVyYm9zZSBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuVmVyYm9zZSA9ICd2ZXJib3NlJztcbn0pKFRyYWNlVmFsdWVzIHx8IChleHBvcnRzLlRyYWNlVmFsdWVzID0gVHJhY2VWYWx1ZXMgPSB7fSkpO1xuKGZ1bmN0aW9uIChUcmFjZSkge1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCFJcy5zdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnb2ZmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICAgICAgY2FzZSAnbWVzc2FnZXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5NZXNzYWdlcztcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBhY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5Db21wYWN0O1xuICAgICAgICAgICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLlZlcmJvc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2UuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5PZmY6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5NZXNzYWdlczpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21lc3NhZ2VzJztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuQ29tcGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NvbXBhY3QnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5WZXJib3NlOlxuICAgICAgICAgICAgICAgIHJldHVybiAndmVyYm9zZSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZS50b1N0cmluZyA9IHRvU3RyaW5nO1xufSkoVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSBUcmFjZSA9IHt9KSk7XG52YXIgVHJhY2VGb3JtYXQ7XG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XG4gICAgVHJhY2VGb3JtYXRbXCJUZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgVHJhY2VGb3JtYXRbXCJKU09OXCJdID0gXCJqc29uXCI7XG59KShUcmFjZUZvcm1hdCB8fCAoZXhwb3J0cy5UcmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0ID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2VGb3JtYXQpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LkpTT047XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZUZvcm1hdC5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbn0pKFRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQgPSB7fSkpO1xudmFyIFNldFRyYWNlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTZXRUcmFjZU5vdGlmaWNhdGlvbikge1xuICAgIFNldFRyYWNlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL3NldFRyYWNlJyk7XG59KShTZXRUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IFNldFRyYWNlTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBMb2dUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoTG9nVHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9sb2dUcmFjZScpO1xufSkoTG9nVHJhY2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuTG9nVHJhY2VOb3RpZmljYXRpb24gPSBMb2dUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbkVycm9ycztcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkVycm9ycykge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJDbG9zZWRcIl0gPSAxXSA9IFwiQ2xvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkRpc3Bvc2VkXCJdID0gMl0gPSBcIkRpc3Bvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBpbiBsaXN0ZW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJBbHJlYWR5TGlzdGVuaW5nXCJdID0gM10gPSBcIkFscmVhZHlMaXN0ZW5pbmdcIjtcbn0pKENvbm5lY3Rpb25FcnJvcnMgfHwgKGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyA9IENvbm5lY3Rpb25FcnJvcnMgPSB7fSkpO1xuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDb25uZWN0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbnZhciBDb25uZWN0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNhbmNlbFVuZGlzcGF0Y2hlZCk7XG4gICAgfVxuICAgIENvbm5lY3Rpb25TdHJhdGVneS5pcyA9IGlzO1xufSkoQ29ubmVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IENvbm5lY3Rpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUua2luZCA9PT0gJ2lkJykgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UpICYmIChjYW5kaWRhdGUuZGlzcG9zZSA9PT0gdW5kZWZpbmVkIHx8IElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpKTtcbiAgICB9XG4gICAgSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlcXVlc3QnICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKSAmJiAoY2FuZGlkYXRlLmRpc3Bvc2UgPT09IHVuZGVmaW5lZCB8fCBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSk7XG4gICAgfVxuICAgIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5SZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5NZXNzYWdlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXModmFsdWUpIHx8IFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKHZhbHVlKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZW5kQ2FuY2VsbGF0aW9uKGNvbm4sIGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubi5zZW5kTm90aWZpY2F0aW9uKENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLCB7IGlkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwKF8pIHsgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLnNlbmRDYW5jZWxsYXRpb24pICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNsZWFudXApO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICByZWNlaXZlcjogQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5NZXNzYWdlLFxuICAgICAgICBzZW5kZXI6IENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2VcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5yZWNlaXZlcikgJiYgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnNlbmRlcik7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IENhbmNlbGxhdGlvblN0cmF0ZWd5ID0ge30pKTtcbnZhciBNZXNzYWdlU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKE1lc3NhZ2VTdHJhdGVneSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmhhbmRsZU1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlU3RyYXRlZ3kuaXMgPSBpcztcbn0pKE1lc3NhZ2VTdHJhdGVneSB8fCAoZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBNZXNzYWdlU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChDYW5jZWxsYXRpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY2FuY2VsbGF0aW9uU3RyYXRlZ3kpIHx8IENvbm5lY3Rpb25TdHJhdGVneS5pcyhjYW5kaWRhdGUuY29ubmVjdGlvblN0cmF0ZWd5KSB8fCBNZXNzYWdlU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLm1lc3NhZ2VTdHJhdGVneSkpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoQ29ubmVjdGlvbk9wdGlvbnMgfHwgKGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBDb25uZWN0aW9uT3B0aW9ucyA9IHt9KSk7XG52YXIgQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTmV3XCJdID0gMV0gPSBcIk5ld1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJMaXN0ZW5pbmdcIl0gPSAyXSA9IFwiTGlzdGVuaW5nXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkNsb3NlZFwiXSA9IDNdID0gXCJDbG9zZWRcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiRGlzcG9zZWRcIl0gPSA0XSA9IFwiRGlzcG9zZWRcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKG1lc3NhZ2VSZWFkZXIsIG1lc3NhZ2VXcml0ZXIsIF9sb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBfbG9nZ2VyICE9PSB1bmRlZmluZWQgPyBfbG9nZ2VyIDogZXhwb3J0cy5OdWxsTG9nZ2VyO1xuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgbGV0IG5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgdW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGNvbnN0IHZlcnNpb24gPSAnMi4wJztcbiAgICBsZXQgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvZ3Jlc3NIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdGltZXI7XG4gICAgbGV0IG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICBsZXQgcmVzcG9uc2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgIGxldCByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgIGxldCB0cmFjZSA9IFRyYWNlLk9mZjtcbiAgICBsZXQgdHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdC5UZXh0O1xuICAgIGxldCB0cmFjZXI7XG4gICAgbGV0IHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLk5ldztcbiAgICBjb25zdCBlcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBkaXNwb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNhbmNlbGxhdGlvblN0cmF0ZWd5KSA/IG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kgOiBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2VuZCByZXF1ZXN0cyB3aXRoIGlkIG51bGwgc2luY2UgdGhlIHJlc3BvbnNlIGNhbid0IGJlIGNvcnJlbGF0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdyZXEtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy11bmtub3duLScgKyAoKyt1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLScgKyBpZC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCkge1xuICAgICAgICByZXR1cm4gJ25vdC0nICsgKCsrbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE1lc3NhZ2VUb1F1ZXVlKHF1ZXVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KG1lc3NhZ2UuaWQpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbFVuZGlzcGF0Y2hlZChfbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpc3RlbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VIYW5kbGVyKCkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5OZXcgfHwgc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZDtcbiAgICAgICAgICAgIGNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gaXMgZGlzcG9zZWQgZG9uJ3Qgc2VudCBjbG9zZSBldmVudHMuXG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoW2Vycm9yLCB1bmRlZmluZWQsIHVuZGVmaW5lZF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUVycm9ySGFuZGxlcihkYXRhKSB7XG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKGRhdGEpO1xuICAgIH1cbiAgICBtZXNzYWdlUmVhZGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlUmVhZGVyLm9uRXJyb3IocmVhZEVycm9ySGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkVycm9yKHdyaXRlRXJyb3JIYW5kbGVyKTtcbiAgICBmdW5jdGlvbiB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAodGltZXIgfHwgbWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHByb2Nlc3NNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAobWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyYXRlZ3kgPSBvcHRpb25zPy5tZXNzYWdlU3RyYXRlZ3k7XG4gICAgICAgICAgICBpZiAoTWVzc2FnZVN0cmF0ZWd5LmlzKG1lc3NhZ2VTdHJhdGVneSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlU3RyYXRlZ3kuaGFuZGxlTWVzc2FnZShtZXNzYWdlLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2sgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWNlaXZlZCBhIGNhbmNlbGxhdGlvbiBtZXNzYWdlLiBDaGVjayBpZiB0aGUgbWVzc2FnZSBpcyBzdGlsbCBpbiB0aGUgcXVldWVcbiAgICAgICAgICAgIC8vIGFuZCBjYW5jZWwgaXQgaWYgYWxsb3dlZCB0byBkbyBzby5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkgJiYgbWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0NhbmNlbCA9IG1lc3NhZ2VRdWV1ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdCh0b0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBvcHRpb25zPy5jb25uZWN0aW9uU3RyYXRlZ3k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKHN0cmF0ZWd5ICYmIHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCkgPyBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwsIGNhbmNlbFVuZGlzcGF0Y2hlZCkgOiBjYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLmVycm9yICE9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UucmVzdWx0ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZShjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5pZCA9IHRvQ2FuY2VsLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UocmVzcG9uc2UsIG1lc3NhZ2UubWV0aG9kLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUocmVzcG9uc2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmb3IgY2FuY2VsZWQgbWVzc2FnZSBmYWlsZWQuYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gcmVxdWVzdFRva2Vucy5nZXQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGlzIGFscmVhZHkgcnVubmluZy4gQ2FuY2VsIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25Ub2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgY2FuY2VsIGJ1dCBzdGlsbCBxdWV1ZSB0aGUgbWVzc2FnZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCBzdGF0ZSBpbiBwcm9jZXNzIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5hZGQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZE1lc3NhZ2VUb1F1ZXVlKG1lc3NhZ2VRdWV1ZSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gd2UgcmV0dXJuIGhlcmUgc2lsZW50bHkgc2luY2Ugd2UgZmlyZWQgYW4gZXZlbnQgd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5KHJlc3VsdE9yRXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdE9yRXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVzdWx0T3JFcnJvci50b0pzb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzdWx0ID0gcmVzdWx0T3JFcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJlc3VsdE9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5RXJyb3IoZXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci50b0pzb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlTdWNjZXNzKHJlc3VsdCwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBKU09OIFJQQyBkZWZpbmVzIHRoYXQgYSByZXNwb25zZSBtdXN0IGVpdGhlciBoYXZlIGEgcmVzdWx0IG9yIGFuIGVycm9yXG4gICAgICAgICAgICAvLyBTbyB3ZSBjYW4ndCB0cmVhdCB1bmRlZmluZWQgYXMgYSB2YWxpZCByZXNwb25zZSByZXN1bHQuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2VSZWNlaXZlZFJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVxdWVzdEhhbmRsZXJzLmdldChyZXF1ZXN0TWVzc2FnZS5tZXRob2QpO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgbGV0IHJlcXVlc3RIYW5kbGVyO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0SGFuZGxlciB8fCBzdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuS2V5ID0gcmVxdWVzdE1lc3NhZ2UuaWQgPz8gU3RyaW5nKERhdGUubm93KCkpOyAvL1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uU291cmNlID0gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyKVxuICAgICAgICAgICAgICAgID8gY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UodG9rZW5LZXkpXG4gICAgICAgICAgICAgICAgOiBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwgJiYga25vd25DYW5jZWxlZFJlcXVlc3RzLmhhcyhyZXF1ZXN0TWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Tb3VyY2UuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLnNldCh0b2tlbktleSwgY2FuY2VsbGF0aW9uU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdE1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKC4uLnJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gc3RhclJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgcmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseVN1Y2Nlc3MoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHRPckVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseShyZXN1bHRPckVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQsIGBVbmhhbmRsZWQgbWV0aG9kICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFNlZSBoYW5kbGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQ6IEVycm9yIGlzOiBcXG4ke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZS5lcnJvciwgdW5kZWZpbmVkLCA0KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgcmVzcG9uc2UgbWVzc2FnZSB3aXRob3V0IGlkLiBObyBmdXJ0aGVyIGVycm9yIGluZm9ybWF0aW9uIHByb3ZpZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVzcG9uc2VNZXNzYWdlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZU1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgaGFwcGVuLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZXNwb25zZSBoYW5kbGVyICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB1bmV4cGVjdGVkbHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbm90aWZpY2F0aW9uSGFuZGxlcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDYW5jZWxOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICBrbm93bkNhbmNlbGVkUmVxdWVzdHMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm90aWZpY2F0aW9uSGFuZGxlcnMuZ2V0KG1lc3NhZ2UubWV0aG9kKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciA9IGVsZW1lbnQuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyIHx8IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gMCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgIT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBKU09OLVJQQyBsaWJyYXJpZXMgdGhhdCBzZW5kIHByb2dyZXNzIG1lc3NhZ2UgYXMgcG9zaXRpb25hbCBwYXJhbXMgYWx0aG91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBhcyBuYW1lZC4gU28gY29udmVydCB0aGVtIGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBtZXNzYWdlLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZS5tZXRob2QgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMiAmJiBQcm9ncmVzc1Rva2VuLmlzKHBhcmFtc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKHsgdG9rZW46IHBhcmFtc1swXSwgdmFsdWU6IHBhcmFtc1sxXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgcG9zaXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gbWVzc2FnZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCAke3BhcmFtcy5sZW5ndGh9IGFyZ3VtZW50c2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFyTm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiBoYW5kbGVyICcke21lc3NhZ2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmZpcmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignUmVjZWl2ZWQgZW1wdHkgbWVzc2FnZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2Ugd2hpY2ggaXMgbmVpdGhlciBhIHJlc3BvbnNlIG5vciBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlOlxcbiR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSwgbnVsbCwgNCl9YCk7XG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciB3ZSBmaW5kIGFuIGlkIHRvIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoSXMuc3RyaW5nKHJlc3BvbnNlTWVzc2FnZS5pZCkgfHwgSXMubnVtYmVyKHJlc3BvbnNlTWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3BvbnNlTWVzc2FnZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IHJlc3BvbnNlUHJvbWlzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnJlamVjdChuZXcgRXJyb3IoJ1RoZSByZWNlaXZlZCByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdCBub3IgYW4gZXJyb3IgcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVRyYWNlKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHJhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCA0KTtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuQ29tcGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVzcG9uc2UgJyR7bWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuIFByb2Nlc3NpbmcgcmVxdWVzdCB0b29rICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2AsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVxdWVzdCAnJHttZXNzYWdlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXF1ZXN0JywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIgfHwgbWVzc2FnZS5tZXRob2QgPT09IExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkUmVzcG9uc2UobWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG1lc3NhZ2UuZXJyb3IgPyBgIFJlcXVlc3QgZmFpbGVkOiAke21lc3NhZ2UuZXJyb3IubWVzc2FnZX0gKCR7bWVzc2FnZS5lcnJvci5jb2RlfSkuYCA6ICcnO1xuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJyBpbiAke0RhdGUubm93KCkgLSByZXNwb25zZVByb21pc2UudGltZXJTdGFydH1tcy4ke2Vycm9yfWAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJHttZXNzYWdlLmlkfSB3aXRob3V0IGFjdGl2ZSByZXNwb25zZSBwcm9taXNlLmAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ0xTUE1lc3NhZ2UodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRyYWNlciB8fCB0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHNwTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlzTFNQTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRyYWNlci5sb2cobHNwTWVzc2FnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCkge1xuICAgICAgICBpZiAoaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkNsb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5EaXNwb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgZGlzcG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkxpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKGlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5BbHJlYWR5TGlzdGVuaW5nLCAnQ29ubmVjdGlvbiBpcyBhbHJlYWR5IGxpc3RlbmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZOb3RMaXN0ZW5pbmcoKSB7XG4gICAgICAgIGlmICghaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGxpc3RlbigpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuZGVmaW5lZFRvTnVsbChwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc05hbWVkUGFyYW0ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtICE9PSB1bmRlZmluZWQgJiYgcGFyYW0gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocGFyYW0pICYmIHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbSkge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtZXRlclN0cnVjdHVyZXMpIHtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG86XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZFRvTnVsbChwYXJhbSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZTpcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHBhcmFtIGlzIG5vdCBhbiBvYmplY3QgbGl0ZXJhbC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgc3RydWN0dXJlICR7cGFyYW1ldGVyU3RydWN0dXJlcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHR5cGUubnVtYmVyT2ZQYXJhbXM7XG4gICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZVNpbmdsZVBhcmFtKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcywgcGFyYW1zWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoICYmIGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZFRvTnVsbChwYXJhbXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPCBudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyYW1zLmxlbmd0aDsgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgIHNlbmROb3RpZmljYXRpb246ICh0eXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlUGFyYW1zO1xuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyU3RydWN0dXJlcyA9IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuaXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbUVuZCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gcGFyYW1FbmQgLSBwYXJhbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIGFyZ3NbcGFyYW1TdGFydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgJHtudW1iZXJPZlBhcmFtc30gcGFyYW1ldGVycyBmb3IgJ2J5IE5hbWUnIG5vdGlmaWNhdGlvbiBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3RpZmljYXRpb25NZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VXcml0ZXIud3JpdGUobm90aWZpY2F0aW9uTWVzc2FnZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiBmYWlsZWQuYCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob3RpZmljYXRpb246ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUsIHsgdHlwZTogdW5kZWZpbmVkLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLnNldCh0eXBlLm1ldGhvZCwgeyB0eXBlLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NIYW5kbGVycy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmVzcyBoYW5kbGVyIGZvciB0b2tlbiAke3Rva2VufSBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuc2V0KHRva2VuLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXJzLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGF3YWl0IGJ1dCBzaW1wbGUgcmV0dXJuIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IGhhdmUgYW5vdGhlclxuICAgICAgICAgICAgLy8gYXN5bmMgc2NoZWR1bGluZy4gT3RoZXJ3aXNlIG9uZSBzZW5kIGNvdWxkIG92ZXJ0YWtlIGFub3RoZXIgc2VuZC5cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSwgeyB0b2tlbiwgdmFsdWUgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVW5oYW5kbGVkUHJvZ3Jlc3M6IHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlci5ldmVudCxcbiAgICAgICAgc2VuZFJlcXVlc3Q6ICh0eXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZk5vdExpc3RlbmluZygpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlUGFyYW1zO1xuICAgICAgICAgICAgbGV0IHRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuLmlzKGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtRW5kID0gcGFyYW1FbmQgLSAxO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gcGFyYW1FbmQgLSBwYXJhbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIGFyZ3NbcGFyYW1TdGFydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgJHtudW1iZXJPZlBhcmFtc30gcGFyYW1ldGVycyBmb3IgJ2J5IE5hbWUnIHJlcXVlc3QgcGFyYW1ldGVyIHN0cnVjdHVyZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBhcmdzLnNsaWNlKHBhcmFtU3RhcnQsIHBhcmFtRW5kKS5tYXAodmFsdWUgPT4gdW5kZWZpbmVkVG9OdWxsKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuLmlzKHBhcmFtc1tudW1iZXJPZlBhcmFtc10pID8gcGFyYW1zW251bWJlck9mUGFyYW1zXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2VxdWVuY2VOdW1iZXIrKztcbiAgICAgICAgICAgIGxldCBkaXNwb3NhYmxlO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZSA9IHRva2VuLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5zZW5kQ2FuY2VsbGF0aW9uKGNvbm5lY3Rpb24sIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVjZWl2ZWQgbm8gcHJvbWlzZSBmcm9tIGNhbmNlbGxhdGlvbiBzdHJhdGVneSB3aGVuIGNhbmNlbGxpbmcgaWQgJHtpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTZW5kaW5nIGNhbmNlbGxhdGlvbiBtZXNzYWdlcyBmb3IgaWQgJHtpZH0gZmFpbGVkYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWplY3RXaXRoQ2xlYW51cCA9IChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB7IG1ldGhvZDogbWV0aG9kLCB0aW1lclN0YXJ0OiBEYXRlLm5vdygpLCByZXNvbHZlOiByZXNvbHZlV2l0aENsZWFudXAsIHJlamVjdDogcmVqZWN0V2l0aENsZWFudXAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBtZXNzYWdlV3JpdGVyLndyaXRlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5zZXQoaWQsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVxdWVzdCBmYWlsZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRpbmcgdGhlIG1lc3NhZ2UgZmFpbGVkLiBTbyB3ZSBuZWVkIHRvIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciwgZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biByZWFzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblJlcXVlc3Q6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoU3RhclJlcXVlc3RIYW5kbGVyLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLnNldCh0eXBlLCB7IGhhbmRsZXI6IGhhbmRsZXIsIHR5cGU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1BlbmRpbmdSZXNwb25zZTogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZXMuc2l6ZSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNlOiBhc3luYyAoX3ZhbHVlLCBfdHJhY2VyLCBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGxldCBfc2VuZE5vdGlmaWNhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IF90cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICBpZiAoc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuYm9vbGVhbihzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zZW5kTm90aWZpY2F0aW9uID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMuc2VuZE5vdGlmaWNhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RyYWNlRm9ybWF0ID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zLnRyYWNlRm9ybWF0IHx8IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UgPSBfdmFsdWU7XG4gICAgICAgICAgICB0cmFjZUZvcm1hdCA9IF90cmFjZUZvcm1hdDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gX3RyYWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfc2VuZE5vdGlmaWNhdGlvbiAmJiAhaXNDbG9zZWQoKSAmJiAhaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKFNldFRyYWNlTm90aWZpY2F0aW9uLnR5cGUsIHsgdmFsdWU6IFRyYWNlLnRvU3RyaW5nKF92YWx1ZSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGVycm9yRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25DbG9zZTogY2xvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvblVuaGFuZGxlZE5vdGlmaWNhdGlvbjogdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25EaXNwb3NlOiBkaXNwb3NlRW1pdHRlci5ldmVudCxcbiAgICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XG4gICAgICAgICAgICBkaXNwb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkLCAnUGVuZGluZyByZXNwb25zZSByZWplY3RlZCBzaW5jZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHJlc3BvbnNlUHJvbWlzZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmVxdWVzdFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlV3JpdGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlUmVhZGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHRocm93SWZMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZztcbiAgICAgICAgICAgIG1lc3NhZ2VSZWFkZXIubGlzdGVuKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zcGVjdDogKCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLmNvbnNvbGUubG9nKCdpbnNwZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZSA9IHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0O1xuICAgICAgICB0cmFjZXIubG9nKHBhcmFtcy5tZXNzYWdlLCB2ZXJib3NlID8gcGFyYW1zLnZlcmJvc2UgOiB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcHJvZ3Jlc3NIYW5kbGVycy5nZXQocGFyYW1zLnRva2VuKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyYW1zLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlci5maXJlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn1cbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODg0NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSB2b2lkIDA7XG52YXIgRGlzcG9zYWJsZTtcbihmdW5jdGlvbiAoRGlzcG9zYWJsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmdW5jKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpc3Bvc2FibGUuY3JlYXRlID0gY3JlYXRlO1xufSkoRGlzcG9zYWJsZSB8fCAoZXhwb3J0cy5EaXNwb3NhYmxlID0gRGlzcG9zYWJsZSA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI0Nzk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG52YXIgRXZlbnQ7XG4oZnVuY3Rpb24gKEV2ZW50KSB7XG4gICAgY29uc3QgX2Rpc3Bvc2FibGUgPSB7IGRpc3Bvc2UoKSB7IH0gfTtcbiAgICBFdmVudC5Ob25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Rpc3Bvc2FibGU7IH07XG59KShFdmVudCB8fCAoZXhwb3J0cy5FdmVudCA9IEV2ZW50ID0ge30pKTtcbmNsYXNzIENhbGxiYWNrTGlzdCB7XG4gICAgYWRkKGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCwgYnVja2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWNrZXQpKSB7XG4gICAgICAgICAgICBidWNrZXQucHVzaCh7IGRpc3Bvc2U6ICgpID0+IHRoaXMucmVtb3ZlKGNhbGxiYWNrLCBjb250ZXh0KSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZXh0c1tpXSA9PT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayAmIGNvbnRleHQgbWF0Y2ggPT4gcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGFkZGluZyBhIGxpc3RlbmVyIHdpdGggYSBjb250ZXh0LCB5b3Ugc2hvdWxkIHJlbW92ZSBpdCB3aXRoIHRoZSBzYW1lIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IFtdLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3Muc2xpY2UoMCksIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHMuc2xpY2UoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goY2FsbGJhY2tzW2ldLmFwcGx5KGNvbnRleHRzW2ldLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2NhbGxiYWNrcyB8fCB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBwdWJsaWMgdG8gYWxsb3cgdG8gc3Vic2NyaWJlXG4gICAgICogdG8gZXZlbnRzIGZyb20gdGhpcyBFbWl0dGVyXG4gICAgICovXG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudCA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IENhbGxiYWNrTGlzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuYWRkKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3Bvc2FibGUgaXMgZGlzcG9zZWQgYWZ0ZXIgZW1pdHRlciBpcyBkaXNwb3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MucmVtb3ZlKGxpc3RlbmVyLCB0aGlzQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcG9zZSA9IEVtaXR0ZXIuX25vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGtlcHQgcHJpdmF0ZSB0byBmaXJlIGFuIGV2ZW50IHRvXG4gICAgICogc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5pbnZva2UuY2FsbCh0aGlzLl9jYWxsYmFja3MsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FbWl0dGVyID0gRW1pdHRlcjtcbkVtaXR0ZXIuX25vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY2MTg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy5mdW5jID0gZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJvb2xlYW4gPSB2b2lkIDA7XG5mdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRXJyb3I7XG59XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5mdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5mdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmZ1bmN0aW9uIHN0cmluZ0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShlbGVtID0+IHN0cmluZyhlbGVtKSk7XG59XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gc3RyaW5nQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExMDk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MUlVDYWNoZSA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5Ub3VjaCA9IHZvaWQgMDtcbnZhciBUb3VjaDtcbihmdW5jdGlvbiAoVG91Y2gpIHtcbiAgICBUb3VjaC5Ob25lID0gMDtcbiAgICBUb3VjaC5GaXJzdCA9IDE7XG4gICAgVG91Y2guQXNPbGQgPSBUb3VjaC5GaXJzdDtcbiAgICBUb3VjaC5MYXN0ID0gMjtcbiAgICBUb3VjaC5Bc05ldyA9IFRvdWNoLkxhc3Q7XG59KShUb3VjaCB8fCAoZXhwb3J0cy5Ub3VjaCA9IFRvdWNoID0ge30pKTtcbmNsYXNzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXNbX2FdID0gJ0xpbmtlZE1hcCc7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWQ/LnZhbHVlO1xuICAgIH1cbiAgICBnZXQgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhaWw/LnZhbHVlO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guTm9uZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUsIHRvdWNoID0gVG91Y2guTm9uZSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b3VjaCAhPT0gVG91Y2guTm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHsga2V5LCB2YWx1ZSwgbmV4dDogdW5kZWZpbmVkLCBwcmV2aW91czogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBzd2l0Y2ggKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5Ob25lOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkZpcnN0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1GaXJzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5MYXN0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlbW92ZShrZXkpO1xuICAgIH1cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoaXRlbS5rZXkpO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpc0FyZykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uYmluZCh0aGlzQXJnKShjdXJyZW50LnZhbHVlLCBjdXJyZW50LmtleSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja2ZuKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQudmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogW2N1cnJlbnQua2V5LCBjdXJyZW50LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgWyhfYSA9IFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgdHJpbU9sZChuZXdTaXplKSB7XG4gICAgICAgIGlmIChuZXdTaXplID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnRTaXplID4gbmV3U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShjdXJyZW50LmtleSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgY3VycmVudFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IGN1cnJlbnRTaXplO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBhZGRJdGVtRmlyc3QoaXRlbSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBhZGRJdGVtTGFzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCAmJiBpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW5lZCBpZiBzaXplID09PSAxIHdoaWNoIGlzIGhhbmRsZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGNhc2UgYWJvdmUuXG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8ICFwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHRvdWNoKGl0ZW0sIHRvdWNoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRvdWNoICE9PSBUb3VjaC5GaXJzdCAmJiB0b3VjaCAhPT0gVG91Y2guTGFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggPT09IFRvdWNoLkZpcnN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW1cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCBoZWFkIGJ1dCBpcyB0YWlsXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZSBhdCBoZWFkXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSBUb3VjaC5MYXN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW0uXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIC8vIG5leHQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCB0YWlsIGJ1dCBpcyBoZWFkXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGlua2VkTWFwID0gTGlua2VkTWFwO1xuY2xhc3MgTFJVQ2FjaGUgZXh0ZW5kcyBMaW5rZWRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxpbWl0LCByYXRpbyA9IDEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCByYXRpbyksIDEpO1xuICAgIH1cbiAgICBnZXQgbGltaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW1pdDtcbiAgICB9XG4gICAgc2V0IGxpbWl0KGxpbWl0KSB7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldCByYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhdGlvO1xuICAgIH1cbiAgICBzZXQgcmF0aW8ocmF0aW8pIHtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCByYXRpbyksIDEpO1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgIH1cbiAgICBnZXQoa2V5LCB0b3VjaCA9IFRvdWNoLkFzTmV3KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCB0b3VjaCk7XG4gICAgfVxuICAgIHBlZWsoa2V5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCBUb3VjaC5Ob25lKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUsIFRvdWNoLkxhc3QpO1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2hlY2tUcmltKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID4gdGhpcy5fbGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpbU9sZChNYXRoLnJvdW5kKHRoaXMuX2xpbWl0ICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgwNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IENSID0gMTM7XG5jb25zdCBMRiA9IDEwO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgdGhpcy5fY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIGFwcGVuZChjaHVuaykge1xuICAgICAgICBjb25zdCB0b0FwcGVuZCA9IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyB0aGlzLmZyb21TdHJpbmcoY2h1bmssIHRoaXMuX2VuY29kaW5nKSA6IGNodW5rO1xuICAgICAgICB0aGlzLl9jaHVua3MucHVzaCh0b0FwcGVuZCk7XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoICs9IHRvQXBwZW5kLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRyeVJlYWRIZWFkZXJzKGxvd2VyQ2FzZUtleXMgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtCeXRlc1JlYWQgPSAwO1xuICAgICAgICByb3c6IHdoaWxlIChjaHVua0luZGV4IDwgdGhpcy5fY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29sdW1uOiB3aGlsZSAob2Zmc2V0IDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVua1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExGOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua0J5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY2h1bmtJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVmZmVyIGNvbnRhaW5zIHRoZSB0d28gQ1JMRiBhdCB0aGUgZW5kLiBTbyB3ZSB3aWxsXG4gICAgICAgIC8vIGhhdmUgdHdvIGVtcHR5IGxpbmVzIGFmdGVyIHRoZSBzcGxpdCBhdCB0aGUgZW5kIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3JlYWQoY2h1bmtCeXRlc1JlYWQgKyBvZmZzZXQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnRvU3RyaW5nKGJ1ZmZlciwgJ2FzY2lpJykuc3BsaXQoQ1JMRik7XG4gICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaGVhZGVyLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaGVhZGVyIG11c3Qgc2VwYXJhdGUga2V5IGFuZCB2YWx1ZSB1c2luZyAnOidcXG4ke2hlYWRlcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGhlYWRlci5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuc3Vic3RyKGluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNldChsb3dlckNhc2VLZXlzID8ga2V5LnRvTG93ZXJDYXNlKCkgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0cnlSZWFkQm9keShsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsTGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKGxlbmd0aCk7XG4gICAgfVxuICAgIGdldCBudW1iZXJPZkJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxMZW5ndGg7XG4gICAgfVxuICAgIF9yZWFkKGJ5dGVDb3VudCkge1xuICAgICAgICBpZiAoYnl0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUJ1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlQ291bnQgPiB0aGlzLl90b3RhbExlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCBzbyBtYW55IGJ5dGVzIWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA9PT0gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBzdXBlciBmYXN0IHBhdGgsIHByZWNpc2VseSBmaXJzdCBjaHVuayBtdXN0IGJlIHJldHVybmVkXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNOYXRpdmUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3NbMF0uYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gZmFzdCBwYXRoLCB0aGUgcmVhZGluZyBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIGZpcnN0IGNodW5rXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNOYXRpdmUoY2h1bmssIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl9jaHVua3NbMF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG9jTmF0aXZlKGJ5dGVDb3VudCk7XG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChieXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIHN1cnZpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1BhcnQgPSBjaHVuay5zbGljZSgwLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmtQYXJ0LCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBiZSBlbnRpcmVseSByZWFkXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVuaywgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIgPSBBYnN0cmFjdE1lc3NhZ2VCdWZmZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY1Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbmNvbnN0IHNlbWFwaG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTgpO1xudmFyIE1lc3NhZ2VSZWFkZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VSZWFkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUubGlzdGVuKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSAmJlxuICAgICAgICAgICAgSXMuZnVuYyhjYW5kaWRhdGUub25FcnJvcikgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25QYXJ0aWFsTWVzc2FnZSk7XG4gICAgfVxuICAgIE1lc3NhZ2VSZWFkZXIuaXMgPSBpcztcbn0pKE1lc3NhZ2VSZWFkZXIgfHwgKGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IE1lc3NhZ2VSZWFkZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKHRoaXMuYXNFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0IG9uUGFydGlhbE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZVBhcnRpYWxNZXNzYWdlKGluZm8pIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZmlyZShpbmZvKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgUmVhZGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gQWJzdHJhY3RNZXNzYWdlUmVhZGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGxldCBjaGFyc2V0O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgY29udGVudERlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnREZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGVEZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zID8/ICd1dGYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCc7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXIgPSBvcHRpb25zLmNvbnRlbnREZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoY29udGVudERlY29kZXIubmFtZSwgY29udGVudERlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50RGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZURlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmRlY29kZXI7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFyc2V0LCBjb250ZW50RGVjb2RlciwgY29udGVudERlY29kZXJzLCBjb250ZW50VHlwZURlY29kZXIsIGNvbnRlbnRUeXBlRGVjb2RlcnMgfTtcbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5tZXNzYWdlQnVmZmVyLmNyZWF0ZSh0aGlzLm9wdGlvbnMuY2hhcnNldCk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IDEwMDAwO1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICB9XG4gICAgc2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQ7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZGFibGUub25EYXRhKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChkYXRhKTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmJ1ZmZlci50cnlSZWFkSGVhZGVycyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcihgSGVhZGVyIG11c3QgcHJvdmlkZSBhIENvbnRlbnQtTGVuZ3RoIHByb3BlcnR5LlxcbiR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKGhlYWRlcnMpKX1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoY29udGVudExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihuZXcgRXJyb3IoYENvbnRlbnQtTGVuZ3RoIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuIEdvdCAke2NvbnRlbnRMZW5ndGh9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQm9keSh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBXZSBoYXZlbid0IHJlY2VpdmVkIHRoZSBmdWxsIG1lc3NhZ2UgeWV0LiAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPSAtMTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBjb252ZXJ0IG9uZSByZWNlaXZlZCBtZXNzYWdlIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIG90aGVyLiBPdGhlcndpc2UgaXQgY291bGQgaGFwcGVuIHRoYXQgYSBkZWNvZGluZyBvZiBhIHNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHNtYWxsZXIgbWVzc2FnZSBmaW5pc2hlZCBiZWZvcmUgdGhlIGRlY29kaW5nIG9mIGEgZmlyc3QgbGFyZ2VyXG4gICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBhbmQgdGhlbiB3ZSB3b3VsZCBkZWxpdmVyIHRoZSBzZWNvbmQgbWVzc2FnZSBmaXJzdC5cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5vcHRpb25zLmNvbnRlbnREZWNvZGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5vcHRpb25zLmNvbnRlbnREZWNvZGVyLmRlY29kZShib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib2R5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlRGVjb2Rlci5kZWNvZGUoYnl0ZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhclBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UGFydGlhbE1lc3NhZ2VUaW1lcigpIHtcbiAgICAgICAgdGhpcy5jbGVhclBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dCgodG9rZW4sIHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gdGhpcy5tZXNzYWdlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVQYXJ0aWFsTWVzc2FnZSh7IG1lc3NhZ2VUb2tlbjogdG9rZW4sIHdhaXRpbmdUaW1lOiB0aW1lb3V0IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQsIHRoaXMubWVzc2FnZVRva2VuLCB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyID0gUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MDM2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuTWVzc2FnZVdyaXRlciA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IHNlbWFwaG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MTgpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3QgQ29udGVudExlbmd0aCA9ICdDb250ZW50LUxlbmd0aDogJztcbmNvbnN0IENSTEYgPSAnXFxyXFxuJztcbnZhciBNZXNzYWdlV3JpdGVyO1xuKGZ1bmN0aW9uIChNZXNzYWdlV3JpdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmRpc3Bvc2UpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uQ2xvc2UpICYmXG4gICAgICAgICAgICBJcy5mdW5jKGNhbmRpZGF0ZS5vbkVycm9yKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS53cml0ZSk7XG4gICAgfVxuICAgIE1lc3NhZ2VXcml0ZXIuaXMgPSBpcztcbn0pKE1lc3NhZ2VXcml0ZXIgfHwgKGV4cG9ydHMuTWVzc2FnZVdyaXRlciA9IE1lc3NhZ2VXcml0ZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGNvdW50KSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUoW3RoaXMuYXNFcnJvcihlcnJvciksIG1lc3NhZ2UsIGNvdW50XSk7XG4gICAgfVxuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBhc0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBXcml0ZXIgcmVjZWl2ZWQgZXJyb3IuIFJlYXNvbjogJHtJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBBYnN0cmFjdE1lc3NhZ2VXcml0ZXI7XG52YXIgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucztcbihmdW5jdGlvbiAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMgPz8gJ3V0Zi04JywgY29udGVudFR5cGVFbmNvZGVyOiAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcnNldDogb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCcsIGNvbnRlbnRFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRFbmNvZGVyLCBjb250ZW50VHlwZUVuY29kZXI6IG9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyID8/ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5lbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0YWJsZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IDA7XG4gICAgICAgIHRoaXMud3JpdGVTZW1hcGhvcmUgPSBuZXcgc2VtYXBob3JlXzEuU2VtYXBob3JlKDEpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uRXJyb3IoKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uQ2xvc2UoKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XG4gICAgfVxuICAgIGFzeW5jIHdyaXRlKG1zZykge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVNlbWFwaG9yZS5sb2NrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyLmVuY29kZShtc2csIHRoaXMub3B0aW9ucykudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RW5jb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIuZW5jb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChDb250ZW50TGVuZ3RoLCBidWZmZXIuYnl0ZUxlbmd0aC50b1N0cmluZygpLCBDUkxGKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ1JMRik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9Xcml0ZShtc2csIGhlYWRlcnMsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRvV3JpdGUobXNnLCBoZWFkZXJzLCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRhYmxlLndyaXRlKGhlYWRlcnMuam9pbignJyksICdhc2NpaScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGFibGUud3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbXNnKSB7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCsrO1xuICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvciwgbXNnLCB0aGlzLmVycm9yQ291bnQpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzE2Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5NZXNzYWdlID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5SZXNwb25zZUVycm9yID0gZXhwb3J0cy5FcnJvckNvZGVzID0gdm9pZCAwO1xuY29uc3QgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuLyoqXG4gKiBQcmVkZWZpbmVkIGVycm9yIGNvZGVzLlxuICovXG52YXIgRXJyb3JDb2RlcztcbihmdW5jdGlvbiAoRXJyb3JDb2Rlcykge1xuICAgIC8vIERlZmluZWQgYnkgSlNPTiBSUENcbiAgICBFcnJvckNvZGVzLlBhcnNlRXJyb3IgPSAtMzI3MDA7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUmVxdWVzdCA9IC0zMjYwMDtcbiAgICBFcnJvckNvZGVzLk1ldGhvZE5vdEZvdW5kID0gLTMyNjAxO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFBhcmFtcyA9IC0zMjYwMjtcbiAgICBFcnJvckNvZGVzLkludGVybmFsRXJyb3IgPSAtMzI2MDM7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgc3RhcnQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuIE5vIGFwcGxpY2F0aW9uIGVycm9yIGNvZGVzIHNob3VsZFxuICAgICAqIGJlIGRlZmluZWQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCByYW5nZS4gRm9yIGJhY2t3YXJkc1xuICAgICAqIGNvbXBhdGliaWxpdHkgdGhlIGBTZXJ2ZXJOb3RJbml0aWFsaXplZGAgYW5kIHRoZSBgVW5rbm93bkVycm9yQ29kZWBcbiAgICAgKiBhcmUgbGVmdCBpbiB0aGUgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCA9IC0zMjA5OTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiB3cml0ZSBhIG1lc3NhZ2UgdG8gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gcmVhZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVJlYWRFcnJvciA9IC0zMjA5ODtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQgb3IgbG9zdCBhbmQgYWxsIHBlbmRpbmcgcmVzcG9uc2VzIGdvdFxuICAgICAqIHJlamVjdGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQgPSAtMzIwOTc7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgaW5hY3RpdmUgYW5kIGEgdXNlIG9mIGl0IGZhaWxlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLkNvbm5lY3Rpb25JbmFjdGl2ZSA9IC0zMjA5NjtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHNlcnZlciByZWNlaXZlZCBhIG5vdGlmaWNhdGlvbiBvclxuICAgICAqIHJlcXVlc3QgYmVmb3JlIHRoZSBzZXJ2ZXIgaGFzIHJlY2VpdmVkIHRoZSBgaW5pdGlhbGl6ZWAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlNlcnZlck5vdEluaXRpYWxpemVkID0gLTMyMDAyO1xuICAgIEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZSA9IC0zMjAwMTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzIwMDA7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JFbmQgPSAtMzIwMDA7XG59KShFcnJvckNvZGVzIHx8IChleHBvcnRzLkVycm9yQ29kZXMgPSBFcnJvckNvZGVzID0ge30pKTtcbi8qKlxuICogQW4gZXJyb3Igb2JqZWN0IHJldHVybiBpbiBhIHJlc3BvbnNlIGluIGNhc2UgYSByZXF1ZXN0XG4gKiBoYXMgZmFpbGVkLlxuICovXG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGlzLm51bWJlcihjb2RlKSA/IGNvZGUgOiBFcnJvckNvZGVzLlVua25vd25FcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSZXNwb25zZUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHRvSnNvbigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBSZXNwb25zZUVycm9yO1xuY2xhc3MgUGFyYW1ldGVyU3RydWN0dXJlcyB7XG4gICAgY29uc3RydWN0b3Ioa2luZCkge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8gfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lIHx8IHZhbHVlID09PSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb247XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5raW5kO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXM7XG4vKipcbiAqIFRoZSBwYXJhbWV0ZXIgc3RydWN0dXJlIGlzIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgb24gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzXG4gKiBhbmQgdGhlIHBhcmFtZXRlciB0eXBlIGluIGNhc2Ugb2YgYSBzaW5nbGUgcGFyYW0uXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdhdXRvJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlQb3NpdGlvbmAgcGFyYW1ldGVyIHN0cnVjdHVyZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGhhdmUgYSBzaW5nbGVcbiAqIHBhcmFtZXRlciB3aGljaCBoYXMgYSBsaXRlcmFsIHR5cGUuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbiA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieVBvc2l0aW9uJyk7XG4vKipcbiAqIEZvcmNlcyBgYnlOYW1lYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIG9ubHkgdXNlZnVsIHdoZW4gaGF2aW5nIGEgc2luZ2xlXG4gKiBwYXJhbWV0ZXIuIFRoZSBsaWJyYXJ5IHdpbGwgcmVwb3J0IGVycm9ycyBpZiB1c2VkIHdpdGggYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gKiBwYXJhbWV0ZXJzLlxuICovXG5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSA9IG5ldyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzKCdieU5hbWUnKTtcbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBNZXNzYWdlVHlwZS5cbiAqL1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLm51bWJlck9mUGFyYW1zID0gbnVtYmVyT2ZQYXJhbXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlO1xuLyoqXG4gKiBDbGFzc2VzIHRvIHR5cGUgcmVxdWVzdCByZXNwb25zZSBwYWlyc1xuICovXG5jbGFzcyBSZXF1ZXN0VHlwZTAgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUwID0gUmVxdWVzdFR5cGUwO1xuY2xhc3MgUmVxdWVzdFR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IFJlcXVlc3RUeXBlO1xuY2xhc3MgUmVxdWVzdFR5cGUxIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUxID0gUmVxdWVzdFR5cGUxO1xuY2xhc3MgUmVxdWVzdFR5cGUyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMiA9IFJlcXVlc3RUeXBlMjtcbmNsYXNzIFJlcXVlc3RUeXBlMyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBSZXF1ZXN0VHlwZTM7XG5jbGFzcyBSZXF1ZXN0VHlwZTQgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gUmVxdWVzdFR5cGU0O1xuY2xhc3MgUmVxdWVzdFR5cGU1IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA1KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNSA9IFJlcXVlc3RUeXBlNTtcbmNsYXNzIFJlcXVlc3RUeXBlNiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNik7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBSZXF1ZXN0VHlwZTY7XG5jbGFzcyBSZXF1ZXN0VHlwZTcgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gUmVxdWVzdFR5cGU3O1xuY2xhc3MgUmVxdWVzdFR5cGU4IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA4KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOCA9IFJlcXVlc3RUeXBlODtcbmNsYXNzIFJlcXVlc3RUeXBlOSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBSZXF1ZXN0VHlwZTk7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMSk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBfcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IE5vdGlmaWNhdGlvblR5cGU7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IE5vdGlmaWNhdGlvblR5cGUwO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMSA9IE5vdGlmaWNhdGlvblR5cGUxO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBOb3RpZmljYXRpb25UeXBlMjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gTm90aWZpY2F0aW9uVHlwZTM7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNCA9IE5vdGlmaWNhdGlvblR5cGU0O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBOb3RpZmljYXRpb25UeXBlNTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gTm90aWZpY2F0aW9uVHlwZTY7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNyA9IE5vdGlmaWNhdGlvblR5cGU3O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBOb3RpZmljYXRpb25UeXBlODtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gTm90aWZpY2F0aW9uVHlwZTk7XG52YXIgTWVzc2FnZTtcbihmdW5jdGlvbiAoTWVzc2FnZSkge1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBnaXZlbiBtZXNzYWdlIGlzIGEgcmVxdWVzdCBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1JlcXVlc3QgPSBpc1JlcXVlc3Q7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSBub3RpZmljYXRpb24gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBpcy5zdHJpbmcoY2FuZGlkYXRlLm1ldGhvZCkgJiYgbWVzc2FnZS5pZCA9PT0gdm9pZCAwO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzTm90aWZpY2F0aW9uID0gaXNOb3RpZmljYXRpb247XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXNwb25zZSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5yZXN1bHQgIT09IHZvaWQgMCB8fCAhIWNhbmRpZGF0ZS5lcnJvcikgJiYgKGlzLnN0cmluZyhjYW5kaWRhdGUuaWQpIHx8IGlzLm51bWJlcihjYW5kaWRhdGUuaWQpIHx8IGNhbmRpZGF0ZS5pZCA9PT0gbnVsbCk7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNSZXNwb25zZSA9IGlzUmVzcG9uc2U7XG59KShNZXNzYWdlIHx8IChleHBvcnRzLk1lc3NhZ2UgPSBNZXNzYWdlID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTA5MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xubGV0IF9yYWw7XG5mdW5jdGlvbiBSQUwoKSB7XG4gICAgaWYgKF9yYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bnRpbWUgYWJzdHJhY3Rpb24gbGF5ZXIgaW5zdGFsbGVkYCk7XG4gICAgfVxuICAgIHJldHVybiBfcmFsO1xufVxuKGZ1bmN0aW9uIChSQUwpIHtcbiAgICBmdW5jdGlvbiBpbnN0YWxsKHJhbCkge1xuICAgICAgICBpZiAocmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBwcm92aWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIF9yYWwgPSByYWw7XG4gICAgfVxuICAgIFJBTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJBTCB8fCAoUkFMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUkFMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MTg6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwOTEpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjYXBhY2l0eSA9IDEpIHtcbiAgICAgICAgaWYgKGNhcGFjaXR5IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcbiAgICB9XG4gICAgbG9jayh0aHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZy5wdXNoKHsgdGh1bmssIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgcnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1J1bk5leHQoKSk7XG4gICAgfVxuICAgIGRvUnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA+IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvIG1hbnkgdGh1bmtzIGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXh0LnRodW5rKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDg5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IHZvaWQgMDtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU3KTtcbnZhciBDYW5jZWxsYXRpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RhdGUpIHtcbiAgICBDYW5jZWxsYXRpb25TdGF0ZS5Db250aW51ZSA9IDA7XG4gICAgQ2FuY2VsbGF0aW9uU3RhdGUuQ2FuY2VsbGVkID0gMTtcbn0pKENhbmNlbGxhdGlvblN0YXRlIHx8IChDYW5jZWxsYXRpb25TdGF0ZSA9IHt9KSk7XG5jbGFzcyBTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBlbmFibGVDYW5jZWxsYXRpb24ocmVxdWVzdCkge1xuICAgICAgICBpZiAocmVxdWVzdC5pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcig0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIGRhdGFbMF0gPSBDYW5jZWxsYXRpb25TdGF0ZS5Db250aW51ZTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnNldChyZXF1ZXN0LmlkLCBidWZmZXIpO1xuICAgICAgICByZXF1ZXN0LiRjYW5jZWxsYXRpb25EYXRhID0gYnVmZmVyO1xuICAgIH1cbiAgICBhc3luYyBzZW5kQ2FuY2VsbGF0aW9uKF9jb25uLCBpZCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIEF0b21pY3Muc3RvcmUoZGF0YSwgMCwgQ2FuY2VsbGF0aW9uU3RhdGUuQ2FuY2VsbGVkKTtcbiAgICB9XG4gICAgY2xlYW51cChpZCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmNsZWFyKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneTtcbmNsYXNzIFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiBBdG9taWNzLmxvYWQodGhpcy5kYXRhLCAwKSA9PT0gQ2FuY2VsbGF0aW9uU3RhdGUuQ2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuY2VsbGF0aW9uIG92ZXIgU2hhcmVkQXJyYXlCdWZmZXIgZG9lc24ndCBzdXBwb3J0IGNhbmNlbGxhdGlvbiBldmVudHNgKTtcbiAgICB9XG59XG5jbGFzcyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuKGJ1ZmZlcik7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICB9XG59XG5jbGFzcyBTaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmtpbmQgPSAncmVxdWVzdCc7XG4gICAgfVxuICAgIGNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gcmVxdWVzdC4kY2FuY2VsbGF0aW9uRGF0YTtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuU291cmNlKGJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBTaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3k7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg3MTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTUwMTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjA4KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMDgpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNDcpLCBleHBvcnRzKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCBicm93c2VyXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxNDc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxTUEVycm9yQ29kZXMgPSBleHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NTIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MTUpLCBleHBvcnRzKTtcbnZhciBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uOyB9IH0pKTtcbnZhciBMU1BFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChMU1BFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyODk5O1xuICAgIC8qKlxuICAgICAqIEEgcmVxdWVzdCBmYWlsZWQgYnV0IGl0IHdhcyBzeW50YWN0aWNhbGx5IGNvcnJlY3QsIGUuZyB0aGVcbiAgICAgKiBtZXRob2QgbmFtZSB3YXMga25vd24gYW5kIHRoZSBwYXJhbWV0ZXJzIHdlcmUgdmFsaWQuIFRoZSBlcnJvclxuICAgICAqIG1lc3NhZ2Ugc2hvdWxkIGNvbnRhaW4gaHVtYW4gcmVhZGFibGUgaW5mb3JtYXRpb24gYWJvdXQgd2h5XG4gICAgICogdGhlIHJlcXVlc3QgZmFpbGVkLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdEZhaWxlZCA9IC0zMjgwMztcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGNhbmNlbGxlZCB0aGUgcmVxdWVzdC4gVGhpcyBlcnJvciBjb2RlIHNob3VsZFxuICAgICAqIG9ubHkgYmUgdXNlZCBmb3IgcmVxdWVzdHMgdGhhdCBleHBsaWNpdGx5IHN1cHBvcnQgYmVpbmdcbiAgICAgKiBzZXJ2ZXIgY2FuY2VsbGFibGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5TZXJ2ZXJDYW5jZWxsZWQgPSAtMzI4MDI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBkZXRlY3RlZCB0aGF0IHRoZSBjb250ZW50IG9mIGEgZG9jdW1lbnQgZ290XG4gICAgICogbW9kaWZpZWQgb3V0c2lkZSBub3JtYWwgY29uZGl0aW9ucy4gQSBzZXJ2ZXIgc2hvdWxkXG4gICAgICogTk9UIHNlbmQgdGhpcyBlcnJvciBjb2RlIGlmIGl0IGRldGVjdHMgYSBjb250ZW50IGNoYW5nZVxuICAgICAqIGluIGl0IHVucHJvY2Vzc2VkIG1lc3NhZ2VzLiBUaGUgcmVzdWx0IGV2ZW4gY29tcHV0ZWRcbiAgICAgKiBvbiBhbiBvbGRlciBzdGF0ZSBtaWdodCBzdGlsbCBiZSB1c2VmdWwgZm9yIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIGNsaWVudCBkZWNpZGVzIHRoYXQgYSByZXN1bHQgaXMgbm90IG9mIGFueSB1c2UgYW55bW9yZVxuICAgICAqIHRoZSBjbGllbnQgc2hvdWxkIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLkNvbnRlbnRNb2RpZmllZCA9IC0zMjgwMTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IGhhcyBjYW5jZWxlZCBhIHJlcXVlc3QgYW5kIGEgc2VydmVyIGFzIGRldGVjdGVkXG4gICAgICogdGhlIGNhbmNlbC5cbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlJlcXVlc3RDYW5jZWxsZWQgPSAtMzI4MDA7XG4gICAgLyoqXG4gICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgTFNQIHJlc2VydmVkIGVycm9yIGNvZGVzLlxuICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgKlxuICAgICogQHNpbmNlIDMuMTYuMFxuICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5sc3BSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzI4MDA7XG59KShMU1BFcnJvckNvZGVzIHx8IChleHBvcnRzLkxTUEVycm9yQ29kZXMgPSBMU1BFcnJvckNvZGVzID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKGlucHV0LCBvdXRwdXQsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGlmICh2c2NvZGVfanNvbnJwY18xLkNvbm5lY3Rpb25TdHJhdGVneS5pcyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0geyBjb25uZWN0aW9uU3RyYXRlZ3k6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCB2c2NvZGVfanNvbnJwY18xLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKShpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSBjcmVhdGVQcm90b2NvbENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0MzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlID0gZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xudmFyIE1lc3NhZ2VEaXJlY3Rpb247XG4oZnVuY3Rpb24gKE1lc3NhZ2VEaXJlY3Rpb24pIHtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wiY2xpZW50VG9TZXJ2ZXJcIl0gPSBcImNsaWVudFRvU2VydmVyXCI7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcInNlcnZlclRvQ2xpZW50XCJdID0gXCJzZXJ2ZXJUb0NsaWVudFwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJib3RoXCJdID0gXCJib3RoXCI7XG59KShNZXNzYWdlRGlyZWN0aW9uIHx8IChleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gPSBNZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbmNsYXNzIFJlZ2lzdHJhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBSZWdpc3RyYXRpb25UeXBlO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZTAgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IFByb3RvY29sUmVxdWVzdFR5cGUwO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IFByb3RvY29sUmVxdWVzdFR5cGU7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMDtcbmNsYXNzIFByb3RvY29sTm90aWZpY2F0aW9uVHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgdnNjb2RlX2pzb25ycGNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2MDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXN1bHQgYSBgQ2FsbEhpZXJhcmNoeUl0ZW1gIGluIGEgZG9jdW1lbnQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAqIENhbiBiZSB1c2VkIGFzIGFuIGlucHV0IHRvIGFuIGluY29taW5nIG9yIG91dGdvaW5nIGNhbGwgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZUNhbGxIaWVyYXJjaHknO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCB8fCAoZXhwb3J0cy5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSBDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW5jb21pbmcgY2FsbHMgZm9yIGEgZ2l2ZW4gYENhbGxIaWVyYXJjaHlJdGVtYC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCkge1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXRob2QgPSAnY2FsbEhpZXJhcmNoeS9pbmNvbWluZ0NhbGxzJztcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgfHwgKGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0gQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIG91dGdvaW5nIGNhbGxzIGZvciBhIGdpdmVuIGBDYWxsSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QpIHtcbiAgICBDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWV0aG9kID0gJ2NhbGxIaWVyYXJjaHkvb3V0Z29pbmdDYWxscyc7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXRob2QpO1xufSkoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3NDc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgY29sb3Igc3ltYm9scyBmb3VuZCBpbiBhIGdpdmVuIHRleHQgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudENvbG9yUGFyYW1zfSB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb24gQ29sb3JJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudENvbG9yUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRDb2xvclJlcXVlc3QpIHtcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50Q29sb3InO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50Q29sb3JSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Q29sb3JSZXF1ZXN0ID0gRG9jdW1lbnRDb2xvclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgcHJlc2VudGF0aW9uIGZvciBhIGNvbG9yLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb25QYXJhbXN9IHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbiBDb2xvckluZm9ybWF0aW9uW119IG9yIGEgVGhlbmFibGVcbiAqIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29sb3JQcmVzZW50YXRpb24nO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjM5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vLy0tLS0gR2V0IENvbmZpZ3VyYXRpb24gcmVxdWVzdCAtLS0tXG4vKipcbiAqIFRoZSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCBhIGNlcnRhaW5cbiAqIGNvbmZpZ3VyYXRpb24gc2V0dGluZy5cbiAqXG4gKiBUaGlzIHB1bGwgbW9kZWwgcmVwbGFjZXMgdGhlIG9sZCBwdXNoIG1vZGVsIHdlcmUgdGhlIGNsaWVudCBzaWduYWxlZCBjb25maWd1cmF0aW9uIGNoYW5nZSB2aWEgYW5cbiAqIGV2ZW50LiBJZiB0aGUgc2VydmVyIHN0aWxsIG5lZWRzIHRvIHJlYWN0IHRvIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyAoc2luY2UgdGhlIHNlcnZlciBjYWNoZXMgdGhlXG4gKiByZXN1bHQgb2YgYHdvcmtzcGFjZS9jb25maWd1cmF0aW9uYCByZXF1ZXN0cykgdGhlIHNlcnZlciBzaG91bGQgcmVnaXN0ZXIgZm9yIGFuIGVtcHR5IGNvbmZpZ3VyYXRpb25cbiAqIGNoYW5nZSBldmVudCBhbmQgZW1wdHkgdGhlIGNhY2hlIGlmIHN1Y2ggYW4gZXZlbnQgaXMgcmVjZWl2ZWQuXG4gKi9cbnZhciBDb25maWd1cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29uZmlndXJhdGlvblJlcXVlc3QpIHtcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24nO1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29uZmlndXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbmZpZ3VyYXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gQ29uZmlndXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlY2xhcmF0aW9ufSBvciBhIHR5cGVkIGFycmF5IG9mIHtAbGluayBEZWNsYXJhdGlvbkxpbmt9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERlY2xhcmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoRGVjbGFyYXRpb25SZXF1ZXN0KSB7XG4gICAgRGVjbGFyYXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVjbGFyYXRpb24nO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWNsYXJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKERlY2xhcmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSBEZWNsYXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDk0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTExMCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUucmV0cmlnZ2VyUmVxdWVzdCk7XG4gICAgfVxuICAgIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhLmlzID0gaXM7XG59KShEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSB8fCAoZXhwb3J0cy5EaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVwb3J0IGtpbmRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIGRpYWdub3N0aWMgcmVwb3J0IHdpdGggYSBmdWxsXG4gICAgICogc2V0IG9mIHByb2JsZW1zLlxuICAgICAqL1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQuRnVsbCA9ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBBIHJlcG9ydCBpbmRpY2F0aW5nIHRoYXQgdGhlIGxhc3RcbiAgICAgKiByZXR1cm5lZCByZXBvcnQgaXMgc3RpbGwgYWNjdXJhdGUuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5VbmNoYW5nZWQgPSAndW5jaGFuZ2VkJztcbn0pKERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgfHwgKGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IERvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgZGlhZ25vc3RpYyByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCkge1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWFnbm9zdGljJztcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIHdvcmtzcGFjZSBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2RpYWdub3N0aWMnO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgcmVmcmVzaCByZXF1ZXN0IGRlZmluaXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9kaWFnbm9zdGljL3JlZnJlc2hgO1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc4MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSBwYXR0ZXJuIGtpbmQgZGVzY3JpYmluZyBpZiBhIGdsb2IgcGF0dGVybiBtYXRjaGVzIGEgZmlsZSBhIGZvbGRlciBvclxuICogYm90aC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7XG4oZnVuY3Rpb24gKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIG1hdGNoZXMgYSBmaWxlIG9ubHkuXG4gICAgICovXG4gICAgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kLmZpbGUgPSAnZmlsZSc7XG4gICAgLyoqXG4gICAgICogVGhlIHBhdHRlcm4gbWF0Y2hlcyBhIGZvbGRlciBvbmx5LlxuICAgICAqL1xuICAgIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZC5mb2xkZXIgPSAnZm9sZGVyJztcbn0pKEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCB8fCAoZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBjcmVhdGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGNyZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY3JlYXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIHJldHVybiBhIGBXb3Jrc3BhY2VFZGl0YCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gd29ya3NwYWNlIGJlZm9yZSB0aGVcbiAqIGZpbGVzIGFyZSBjcmVhdGVkLiBIZW5jZSB0aGUgYFdvcmtzcGFjZUVkaXRgIGNhbiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGUgZmlsZVxuICogdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxDcmVhdGVGaWxlcyc7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0gV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgY3JlYXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgY3JlYXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbikge1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ3JlYXRlRmlsZXMnO1xuICAgIERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIHJlbmFtZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogcmVuYW1lZCBhcyBsb25nIGFzIHRoZSByZW5hbWUgaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsUmVuYW1lRmlsZXMnO1xuICAgIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCA9IFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIHJlbmFtZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIHJlbmFtZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZFJlbmFtZUZpbGVzJztcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBkZWxldGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGRlbGV0ZWQgYXMgbG9uZyBhcyB0aGUgZGVsZXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWREZWxldGVGaWxlcyc7XG4gICAgRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCBkZWxldGUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSBkZWxldGVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCkge1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93aWxsRGVsZXRlRmlsZXMnO1xuICAgIFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QgfHwgKGV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IFdpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgZm9sZGluZyByYW5nZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3Qnc1xuICogcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEZvbGRpbmdSYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlTGlzdH0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRm9sZGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb2xkaW5nUmFuZ2UnO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBGb2xkaW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEZvbGRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKEZvbGRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IEZvbGRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xOC4wXG4gKiBAcHJvcG9zZWRcbiAqL1xudmFyIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCkge1xuICAgIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvZm9sZGluZ1JhbmdlL3JlZnJlc2hgO1xuICAgIEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShGb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZWZyZXNoUmVxdWVzdCA9IEZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW1wbGVtZW50YXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW1wbGVtZW50YXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbXBsZW1lbnRhdGlvblJlcXVlc3QpIHtcbiAgICBJbXBsZW1lbnRhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbXBsZW1lbnRhdGlvbic7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoSW1wbGVtZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IEltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5sYXkgaGludHMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGF5SGludHNQYXJhbXN9LCB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIElubGF5SGludCBJbmxheUhpbnRbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVxdWVzdCkge1xuICAgIElubGF5SGludFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxheUhpbnQnO1xuICAgIElubGF5SGludFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxheUhpbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IElubGF5SGludFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIGFuIGlubGF5IGhpbnQuXG4gKiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBJbmxheUhpbnR9LCB0aGUgcmVzcG9uc2UgaXNcbiAqIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2lubGF5SGludC9yZXNvbHZlJztcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IElubGF5SGludFJlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGF5SGludFJlZnJlc2hSZXF1ZXN0KSB7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxheUhpbnQvcmVmcmVzaGA7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBJbmxheUhpbnRSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMzIyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lQ29tcGxldGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5saW5lIGNvbXBsZXRpb25zIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBJbmxpbmVDb21wbGV0aW9uUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVDb21wbGV0aW9uIElubGluZUNvbXBsZXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTguMFxuICogQHByb3Bvc2VkXG4gKi9cbnZhciBJbmxpbmVDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBJbmxpbmVDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZUNvbXBsZXRpb24nO1xuICAgIElubGluZUNvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5saW5lQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKElubGluZUNvbXBsZXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLklubGluZUNvbXBsZXRpb25SZXF1ZXN0ID0gSW5saW5lQ29tcGxldGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGluZSB2YWx1ZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGluZVZhbHVlUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVWYWx1ZSBJbmxpbmVWYWx1ZVtdfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZVZhbHVlJztcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lVmFsdWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlcXVlc3QgfHwgKGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gSW5saW5lVmFsdWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9pbmxpbmVWYWx1ZS9yZWZyZXNoYDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE4MTU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgPSBleHBvcnRzLlJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSBleHBvcnRzLlNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCA9IGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2F0Y2hLaW5kID0gZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLkRpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5NZXNzYWdlVHlwZSA9IGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRXhpdE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IGV4cG9ydHMuVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyA9IGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciA9IHZvaWQgMDtcbmV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJLaW5kID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgPSBleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkZvbGRpbmdSYW5nZVJlcXVlc3QgPSBleHBvcnRzLkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRDb2xvclJlcXVlc3QgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSBleHBvcnRzLkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlJlbmFtZVJlcXVlc3QgPSBleHBvcnRzLlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1Jlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gdm9pZCAwO1xuZXhwb3J0cy5JbmxpbmVDb21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSBleHBvcnRzLklubGF5SGludFJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuY29uc3QgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NTIpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2MzMpO1xuY29uc3QgcHJvdG9jb2xfaW1wbGVtZW50YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzI4Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBsZW1lbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xLkltcGxlbWVudGF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjY0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVEZWZpbml0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEuVHlwZURlZmluaXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjM5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbmZpZ3VyYXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29uZmlndXJhdGlvbl8xLkNvbmZpZ3VyYXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzc0Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb2N1bWVudENvbG9yUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Eb2N1bWVudENvbG9yUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjAzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMS5Gb2xkaW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvbGRpbmdSYW5nZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEuRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZGVjbGFyYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTU4MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kZWNsYXJhdGlvbl8xLkRlY2xhcmF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbGVjdGlvblJhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Byb2dyZXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNjYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MDIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbkZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuVG9rZW5Gb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Nob3dEb2N1bWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzMzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNob3dEb2N1bWVudFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zaG93RG9jdW1lbnRfMS5TaG93RG9jdW1lbnRSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQ5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3ODEpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Njg0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzgzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9pbmxpbmVDb21wbGV0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMjIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5saW5lQ29tcGxldGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVDb21wbGV0aW9uXzEuSW5saW5lQ29tcGxldGlvblJlcXVlc3Q7IH0gfSkpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuc2NoZW1lKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnBhdHRlcm4pKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50RmlsdGVyID0gVGV4dERvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tEb2N1bWVudEZpbHRlcn0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tEb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLm5vdGVib29rVHlwZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5zY2hlbWUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUucGF0dGVybikpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50RmlsdGVyIHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBOb3RlYm9va0RvY3VtZW50RmlsdGVyID0ge30pKTtcbi8qKlxuICogVGhlIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLm5vdGVib29rKSB8fCBOb3RlYm9va0RvY3VtZW50RmlsdGVyLmlzKGNhbmRpZGF0ZS5ub3RlYm9vaykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmxhbmd1YWdlID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0gRG9jdW1lbnRTZWxlY3RvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBgY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHJlZ2lzdGVyIGEgbmV3IGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgUmVnaXN0cmF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVnaXN0cmF0aW9uUmVxdWVzdCkge1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC9yZWdpc3RlckNhcGFiaWxpdHknO1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBSZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKFJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCA9IFJlZ2lzdHJhdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYGNsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHVucmVnaXN0ZXIgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBVbnJlZ2lzdHJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKFVucmVnaXN0cmF0aW9uUmVxdWVzdCkge1xuICAgIFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3VucmVnaXN0ZXJDYXBhYmlsaXR5JztcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShVbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCB8fCAoZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBSZXNvdXJjZU9wZXJhdGlvbktpbmQgPSB7fSkpO1xudmFyIEZhaWx1cmVIYW5kbGluZ0tpbmQ7XG4oZnVuY3Rpb24gKEZhaWx1cmVIYW5kbGluZ0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyB0aGUgd29ya3NwYWNlIGNoYW5nZSBpcyBzaW1wbHkgYWJvcnRlZCBpZiBvbmUgb2YgdGhlIGNoYW5nZXMgcHJvdmlkZWRcbiAgICAgKiBmYWlscy4gQWxsIG9wZXJhdGlvbnMgZXhlY3V0ZWQgYmVmb3JlIHRoZSBmYWlsaW5nIG9wZXJhdGlvbiBzdGF5IGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuQWJvcnQgPSAnYWJvcnQnO1xuICAgIC8qKlxuICAgICAqIEFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLiBUaGF0IG1lYW5zIHRoZXkgZWl0aGVyIGFsbFxuICAgICAqIHN1Y2NlZWQgb3Igbm8gY2hhbmdlcyBhdCBhbGwgYXJlIGFwcGxpZWQgdG8gdGhlIHdvcmtzcGFjZS5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlRyYW5zYWN0aW9uYWwgPSAndHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHdvcmtzcGFjZSBlZGl0IGNvbnRhaW5zIG9ubHkgdGV4dHVhbCBmaWxlIGNoYW5nZXMgdGhleSBhcmUgZXhlY3V0ZWQgdHJhbnNhY3Rpb25hbC5cbiAgICAgKiBJZiByZXNvdXJjZSBjaGFuZ2VzIChjcmVhdGUsIHJlbmFtZSBvciBkZWxldGUgZmlsZSkgYXJlIHBhcnQgb2YgdGhlIGNoYW5nZSB0aGUgZmFpbHVyZVxuICAgICAqIGhhbmRsaW5nIHN0cmF0ZWd5IGlzIGFib3J0LlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVGV4dE9ubHlUcmFuc2FjdGlvbmFsID0gJ3RleHRPbmx5VHJhbnNhY3Rpb25hbCc7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0cmllcyB0byB1bmRvIHRoZSBvcGVyYXRpb25zIGFscmVhZHkgZXhlY3V0ZWQuIEJ1dCB0aGVyZSBpcyBub1xuICAgICAqIGd1YXJhbnRlZSB0aGF0IHRoaXMgaXMgc3VjY2VlZGluZy5cbiAgICAgKi9cbiAgICBGYWlsdXJlSGFuZGxpbmdLaW5kLlVuZG8gPSAndW5kbyc7XG59KShGYWlsdXJlSGFuZGxpbmdLaW5kIHx8IChleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgPSBGYWlsdXJlSGFuZGxpbmdLaW5kID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBwb3NpdGlvbiBlbmNvZGluZyBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBQb3NpdGlvbkVuY29kaW5nS2luZDtcbihmdW5jdGlvbiAoUG9zaXRpb25FbmNvZGluZ0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtOCBjb2RlIHVuaXRzIChlLmcuIGJ5dGVzKS5cbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEY4ID0gJ3V0Zi04JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMTYgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgYW5kIG11c3QgYWx3YXlzIGJlIHN1cHBvcnRlZFxuICAgICAqIGJ5IHNlcnZlcnNcbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEYxNiA9ICd1dGYtMTYnO1xuICAgIC8qKlxuICAgICAqIENoYXJhY3RlciBvZmZzZXRzIGNvdW50IFVURi0zMiBjb2RlIHVuaXRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50YXRpb24gbm90ZTogdGhlc2UgYXJlIHRoZSBzYW1lIGFzIFVuaWNvZGUgY29kZXBvaW50cyxcbiAgICAgKiBzbyB0aGlzIGBQb3NpdGlvbkVuY29kaW5nS2luZGAgbWF5IGFsc28gYmUgdXNlZCBmb3IgYW5cbiAgICAgKiBlbmNvZGluZy1hZ25vc3RpYyByZXByZXNlbnRhdGlvbiBvZiBjaGFyYWN0ZXIgb2Zmc2V0cy5cbiAgICAgKi9cbiAgICBQb3NpdGlvbkVuY29kaW5nS2luZC5VVEYzMiA9ICd1dGYtMzInO1xufSkoUG9zaXRpb25FbmNvZGluZ0tpbmQgfHwgKGV4cG9ydHMuUG9zaXRpb25FbmNvZGluZ0tpbmQgPSBQb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5kb2N1bWVudFNlbGVjdG9yID09PSBudWxsIHx8IERvY3VtZW50U2VsZWN0b3IuaXMoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucy5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBXb3JrRG9uZVByb2dyZXNzT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLndvcmtEb25lUHJvZ3Jlc3MgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzKSk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmlzID0gaXM7XG4gICAgZnVuY3Rpb24gaGFzV29ya0RvbmVQcm9ncmVzcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzKTtcbiAgICB9XG4gICAgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMuaGFzV29ya0RvbmVQcm9ncmVzcyA9IGhhc1dvcmtEb25lUHJvZ3Jlc3M7XG59KShXb3JrRG9uZVByb2dyZXNzT3B0aW9ucyB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzT3B0aW9ucyA9IFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0IHx8IChleHBvcnRzLkluaXRpYWxpemVSZXF1ZXN0ID0gSW5pdGlhbGl6ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBLbm93biBlcnJvciBjb2RlcyBmb3IgYW4gYEluaXRpYWxpemVFcnJvckNvZGVzYDtcbiAqL1xudmFyIEluaXRpYWxpemVFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplRXJyb3JDb2Rlcykge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcm90b2NvbCB2ZXJzaW9uIHByb3ZpZGVkIGJ5IHRoZSBjbGllbnQgY2FuJ3QgYmUgaGFuZGxlZCBieSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBpbml0aWFsaXplIGVycm9yIGdvdCByZXBsYWNlZCBieSBjbGllbnQgY2FwYWJpbGl0aWVzLiBUaGVyZSBpc1xuICAgICAqIG5vIHZlcnNpb24gaGFuZHNoYWtlIGluIHZlcnNpb24gMy4weFxuICAgICAqL1xuICAgIEluaXRpYWxpemVFcnJvckNvZGVzLnVua25vd25Qcm90b2NvbFZlcnNpb24gPSAxO1xufSkoSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSBJbml0aWFsaXplRXJyb3JDb2RlcyA9IHt9KSk7XG4vKipcbiAqIFRoZSBpbml0aWFsaXplZCBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlXG4gKiBzZXJ2ZXIgYWZ0ZXIgdGhlIGNsaWVudCBpcyBmdWxseSBpbml0aWFsaXplZCBhbmQgdGhlIHNlcnZlclxuICogaXMgYWxsb3dlZCB0byBzZW5kIHJlcXVlc3RzIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LlxuICovXG52YXIgSW5pdGlhbGl6ZWROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEluaXRpYWxpemVkTm90aWZpY2F0aW9uKSB7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWV0aG9kID0gJ2luaXRpYWxpemVkJztcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKEluaXRpYWxpemVkTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkluaXRpYWxpemVkTm90aWZpY2F0aW9uID0gSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgfHwgKGV4cG9ydHMuU2h1dGRvd25SZXF1ZXN0ID0gU2h1dGRvd25SZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBFeGl0IE5vdGlmaWNhdGlvbiAtLS0tXG4vKipcbiAqIFRoZSBleGl0IGV2ZW50IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG9cbiAqIGFzayB0aGUgc2VydmVyIHRvIGV4aXQgaXRzIHByb2Nlc3MuXG4gKi9cbnZhciBFeGl0Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChFeGl0Tm90aWZpY2F0aW9uKSB7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnZXhpdCc7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEV4aXROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAoRXhpdE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRXhpdE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uID0gRXhpdE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlclxuICogd2hlbiB0aGUgY2xpZW50J3MgY29uZmlndXJhdGlvbiBoYXMgY2hhbmdlZC4gVGhlIG5vdGlmaWNhdGlvbiBjb250YWluc1xuICogdGhlIGNoYW5nZWQgY29uZmlndXJhdGlvbiBhcyBkZWZpbmVkIGJ5IHRoZSBsYW5ndWFnZSBjbGllbnQuXG4gKi9cbnZhciBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZENoYW5nZUNvbmZpZ3VyYXRpb24nO1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uID0gRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xuICAgIC8qKlxuICAgICAqIEEgZGVidWcgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE4LjBcbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5EZWJ1ZyA9IDU7XG59KShNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlVHlwZSA9IE1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBTaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBzaG93IG1lc3NhZ2UgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNob3cgYSBtZXNzYWdlXG4gKiBhbmQgYSBzZXQgb2Ygb3B0aW9ucyBhY3Rpb25zIHRvIHRoZSB1c2VyLlxuICovXG52YXIgU2hvd01lc3NhZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZVJlcXVlc3QpIHtcbiAgICBTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93TWVzc2FnZVJlcXVlc3QnO1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaG93TWVzc2FnZVJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dNZXNzYWdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgPSBTaG93TWVzc2FnZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgbG9nIG1lc3NhZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyBhIHBhcnRpY3VsYXIgbWVzc2FnZS5cbiAqL1xudmFyIExvZ01lc3NhZ2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKExvZ01lc3NhZ2VOb3RpZmljYXRpb24pIHtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvbG9nTWVzc2FnZSc7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShMb2dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShMb2dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ01lc3NhZ2VOb3RpZmljYXRpb24gPSBMb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgaG93IHRoZSBob3N0IChlZGl0b3IpIHNob3VsZCBzeW5jXG4gKiBkb2N1bWVudCBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTeW5jS2luZDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U3luY0tpbmQpIHtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgc2hvdWxkIG5vdCBiZSBzeW5jZWQgYXQgYWxsLlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFN5bmNLaW5kLk5vbmUgPSAwO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBhcmUgc3luY2VkIGJ5IGFsd2F5cyBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnRcbiAgICAgKiBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbCA9IDE7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgc2VuZGluZyB0aGUgZnVsbCBjb250ZW50IG9uIG9wZW4uXG4gICAgICogQWZ0ZXIgdGhhdCBvbmx5IGluY3JlbWVudGFsIHVwZGF0ZXMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgICAqIHNlbmQuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgPSAyO1xufSkoVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSBUZXh0RG9jdW1lbnRTeW5jS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBvcGVuIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIHNpZ25hbFxuICogbmV3bHkgb3BlbmVkIHRleHQgZG9jdW1lbnRzLiBUaGUgZG9jdW1lbnQncyB0cnV0aCBpcyBub3cgbWFuYWdlZCBieSB0aGUgY2xpZW50XG4gKiBhbmQgdGhlIHNlcnZlciBtdXN0IG5vdCB0cnkgdG8gcmVhZCB0aGUgZG9jdW1lbnQncyB0cnV0aCB1c2luZyB0aGUgZG9jdW1lbnQnc1xuICogdXJpLiBPcGVuIGluIHRoaXMgc2Vuc2UgbWVhbnMgaXQgaXMgbWFuYWdlZCBieSB0aGUgY2xpZW50LiBJdCBkb2Vzbid0IG5lY2Vzc2FyaWx5XG4gKiBtZWFuIHRoYXQgaXRzIGNvbnRlbnQgaXMgcHJlc2VudGVkIGluIGFuIGVkaXRvci4gQW4gb3BlbiBub3RpZmljYXRpb24gbXVzdCBub3RcbiAqIGJlIHNlbnQgbW9yZSB0aGFuIG9uY2Ugd2l0aG91dCBhIGNvcnJlc3BvbmRpbmcgY2xvc2Ugbm90aWZpY2F0aW9uIHNlbmQgYmVmb3JlLlxuICogVGhpcyBtZWFucyBvcGVuIGFuZCBjbG9zZSBub3RpZmljYXRpb24gbXVzdCBiZSBiYWxhbmNlZCBhbmQgdGhlIG1heCBvcGVuIGNvdW50XG4gKiBpcyBvbmUuXG4gKi9cbnZhciBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZE9wZW4nO1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IHx8IChleHBvcnRzLlRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gc2lnbmFsXG4gKiBjaGFuZ2VzIHRvIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlkQ2hhbmdlJztcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgY2xvc2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogdGhlIGRvY3VtZW50IGdvdCBjbG9zZWQgaW4gdGhlIGNsaWVudC4gVGhlIGRvY3VtZW50J3MgdHJ1dGggbm93IGV4aXN0cyB3aGVyZVxuICogdGhlIGRvY3VtZW50J3MgdXJpIHBvaW50cyB0byAoZS5nLiBpZiB0aGUgZG9jdW1lbnQncyB1cmkgaXMgYSBmaWxlIHVyaSB0aGVcbiAqIHRydXRoIG5vdyBleGlzdHMgb24gZGlzaykuIEFzIHdpdGggdGhlIG9wZW4gbm90aWZpY2F0aW9uIHRoZSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGlzIGFib3V0IG1hbmFnaW5nIHRoZSBkb2N1bWVudCdzIGNvbnRlbnQuIFJlY2VpdmluZyBhIGNsb3NlIG5vdGlmaWNhdGlvblxuICogZG9lc24ndCBtZWFuIHRoYXQgdGhlIGRvY3VtZW50IHdhcyBvcGVuIGluIGFuIGVkaXRvciBiZWZvcmUuIEEgY2xvc2VcbiAqIG5vdGlmaWNhdGlvbiByZXF1aXJlcyBhIHByZXZpb3VzIG9wZW4gbm90aWZpY2F0aW9uIHRvIGJlIHNlbnQuXG4gKi9cbnZhciBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZENsb3NlJztcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgcmVhc29ucyB3aHkgYSB0ZXh0IGRvY3VtZW50IGlzIHNhdmVkLlxuICovXG52YXIgVGV4dERvY3VtZW50U2F2ZVJlYXNvbjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50U2F2ZVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHRyaWdnZXJlZCwgZS5nLiBieSB0aGUgdXNlciBwcmVzc2luZyBzYXZlLCBieSBzdGFydGluZyBkZWJ1Z2dpbmcsXG4gICAgICogb3IgYnkgYW4gQVBJIGNhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWwgPSAxO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBhZnRlciBhIGRlbGF5LlxuICAgICAqL1xuICAgIFRleHREb2N1bWVudFNhdmVSZWFzb24uQWZ0ZXJEZWxheSA9IDI7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgZWRpdG9yIGxvc3QgZm9jdXMuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5Gb2N1c091dCA9IDM7XG59KShUZXh0RG9jdW1lbnRTYXZlUmVhc29uIHx8IChleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gPSBUZXh0RG9jdW1lbnRTYXZlUmVhc29uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCB3aWxsIHNhdmUgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuXG4gKi9cbnZhciBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3dpbGxTYXZlJztcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2F0Y2hlZCBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgY2xpZW50IGRldGVjdHMgY2hhbmdlcyB0byBmaWxlIHdhdGNoZWQgYnkgdGhlIGxhbmd1YWdlIGNsaWVudC5cbiAqL1xudmFyIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzJztcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZmlsZSBldmVudCB0eXBlXG4gKi9cbnZhciBGaWxlQ2hhbmdlVHlwZTtcbihmdW5jdGlvbiAoRmlsZUNoYW5nZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5DcmVhdGVkID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5DaGFuZ2VkID0gMjtcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBnb3QgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBGaWxlQ2hhbmdlVHlwZS5EZWxldGVkID0gMztcbn0pKEZpbGVDaGFuZ2VUeXBlIHx8IChleHBvcnRzLkZpbGVDaGFuZ2VUeXBlID0gRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gfHwgKGV4cG9ydHMuUmVsYXRpdmVQYXR0ZXJuID0gUmVsYXRpdmVQYXR0ZXJuID0ge30pKTtcbnZhciBXYXRjaEtpbmQ7XG4oZnVuY3Rpb24gKFdhdGNoS2luZCkge1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY3JlYXRlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ3JlYXRlID0gMTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGNoYW5nZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuQ2hhbmdlID0gMjtcbiAgICAvKipcbiAgICAgKiBJbnRlcmVzdGVkIGluIGRlbGV0ZSBldmVudHNcbiAgICAgKi9cbiAgICBXYXRjaEtpbmQuRGVsZXRlID0gNDtcbn0pKFdhdGNoS2luZCB8fCAoZXhwb3J0cy5XYXRjaEtpbmQgPSBXYXRjaEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEaWFnbm9zdGljcyBub3RpZmljYXRpb24gYXJlIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2lnbmFsXG4gKiByZXN1bHRzIG9mIHZhbGlkYXRpb24gcnVucy5cbiAqL1xudmFyIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uKSB7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHVibGlzaERpYWdub3N0aWNzJztcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kID0gQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXF1ZXN0IGNvbXBsZXRpb24gYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50UG9zaXRpb259IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0gQ29tcGxldGlvbkl0ZW1bXX0gb3Ige0BsaW5rIENvbXBsZXRpb25MaXN0fVxuICogb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIGRlbGF5IHRoZSBjb21wdXRhdGlvbiBvZiB0aGUge0BsaW5rIENvbXBsZXRpb25JdGVtLmRldGFpbCBgZGV0YWlsYH1cbiAqIGFuZCB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZG9jdW1lbnRhdGlvbiBgZG9jdW1lbnRhdGlvbmB9IHByb3BlcnRpZXMgdG8gdGhlIGBjb21wbGV0aW9uSXRlbS9yZXNvbHZlYFxuICogcmVxdWVzdC4gSG93ZXZlciwgcHJvcGVydGllcyB0aGF0IGFyZSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsIHNvcnRpbmcgYW5kIGZpbHRlcmluZywgbGlrZSBgc29ydFRleHRgLFxuICogYGZpbHRlclRleHRgLCBgaW5zZXJ0VGV4dGAsIGFuZCBgdGV4dEVkaXRgLCBtdXN0IG5vdCBiZSBjaGFuZ2VkIGR1cmluZyByZXNvbHZlLlxuICovXG52YXIgQ29tcGxldGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25SZXF1ZXN0KSB7XG4gICAgQ29tcGxldGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb21wbGV0aW9uJztcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbXBsZXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IENvbXBsZXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogUmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gY29tcGxldGlvbiBpdGVtLlRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbX0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCkge1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnY29tcGxldGlvbkl0ZW0vcmVzb2x2ZSc7XG4gICAgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgfHwgKGV4cG9ydHMuSG92ZXJSZXF1ZXN0ID0gSG92ZXJSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogSG93IGEgc2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZC5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyBpbnZva2VkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyIG9yIGJ5IGEgY29tbWFuZC5cbiAgICAgKi9cbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIHRyaWdnZXJlZCBieSBhIHRyaWdnZXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5UcmlnZ2VyQ2hhcmFjdGVyID0gMjtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSBjdXJzb3IgbW92aW5nIG9yIGJ5IHRoZSBkb2N1bWVudCBjb250ZW50IGNoYW5naW5nLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5Db250ZW50Q2hhbmdlID0gMztcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSB7fSkpO1xudmFyIFNpZ25hdHVyZUhlbHBSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTaWduYXR1cmVIZWxwUmVxdWVzdCkge1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2lnbmF0dXJlSGVscCc7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QpO1xufSkoU2lnbmF0dXJlSGVscFJlcXVlc3QgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFJlcXVlc3QgPSBTaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9ufVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhIHR5cGVkIGFycmF5IG9mXG4gKiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRGVmaW5pdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKERlZmluaXRpb25SZXF1ZXN0KSB7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kZWZpbml0aW9uJztcbiAgICBEZWZpbml0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERlZmluaXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWZpbml0aW9uUmVxdWVzdCA9IERlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0IHx8IChleHBvcnRzLlJlZmVyZW5jZXNSZXF1ZXN0ID0gUmVmZXJlbmNlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYSB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGZvciBhIGdpdmVuXG4gKiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn1cbiAqIHRoZSByZXF1ZXN0IHJlc3BvbnNlIGlzIGFuIGFycmF5IG9mIHR5cGUge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fVxuICogb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdCkge1xuICAgIERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50SGlnaGxpZ2h0JztcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0gRG9jdW1lbnRTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiB0ZXh0IGRvY3VtZW50IGFuZCByYW5nZS5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVxdWVzdCkge1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29kZUFjdGlvbic7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSBDb2RlQWN0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvZGUgYWN0aW9uLlRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSB0aGUgcmVzcG9uc2VcbiAqIGlzIG9mIHR5cGUge0BsaW5rIENvZGVBY3Rpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVBY3Rpb24vcmVzb2x2ZSc7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0gV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSByYW5nZSBpbnNpZGUgdGhlIHdvcmtzcGFjZVxuICogc3ltYm9sJ3MgbG9jYXRpb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZVN5bWJvbC9yZXNvbHZlJztcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1ldGhvZCk7XG59KShXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgY29kZSBsZW5zIGZvciB0aGUgZ2l2ZW4gdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIENvZGVMZW5zUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvY29kZUxlbnMnO1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVMZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlTGVuc1JlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSBDb2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVmcmVzaCBhbGwgY29kZSBhY3Rpb25zXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kID0gYHdvcmtzcGFjZS9jb2RlTGVucy9yZWZyZXNoYDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QpO1xufSkoQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGRvY3VtZW50IGxpbmtzXG4gKi9cbnZhciBEb2N1bWVudExpbmtSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50TGluayc7XG4gICAgRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRMaW5rUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudExpbmtSZXF1ZXN0ID0gRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBmb3JtYXQgYSB3aG9sZSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBmb3JtYXQgYSByYW5nZSBpbiBhIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yYW5nZUZvcm1hdHRpbmcnO1xuICAgIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IHJhbmdlcyBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG52YXIgRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9yYW5nZXNGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRSYW5nZXNGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QgPSBEb2N1bWVudFJhbmdlc0Zvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGZvcm1hdCBhIGRvY3VtZW50IG9uIHR5cGUuXG4gKi9cbnZhciBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L29uVHlwZUZvcm1hdHRpbmcnO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIFJlbmFtZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3I7XG4oZnVuY3Rpb24gKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCdzIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gc2VsZWN0IHRoZSBpZGVudGlmaWVyXG4gICAgICogYWNjb3JkaW5nIHRoZSB0byBsYW5ndWFnZSdzIHN5bnRheCBydWxlLlxuICAgICAqL1xuICAgIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yLklkZW50aWZpZXIgPSAxO1xufSkoUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgfHwgKGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgPSBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0gUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byB0ZXN0IGFuZCBwZXJmb3JtIHRoZSBzZXR1cCBuZWNlc3NhcnkgZm9yIGEgcmVuYW1lLlxuICpcbiAqIEBzaW5jZSAzLjE2IC0gc3VwcG9ydCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICovXG52YXIgUHJlcGFyZVJlbmFtZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFByZXBhcmVSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlUmVuYW1lJztcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShQcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHNlbmQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgdG8gZXhlY3V0ZSBhIGNvbW1hbmQuIFRoZSByZXF1ZXN0IG1pZ2h0IHJldHVyblxuICogYSB3b3Jrc3BhY2UgZWRpdCB3aGljaCB0aGUgY2xpZW50IHdpbGwgYXBwbHkgdG8gdGhlIHdvcmtzcGFjZS5cbiAqL1xudmFyIEV4ZWN1dGVDb21tYW5kUmVxdWVzdDtcbihmdW5jdGlvbiAoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0KSB7XG4gICAgRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvZXhlY3V0ZUNvbW1hbmQnO1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWV0aG9kKTtcbn0pKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0gQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIyNDk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IGNhbiBiZSBlZGl0ZWQgdG9nZXRoZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCkge1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9saW5rZWRFZGl0aW5nUmFuZ2UnO1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QubWV0aG9kKTtcbn0pKExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njg0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1vbmlrZXJSZXF1ZXN0ID0gZXhwb3J0cy5Nb25pa2VyS2luZCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIE1vbmlrZXIgdW5pcXVlbmVzcyBsZXZlbCB0byBkZWZpbmUgc2NvcGUgb2YgdGhlIG1vbmlrZXIuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgVW5pcXVlbmVzc0xldmVsO1xuKGZ1bmN0aW9uIChVbmlxdWVuZXNzTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyBvbmx5IHVuaXF1ZSBpbnNpZGUgYSBkb2N1bWVudFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5kb2N1bWVudCA9ICdkb2N1bWVudCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSBhIHByb2plY3QgZm9yIHdoaWNoIGEgZHVtcCBnb3QgY3JlYXRlZFxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5wcm9qZWN0ID0gJ3Byb2plY3QnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgdGhlIGdyb3VwIHRvIHdoaWNoIGEgcHJvamVjdCBiZWxvbmdzXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdyb3VwID0gJ2dyb3VwJztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBtb25pa2VyIHNjaGVtZS5cbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuc2NoZW1lID0gJ3NjaGVtZSc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgZ2xvYmFsbHkgdW5pcXVlXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLmdsb2JhbCA9ICdnbG9iYWwnO1xufSkoVW5pcXVlbmVzc0xldmVsIHx8IChleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IFVuaXF1ZW5lc3NMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBtb25pa2VyIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTW9uaWtlcktpbmQ7XG4oZnVuY3Rpb24gKE1vbmlrZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50IGEgc3ltYm9sIHRoYXQgaXMgaW1wb3J0ZWQgaW50byBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kaW1wb3J0ID0gJ2ltcG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGV4cG9ydGVkIGZyb20gYSBwcm9qZWN0XG4gICAgICovXG4gICAgTW9uaWtlcktpbmQuJGV4cG9ydCA9ICdleHBvcnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIHJlcHJlc2VudHMgYSBzeW1ib2wgdGhhdCBpcyBsb2NhbCB0byBhIHByb2plY3QgKGUuZy4gYSBsb2NhbFxuICAgICAqIHZhcmlhYmxlIG9mIGEgZnVuY3Rpb24sIGEgY2xhc3Mgbm90IHZpc2libGUgb3V0c2lkZSB0aGUgcHJvamVjdCwgLi4uKVxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLmxvY2FsID0gJ2xvY2FsJztcbn0pKE1vbmlrZXJLaW5kIHx8IChleHBvcnRzLk1vbmlrZXJLaW5kID0gTW9uaWtlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZ2V0IHRoZSBtb25pa2VyIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dCBkb2N1bWVudCBwb3NpdGlvbi5cbiAqIFRoZSByZXF1ZXN0IHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc30uXG4gKiBUaGUgcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgTW9uaWtlciBNb25pa2VyW119IG9yIGBudWxsYC5cbiAqL1xudmFyIE1vbmlrZXJSZXF1ZXN0O1xuKGZ1bmN0aW9uIChNb25pa2VyUmVxdWVzdCkge1xuICAgIE1vbmlrZXJSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvbW9uaWtlcic7XG4gICAgTW9uaWtlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBNb25pa2VyUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShNb25pa2VyUmVxdWVzdC5tZXRob2QpO1xufSkoTW9uaWtlclJlcXVlc3QgfHwgKGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBNb25pa2VyUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3OTI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBleHBvcnRzLk5vdGVib29rQ2VsbCA9IGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODUyKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NjMzKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIG5vdGVib29rIGNlbGwga2luZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxLaW5kO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSBtYXJrdXAtY2VsbCBpcyBmb3JtYXR0ZWQgc291cmNlIHRoYXQgaXMgdXNlZCBmb3IgZGlzcGxheS5cbiAgICAgKi9cbiAgICBOb3RlYm9va0NlbGxLaW5kLk1hcmt1cCA9IDE7XG4gICAgLyoqXG4gICAgICogQSBjb2RlLWNlbGwgaXMgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5Db2RlID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbEtpbmQuaXMgPSBpcztcbn0pKE5vdGVib29rQ2VsbEtpbmQgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsS2luZCA9IE5vdGVib29rQ2VsbEtpbmQgPSB7fSkpO1xudmFyIEV4ZWN1dGlvblN1bW1hcnk7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZXhlY3V0aW9uT3JkZXIsIHN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBleGVjdXRpb25PcmRlciB9O1xuICAgICAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSB8fCBzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5leGVjdXRpb25PcmRlcikgJiYgKGNhbmRpZGF0ZS5zdWNjZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuc3VjY2VzcykpO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmUuZXhlY3V0aW9uT3JkZXIgPT09IG90aGVyLmV4ZWN1dGlvbk9yZGVyICYmIG9uZS5zdWNjZXNzID09PSBvdGhlci5zdWNjZXNzO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyA9IGVxdWFscztcbn0pKEV4ZWN1dGlvblN1bW1hcnkgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IEV4ZWN1dGlvblN1bW1hcnkgPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbDtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGtpbmQsIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQsIGRvY3VtZW50IH07XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgTm90ZWJvb2tDZWxsS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuRG9jdW1lbnRVcmkuaXMoY2FuZGlkYXRlLmRvY3VtZW50KSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5tZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlLm1ldGFkYXRhKSk7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGRpZmYob25lLCB0d28pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAob25lLmRvY3VtZW50ICE9PSB0d28uZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2RvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZS5raW5kICE9PSB0d28ua2luZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgna2luZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUuZXhlY3V0aW9uU3VtbWFyeSAhPT0gdHdvLmV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ2V4ZWN1dGlvblN1bW1hcnknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9uZS5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkIHx8IHR3by5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSAmJiAhZXF1YWxzTWV0YWRhdGEob25lLm1ldGFkYXRhLCB0d28ubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdtZXRhZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob25lLmV4ZWN1dGlvblN1bW1hcnkgIT09IHVuZGVmaW5lZCB8fCB0d28uZXhlY3V0aW9uU3VtbWFyeSAhPT0gdW5kZWZpbmVkKSAmJiAhRXhlY3V0aW9uU3VtbWFyeS5lcXVhbHMob25lLmV4ZWN1dGlvblN1bW1hcnksIHR3by5leGVjdXRpb25TdW1tYXJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZXhlY3V0aW9uU3VtbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIE5vdGVib29rQ2VsbC5kaWZmID0gZGlmZjtcbiAgICBmdW5jdGlvbiBlcXVhbHNNZXRhZGF0YShvbmUsIG90aGVyKSB7XG4gICAgICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uZSAhPT0gdHlwZW9mIG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25lQXJyYXkgPSBBcnJheS5pc0FycmF5KG9uZSk7XG4gICAgICAgIGNvbnN0IG90aGVyQXJyYXkgPSBBcnJheS5pc0FycmF5KG90aGVyKTtcbiAgICAgICAgaWYgKG9uZUFycmF5ICE9PSBvdGhlckFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZUFycmF5ICYmIG90aGVyQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lW2ldLCBvdGhlcltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMub2JqZWN0TGl0ZXJhbChvbmUpICYmIElzLm9iamVjdExpdGVyYWwob3RoZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBvbmVLZXlzID0gT2JqZWN0LmtleXMob25lKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKTtcbiAgICAgICAgICAgIGlmIChvbmVLZXlzLmxlbmd0aCAhPT0gb3RoZXJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uZUtleXMuc29ydCgpO1xuICAgICAgICAgICAgb3RoZXJLZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lS2V5cywgb3RoZXJLZXlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBvbmVLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzTWV0YWRhdGEob25lW3Byb3BdLCBvdGhlcltwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KShOb3RlYm9va0NlbGwgfHwgKGV4cG9ydHMuTm90ZWJvb2tDZWxsID0gTm90ZWJvb2tDZWxsID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50O1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbm90ZWJvb2tUeXBlLCB2ZXJzaW9uLCBjZWxscykge1xuICAgICAgICByZXR1cm4geyB1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLmludGVnZXIuaXMoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpO1xuICAgIH1cbiAgICBOb3RlYm9va0RvY3VtZW50LmlzID0gaXM7XG59KShOb3RlYm9va0RvY3VtZW50IHx8IChleHBvcnRzLk5vdGVib29rRG9jdW1lbnQgPSBOb3RlYm9va0RvY3VtZW50ID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9zeW5jJztcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0ge30pKTtcbi8qKlxuICogQSBub3RpZmljYXRpb24gc2VudCB3aGVuIGEgbm90ZWJvb2sgb3BlbnMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkT3Blbic7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGxBcnJheUNoYW5nZSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5zdGFydCkgJiYgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEudWludGVnZXIuaXMoY2FuZGlkYXRlLmRlbGV0ZUNvdW50KSAmJiAoY2FuZGlkYXRlLmNlbGxzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY2VsbHMsIE5vdGVib29rQ2VsbC5pcykpO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydCwgZGVsZXRlQ291bnQsIGNlbGxzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgc3RhcnQsIGRlbGV0ZUNvdW50IH07XG4gICAgICAgIGlmIChjZWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2VsbHMgPSBjZWxscztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxBcnJheUNoYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG59KShOb3RlYm9va0NlbGxBcnJheUNoYW5nZSB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZSA9IE5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0ge30pKTtcbnZhciBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBkb2N1bWVudCBpcyBzYXZlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRTYXZlJztcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGNsb3Nlcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE2Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG52YXIgV29ya0RvbmVQcm9ncmVzcztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzcykge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3MudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gV29ya0RvbmVQcm9ncmVzcy50eXBlO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzLmlzID0gaXM7XG59KShXb3JrRG9uZVByb2dyZXNzIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSBXb3JrRG9uZVByb2dyZXNzID0ge30pKTtcbi8qKlxuICogVGhlIGB3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jcmVhdGVgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBpbml0aWF0ZSBwcm9ncmVzc1xuICogcmVwb3J0aW5nIGZyb20gdGhlIHNlcnZlci5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCkge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1ldGhvZCA9ICd3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jcmVhdGUnO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbGAgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSAgdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGNhbmNlbCBhIHByb2dyZXNzXG4gKiBpbml0aWF0ZWQgb24gdGhlIHNlcnZlciBzaWRlLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbikge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NhbmNlbCc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBzZWxlY3Rpb24gcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU2VsZWN0aW9uUmFuZ2UgU2VsZWN0aW9uUmFuZ2VbXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZVJlcXVlc3QpIHtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZWxlY3Rpb25SYW5nZSc7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0IHx8IChleHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IFNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIwNjc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vLS0tLS0tLSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zJyAtLS0tLVxudmFyIFRva2VuRm9ybWF0O1xuKGZ1bmN0aW9uIChUb2tlbkZvcm1hdCkge1xuICAgIFRva2VuRm9ybWF0LlJlbGF0aXZlID0gJ3JlbGF0aXZlJztcbn0pKFRva2VuRm9ybWF0IHx8IChleHBvcnRzLlRva2VuRm9ybWF0ID0gVG9rZW5Gb3JtYXQgPSB7fSkpO1xudmFyIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlKSB7XG4gICAgU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnO1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUmVnaXN0cmF0aW9uVHlwZShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc1JlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwvZGVsdGEnO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvcmFuZ2UnO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5yZWdpc3RyYXRpb25NZXRob2QgPSBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QgPSBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2Uvc2VtYW50aWNUb2tlbnMvcmVmcmVzaGA7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MzMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHNob3cgYSBkb2N1bWVudC4gVGhpcyByZXF1ZXN0IG1pZ2h0IG9wZW4gYW5cbiAqIGV4dGVybmFsIHByb2dyYW0gZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB0aGUgVVJJIHRvIG9wZW4uXG4gKiBGb3IgZXhhbXBsZSBhIHJlcXVlc3QgdG8gb3BlbiBgaHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vYFxuICogd2lsbCB2ZXJ5IGxpa2VseSBvcGVuIHRoZSBVUkkgaW4gYSBXRUIgYnJvd3Nlci5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4qL1xudmFyIFNob3dEb2N1bWVudFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dEb2N1bWVudFJlcXVlc3QpIHtcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0Lm1ldGhvZCA9ICd3aW5kb3cvc2hvd0RvY3VtZW50JztcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd0RvY3VtZW50UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTaG93RG9jdW1lbnRSZXF1ZXN0Lm1ldGhvZCk7XG59KShTaG93RG9jdW1lbnRSZXF1ZXN0IHx8IChleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgPSBTaG93RG9jdW1lbnRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI2NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfVxuICogdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgVHlwZURlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlRGVmaW5pdGlvblJlcXVlc3QpIHtcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC90eXBlRGVmaW5pdGlvbic7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZURlZmluaXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZURlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IFR5cGVEZWZpbml0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNjI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzdWx0IGEgYFR5cGVIaWVyYXJjaHlJdGVtYCBpbiBhIGRvY3VtZW50IGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gKiBDYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCB0byBhIHN1YnR5cGVzIG9yIHN1cGVydHlwZXMgdHlwZSBoaWVyYXJjaHkuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9wcmVwYXJlVHlwZUhpZXJhcmNoeSc7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdXBlcnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VwZXJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdWJ0eXBlcyBmb3IgYSBnaXZlbiBgVHlwZUhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1ldGhvZCA9ICd0eXBlSGllcmFyY2h5L3N1YnR5cGVzJztcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBUaGUgYHdvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzYCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGZldGNoIHRoZSBvcGVuIHdvcmtzcGFjZSBmb2xkZXJzLlxuICovXG52YXIgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS93b3Jrc3BhY2VGb2xkZXJzJztcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd29ya3NwYWNlL2RpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gdGhlIHdvcmtzcGFjZVxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyc7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODYzMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5vYmplY3RMaXRlcmFsID0gZXhwb3J0cy50eXBlZEFycmF5ID0gZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcbmZ1bmN0aW9uIHR5cGVkQXJyYXkodmFsdWUsIGNoZWNrKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGNoZWNrKTtcbn1cbmV4cG9ydHMudHlwZWRBcnJheSA9IHR5cGVkQXJyYXk7XG5mdW5jdGlvbiBvYmplY3RMaXRlcmFsKHZhbHVlKSB7XG4gICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcgY2xhc3MgaW5zdGFuY2VzIHBhc3MgdGhpcyBjaGVjayBhcyB3ZWxsLiBTaW5jZSB0aGUgTFNQXG4gICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAvLyBsaWtlIHRoaXM6IGBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpKSA9PT0gbnVsbGBcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMub2JqZWN0TGl0ZXJhbCA9IG9iamVjdExpdGVyYWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ4Nzk6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODkyNyk7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTY5KTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDg5NjkpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTI3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTY5KTtcbmNsYXNzIE1lc3NhZ2VCdWZmZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuYXNjaWlEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICAgIH1cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXI7XG4gICAgfVxuICAgIGZyb21TdHJpbmcodmFsdWUsIF9lbmNvZGluZykge1xuICAgICAgICByZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc2NpaURlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc05hdGl2ZShidWZmZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NOYXRpdmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH1cbn1cbk1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBhcGlfMS5SQUwpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgYXBpXzEuUkFMLmluc3RhbGwoX3JpbCk7XG4gICAgfVxuICAgIFJJTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJJTCB8fCAoUklMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUklMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTY5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvdGhlbmFibGUuZC50c1wiIC8+XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5Ub3VjaCA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuUkFMID0gdm9pZCAwO1xuZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzEzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk1lc3NhZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNlRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2Rlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuRXJyb3JDb2RlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzOyB9IH0pKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTc2KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZE1hcFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxpbmtlZE1hcDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMUlVDYWNoZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxSVUNhY2hlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvdWNoXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuVG91Y2g7IH0gfSkpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTYzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3Bvc2FibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZTsgfSB9KSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjc4MCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkV2ZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtaXR0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FbWl0dGVyOyB9IH0pKTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTA2KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuU291cmNlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KSk7XG5jb25zdCBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDkyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVJlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODEzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlUmVhZGVyXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVdyaXRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzQ1KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuQWJzdHJhY3RNZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlV3JpdGVyXzEuV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlQnVmZmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxODApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RNZXNzYWdlQnVmZmVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZUJ1ZmZlcl8xLkFic3RyYWN0TWVzc2FnZUJ1ZmZlcjsgfSB9KSk7XG5jb25zdCBjb25uZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2MzApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25TdHJhdGVneTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uT3B0aW9uc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uT3B0aW9uczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsTG9nZ2VyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk51bGxMb2dnZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUb2tlblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1Rva2VuOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2dyZXNzVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Qcm9ncmVzc1R5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VWYWx1ZXNcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VWYWx1ZXM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhY2VGb3JtYXRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuVHJhY2VGb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2V0VHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuU2V0VHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nVHJhY2VOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTG9nVHJhY2VOb3RpZmljYXRpb247IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3JzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25FcnJvclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VTdHJhdGVneVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5NZXNzYWdlU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNTQpO1xuZXhwb3J0cy5SQUwgPSByYWxfMS5kZWZhdWx0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMTA2OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNTQpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNDUpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3ODApO1xudmFyIENhbmNlbGxhdGlvblRva2VuO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lXG4gICAgICAgICAgICB8fCBjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZFxuICAgICAgICAgICAgfHwgKElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSAmJiAhIWNhbmRpZGF0ZS5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCkpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbiA9IHt9KSk7XG5jb25zdCBzaG9ydGN1dEV2ZW50ID0gT2JqZWN0LmZyZWV6ZShmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBjb25zdCBoYW5kbGUgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQoY29udGV4dCksIDApO1xuICAgIHJldHVybiB7IGRpc3Bvc2UoKSB7IGhhbmRsZS5kaXNwb3NlKCk7IH0gfTtcbn0pO1xuY2xhc3MgTXV0YWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENhbmNlbGxhdGlvblRva2VuU291cmNlIHtcbiAgICBnZXQgdG9rZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGJlIGxhenkgYW5kIGNyZWF0ZSB0aGUgdG9rZW4gb25seSB3aGVuXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gbmV3IE11dGFibGVUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFuIG9iamVjdCBieSByZXR1cm5pbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGNhbmNlbGxlZCB0b2tlbiB3aGVuIGNhbmNlbGxhdGlvbiBoYXBwZW5zXG4gICAgICAgICAgICAvLyBiZWZvcmUgc29tZW9uZSBhc2tzIGZvciB0aGUgdG9rZW5cbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdG9rZW4uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRvIGluaXRpYWxpemUgd2l0aCBhbiBlbXB0eSB0b2tlbiBpZiB3ZSBoYWQgbm9uZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rva2VuIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XG4gICAgICAgICAgICAvLyBhY3R1YWxseSBkaXNwb3NlXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ2MzA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zID0gZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLklkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlVmFsdWVzID0gZXhwb3J0cy5UcmFjZSA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNTQpO1xuY29uc3QgSXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxNDUpO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMxMyk7XG5jb25zdCBsaW5rZWRNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjE3Nik7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjc4MCk7XG5jb25zdCBjYW5jZWxsYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEwNik7XG52YXIgQ2FuY2VsTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBDYW5jZWxOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvY2FuY2VsUmVxdWVzdCcpO1xufSkoQ2FuY2VsTm90aWZpY2F0aW9uIHx8IChDYW5jZWxOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIFByb2dyZXNzVG9rZW47XG4oZnVuY3Rpb24gKFByb2dyZXNzVG9rZW4pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBQcm9ncmVzc1Rva2VuLmlzID0gaXM7XG59KShQcm9ncmVzc1Rva2VuIHx8IChleHBvcnRzLlByb2dyZXNzVG9rZW4gPSBQcm9ncmVzc1Rva2VuID0ge30pKTtcbnZhciBQcm9ncmVzc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoUHJvZ3Jlc3NOb3RpZmljYXRpb24pIHtcbiAgICBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9wcm9ncmVzcycpO1xufSkoUHJvZ3Jlc3NOb3RpZmljYXRpb24gfHwgKFByb2dyZXNzTm90aWZpY2F0aW9uID0ge30pKTtcbmNsYXNzIFByb2dyZXNzVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBQcm9ncmVzc1R5cGU7XG52YXIgU3RhclJlcXVlc3RIYW5kbGVyO1xuKGZ1bmN0aW9uIChTdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXMuZnVuYyh2YWx1ZSk7XG4gICAgfVxuICAgIFN0YXJSZXF1ZXN0SGFuZGxlci5pcyA9IGlzO1xufSkoU3RhclJlcXVlc3RIYW5kbGVyIHx8IChTdGFyUmVxdWVzdEhhbmRsZXIgPSB7fSkpO1xuZXhwb3J0cy5OdWxsTG9nZ2VyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6ICgpID0+IHsgfSxcbiAgICB3YXJuOiAoKSA9PiB7IH0sXG4gICAgaW5mbzogKCkgPT4geyB9LFxuICAgIGxvZzogKCkgPT4geyB9XG59KTtcbnZhciBUcmFjZTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBUcmFjZVtUcmFjZVtcIk9mZlwiXSA9IDBdID0gXCJPZmZcIjtcbiAgICBUcmFjZVtUcmFjZVtcIk1lc3NhZ2VzXCJdID0gMV0gPSBcIk1lc3NhZ2VzXCI7XG4gICAgVHJhY2VbVHJhY2VbXCJDb21wYWN0XCJdID0gMl0gPSBcIkNvbXBhY3RcIjtcbiAgICBUcmFjZVtUcmFjZVtcIlZlcmJvc2VcIl0gPSAzXSA9IFwiVmVyYm9zZVwiO1xufSkoVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSBUcmFjZSA9IHt9KSk7XG52YXIgVHJhY2VWYWx1ZXM7XG4oZnVuY3Rpb24gKFRyYWNlVmFsdWVzKSB7XG4gICAgLyoqXG4gICAgICogVHVybiB0cmFjaW5nIG9mZi5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5PZmYgPSAnb2ZmJztcbiAgICAvKipcbiAgICAgKiBUcmFjZSBtZXNzYWdlcyBvbmx5LlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLk1lc3NhZ2VzID0gJ21lc3NhZ2VzJztcbiAgICAvKipcbiAgICAgKiBDb21wYWN0IG1lc3NhZ2UgdHJhY2luZy5cbiAgICAgKi9cbiAgICBUcmFjZVZhbHVlcy5Db21wYWN0ID0gJ2NvbXBhY3QnO1xuICAgIC8qKlxuICAgICAqIFZlcmJvc2UgbWVzc2FnZSB0cmFjaW5nLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLlZlcmJvc2UgPSAndmVyYm9zZSc7XG59KShUcmFjZVZhbHVlcyB8fCAoZXhwb3J0cy5UcmFjZVZhbHVlcyA9IFRyYWNlVmFsdWVzID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuTWVzc2FnZXM7XG4gICAgICAgICAgICBjYXNlICdjb21wYWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuQ29tcGFjdDtcbiAgICAgICAgICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5WZXJib3NlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuT2ZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuT2ZmOlxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmJztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuTWVzc2FnZXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtZXNzYWdlcyc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjb21wYWN0JztcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcmJvc2UnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2UudG9TdHJpbmcgPSB0b1N0cmluZztcbn0pKFRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0gVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlRm9ybWF0O1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIFRyYWNlRm9ybWF0W1wiVGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIFRyYWNlRm9ybWF0W1wiSlNPTlwiXSA9IFwianNvblwiO1xufSkoVHJhY2VGb3JtYXQgfHwgKGV4cG9ydHMuVHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdCA9IHt9KSk7XG4oZnVuY3Rpb24gKFRyYWNlRm9ybWF0KSB7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5UZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZUZvcm1hdC5KU09OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhY2VGb3JtYXQuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG59KShUcmFjZUZvcm1hdCB8fCAoZXhwb3J0cy5UcmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0ID0ge30pKTtcbnZhciBTZXRUcmFjZU5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoU2V0VHJhY2VOb3RpZmljYXRpb24pIHtcbiAgICBTZXRUcmFjZU5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9zZXRUcmFjZScpO1xufSkoU2V0VHJhY2VOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBTZXRUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgTG9nVHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKExvZ1RyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvbG9nVHJhY2UnKTtcbn0pKExvZ1RyYWNlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkxvZ1RyYWNlTm90aWZpY2F0aW9uID0gTG9nVHJhY2VOb3RpZmljYXRpb24gPSB7fSkpO1xudmFyIENvbm5lY3Rpb25FcnJvcnM7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25FcnJvcnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiQ2xvc2VkXCJdID0gMV0gPSBcIkNsb3NlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJEaXNwb3NlZFwiXSA9IDJdID0gXCJEaXNwb3NlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGFscmVhZHkgaW4gbGlzdGVuaW5nIG1vZGUuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkVycm9yc1tDb25uZWN0aW9uRXJyb3JzW1wiQWxyZWFkeUxpc3RlbmluZ1wiXSA9IDNdID0gXCJBbHJlYWR5TGlzdGVuaW5nXCI7XG59KShDb25uZWN0aW9uRXJyb3JzIHx8IChleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgPSBDb25uZWN0aW9uRXJyb3JzID0ge30pKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBDb25uZWN0aW9uRXJyb3I7XG52YXIgQ29ubmVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jYW5jZWxVbmRpc3BhdGNoZWQpO1xuICAgIH1cbiAgICBDb25uZWN0aW9uU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSBDb25uZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmtpbmQgPT09ICdpZCcpICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKSAmJiAoY2FuZGlkYXRlLmRpc3Bvc2UgPT09IHVuZGVmaW5lZCB8fCBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSk7XG4gICAgfVxuICAgIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLklkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdyZXF1ZXN0JyAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSkgJiYgKGNhbmRpZGF0ZS5kaXNwb3NlID09PSB1bmRlZmluZWQgfHwgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkpO1xuICAgIH1cbiAgICBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKHZhbHVlKSB8fCBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgc2VuZENhbmNlbGxhdGlvbihjb25uLCBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm4uc2VuZE5vdGlmaWNhdGlvbihDYW5jZWxOb3RpZmljYXRpb24udHlwZSwgeyBpZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cChfKSB7IH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5zZW5kQ2FuY2VsbGF0aW9uKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jbGVhbnVwKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcmVjZWl2ZXI6IENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuTWVzc2FnZSxcbiAgICAgICAgc2VuZGVyOiBDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneS5NZXNzYWdlXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyhjYW5kaWRhdGUucmVjZWl2ZXIpICYmIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5zZW5kZXIpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25TdHJhdGVneS5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSBDYW5jZWxsYXRpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgTWVzc2FnZVN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChNZXNzYWdlU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5oYW5kbGVNZXNzYWdlKTtcbiAgICB9XG4gICAgTWVzc2FnZVN0cmF0ZWd5LmlzID0gaXM7XG59KShNZXNzYWdlU3RyYXRlZ3kgfHwgKGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gTWVzc2FnZVN0cmF0ZWd5ID0ge30pKTtcbnZhciBDb25uZWN0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLmNhbmNlbGxhdGlvblN0cmF0ZWd5KSB8fCBDb25uZWN0aW9uU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLmNvbm5lY3Rpb25TdHJhdGVneSkgfHwgTWVzc2FnZVN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5tZXNzYWdlU3RyYXRlZ3kpKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvbk9wdGlvbnMuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25PcHRpb25zIHx8IChleHBvcnRzLkNvbm5lY3Rpb25PcHRpb25zID0gQ29ubmVjdGlvbk9wdGlvbnMgPSB7fSkpO1xudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIk5ld1wiXSA9IDFdID0gXCJOZXdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTGlzdGVuaW5nXCJdID0gMl0gPSBcIkxpc3RlbmluZ1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJDbG9zZWRcIl0gPSAzXSA9IFwiQ2xvc2VkXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkRpc3Bvc2VkXCJdID0gNF0gPSBcIkRpc3Bvc2VkXCI7XG59KShDb25uZWN0aW9uU3RhdGUgfHwgKENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihtZXNzYWdlUmVhZGVyLCBtZXNzYWdlV3JpdGVyLCBfbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gX2xvZ2dlciAhPT0gdW5kZWZpbmVkID8gX2xvZ2dlciA6IGV4cG9ydHMuTnVsbExvZ2dlcjtcbiAgICBsZXQgc2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGxldCBub3RpZmljYXRpb25TZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgbGV0IHVua25vd25SZXNwb25zZVNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBjb25zdCB2ZXJzaW9uID0gJzIuMCc7XG4gICAgbGV0IHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXF1ZXN0SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbkhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHByb2dyZXNzSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRpbWVyO1xuICAgIGxldCBtZXNzYWdlUXVldWUgPSBuZXcgbGlua2VkTWFwXzEuTGlua2VkTWFwKCk7XG4gICAgbGV0IHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGtub3duQ2FuY2VsZWRSZXF1ZXN0cyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcmVxdWVzdFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdHJhY2UgPSBUcmFjZS5PZmY7XG4gICAgbGV0IHRyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICBsZXQgdHJhY2VyO1xuICAgIGxldCBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5OZXc7XG4gICAgY29uc3QgZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBjbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IHVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgZGlzcG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jYW5jZWxsYXRpb25TdHJhdGVneSkgPyBvcHRpb25zLmNhbmNlbGxhdGlvblN0cmF0ZWd5IDogQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuTWVzc2FnZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0UXVldWVLZXkoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNlbmQgcmVxdWVzdHMgd2l0aCBpZCBudWxsIHNpbmNlIHRoZSByZXNwb25zZSBjYW4ndCBiZSBjb3JyZWxhdGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncmVxLScgKyBpZC50b1N0cmluZygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZVF1ZXVlS2V5KGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdyZXMtdW5rbm93bi0nICsgKCsrdW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy0nICsgaWQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSgpIHtcbiAgICAgICAgcmV0dXJuICdub3QtJyArICgrK25vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRNZXNzYWdlVG9RdWV1ZShxdWV1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShtZXNzYWdlLmlkKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVzcG9uc2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVSZXNwb25zZVF1ZXVlS2V5KG1lc3NhZ2UuaWQpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSgpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWxVbmRpc3BhdGNoZWQoX21lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaXN0ZW5pbmcoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlSGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTmV3IHx8IHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQ7XG4gICAgICAgICAgICBjbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzIGRpc3Bvc2VkIGRvbid0IHNlbnQgY2xvc2UgZXZlbnRzLlxuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkRXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKFtlcnJvciwgdW5kZWZpbmVkLCB1bmRlZmluZWRdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVFcnJvckhhbmRsZXIoZGF0YSkge1xuICAgICAgICBlcnJvckVtaXR0ZXIuZmlyZShkYXRhKTtcbiAgICB9XG4gICAgbWVzc2FnZVJlYWRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XG4gICAgbWVzc2FnZVJlYWRlci5vbkVycm9yKHJlYWRFcnJvckhhbmRsZXIpO1xuICAgIG1lc3NhZ2VXcml0ZXIub25DbG9zZShjbG9zZUhhbmRsZXIpO1xuICAgIG1lc3NhZ2VXcml0ZXIub25FcnJvcih3cml0ZUVycm9ySGFuZGxlcik7XG4gICAgZnVuY3Rpb24gdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRpbWVyIHx8IG1lc3NhZ2VRdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwcm9jZXNzTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZVJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVzcG9uc2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2VRdWV1ZSgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VRdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVN0cmF0ZWd5ID0gb3B0aW9ucz8ubWVzc2FnZVN0cmF0ZWd5O1xuICAgICAgICAgICAgaWYgKE1lc3NhZ2VTdHJhdGVneS5pcyhtZXNzYWdlU3RyYXRlZ3kpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVN0cmF0ZWd5LmhhbmRsZU1lc3NhZ2UobWVzc2FnZSwgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhbGxiYWNrID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVjZWl2ZWQgYSBjYW5jZWxsYXRpb24gbWVzc2FnZS4gQ2hlY2sgaWYgdGhlIG1lc3NhZ2UgaXMgc3RpbGwgaW4gdGhlIHF1ZXVlXG4gICAgICAgICAgICAvLyBhbmQgY2FuY2VsIGl0IGlmIGFsbG93ZWQgdG8gZG8gc28uXG4gICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzTm90aWZpY2F0aW9uKG1lc3NhZ2UpICYmIG1lc3NhZ2UubWV0aG9kID09PSBDYW5jZWxOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxJZCA9IG1lc3NhZ2UucGFyYW1zLmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9DYW5jZWwgPSBtZXNzYWdlUXVldWUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuTWVzc2FnZS5pc1JlcXVlc3QodG9DYW5jZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gb3B0aW9ucz8uY29ubmVjdGlvblN0cmF0ZWd5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IChzdHJhdGVneSAmJiBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQpID8gc3RyYXRlZ3kuY2FuY2VsVW5kaXNwYXRjaGVkKHRvQ2FuY2VsLCBjYW5jZWxVbmRpc3BhdGNoZWQpIDogY2FuY2VsVW5kaXNwYXRjaGVkKHRvQ2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIChyZXNwb25zZS5lcnJvciAhPT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaWQgPSB0b0NhbmNlbC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKHJlc3BvbnNlLCBtZXNzYWdlLm1ldGhvZCwgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKHJlc3BvbnNlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZm9yIGNhbmNlbGVkIG1lc3NhZ2UgZmFpbGVkLmApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IHJlcXVlc3RUb2tlbnMuZ2V0KGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVxdWVzdCBpcyBhbHJlYWR5IHJ1bm5pbmcuIENhbmNlbCB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGF0aW9uVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGNhbmNlbCBidXQgc3RpbGwgcXVldWUgdGhlIG1lc3NhZ2UgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW4gdXAgc3RhdGUgaW4gcHJvY2VzcyBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICBrbm93bkNhbmNlbGVkUmVxdWVzdHMuYWRkKGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRNZXNzYWdlVG9RdWV1ZShtZXNzYWdlUXVldWUsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJpZ2dlck1lc3NhZ2VRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIHdlIHJldHVybiBoZXJlIHNpbGVudGx5IHNpbmNlIHdlIGZpcmVkIGFuIGV2ZW50IHdoZW4gdGhlXG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseShyZXN1bHRPckVycm9yLCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPckVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IHJlc3VsdE9yRXJyb3IudG9Kc29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlc3VsdCA9IHJlc3VsdE9yRXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiByZXN1bHRPckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UobWVzc2FnZSwgbWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgbWVzc2FnZVdyaXRlci53cml0ZShtZXNzYWdlKS5jYXRjaCgoKSA9PiBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVzcG9uc2UgZmFpbGVkLmApKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBseUVycm9yKGVycm9yLCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IudG9Kc29uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5U3VjY2VzcyhyZXN1bHQsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAvLyBUaGUgSlNPTiBSUEMgZGVmaW5lcyB0aGF0IGEgcmVzcG9uc2UgbXVzdCBlaXRoZXIgaGF2ZSBhIHJlc3VsdCBvciBhbiBlcnJvclxuICAgICAgICAgICAgLy8gU28gd2UgY2FuJ3QgdHJlYXQgdW5kZWZpbmVkIGFzIGEgdmFsaWQgcmVzcG9uc2UgcmVzdWx0LlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogcmVxdWVzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlUmVjZWl2ZWRSZXF1ZXN0KHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlcXVlc3RIYW5kbGVycy5nZXQocmVxdWVzdE1lc3NhZ2UubWV0aG9kKTtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGxldCByZXF1ZXN0SGFuZGxlcjtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgICByZXF1ZXN0SGFuZGxlciA9IGVsZW1lbnQuaGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAocmVxdWVzdEhhbmRsZXIgfHwgc3RhclJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbktleSA9IHJlcXVlc3RNZXNzYWdlLmlkID8/IFN0cmluZyhEYXRlLm5vdygpKTsgLy9cbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblNvdXJjZSA9IElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyhjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlcilcbiAgICAgICAgICAgICAgICA/IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHRva2VuS2V5KVxuICAgICAgICAgICAgICAgIDogY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLmlkICE9PSBudWxsICYmIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5oYXMocmVxdWVzdE1lc3NhZ2UuaWQpKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU291cmNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RNZXNzYWdlLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5zZXQodG9rZW5LZXksIGNhbmNlbGxhdGlvblNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UucGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkIG5vbmUuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIoY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3RNZXNzYWdlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgcG9zaXRpb25gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlciguLi5yZXF1ZXN0TWVzc2FnZS5wYXJhbXMsIGNhbmNlbGxhdGlvblNvdXJjZS50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgcG9zaXRpb24gYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHN0YXJSZXF1ZXN0SGFuZGxlcihyZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlTdWNjZXNzKGhhbmRsZXJSZXN1bHQsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbigocmVzdWx0T3JFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHkocmVzdWx0T3JFcnJvciwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKGVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB1bmV4cGVjdGVkbHkgd2l0aG91dCBwcm92aWRpbmcgYW55IGRldGFpbHMuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5KGhhbmRsZXJSZXN1bHQsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5KGVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludGVybmFsRXJyb3IsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB1bmV4cGVjdGVkbHkgd2l0aG91dCBwcm92aWRpbmcgYW55IGRldGFpbHMuYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLk1ldGhvZE5vdEZvdW5kLCBgVW5oYW5kbGVkIG1ldGhvZCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAvLyBTZWUgaGFuZGxlIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgcmVzcG9uc2UgbWVzc2FnZSB3aXRob3V0IGlkOiBFcnJvciBpczogXFxuJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZU1lc3NhZ2UuZXJyb3IsIHVuZGVmaW5lZCwgNCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIHJlc3BvbnNlIG1lc3NhZ2Ugd2l0aG91dCBpZC4gTm8gZnVydGhlciBlcnJvciBpbmZvcm1hdGlvbiBwcm92aWRlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3BvbnNlTWVzc2FnZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB0cmFjZVJlY2VpdmVkUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlLCByZXNwb25zZVByb21pc2UpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlc3BvbnNlTWVzc2FnZS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlLCBlcnJvci5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VNZXNzYWdlLnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZU1lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVzcG9uc2UgaGFuZGxlciAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfScgZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZXNwb25zZSBoYW5kbGVyICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9JyBmYWlsZWQgdW5leHBlY3RlZGx5LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFNlZSBoYW5kbGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG5vdGlmaWNhdGlvbkhhbmRsZXI7XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxJZCA9IG1lc3NhZ2UucGFyYW1zLmlkO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzLmRlbGV0ZShjYW5jZWxJZCk7XG4gICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vdGlmaWNhdGlvbkhhbmRsZXJzLmdldChtZXNzYWdlLm1ldGhvZCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIgPSBlbGVtZW50LmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90aWZpY2F0aW9uSGFuZGxlciB8fCBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IDAgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzICE9PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgJHt0eXBlLm51bWJlck9mUGFyYW1zfSBwYXJhbXMgYnV0IHJlY2VpdmVkIG5vbmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgSlNPTi1SUEMgbGlicmFyaWVzIHRoYXQgc2VuZCBwcm9ncmVzcyBtZXNzYWdlIGFzIHBvc2l0aW9uYWwgcGFyYW1zIGFsdGhvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgYXMgbmFtZWQuIFNvIGNvbnZlcnQgdGhlbSBpZiB0aGlzIGlzIHRoZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbWVzc2FnZS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kICYmIHBhcmFtcy5sZW5ndGggPT09IDIgJiYgUHJvZ3Jlc3NUb2tlbi5pcyhwYXJhbXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcih7IHRva2VuOiBwYXJhbXNbMF0sIHZhbHVlOiBwYXJhbXNbMV0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCByZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IHBvc2l0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUubnVtYmVyT2ZQYXJhbXMgIT09IG1lc3NhZ2UucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgJHtwYXJhbXMubGVuZ3RofSBhcmd1bWVudHNgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgcG9zaXRpb24gYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgbmFtZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiBoYW5kbGVyICcke21lc3NhZ2UubWV0aG9kfScgZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gaGFuZGxlciAnJHttZXNzYWdlLm1ldGhvZH0nIGZhaWxlZCB1bmV4cGVjdGVkbHkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlci5maXJlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUludmFsaWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1JlY2VpdmVkIGVtcHR5IG1lc3NhZ2UuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIHdoaWNoIGlzIG5laXRoZXIgYSByZXNwb25zZSBub3IgYSBub3RpZmljYXRpb24gbWVzc2FnZTpcXG4ke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDQpfWApO1xuICAgICAgICAvLyBUZXN0IHdoZXRoZXIgd2UgZmluZCBhbiBpZCB0byByZWplY3QgdGhlIHByb21pc2VcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKElzLnN0cmluZyhyZXNwb25zZU1lc3NhZ2UuaWQpIHx8IElzLm51bWJlcihyZXNwb25zZU1lc3NhZ2UuaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSByZXNwb25zZU1lc3NhZ2UuaWQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSByZXNwb25zZVByb21pc2VzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlci5yZWplY3QobmV3IEVycm9yKCdUaGUgcmVjZWl2ZWQgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHQgbm9yIGFuIGVycm9yIHByb3BlcnR5LicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlUcmFjZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRyYWNlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgNCk7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLkNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkgJiYgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVxdWVzdCAnJHttZXNzYWdlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXF1ZXN0JywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHBhcmFtZXRlcnMgcHJvdmlkZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yICYmIG1lc3NhZ2UuZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYEVycm9yIGRhdGE6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5lcnJvci5kYXRhKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFJlc3VsdDogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnJlc3VsdCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcmVzdWx0IHJldHVybmVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBTZW5kaW5nIHJlc3BvbnNlICcke21ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLiBQcm9jZXNzaW5nIHJlcXVlc3QgdG9vayAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3NlbmQtcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkgJiYgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlcXVlc3QgJyR7bWVzc2FnZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtcmVxdWVzdCcsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyIHx8IG1lc3NhZ2UubWV0aG9kID09PSBMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGBQYXJhbXM6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5wYXJhbXMpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gJ05vIHBhcmFtZXRlcnMgcHJvdmlkZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCBub3RpZmljYXRpb24gJyR7bWVzc2FnZS5tZXRob2R9Jy5gLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtbm90aWZpY2F0aW9uJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZFJlc3BvbnNlKG1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVycm9yICYmIG1lc3NhZ2UuZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYEVycm9yIGRhdGE6ICR7c3RyaW5naWZ5VHJhY2UobWVzc2FnZS5lcnJvci5kYXRhKX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFJlc3VsdDogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnJlc3VsdCl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcmVzdWx0IHJldHVybmVkLlxcblxcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBtZXNzYWdlLmVycm9yID8gYCBSZXF1ZXN0IGZhaWxlZDogJHttZXNzYWdlLmVycm9yLm1lc3NhZ2V9ICgke21lc3NhZ2UuZXJyb3IuY29kZX0pLmAgOiAnJztcbiAgICAgICAgICAgICAgICB0cmFjZXIubG9nKGBSZWNlaXZlZCByZXNwb25zZSAnJHtyZXNwb25zZVByb21pc2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScgaW4gJHtEYXRlLm5vdygpIC0gcmVzcG9uc2VQcm9taXNlLnRpbWVyU3RhcnR9bXMuJHtlcnJvcn1gLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICR7bWVzc2FnZS5pZH0gd2l0aG91dCBhY3RpdmUgcmVzcG9uc2UgcHJvbWlzZS5gLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0xTUE1lc3NhZ2UoJ3JlY2VpdmUtcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dMU1BNZXNzYWdlKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0cmFjZXIgfHwgdHJhY2UgPT09IFRyYWNlLk9mZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxzcE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBpc0xTUE1lc3NhZ2U6IHRydWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICB0cmFjZXIubG9nKGxzcE1lc3NhZ2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpIHtcbiAgICAgICAgaWYgKGlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5DbG9zZWQsICdDb25uZWN0aW9uIGlzIGNsb3NlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuRGlzcG9zZWQsICdDb25uZWN0aW9uIGlzIGRpc3Bvc2VkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZMaXN0ZW5pbmcoKSB7XG4gICAgICAgIGlmIChpc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKENvbm5lY3Rpb25FcnJvcnMuQWxyZWFkeUxpc3RlbmluZywgJ0Nvbm5lY3Rpb24gaXMgYWxyZWFkeSBsaXN0ZW5pbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd0lmTm90TGlzdGVuaW5nKCkge1xuICAgICAgICBpZiAoIWlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbCBsaXN0ZW4oKSBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bmRlZmluZWRUb051bGwocGFyYW0pIHtcbiAgICAgICAgaWYgKHBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51bGxUb1VuZGVmaW5lZChwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOYW1lZFBhcmFtKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHBhcmFtKSAmJiB0eXBlb2YgcGFyYW0gPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlU2luZ2xlUGFyYW0ocGFyYW1ldGVyU3RydWN0dXJlcywgcGFyYW0pIHtcbiAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXJTdHJ1Y3R1cmVzKSB7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvOlxuICAgICAgICAgICAgICAgIGlmIChpc05hbWVkUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsVG9VbmRlZmluZWQocGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRUb051bGwocGFyYW0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWU6XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hbWVkUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lIGJ1dCBwYXJhbSBpcyBub3QgYW4gb2JqZWN0IGxpdGVyYWwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsVG9VbmRlZmluZWQocGFyYW0pO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZFRvTnVsbChwYXJhbSldO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIHN0cnVjdHVyZSAke3BhcmFtZXRlclN0cnVjdHVyZXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZQYXJhbXMgPSB0eXBlLm51bWJlck9mUGFyYW1zO1xuICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVTaW5nbGVQYXJhbSh0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMsIHBhcmFtc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aCAmJiBpIDwgbnVtYmVyT2ZQYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWRUb051bGwocGFyYW1zW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoIDwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICBzZW5kTm90aWZpY2F0aW9uOiAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcbiAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1TdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtZXRlclN0cnVjdHVyZXMgPSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bztcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmlzKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyU3RydWN0dXJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1FbmQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHBhcmFtRW5kIC0gcGFyYW1TdGFydDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBhcmdzW3BhcmFtU3RhcnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkICR7bnVtYmVyT2ZQYXJhbXN9IHBhcmFtZXRlcnMgZm9yICdieSBOYW1lJyBub3RpZmljYXRpb24gcGFyYW1ldGVyIHN0cnVjdHVyZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBhcmdzLnNsaWNlKHBhcmFtU3RhcnQsIHBhcmFtRW5kKS5tYXAodmFsdWUgPT4gdW5kZWZpbmVkVG9OdWxsKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogbWVzc2FnZVBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbihub3RpZmljYXRpb25NZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlV3JpdGVyLndyaXRlKG5vdGlmaWNhdGlvbk1lc3NhZ2UpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyBub3RpZmljYXRpb24gZmFpbGVkLmApO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTm90aWZpY2F0aW9uOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLnNldCh0eXBlLCB7IHR5cGU6IHVuZGVmaW5lZCwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJOb3RpZmljYXRpb25IYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qcm9ncmVzczogKF90eXBlLCB0b2tlbiwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzSGFuZGxlcnMuaGFzKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3Jlc3MgaGFuZGxlciBmb3IgdG9rZW4gJHt0b2tlbn0gYWxyZWFkeSByZWdpc3RlcmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXJzLnNldCh0b2tlbiwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVycy5kZWxldGUodG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmRQcm9ncmVzczogKF90eXBlLCB0b2tlbiwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBhd2FpdCBidXQgc2ltcGxlIHJldHVybiB0byBlbnN1cmUgdGhhdCB3ZSBkb24ndCBoYXZlIGFub3RoZXJcbiAgICAgICAgICAgIC8vIGFzeW5jIHNjaGVkdWxpbmcuIE90aGVyd2lzZSBvbmUgc2VuZCBjb3VsZCBvdmVydGFrZSBhbm90aGVyIHNlbmQuXG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKFByb2dyZXNzTm90aWZpY2F0aW9uLnR5cGUsIHsgdG9rZW4sIHZhbHVlIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblVuaGFuZGxlZFByb2dyZXNzOiB1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIuZXZlbnQsXG4gICAgICAgIHNlbmRSZXF1ZXN0OiAodHlwZSwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHRocm93SWZOb3RMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVBhcmFtcztcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyU3RydWN0dXJlcyA9IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuaXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbUVuZCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbi5pcyhsYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbUVuZCA9IHBhcmFtRW5kIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBsYXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHBhcmFtRW5kIC0gcGFyYW1TdGFydDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG51bWJlck9mUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBhcmdzW3BhcmFtU3RhcnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkICR7bnVtYmVyT2ZQYXJhbXN9IHBhcmFtZXRlcnMgZm9yICdieSBOYW1lJyByZXF1ZXN0IHBhcmFtZXRlciBzdHJ1Y3R1cmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gYXJncy5zbGljZShwYXJhbVN0YXJ0LCBwYXJhbUVuZCkubWFwKHZhbHVlID0+IHVuZGVmaW5lZFRvTnVsbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncztcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZU1lc3NhZ2VQYXJhbXModHlwZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHR5cGUubnVtYmVyT2ZQYXJhbXM7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbi5pcyhwYXJhbXNbbnVtYmVyT2ZQYXJhbXNdKSA/IHBhcmFtc1tudW1iZXJPZlBhcmFtc10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNlcXVlbmNlTnVtYmVyKys7XG4gICAgICAgICAgICBsZXQgZGlzcG9zYWJsZTtcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUgPSB0b2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuc2VuZENhbmNlbGxhdGlvbihjb25uZWN0aW9uLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlY2VpdmVkIG5vIHByb21pc2UgZnJvbSBjYW5jZWxsYXRpb24gc3RyYXRlZ3kgd2hlbiBjYW5jZWxsaW5nIGlkICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU2VuZGluZyBjYW5jZWxsYXRpb24gbWVzc2FnZXMgZm9yIGlkICR7aWR9IGZhaWxlZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogbWVzc2FnZVBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1JlcXVlc3QocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuZW5hYmxlQ2FuY2VsbGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmVuYWJsZUNhbmNlbGxhdGlvbihyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVXaXRoQ2xlYW51cCA9IChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocik7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5jbGVhbnVwKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZT8uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVqZWN0V2l0aENsZWFudXAgPSAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qocik7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5jbGVhbnVwKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZT8uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0geyBtZXRob2Q6IG1ldGhvZCwgdGltZXJTdGFydDogRGF0ZS5ub3coKSwgcmVzb2x2ZTogcmVzb2x2ZVdpdGhDbGVhbnVwLCByZWplY3Q6IHJlamVjdFdpdGhDbGVhbnVwIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5zZXQoaWQsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG1lc3NhZ2VXcml0ZXIud3JpdGUocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGluZyB0aGUgbWVzc2FnZSBmYWlsZWQuIFNvIHdlIG5lZWQgdG8gZGVsZXRlIGl0IGZyb20gdGhlIHJlc3BvbnNlIHByb21pc2VzIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyByZWplY3QgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciwgZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biByZWFzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXF1ZXN0IGZhaWxlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdDogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChTdGFyUmVxdWVzdEhhbmRsZXIuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUsIHsgaGFuZGxlcjogaGFuZGxlciwgdHlwZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5zZXQodHlwZS5tZXRob2QsIHsgdHlwZSwgaGFuZGxlciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUGVuZGluZ1Jlc3BvbnNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcy5zaXplID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2U6IGFzeW5jIChfdmFsdWUsIF90cmFjZXIsIHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgbGV0IF9zZW5kTm90aWZpY2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgX3RyYWNlRm9ybWF0ID0gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgIGlmIChzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChJcy5ib29sZWFuKHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc2VuZE5vdGlmaWNhdGlvbiA9IHNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucy5zZW5kTm90aWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdHJhY2VGb3JtYXQgPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMudHJhY2VGb3JtYXQgfHwgVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZSA9IF92YWx1ZTtcbiAgICAgICAgICAgIHRyYWNlRm9ybWF0ID0gX3RyYWNlRm9ybWF0O1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYpIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFjZXIgPSBfdHJhY2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZW5kTm90aWZpY2F0aW9uICYmICFpc0Nsb3NlZCgpICYmICFpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSwgeyB2YWx1ZTogVHJhY2UudG9TdHJpbmcoX3ZhbHVlKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZXJyb3JFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkNsb3NlOiBjbG9zZUVtaXR0ZXIuZXZlbnQsXG4gICAgICAgIG9uVW5oYW5kbGVkTm90aWZpY2F0aW9uOiB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmV2ZW50LFxuICAgICAgICBvbkRpc3Bvc2U6IGRpc3Bvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBlbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIuZW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICAgICAgICAgIGRpc3Bvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQsICdQZW5kaW5nIHJlc3BvbnNlIHJlamVjdGVkIHNpbmNlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgcmVzcG9uc2VQcm9taXNlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbWVzc2FnZVF1ZXVlID0gbmV3IGxpbmtlZE1hcF8xLkxpbmtlZE1hcCgpO1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VXcml0ZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJcy5mdW5jKG1lc3NhZ2VSZWFkZXIuZGlzcG9zZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlUmVhZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuOiAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZkxpc3RlbmluZygpO1xuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5saXN0ZW4oY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBpbnNwZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkuY29uc29sZS5sb2coJ2luc3BlY3QnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihMb2dUcmFjZU5vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlID0gdHJhY2UgPT09IFRyYWNlLlZlcmJvc2UgfHwgdHJhY2UgPT09IFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgIHRyYWNlci5sb2cocGFyYW1zLm1lc3NhZ2UsIHZlcmJvc2UgPyBwYXJhbXMudmVyYm9zZSA6IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbihQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlLCAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9ncmVzc0hhbmRsZXJzLmdldChwYXJhbXMudG9rZW4pO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyLmZpcmUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTYzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IHZvaWQgMDtcbnZhciBEaXNwb3NhYmxlO1xuKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlIHx8IChleHBvcnRzLkRpc3Bvc2FibGUgPSBEaXNwb3NhYmxlID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjc4MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjU0KTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0gRXZlbnQgPSB7fSkpO1xuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcbiAgICBhZGQoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Y2tldCkpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzW2ldID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrICYgY29udGV4dCBtYXRjaCA9PiByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gYWRkaW5nIGEgbGlzdGVuZXIgd2l0aCBhIGNvbnRleHQsIHlvdSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggdGhlIHNhbWUgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gW10sIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5zbGljZSgwKSwgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cy5zbGljZSgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dHNbaV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgKi9cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBhZnRlciBlbWl0dGVyIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5yZW1vdmUobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cbiAgICAgKiBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmludm9rZS5jYWxsKHRoaXMuX2NhbGxiYWNrcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuRW1pdHRlci5fbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjE0NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjE3Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5MaW5rZWRNYXAgPSBleHBvcnRzLlRvdWNoID0gdm9pZCAwO1xudmFyIFRvdWNoO1xuKGZ1bmN0aW9uIChUb3VjaCkge1xuICAgIFRvdWNoLk5vbmUgPSAwO1xuICAgIFRvdWNoLkZpcnN0ID0gMTtcbiAgICBUb3VjaC5Bc09sZCA9IFRvdWNoLkZpcnN0O1xuICAgIFRvdWNoLkxhc3QgPSAyO1xuICAgIFRvdWNoLkFzTmV3ID0gVG91Y2guTGFzdDtcbn0pKFRvdWNoIHx8IChleHBvcnRzLlRvdWNoID0gVG91Y2ggPSB7fSkpO1xuY2xhc3MgTGlua2VkTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tfYV0gPSAnTGlua2VkTWFwJztcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RhaWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWw7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZD8udmFsdWU7XG4gICAgfVxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFpbD8udmFsdWU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IFRvdWNoLk5vbmUpIHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdG91Y2ggPSBUb3VjaC5Ob25lKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLk5vbmU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVG91Y2guRmlyc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUZpcnN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkxhc3Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbUxhc3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faGVhZDtcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShpdGVtLmtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5iaW5kKHRoaXNBcmcpKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oY3VycmVudC52YWx1ZSwgY3VycmVudC5rZXksIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQua2V5LCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBbY3VycmVudC5rZXksIGN1cnJlbnQudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBbKF9hID0gU3ltYm9sLnRvU3RyaW5nVGFnLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICB0cmltT2xkKG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZS0tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLl9zaXplID0gY3VycmVudFNpemU7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuZWQgaWYgc2l6ZSA9PT0gMSB3aGljaCBpcyBoYW5kbGVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBjYXNlIGFib3ZlLlxuICAgICAgICAgICAgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgIXByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgdG91Y2goaXRlbSwgdG91Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkIHx8ICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG91Y2ggIT09IFRvdWNoLkZpcnN0ICYmIHRvdWNoICE9PSBUb3VjaC5MYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gVG91Y2guRmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbVxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IGhlYWQgYnV0IGlzIHRhaWxcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBub2RlIGF0IGhlYWRcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IFRvdWNoLkxhc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIC8vIFVubGluayB0aGUgaXRlbS5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBtdXN0IGJlIGRlZmluZWQgc2luY2UgaXRlbSB3YXMgbm90IHRhaWwgYnV0IGlzIGhlYWRcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uIGl0ZW0gaW4gdGhlIG1hcFxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MaW5rZWRNYXAgPSBMaW5rZWRNYXA7XG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0IHJhdGlvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF0aW87XG4gICAgfVxuICAgIHNldCByYXRpbyhyYXRpbykge1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guQXNOZXcpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIHRvdWNoKTtcbiAgICB9XG4gICAgcGVlayhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXksIFRvdWNoLk5vbmUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgVG91Y2guTGFzdCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltT2xkKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTgwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgQ1IgPSAxMztcbmNvbnN0IExGID0gMTA7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRvQXBwZW5kID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IHRoaXMuZnJvbVN0cmluZyhjaHVuaywgdGhpcy5fZW5jb2RpbmcpIDogY2h1bms7XG4gICAgICAgIHRoaXMuX2NodW5rcy5wdXNoKHRvQXBwZW5kKTtcbiAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggKz0gdG9BcHBlbmQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ5UmVhZEhlYWRlcnMobG93ZXJDYXNlS2V5cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0J5dGVzUmVhZCA9IDA7XG4gICAgICAgIHJvdzogd2hpbGUgKGNodW5rSW5kZXggPCB0aGlzLl9jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tjaHVua0luZGV4XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb2x1bW46IHdoaWxlIChvZmZzZXQgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rW29mZnNldF07XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rQnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBjaHVua0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBidWZmZXIgY29udGFpbnMgdGhlIHR3byBDUkxGIGF0IHRoZSBlbmQuIFNvIHdlIHdpbGxcbiAgICAgICAgLy8gaGF2ZSB0d28gZW1wdHkgbGluZXMgYWZ0ZXIgdGhlIHNwbGl0IGF0IHRoZSBlbmQgYXMgd2VsbC5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fcmVhZChjaHVua0J5dGVzUmVhZCArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMudG9TdHJpbmcoYnVmZmVyLCAnYXNjaWknKS5zcGxpdChDUkxGKTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBoZWFkZXIuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBoZWFkZXIgbXVzdCBzZXBhcmF0ZSBrZXkgYW5kIHZhbHVlIHVzaW5nICc6J1xcbiR7aGVhZGVyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5ID0gaGVhZGVyLnN1YnN0cigwLCBpbmRleCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0KGxvd2VyQ2FzZUtleXMgPyBrZXkudG9Mb3dlckNhc2UoKSA6IGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyeVJlYWRCb2R5KGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fdG90YWxMZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQobGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IG51bWJlck9mQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbExlbmd0aDtcbiAgICB9XG4gICAgX3JlYWQoYnl0ZUNvdW50KSB7XG4gICAgICAgIGlmIChieXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVDb3VudCA+IHRoaXMuX3RvdGFsTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWFkIHNvIG1hbnkgYnl0ZXMhYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID09PSBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIHN1cGVyIGZhc3QgcGF0aCwgcHJlY2lzZWx5IGZpcnN0IGNodW5rIG11c3QgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc05hdGl2ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rc1swXS5ieXRlTGVuZ3RoID4gYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBmYXN0IHBhdGgsIHRoZSByZWFkaW5nIGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgZmlyc3QgY2h1bmtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzWzBdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc05hdGl2ZShjaHVuaywgYnl0ZUNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuX2NodW5rc1swXSA9IGNodW5rLnNsaWNlKGJ5dGVDb3VudCk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbmd0aCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb2NOYXRpdmUoYnl0ZUNvdW50KTtcbiAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzW2NodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPiBieXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNodW5rIHdpbGwgc3Vydml2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFydCA9IGNodW5rLnNsaWNlKDAsIGJ5dGVDb3VudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChjaHVua1BhcnQsIHJlc3VsdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ICs9IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuay5zbGljZShieXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaHVuayB3aWxsIGJlIGVudGlyZWx5IHJlYWRcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rLCByZXN1bHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdE9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50IC09IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IEFic3RyYWN0TWVzc2FnZUJ1ZmZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgxMzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5SZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuTWVzc2FnZVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjU0KTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTQ1KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzgwKTtcbmNvbnN0IHNlbWFwaG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTMxKTtcbnZhciBNZXNzYWdlUmVhZGVyO1xuKGZ1bmN0aW9uIChNZXNzYWdlUmVhZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmxpc3RlbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uQ2xvc2UpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uUGFydGlhbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlUmVhZGVyLmlzID0gaXM7XG59KShNZXNzYWdlUmVhZGVyIHx8IChleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSBNZXNzYWdlUmVhZGVyID0ge30pKTtcbmNsYXNzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZmlyZSh0aGlzLmFzRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgZ2V0IG9uQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGdldCBvblBhcnRpYWxNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVQYXJ0aWFsTWVzc2FnZShpbmZvKSB7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyLmZpcmUoaW5mbyk7XG4gICAgfVxuICAgIGFzRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFJlYWRlciByZWNlaXZlZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZVJlYWRlciA9IEFic3RyYWN0TWVzc2FnZVJlYWRlcjtcbnZhciBSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zO1xuKGZ1bmN0aW9uIChSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBsZXQgY2hhcnNldDtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGNvbnRlbnREZWNvZGVyO1xuICAgICAgICBjb25zdCBjb250ZW50RGVjb2RlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBjb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlRGVjb2RlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucyA/PyAndXRmLTgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhcnNldCA9IG9wdGlvbnMuY2hhcnNldCA/PyAndXRmLTgnO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVyID0gb3B0aW9ucy5jb250ZW50RGVjb2RlcjtcbiAgICAgICAgICAgICAgICBjb250ZW50RGVjb2RlcnMuc2V0KGNvbnRlbnREZWNvZGVyLm5hbWUsIGNvbnRlbnREZWNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnREZWNvZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNvZGVyIG9mIG9wdGlvbnMuY29udGVudERlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoZGVjb2Rlci5uYW1lLCBkZWNvZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlciA9IG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGNvbnRlbnRUeXBlRGVjb2Rlci5uYW1lLCBjb250ZW50VHlwZURlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZWNvZGVyIG9mIG9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGVEZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5kZWNvZGVyO1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhcnNldCwgY29udGVudERlY29kZXIsIGNvbnRlbnREZWNvZGVycywgY29udGVudFR5cGVEZWNvZGVyLCBjb250ZW50VHlwZURlY29kZXJzIH07XG4gICAgfVxuICAgIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMuZnJvbU9wdGlvbnMgPSBmcm9tT3B0aW9ucztcbn0pKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMgfHwgKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMgPSB7fSkpO1xuY2xhc3MgUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkYWJsZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlYWRhYmxlID0gcmVhZGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkubWVzc2FnZUJ1ZmZlci5jcmVhdGUodGhpcy5vcHRpb25zLmNoYXJzZXQpO1xuICAgICAgICB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLm1lc3NhZ2VUb2tlbiA9IDA7XG4gICAgICAgIHRoaXMucmVhZFNlbWFwaG9yZSA9IG5ldyBzZW1hcGhvcmVfMS5TZW1hcGhvcmUoMSk7XG4gICAgfVxuICAgIHNldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cbiAgICBnZXQgcGFydGlhbE1lc3NhZ2VUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0O1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLm1lc3NhZ2VUb2tlbiA9IDA7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlYWRhYmxlLm9uRGF0YSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWRhYmxlLm9uRXJyb3IoKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xuICAgICAgICB0aGlzLnJlYWRhYmxlLm9uQ2xvc2UoKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQoZGF0YSk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5idWZmZXIudHJ5UmVhZEhlYWRlcnModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihuZXcgRXJyb3IoYEhlYWRlciBtdXN0IHByb3ZpZGUgYSBDb250ZW50LUxlbmd0aCBwcm9wZXJ0eS5cXG4ke0pTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzKSl9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKGBDb250ZW50LUxlbmd0aCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLiBHb3QgJHtjb250ZW50TGVuZ3RofWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5idWZmZXIudHJ5UmVhZEJvZHkodGhpcy5uZXh0TWVzc2FnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvKiogV2UgaGF2ZW4ndCByZWNlaXZlZCB0aGUgZnVsbCBtZXNzYWdlIHlldC4gKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgY29udmVydCBvbmUgcmVjZWl2ZWQgbWVzc2FnZSBhZnRlciB0aGVcbiAgICAgICAgICAgICAgICAvLyBvdGhlci4gT3RoZXJ3aXNlIGl0IGNvdWxkIGhhcHBlbiB0aGF0IGEgZGVjb2Rpbmcgb2YgYSBzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyIG1lc3NhZ2UgZmluaXNoZWQgYmVmb3JlIHRoZSBkZWNvZGluZyBvZiBhIGZpcnN0IGxhcmdlclxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgYW5kIHRoZW4gd2Ugd291bGQgZGVsaXZlciB0aGUgc2Vjb25kIG1lc3NhZ2UgZmlyc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlLmxvY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2Rlci5kZWNvZGUoYm9keSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYm9keTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHRoaXMub3B0aW9ucy5jb250ZW50VHlwZURlY29kZXIuZGVjb2RlKGJ5dGVzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMubWVzc2FnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzc0NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDI1NCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjE0NSk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkzMSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjc4MCk7XG5jb25zdCBDb250ZW50TGVuZ3RoID0gJ0NvbnRlbnQtTGVuZ3RoOiAnO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xudmFyIE1lc3NhZ2VXcml0ZXI7XG4oZnVuY3Rpb24gKE1lc3NhZ2VXcml0ZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub25DbG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLndyaXRlKTtcbiAgICB9XG4gICAgTWVzc2FnZVdyaXRlci5pcyA9IGlzO1xufSkoTWVzc2FnZVdyaXRlciB8fCAoZXhwb3J0cy5NZXNzYWdlV3JpdGVyID0gTWVzc2FnZVdyaXRlciA9IHt9KSk7XG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvciwgbWVzc2FnZSwgY291bnQpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZmlyZShbdGhpcy5hc0Vycm9yKGVycm9yKSwgbWVzc2FnZSwgY291bnRdKTtcbiAgICB9XG4gICAgZ2V0IG9uQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZUNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGFzRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFdyaXRlciByZWNlaXZlZCBlcnJvci4gUmVhc29uOiAke0lzLnN0cmluZyhlcnJvci5tZXNzYWdlKSA/IGVycm9yLm1lc3NhZ2UgOiAndW5rbm93bid9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZVdyaXRlciA9IEFic3RyYWN0TWVzc2FnZVdyaXRlcjtcbnZhciBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zO1xuKGZ1bmN0aW9uIChSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcnNldDogb3B0aW9ucyA/PyAndXRmLTgnLCBjb250ZW50VHlwZUVuY29kZXI6ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5lbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyc2V0OiBvcHRpb25zLmNoYXJzZXQgPz8gJ3V0Zi04JywgY29udGVudEVuY29kZXI6IG9wdGlvbnMuY29udGVudEVuY29kZXIsIGNvbnRlbnRUeXBlRW5jb2Rlcjogb3B0aW9ucy5jb250ZW50VHlwZUVuY29kZXIgPz8gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmVuY29kZXIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zLmZyb21PcHRpb25zID0gZnJvbU9wdGlvbnM7XG59KShSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zIHx8IChSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zID0ge30pKTtcbmNsYXNzIFdyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyaXRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB3cml0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgdGhpcy53cml0ZVNlbWFwaG9yZSA9IG5ldyBzZW1hcGhvcmVfMS5TZW1hcGhvcmUoMSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICB9XG4gICAgYXN5bmMgd3JpdGUobXNnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlU2VtYXBob3JlLmxvY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMub3B0aW9ucy5jb250ZW50VHlwZUVuY29kZXIuZW5jb2RlKG1zZywgdGhpcy5vcHRpb25zKS50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRFbmNvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb250ZW50RW5jb2Rlci5lbmNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gW107XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKENvbnRlbnRMZW5ndGgsIGJ1ZmZlci5ieXRlTGVuZ3RoLnRvU3RyaW5nKCksIENSTEYpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChDUkxGKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb1dyaXRlKG1zZywgaGVhZGVycywgYnVmZmVyKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZG9Xcml0ZShtc2csIGhlYWRlcnMsIGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGFibGUud3JpdGUoaGVhZGVycy5qb2luKCcnKSwgJ2FzY2lpJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0YWJsZS53cml0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZS5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIgPSBXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MzEzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU5ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTcgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU2ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTQgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTEgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTkgPSBleHBvcnRzLlJlcXVlc3RUeXBlOCA9IGV4cG9ydHMuUmVxdWVzdFR5cGU3ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTYgPSBleHBvcnRzLlJlcXVlc3RUeXBlNSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU0ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTMgPSBleHBvcnRzLlJlcXVlc3RUeXBlMiA9IGV4cG9ydHMuUmVxdWVzdFR5cGUxID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBleHBvcnRzLlBhcmFtZXRlclN0cnVjdHVyZXMgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkVycm9yQ29kZXMgPSB2b2lkIDA7XG5jb25zdCBpcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjE0NSk7XG4vKipcbiAqIFByZWRlZmluZWQgZXJyb3IgY29kZXMuXG4gKi9cbnZhciBFcnJvckNvZGVzO1xuKGZ1bmN0aW9uIChFcnJvckNvZGVzKSB7XG4gICAgLy8gRGVmaW5lZCBieSBKU09OIFJQQ1xuICAgIEVycm9yQ29kZXMuUGFyc2VFcnJvciA9IC0zMjcwMDtcbiAgICBFcnJvckNvZGVzLkludmFsaWRSZXF1ZXN0ID0gLTMyNjAwO1xuICAgIEVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQgPSAtMzI2MDE7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zID0gLTMyNjAyO1xuICAgIEVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciA9IC0zMjYwMztcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBzdGFydCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS4gTm8gYXBwbGljYXRpb24gZXJyb3IgY29kZXMgc2hvdWxkXG4gICAgICogYmUgZGVmaW5lZCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHJhbmdlLiBGb3IgYmFja3dhcmRzXG4gICAgICogY29tcGF0aWJpbGl0eSB0aGUgYFNlcnZlck5vdEluaXRpYWxpemVkYCBhbmQgdGhlIGBVbmtub3duRXJyb3JDb2RlYFxuICAgICAqIGFyZSBsZWZ0IGluIHRoZSByYW5nZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0ID0gLTMyMDk5O1xuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgIGpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JTdGFydCA9IC0zMjA5OTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHdyaXRlIGEgbWVzc2FnZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVdyaXRlRXJyb3IgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nIGEgbWVzc2FnZSBmcm9tIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5NZXNzYWdlUmVhZEVycm9yID0gLTMyMDk4O1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCBvciBsb3N0IGFuZCBhbGwgcGVuZGluZyByZXNwb25zZXMgZ290XG4gICAgICogcmVqZWN0ZWQuXG4gICAgICovXG4gICAgRXJyb3JDb2Rlcy5QZW5kaW5nUmVzcG9uc2VSZWplY3RlZCA9IC0zMjA5NztcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBpcyBpbmFjdGl2ZSBhbmQgYSB1c2Ugb2YgaXQgZmFpbGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuQ29ubmVjdGlvbkluYWN0aXZlID0gLTMyMDk2O1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IGEgc2VydmVyIHJlY2VpdmVkIGEgbm90aWZpY2F0aW9uIG9yXG4gICAgICogcmVxdWVzdCBiZWZvcmUgdGhlIHNlcnZlciBoYXMgcmVjZWl2ZWQgdGhlIGBpbml0aWFsaXplYCByZXF1ZXN0LlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuU2VydmVyTm90SW5pdGlhbGl6ZWQgPSAtMzIwMDI7XG4gICAgRXJyb3JDb2Rlcy5Vbmtub3duRXJyb3JDb2RlID0gLTMyMDAxO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBKU09OIFJQQyByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIEVycm9yQ29kZXMuanNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjAwMDtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kICovXG4gICAgRXJyb3JDb2Rlcy5zZXJ2ZXJFcnJvckVuZCA9IC0zMjAwMDtcbn0pKEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuRXJyb3JDb2RlcyA9IEVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBBbiBlcnJvciBvYmplY3QgcmV0dXJuIGluIGEgcmVzcG9uc2UgaW4gY2FzZSBhIHJlcXVlc3RcbiAqIGhhcyBmYWlsZWQuXG4gKi9cbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gaXMubnVtYmVyKGNvZGUpID8gY29kZSA6IEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJlc3BvbnNlRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IFJlc3BvbnNlRXJyb3I7XG5jbGFzcyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byB8fCB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUgfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQ7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcztcbi8qKlxuICogVGhlIHBhcmFtZXRlciBzdHJ1Y3R1cmUgaXMgYXV0b21hdGljYWxseSBpbmZlcnJlZCBvbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnNcbiAqIGFuZCB0aGUgcGFyYW1ldGVyIHR5cGUgaW4gY2FzZSBvZiBhIHNpbmdsZSBwYXJhbS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2F1dG8nKTtcbi8qKlxuICogRm9yY2VzIGBieVBvc2l0aW9uYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgaGF2ZSBhIHNpbmdsZVxuICogcGFyYW1ldGVyIHdoaWNoIGhhcyBhIGxpdGVyYWwgdHlwZS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5UG9zaXRpb24nKTtcbi8qKlxuICogRm9yY2VzIGBieU5hbWVgIHBhcmFtZXRlciBzdHJ1Y3R1cmUuIFRoaXMgaXMgb25seSB1c2VmdWwgd2hlbiBoYXZpbmcgYSBzaW5nbGVcbiAqIHBhcmFtZXRlci4gVGhlIGxpYnJhcnkgd2lsbCByZXBvcnQgZXJyb3JzIGlmIHVzZWQgd2l0aCBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5TmFtZScpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIE1lc3NhZ2VUeXBlLlxuICovXG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbXMgPSBudW1iZXJPZlBhcmFtcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmU7XG4vKipcbiAqIENsYXNzZXMgdG8gdHlwZSByZXF1ZXN0IHJlc3BvbnNlIHBhaXJzXG4gKi9cbmNsYXNzIFJlcXVlc3RUeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBSZXF1ZXN0VHlwZTA7XG5jbGFzcyBSZXF1ZXN0VHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlID0gUmVxdWVzdFR5cGU7XG5jbGFzcyBSZXF1ZXN0VHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBSZXF1ZXN0VHlwZTE7XG5jbGFzcyBSZXF1ZXN0VHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gUmVxdWVzdFR5cGUyO1xuY2xhc3MgUmVxdWVzdFR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMyA9IFJlcXVlc3RUeXBlMztcbmNsYXNzIFJlcXVlc3RUeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBSZXF1ZXN0VHlwZTQ7XG5jbGFzcyBSZXF1ZXN0VHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gUmVxdWVzdFR5cGU1O1xuY2xhc3MgUmVxdWVzdFR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNiA9IFJlcXVlc3RUeXBlNjtcbmNsYXNzIFJlcXVlc3RUeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBSZXF1ZXN0VHlwZTc7XG5jbGFzcyBSZXF1ZXN0VHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gUmVxdWVzdFR5cGU4O1xuY2xhc3MgUmVxdWVzdFR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOSA9IFJlcXVlc3RUeXBlOTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gTm90aWZpY2F0aW9uVHlwZTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gTm90aWZpY2F0aW9uVHlwZTE7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IE5vdGlmaWNhdGlvblR5cGUyO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBOb3RpZmljYXRpb25UeXBlMztcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU0IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gTm90aWZpY2F0aW9uVHlwZTQ7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IE5vdGlmaWNhdGlvblR5cGU1O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDYpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBOb3RpZmljYXRpb25UeXBlNjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU3IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gTm90aWZpY2F0aW9uVHlwZTc7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IE5vdGlmaWNhdGlvblR5cGU4O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBOb3RpZmljYXRpb25UeXBlOTtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXF1ZXN0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkpO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzUmVxdWVzdCA9IGlzUmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiBtZXNzYWdlLmlkID09PSB2b2lkIDA7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNOb3RpZmljYXRpb24gPSBpc05vdGlmaWNhdGlvbjtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLnJlc3VsdCAhPT0gdm9pZCAwIHx8ICEhY2FuZGlkYXRlLmVycm9yKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkgfHwgY2FuZGlkYXRlLmlkID09PSBudWxsKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1Jlc3BvbnNlID0gaXNSZXNwb25zZTtcbn0pKE1lc3NhZ2UgfHwgKGV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2UgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjU0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5sZXQgX3JhbDtcbmZ1bmN0aW9uIFJBTCgpIHtcbiAgICBpZiAoX3JhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBpbnN0YWxsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yYWw7XG59XG4oZnVuY3Rpb24gKFJBTCkge1xuICAgIGZ1bmN0aW9uIGluc3RhbGwocmFsKSB7XG4gICAgICAgIGlmIChyYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgX3JhbCA9IHJhbDtcbiAgICB9XG4gICAgUkFMLmluc3RhbGwgPSBpbnN0YWxsO1xufSkoUkFMIHx8IChSQUwgPSB7fSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSQUw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk5MzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2VtYXBob3JlID0gdm9pZCAwO1xuY29uc3QgcmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNTQpO1xuY2xhc3MgU2VtYXBob3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjYXBhY2l0eSA9IDEpIHtcbiAgICAgICAgaWYgKGNhcGFjaXR5IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuX3dhaXRpbmcgPSBbXTtcbiAgICB9XG4gICAgbG9jayh0aHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2FpdGluZy5wdXNoKHsgdGh1bmssIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgcnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1J1bk5leHQoKSk7XG4gICAgfVxuICAgIGRvUnVuTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmcubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdGl2ZSA9PT0gdGhpcy5fY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUrKztcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSA+IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvIG1hbnkgdGh1bmtzIGFjdGl2ZWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXh0LnRodW5rKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgICAgICBuZXh0LnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUtLTtcbiAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VtYXBob3JlID0gU2VtYXBob3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NDkyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IHZvaWQgMDtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTA2KTtcbnZhciBDYW5jZWxsYXRpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uU3RhdGUpIHtcbiAgICBDYW5jZWxsYXRpb25TdGF0ZS5Db250aW51ZSA9IDA7XG4gICAgQ2FuY2VsbGF0aW9uU3RhdGUuQ2FuY2VsbGVkID0gMTtcbn0pKENhbmNlbGxhdGlvblN0YXRlIHx8IChDYW5jZWxsYXRpb25TdGF0ZSA9IHt9KSk7XG5jbGFzcyBTaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBlbmFibGVDYW5jZWxsYXRpb24ocmVxdWVzdCkge1xuICAgICAgICBpZiAocmVxdWVzdC5pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcig0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIGRhdGFbMF0gPSBDYW5jZWxsYXRpb25TdGF0ZS5Db250aW51ZTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnNldChyZXF1ZXN0LmlkLCBidWZmZXIpO1xuICAgICAgICByZXF1ZXN0LiRjYW5jZWxsYXRpb25EYXRhID0gYnVmZmVyO1xuICAgIH1cbiAgICBhc3luYyBzZW5kQ2FuY2VsbGF0aW9uKF9jb25uLCBpZCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG4gICAgICAgIEF0b21pY3Muc3RvcmUoZGF0YSwgMCwgQ2FuY2VsbGF0aW9uU3RhdGUuQ2FuY2VsbGVkKTtcbiAgICB9XG4gICAgY2xlYW51cChpZCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmNsZWFyKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaGFyZWRBcnJheVNlbmRlclN0cmF0ZWd5ID0gU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneTtcbmNsYXNzIFNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiBBdG9taWNzLmxvYWQodGhpcy5kYXRhLCAwKSA9PT0gQ2FuY2VsbGF0aW9uU3RhdGUuQ2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuY2VsbGF0aW9uIG92ZXIgU2hhcmVkQXJyYXlCdWZmZXIgZG9lc24ndCBzdXBwb3J0IGNhbmNlbGxhdGlvbiBldmVudHNgKTtcbiAgICB9XG59XG5jbGFzcyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuKGJ1ZmZlcik7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICB9XG59XG5jbGFzcyBTaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmtpbmQgPSAncmVxdWVzdCc7XG4gICAgfVxuICAgIGNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gcmVxdWVzdC4kY2FuY2VsbGF0aW9uRGF0YTtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuU291cmNlKGJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBTaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3k7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3MzA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDUpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODM0KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODE4KTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoYXJyLnNsaWNlKTtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZCA9ICRzbGljZSh0eXBlZEFycmF5LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG52YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCBuYW1lKSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2V0dGVyKHZhbHVlKTtcblx0XHRcdFx0Zm91bmQgPSAkc2xpY2UobmFtZSwgMSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDgzNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlKHN0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmUsIC4uLmFkZGVkTGluZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhdm9pZCB0b28gbWFueSBhcmd1bWVudHMgZm9yIHNwbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH1cbiAgICBwb3NpdGlvbkF0KG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH1cbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmNoYXJhY3RlciA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldCkge1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gbGluZU9mZnNldCAmJiBpc0VPTCh0aGlzLl9jb250ZW50LmNoYXJDb2RlQXQob2Zmc2V0IC0gMSkpKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgbGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5jcmVtZW50YWwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfVxufVxudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIGluaXRpYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBUZXh0RG9jdW1lbnQgYnkgbW9kaWZ5aW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgY2hhbmdlcyB2ZXJzaW9uIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dERvY3VtZW50LiBOb3RlOiBUaGF0J3MgdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShkb2N1bWVudCwgY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBGdWxsVGV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC51cGRhdGUoY2hhbmdlcywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHREb2N1bWVudC51cGRhdGU6IGRvY3VtZW50IG11c3QgYmUgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERvY3VtZW50LnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cy5tYXAoZ2V0V2VsbGZvcm1lZEVkaXQpLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygc29ydGVkRWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPCBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ID4gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cmluZyhsYXN0TW9kaWZpZWRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5uZXdUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2goZS5uZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHRleHQuc3Vic3RyKGxhc3RNb2RpZmllZE9mZnNldCkpO1xuICAgICAgICByZXR1cm4gc3BhbnMuam9pbignJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbmZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgLy8gc29ydGVkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICBsZXQgbGVmdElkeCA9IDA7XG4gICAgbGV0IHJpZ2h0SWR4ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgfVxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaXNFT0woY2gpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0T2Zmc2V0ICsgaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0VPTChjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IGNoYXIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZFJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKHRleHRFZGl0LnJhbmdlKTtcbiAgICBpZiAocmFuZ2UgIT09IHRleHRFZGl0LnJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IG5ld1RleHQ6IHRleHRFZGl0Lm5ld1RleHQsIHJhbmdlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0RWRpdDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjg1Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0ZWRUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGVkVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDaGFuZ2VBbm5vdGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25Db250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvblRyaWdnZXJLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZURlc2NyaXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlRGVzY3JpcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlTGVuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUxlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvckluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JQcmVzZW50YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9yUHJlc2VudGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tbWFuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tbWFuZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1UYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ3JlYXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ3JlYXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERlbGV0ZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIERlbGV0ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWNTZXZlcml0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1NldmVyaXR5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1RhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1RhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0OiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRIaWdobGlnaHRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRMaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudExpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFVyaTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRVcmkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBFT0w6ICgpID0+ICgvKiBiaW5kaW5nICovIEVPTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvbGRpbmdSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvcm1hdHRpbmdPcHRpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb3JtYXR0aW5nT3B0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEhvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBIb3ZlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50S2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludExhYmVsUGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50TGFiZWxQYXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25Db250ZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25JdGVtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZUNvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUNvbnRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVGV4dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVUZXh0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFJlcGxhY2VFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRSZXBsYWNlRWRpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEluc2VydFRleHRGb3JtYXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRGb3JtYXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0TW9kZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0VGV4dE1vZGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTG9jYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBMb2NhdGlvbkxpbms6ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uTGluayksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmtlZFN0cmluZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya2VkU3RyaW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTWFya3VwQ29udGVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTWFya3VwQ29udGVudCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cEtpbmQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cEtpbmQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBhcmFtZXRlckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQYXJhbWV0ZXJJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFBvc2l0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBQb3NpdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJhbmdlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJlbmFtZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIFJlbmFtZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBTZWxlY3RlZENvbXBsZXRpb25JbmZvOiAoKSA9PiAoLyogYmluZGluZyAqLyBTZWxlY3RlZENvbXBsZXRpb25JbmZvKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VsZWN0aW9uUmFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbGVjdGlvblJhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbk1vZGlmaWVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNlbWFudGljVG9rZW5UeXBlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlblR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbWFudGljVG9rZW5zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2lnbmF0dXJlSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFNpZ25hdHVyZUluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3RyaW5nVmFsdWU6ICgpID0+ICgvKiBiaW5kaW5nICovIFN0cmluZ1ZhbHVlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFN5bWJvbEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN5bWJvbFRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRFZGl0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEl0ZW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVUkk6ICgpID0+ICgvKiBiaW5kaW5nICovIFVSSSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VDaGFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUNoYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VGb2xkZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUZvbGRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZVN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlU3ltYm9sKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW50ZWdlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50ZWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyB1aW50ZWdlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRG9jdW1lbnRVcmk7XG4oZnVuY3Rpb24gKERvY3VtZW50VXJpKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xudmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xudmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG52YXIgdWludGVnZXI7XG4oZnVuY3Rpb24gKHVpbnRlZ2VyKSB7XG4gICAgdWludGVnZXIuTUlOX1ZBTFVFID0gMDtcbiAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHVpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIHVpbnRlZ2VyLmlzID0gaXM7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3RlciB9O1xuICAgIH1cbiAgICBQb3NpdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBQb3NpdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmNoYXJhY3Rlcik7XG4gICAgfVxuICAgIFBvc2l0aW9uLmlzID0gaXM7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUmFuZ2V9IGxpdGVyYWxzLlxuICovXG52YXIgUmFuZ2U7XG4oZnVuY3Rpb24gKFJhbmdlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9uZSwgdHdvLCB0aHJlZSwgZm91cikge1xuICAgICAgICBpZiAoSXMudWludGVnZXIob25lKSAmJiBJcy51aW50ZWdlcih0d28pICYmIElzLnVpbnRlZ2VyKHRocmVlKSAmJiBJcy51aW50ZWdlcihmb3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZShvbmUsIHR3byksIGVuZDogUG9zaXRpb24uY3JlYXRlKHRocmVlLCBmb3VyKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBvc2l0aW9uLmlzKG9uZSkgJiYgUG9zaXRpb24uaXModHdvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IG9uZSwgZW5kOiB0d28gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzWyR7b25lfSwgJHt0d299LCAke3RocmVlfSwgJHtmb3VyfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbiBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4geyB1cmksIHJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnVyaSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbi5pcyA9IGlzO1xufSkoTG9jYXRpb24gfHwgKExvY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uTGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbkxpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQsXG4gICAgICAgICAgICBncmVlbixcbiAgICAgICAgICAgIGJsdWUsXG4gICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUucmVkLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmdyZWVuLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmJsdWUsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYWxwaGEsIDAsIDEpO1xuICAgIH1cbiAgICBDb2xvci5pcyA9IGlzO1xufSkoQ29sb3IgfHwgKENvbG9yID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9ySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvckluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBDb2xvci5pcyhjYW5kaWRhdGUuY29sb3IpO1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmlzID0gaXM7XG59KShDb2xvckluZm9ybWF0aW9uIHx8IChDb2xvckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yUHJlc2VudGF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9yUHJlc2VudGF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgdGV4dEVkaXQsIGFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsVGV4dEVkaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbClcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRleHRFZGl0KSB8fCBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cykgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cywgVGV4dEVkaXQuaXMpKTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uaXMgPSBpcztcbn0pKENvbG9yUHJlc2VudGF0aW9uIHx8IChDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcmFuZ2Uga2luZHMuXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2VLaW5kO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VLaW5kKSB7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBjb21tZW50XG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5Db21tZW50ID0gJ2NvbW1lbnQnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGFuIGltcG9ydCBvciBpbmNsdWRlXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzID0gJ2ltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiA9ICdyZWdpb24nO1xufSkoRm9sZGluZ1JhbmdlS2luZCB8fCAoRm9sZGluZ1JhbmdlS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBmb2xkaW5nIHJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIEZvbGRpbmdSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2U7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRm9sZGluZ1JhbmdlIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnRDaGFyYWN0ZXIsIGVuZENoYXJhY3Rlciwga2luZCwgY29sbGFwc2VkVGV4dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmUsXG4gICAgICAgICAgICBlbmRMaW5lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHN0YXJ0Q2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0Q2hhcmFjdGVyID0gc3RhcnRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoZW5kQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZENoYXJhY3RlciA9IGVuZENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChraW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvbGxhcHNlZFRleHQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29sbGFwc2VkVGV4dCA9IGNvbGxhcHNlZFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvbGRpbmdSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSk7XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gfHwgKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxuICovXG52YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGVycm9yLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgaGludC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XG59KShEaWFnbm9zdGljU2V2ZXJpdHkgfHwgKERpYWdub3N0aWNTZXZlcml0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgRGlhZ25vc3RpY1RhZztcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1RhZykge1xuICAgIC8qKlxuICAgICAqIFVudXNlZCBvciB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgKiBhbiBlcnJvciBzcXVpZ2dsZS5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG9yIG9ic29sZXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlcmVkIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgc3RyaWtlIHRocm91Z2guXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbn0pKERpYWdub3N0aWNUYWcgfHwgKERpYWdub3N0aWNUYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlRGVzY3JpcHRpb247XG4oZnVuY3Rpb24gKENvZGVEZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaHJlZik7XG4gICAgfVxuICAgIENvZGVEZXNjcmlwdGlvbi5pcyA9IGlzO1xufSkoQ29kZURlc2NyaXB0aW9uIHx8IChDb2RlRGVzY3JpcHRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgRGlhZ25vc3RpYyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEaWFnbm9zdGljfSBsaXRlcmFscy5cbiAqL1xudmFyIERpYWdub3N0aWM7XG4oZnVuY3Rpb24gKERpYWdub3N0aWMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERpYWdub3N0aWMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCBzb3VyY2UsIHJlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSwgbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgdGl0bGUsIGNvbW1hbmQgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb21tYW5kLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbW1hbmR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb21tYW5kKTtcbiAgICB9XG4gICAgQ29tbWFuZC5pcyA9IGlzO1xufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSByZXBsYWNlLFxuICogaW5zZXJ0IGFuZCBkZWxldGUgZWRpdHMgbW9yZSBlYXNpbHkuXG4gKi9cbnZhciBUZXh0RWRpdDtcbihmdW5jdGlvbiAoVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zZXJ0IHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWxldGUgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xuICAgIH1cbiAgICBUZXh0RWRpdC5pcyA9IGlzO1xufSkoVGV4dEVkaXQgfHwgKFRleHRFZGl0ID0ge30pKTtcbnZhciBDaGFuZ2VBbm5vdGF0aW9uO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBuZWVkc0NvbmZpcm1hdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpICYmXG4gICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI7XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyIHx8IChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciA9IHt9KSk7XG52YXIgQW5ub3RhdGVkVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKEFubm90YXRlZFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQ6ICcnLCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSAmJiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmlzID0gaXM7XG59KShBbm5vdGF0ZWRUZXh0RWRpdCB8fCAoQW5ub3RhdGVkVGV4dEVkaXQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZVxuICogYW4gZWRpdCB0aGF0IG1hbmlwdWxhdGVzIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xudmFyIFRleHREb2N1bWVudEVkaXQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0RG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudCwgZWRpdHMgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XG52YXIgQ3JlYXRlRmlsZTtcbihmdW5jdGlvbiAoQ3JlYXRlRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdjcmVhdGUnLFxuICAgICAgICAgICAgdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuaXMgPSBpcztcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xudmFyIFJlbmFtZUZpbGU7XG4oZnVuY3Rpb24gKFJlbmFtZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdyZW5hbWUnLFxuICAgICAgICAgICAgb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlbmFtZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5vbGRVcmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBSZW5hbWVGaWxlLmlzID0gaXM7XG59KShSZW5hbWVGaWxlIHx8IChSZW5hbWVGaWxlID0ge30pKTtcbnZhciBEZWxldGVGaWxlO1xuKGZ1bmN0aW9uIChEZWxldGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2RlbGV0ZScsXG4gICAgICAgICAgICB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5yZWN1cnNpdmUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xufSkoRGVsZXRlRmlsZSB8fCAoRGVsZXRlRmlsZSA9IHt9KSk7XG52YXIgV29ya3NwYWNlRWRpdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRWRpdC5pcyA9IGlzO1xufSkoV29ya3NwYWNlRWRpdCB8fCAoV29ya3NwYWNlRWRpdCA9IHt9KSk7XG5jbGFzcyBUZXh0RWRpdENoYW5nZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRzLCBjaGFuZ2VBbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLmVkaXRzID0gZWRpdHM7XG4gICAgICAgIHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMgPSBjaGFuZ2VBbm5vdGF0aW9ucztcbiAgICB9XG4gICAgaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LmRlbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZChlZGl0KSB7XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0cztcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZWRpdHMuc3BsaWNlKDAsIHRoaXMuZWRpdHMubGVuZ3RoKTtcbiAgICB9XG4gICAgYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGV4dCBlZGl0IGNoYW5nZSBpcyBub3QgY29uZmlndXJlZCB0byBtYW5hZ2UgY2hhbmdlIGFubm90YXRpb25zLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGhlbHBlciBjbGFzc1xuICovXG5jbGFzcyBDaGFuZ2VBbm5vdGF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIG1hbmFnZShpZE9yQW5ub3RhdGlvbiwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElkICR7aWR9IGlzIGFscmVhZHkgaW4gdXNlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uc1tpZF0gPSBhbm5vdGF0aW9uO1xuICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgbmV4dElkKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbmNsYXNzIFdvcmtzcGFjZUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iod29ya3NwYWNlRWRpdCkge1xuICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAod29ya3NwYWNlRWRpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0gd29ya3NwYWNlRWRpdDtcbiAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGNoYW5nZS5lZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2NoYW5nZS50ZXh0RG9jdW1lbnQudXJpXSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwod29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFdvcmtzcGFjZUVkaXR9IGxpdGVyYWxcbiAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZWRpdCgpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgfVxuICAgIGdldFRleHRFZGl0Q2hhbmdlKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50ID0geyB1cmk6IGtleS51cmksIHZlcnNpb246IGtleS52ZXJzaW9uIH07XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb2N1bWVudENoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlRmlsZSh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5hbWVGaWxlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUZpbGUodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAqL1xudmFyIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCB2ZXJzaW9uIH07XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbik7XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0IH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJdGVtIHx8IChUZXh0RG9jdW1lbnRJdGVtID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIHRoZSBjb250ZW50IHR5cGUgdGhhdCBhIGNsaWVudCBzdXBwb3J0cyBpbiB2YXJpb3VzXG4gKiByZXN1bHQgbGl0ZXJhbHMgbGlrZSBgSG92ZXJgLCBgUGFyYW1ldGVySW5mb2Agb3IgYENvbXBsZXRpb25JdGVtYC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGBNYXJrdXBLaW5kc2AgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIGAkYC4gVGhpcyBraW5kc1xuICogYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZS5cbiAqL1xudmFyIE1hcmt1cEtpbmQ7XG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0IGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5QbGFpblRleHQgPSAncGxhaW50ZXh0JztcbiAgICAvKipcbiAgICAgKiBNYXJrZG93biBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuTWFya2Rvd24gPSAnbWFya2Rvd24nO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbHVlIG9mIHRoZSB7QGxpbmsgTWFya3VwS2luZH0gdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbnZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ID0gMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kID0gMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciA9IDQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkID0gNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyA9IDc7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSA9IDg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID0gMTA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgPSAxMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSA9IDEzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkID0gMTQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgPSAxNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSA9IDE3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyID0gMTk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgPSAyMDtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0ID0gMjI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50ID0gMjM7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNTtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAqIHBsYWluIHRleHQgb3IgYSBzbmlwcGV0LlxuICovXG52YXIgSW5zZXJ0VGV4dEZvcm1hdDtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlBsYWluVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgc25pcHBldC5cbiAgICAgKlxuICAgICAqIEEgc25pcHBldCBjYW4gZGVmaW5lIHRhYiBzdG9wcyBhbmQgcGxhY2Vob2xkZXJzIHdpdGggYCQxYCwgYCQyYFxuICAgICAqIGFuZCBgJHszOmZvb31gLiBgJDBgIGRlZmluZXMgdGhlIGZpbmFsIHRhYiBzdG9wLCBpdCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBlbmQgb2YgdGhlIHNuaXBwZXQuIFBsYWNlaG9sZGVycyB3aXRoIGVxdWFsIGlkZW50aWZpZXJzIGFyZSBsaW5rZWQsXG4gICAgICogdGhhdCBpcyB0eXBpbmcgaW4gb25lIHdpbGwgdXBkYXRlIG90aGVycyB0b28uXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL2xhbmd1YWdlLXNlcnZlci1wcm90b2NvbC9zcGVjaWZpY2F0aW9ucy9zcGVjaWZpY2F0aW9uLWN1cnJlbnQvI3NuaXBwZXRfc3ludGF4XG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0ID0gMjtcbn0pKEluc2VydFRleHRGb3JtYXQgfHwgKEluc2VydFRleHRGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBDb21wbGV0aW9uIGl0ZW0gdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgY29tcGxldGlvblxuICogaXRlbS5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEluc2VydFJlcGxhY2VFZGl0O1xuKGZ1bmN0aW9uIChJbnNlcnRSZXBsYWNlRWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zZXJ0IC8gcmVwbGFjZSBlZGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRUZXh0TW9kZTtcbihmdW5jdGlvbiAoSW5zZXJ0VGV4dE1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zZXJ0aW9uIG9yIHJlcGxhY2Ugc3RyaW5ncyBpcyB0YWtlbiBhcyBpdCBpcy4gSWYgdGhlXG4gICAgICogdmFsdWUgaXMgbXVsdGkgbGluZSB0aGUgbGluZXMgYmVsb3cgdGhlIGN1cnNvciB3aWxsIGJlXG4gICAgICogaW5zZXJ0ZWQgdXNpbmcgdGhlIGluZGVudGF0aW9uIGRlZmluZWQgaW4gdGhlIHN0cmluZyB2YWx1ZS5cbiAgICAgKiBUaGUgY2xpZW50IHdpbGwgbm90IGFwcGx5IGFueSBraW5kIG9mIGFkanVzdG1lbnRzIHRvIHRoZVxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hc0lzID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGFkanVzdHMgbGVhZGluZyB3aGl0ZXNwYWNlIG9mIG5ldyBsaW5lcyBzbyB0aGF0XG4gICAgICogdGhleSBtYXRjaCB0aGUgaW5kZW50YXRpb24gdXAgdG8gdGhlIGN1cnNvciBvZiB0aGUgbGluZSBmb3JcbiAgICAgKiB3aGljaCB0aGUgaXRlbSBpcyBhY2NlcHRlZC5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIGEgbGluZSBsaWtlIHRoaXM6IDwydGFicz48Y3Vyc29yPjwzdGFicz5mb28uIEFjY2VwdGluZyBhXG4gICAgICogbXVsdGkgbGluZSBjb21wbGV0aW9uIGl0ZW0gaXMgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFuZCBhbGxcbiAgICAgKiBmb2xsb3dpbmcgbGluZXMgaW5zZXJ0ZWQgd2lsbCBiZSBpbmRlbnRlZCB1c2luZyAyIHRhYnMgYXMgd2VsbC5cbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0TW9kZS5hZGp1c3RJbmRlbnRhdGlvbiA9IDI7XG59KShJbnNlcnRUZXh0TW9kZSB8fCAoSW5zZXJ0VGV4dE1vZGUgPSB7fSkpO1xudmFyIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkgfHwgY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMuaXMgPSBpcztcbn0pKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIHx8IChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21wbGV0aW9uSXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICogY29tcGxldGlvbiBpdGVtcy5cbiAqL1xudmFyIENvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBjb21wbGV0aW9uIGl0ZW0ncyBsYWJlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICByZXR1cm4geyBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbnZhciBDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBsZXRpb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cbiAgICAgKiBAcGFyYW0gaXNJbmNvbXBsZXRlIFRoZSBsaXN0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG52YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5pcyA9IGlzO1xufSkoTWFya2VkU3RyaW5nIHx8IChNYXJrZWRTdHJpbmcgPSB7fSkpO1xudmFyIEhvdmVyO1xuKGZ1bmN0aW9uIChIb3Zlcikge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgIE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICB9XG4gICAgSG92ZXIuaXMgPSBpcztcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQYXJhbWV0ZXJJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQYXJhbWV0ZXJJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoUGFyYW1ldGVySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhcmFtZXRlciBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhYmVsIEEgbGFiZWwgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBkb2N1bWVudGF0aW9uIEEgZG9jIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50YXRpb24gPyB7IGxhYmVsLCBkb2N1bWVudGF0aW9uIH0gOiB7IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24sIC4uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgbGFiZWwgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTaWduYXR1cmVJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTaWduYXR1cmVJbmZvcm1hdGlvbiB8fCAoU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA9IDM7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIERvY3VtZW50SGlnaGxpZ2h0IG5hbWVzcGFjZSB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9jdW1lbnRIaWdobGlnaHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdGhlIGhpZ2hsaWdodCBhcHBsaWVzIHRvLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBoaWdobGlnaHQga2luZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwga2luZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSB9O1xuICAgICAgICBpZiAoSXMubnVtYmVyKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRIaWdobGlnaHQuY3JlYXRlID0gY3JlYXRlO1xufSkoRG9jdW1lbnRIaWdobGlnaHQgfHwgKERvY3VtZW50SGlnaGxpZ2h0ID0ge30pKTtcbi8qKlxuICogQSBzeW1ib2wga2luZC5cbiAqL1xudmFyIFN5bWJvbEtpbmQ7XG4oZnVuY3Rpb24gKFN5bWJvbEtpbmQpIHtcbiAgICBTeW1ib2xLaW5kLkZpbGUgPSAxO1xuICAgIFN5bWJvbEtpbmQuTW9kdWxlID0gMjtcbiAgICBTeW1ib2xLaW5kLk5hbWVzcGFjZSA9IDM7XG4gICAgU3ltYm9sS2luZC5QYWNrYWdlID0gNDtcbiAgICBTeW1ib2xLaW5kLkNsYXNzID0gNTtcbiAgICBTeW1ib2xLaW5kLk1ldGhvZCA9IDY7XG4gICAgU3ltYm9sS2luZC5Qcm9wZXJ0eSA9IDc7XG4gICAgU3ltYm9sS2luZC5GaWVsZCA9IDg7XG4gICAgU3ltYm9sS2luZC5Db25zdHJ1Y3RvciA9IDk7XG4gICAgU3ltYm9sS2luZC5FbnVtID0gMTA7XG4gICAgU3ltYm9sS2luZC5JbnRlcmZhY2UgPSAxMTtcbiAgICBTeW1ib2xLaW5kLkZ1bmN0aW9uID0gMTI7XG4gICAgU3ltYm9sS2luZC5WYXJpYWJsZSA9IDEzO1xuICAgIFN5bWJvbEtpbmQuQ29uc3RhbnQgPSAxNDtcbiAgICBTeW1ib2xLaW5kLlN0cmluZyA9IDE1O1xuICAgIFN5bWJvbEtpbmQuTnVtYmVyID0gMTY7XG4gICAgU3ltYm9sS2luZC5Cb29sZWFuID0gMTc7XG4gICAgU3ltYm9sS2luZC5BcnJheSA9IDE4O1xuICAgIFN5bWJvbEtpbmQuT2JqZWN0ID0gMTk7XG4gICAgU3ltYm9sS2luZC5LZXkgPSAyMDtcbiAgICBTeW1ib2xLaW5kLk51bGwgPSAyMTtcbiAgICBTeW1ib2xLaW5kLkVudW1NZW1iZXIgPSAyMjtcbiAgICBTeW1ib2xLaW5kLlN0cnVjdCA9IDIzO1xuICAgIFN5bWJvbEtpbmQuRXZlbnQgPSAyNDtcbiAgICBTeW1ib2xLaW5kLk9wZXJhdG9yID0gMjU7XG4gICAgU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyID0gMjY7XG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcbi8qKlxuICogU3ltYm9sIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIHN5bWJvbC5cbiAqXG4gKiBAc2luY2UgMy4xNlxuICovXG52YXIgU3ltYm9sVGFnO1xuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBzeW1ib2wgYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIFN5bWJvbFRhZy5EZXByZWNhdGVkID0gMTtcbn0pKFN5bWJvbFRhZyB8fCAoU3ltYm9sVGFnID0ge30pKTtcbnZhciBTeW1ib2xJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU3ltYm9sSW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgcmVzb3VyY2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sIGNvbnRhaW5pbmcgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwga2luZCwgcmFuZ2UsIHVyaSwgY29udGFpbmVyTmFtZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBsb2NhdGlvbjogeyB1cmksIHJhbmdlIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTeW1ib2xJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTeW1ib2xJbmZvcm1hdGlvbiB8fCAoU3ltYm9sSW5mb3JtYXRpb24gPSB7fSkpO1xudmFyIFdvcmtzcGFjZVN5bWJvbDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdvcmtzcGFjZSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgcmVzb3VyY2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIEFuIG9wdGlvbnMgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgV29ya3NwYWNlU3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCB1cmksIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHsgbmFtZSwga2luZCwgbG9jYXRpb246IHsgdXJpLCByYW5nZSB9IH1cbiAgICAgICAgICAgIDogeyBuYW1lLCBraW5kLCBsb2NhdGlvbjogeyB1cmkgfSB9O1xuICAgIH1cbiAgICBXb3Jrc3BhY2VTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xufSkoV29ya3NwYWNlU3ltYm9sIHx8IChXb3Jrc3BhY2VTeW1ib2wgPSB7fSkpO1xudmFyIERvY3VtZW50U3ltYm9sO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25SYW5nZSBUaGUgc2VsZWN0aW9uUmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwgZGV0YWlsLCBraW5kLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50U3ltYm9sfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICBJcy5zdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmIElzLm51bWJlcihjYW5kaWRhdGUua2luZCkgJiZcbiAgICAgICAgICAgIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnNlbGVjdGlvblJhbmdlKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRlcHJlY2F0ZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5kZXByZWNhdGVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5jaGlsZHJlbikpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnRhZ3MgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS50YWdzKSk7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmlzID0gaXM7XG59KShEb2N1bWVudFN5bWJvbCB8fCAoRG9jdW1lbnRTeW1ib2wgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIGNvZGUgYWN0aW9uIGtpbmRzXG4gKi9cbnZhciBDb2RlQWN0aW9uS2luZDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBFbXB0eSBraW5kLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLkVtcHR5ID0gJyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBxdWlja2ZpeCBhY3Rpb25zOiAncXVpY2tmaXgnXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUXVpY2tGaXggPSAncXVpY2tmaXgnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgYWN0aW9uczogJ3JlZmFjdG9yJ1xuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yID0gJ3JlZmFjdG9yJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGV4dHJhY3Rpb24gYWN0aW9uczogJ3JlZmFjdG9yLmV4dHJhY3QnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGV4dHJhY3QgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gRXh0cmFjdCBtZXRob2RcbiAgICAgKiAtIEV4dHJhY3QgZnVuY3Rpb25cbiAgICAgKiAtIEV4dHJhY3QgdmFyaWFibGVcbiAgICAgKiAtIEV4dHJhY3QgaW50ZXJmYWNlIGZyb20gY2xhc3NcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yRXh0cmFjdCA9ICdyZWZhY3Rvci5leHRyYWN0JztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGlubGluZSBhY3Rpb25zOiAncmVmYWN0b3IuaW5saW5lJ1xuICAgICAqXG4gICAgICogRXhhbXBsZSBpbmxpbmUgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gSW5saW5lIGZ1bmN0aW9uXG4gICAgICogLSBJbmxpbmUgdmFyaWFibGVcbiAgICAgKiAtIElubGluZSBjb25zdGFudFxuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JJbmxpbmUgPSAncmVmYWN0b3IuaW5saW5lJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIHJld3JpdGUgYWN0aW9uczogJ3JlZmFjdG9yLnJld3JpdGUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHJld3JpdGUgYWN0aW9uczpcbiAgICAgKlxuICAgICAqIC0gQ29udmVydCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHRvIGNsYXNzXG4gICAgICogLSBBZGQgb3IgcmVtb3ZlIHBhcmFtZXRlclxuICAgICAqIC0gRW5jYXBzdWxhdGUgZmllbGRcbiAgICAgKiAtIE1ha2UgbWV0aG9kIHN0YXRpY1xuICAgICAqIC0gTW92ZSBtZXRob2QgdG8gYmFzZSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JSZXdyaXRlID0gJ3JlZmFjdG9yLnJld3JpdGUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3Igc291cmNlIGFjdGlvbnM6IGBzb3VyY2VgXG4gICAgICpcbiAgICAgKiBTb3VyY2UgY29kZSBhY3Rpb25zIGFwcGx5IHRvIHRoZSBlbnRpcmUgZmlsZS5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2UgPSAnc291cmNlJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGFuIG9yZ2FuaXplIGltcG9ydHMgc291cmNlIGFjdGlvbjogYHNvdXJjZS5vcmdhbml6ZUltcG9ydHNgXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlT3JnYW5pemVJbXBvcnRzID0gJ3NvdXJjZS5vcmdhbml6ZUltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYXV0by1maXggc291cmNlIGFjdGlvbnM6IGBzb3VyY2UuZml4QWxsYC5cbiAgICAgKlxuICAgICAqIEZpeCBhbGwgYWN0aW9ucyBhdXRvbWF0aWNhbGx5IGZpeCBlcnJvcnMgdGhhdCBoYXZlIGEgY2xlYXIgZml4IHRoYXQgZG8gbm90IHJlcXVpcmUgdXNlciBpbnB1dC5cbiAgICAgKiBUaGV5IHNob3VsZCBub3Qgc3VwcHJlc3MgZXJyb3JzIG9yIHBlcmZvcm0gdW5zYWZlIGZpeGVzIHN1Y2ggYXMgZ2VuZXJhdGluZyBuZXcgdHlwZXMgb3IgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE1LjBcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VGaXhBbGwgPSAnc291cmNlLmZpeEFsbCc7XG59KShDb2RlQWN0aW9uS2luZCB8fCAoQ29kZUFjdGlvbktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgcmVhc29uIHdoeSBjb2RlIGFjdGlvbnMgd2VyZSByZXF1ZXN0ZWQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgQ29kZUFjdGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSBleHBsaWNpdGx5IHJlcXVlc3RlZCBieSB0aGUgdXNlciBvciBieSBhbiBleHRlbnNpb24uXG4gICAgICovXG4gICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kLkludm9rZWQgPSAxO1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIGN1cnJlbnQgc2VsZWN0aW9uIGluIGEgZmlsZSBjaGFuZ2VzLCBidXQgY2FuXG4gICAgICogYWxzbyBiZSB0cmlnZ2VyZWQgd2hlbiBmaWxlIGNvbnRlbnQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMjtcbn0pKENvZGVBY3Rpb25UcmlnZ2VyS2luZCB8fCAoQ29kZUFjdGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVBY3Rpb25Db250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBsaXRlcmFscy5cbiAqL1xudmFyIENvZGVBY3Rpb25Db250ZXh0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uQ29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUFjdGlvbkNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZGlhZ25vc3RpY3MsIG9ubHksIHRyaWdnZXJLaW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbnZhciBDb2RlQWN0aW9uO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHRpdGxlIH07XG4gICAgICAgIGxldCBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVja0tpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21tYW5kLmlzKGtpbmRPckNvbW1hbmRPckVkaXQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrS2luZCAmJiBraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCA9PT0gdW5kZWZpbmVkIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2RlTGVuc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUxlbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29kZUxlbnN9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb21tYW5kKSB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIENvZGVMZW5zLmlzID0gaXM7XG59KShDb2RlTGVucyB8fCAoQ29kZUxlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRm9ybWF0dGluZ09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9ybWF0dGluZ09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgRm9ybWF0dGluZ09wdGlvbnM7XG4oZnVuY3Rpb24gKEZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzIH07XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5pcyA9IGlzO1xufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICovXG52YXIgRG9jdW1lbnRMaW5rO1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERvY3VtZW50TGluayBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGFyZ2V0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0YXJnZXQsIGRhdGEgfTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50TGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRhcmdldCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50YXJnZXQpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRMaW5rLmlzID0gaXM7XG59KShEb2N1bWVudExpbmsgfHwgKERvY3VtZW50TGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBTZWxlY3Rpb25SYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIHdvcmsgd2l0aFxuICogU2VsZWN0aW9uUmFuZ2UgbGl0ZXJhbHMuXG4gKi9cbnZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoY2FuZGlkYXRlLnBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IFNlbGVjdGlvblJhbmdlLmlzKGNhbmRpZGF0ZS5wYXJlbnQpKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuaXMgPSBpcztcbn0pKFNlbGVjdGlvblJhbmdlIHx8IChTZWxlY3Rpb25SYW5nZSA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gdHlwZXMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICogYW4gY2xpZW50cyBjYW4gc3BlY2lmeSBhZGRpdGlvbmFsIHRva2VuIHR5cGVzIHZpYSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5UeXBlcykge1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm5hbWVzcGFjZVwiXSA9IFwibmFtZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGdlbmVyaWMgdHlwZS4gQWN0cyBhcyBhIGZhbGxiYWNrIGZvciB0eXBlcyB3aGljaCBjYW4ndCBiZSBtYXBwZWQgdG9cbiAgICAgKiBhIHNwZWNpZmljIHR5cGUgbGlrZSBjbGFzcyBvciBlbnVtLlxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVcIl0gPSBcInR5cGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiaW50ZXJmYWNlXCJdID0gXCJpbnRlcmZhY2VcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwYXJhbWV0ZXJcIl0gPSBcInBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1NZW1iZXJcIl0gPSBcImVudW1NZW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtZXRob2RcIl0gPSBcIm1ldGhvZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtb2RpZmllclwiXSA9IFwibW9kaWZpZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImRlY29yYXRvclwiXSA9IFwiZGVjb3JhdG9yXCI7XG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbk1vZGlmaWVycztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbk1vZGlmaWVycykge1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWNsYXJhdGlvblwiXSA9IFwiZGVjbGFyYXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmaW5pdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJyZWFkb25seVwiXSA9IFwicmVhZG9ubHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wic3RhdGljXCJdID0gXCJzdGF0aWNcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVwcmVjYXRlZFwiXSA9IFwiZGVwcmVjYXRlZFwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhYnN0cmFjdFwiXSA9IFwiYWJzdHJhY3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYXN5bmNcIl0gPSBcImFzeW5jXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcIm1vZGlmaWNhdGlvblwiXSA9IFwibW9kaWZpY2F0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRvY3VtZW50YXRpb25cIl0gPSBcImRvY3VtZW50YXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVmYXVsdExpYnJhcnlcIl0gPSBcImRlZmF1bHRMaWJyYXJ5XCI7XG59KShTZW1hbnRpY1Rva2VuTW9kaWZpZXJzIHx8IChTZW1hbnRpY1Rva2VuTW9kaWZpZXJzID0ge30pKTtcbi8qKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlbnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjYW5kaWRhdGUucmVzdWx0SWQgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZGF0YSkgJiYgKGNhbmRpZGF0ZS5kYXRhLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgY2FuZGlkYXRlLmRhdGFbMF0gPT09ICdudW1iZXInKTtcbiAgICB9XG4gICAgU2VtYW50aWNUb2tlbnMuaXMgPSBpcztcbn0pKFNlbWFudGljVG9rZW5zIHx8IChTZW1hbnRpY1Rva2VucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVUZXh0cy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVRleHQ7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVGV4dCB8fCAoSW5saW5lVmFsdWVUZXh0ID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXApIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cCB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLmNhc2VTZW5zaXRpdmVMb29rdXApXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUpIHx8IGNhbmRpZGF0ZS52YXJpYWJsZU5hbWUgPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgfHwgKElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24uXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb247XG4oZnVuY3Rpb24gKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZXhwcmVzc2lvbikgfHwgY2FuZGlkYXRlLmV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiB8fCAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVDb250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5saW5lVmFsdWVDb250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoSW5saW5lVmFsdWVDb250ZXh0ID0ge30pKTtcbi8qKlxuICogSW5sYXkgaGludCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQW4gaW5sYXkgaGludCB0aGF0IGZvciBhIHR5cGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBJbmxheUhpbnRLaW5kLlR5cGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBpcyBmb3IgYSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5QYXJhbWV0ZXIgPSAyO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSB8fCB2YWx1ZSA9PT0gMjtcbiAgICB9XG4gICAgSW5sYXlIaW50S2luZC5pcyA9IGlzO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG52YXIgSW5sYXlIaW50TGFiZWxQYXJ0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRMYWJlbFBhcnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9XG4gICAgSW5sYXlIaW50TGFiZWxQYXJ0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbnZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBwb3NpdGlvbiwgbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmxhYmVsLCBJbmxheUhpbnRMYWJlbFBhcnQuaXMpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRleHRFZGl0cyA9PT0gdW5kZWZpbmVkKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbnZhciBTdHJpbmdWYWx1ZTtcbihmdW5jdGlvbiAoU3RyaW5nVmFsdWUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVTbmlwcGV0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6ICdzbmlwcGV0JywgdmFsdWUgfTtcbiAgICB9XG4gICAgU3RyaW5nVmFsdWUuY3JlYXRlU25pcHBldCA9IGNyZWF0ZVNuaXBwZXQ7XG59KShTdHJpbmdWYWx1ZSB8fCAoU3RyaW5nVmFsdWUgPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uSXRlbSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCkge1xuICAgICAgICByZXR1cm4geyBpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uSXRlbSB8fCAoSW5saW5lQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uTGlzdCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcykge1xuICAgICAgICByZXR1cm4geyBpdGVtcyB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uTGlzdCB8fCAoSW5saW5lQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IGFuIHtAbGluayBJbmxpbmVDb21wbGV0aW9uSXRlbVByb3ZpZGVyIGlubGluZSBjb21wbGV0aW9uIHByb3ZpZGVyfSB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG52YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDA7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgd2hpbGUgZWRpdGluZy5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMTtcbn0pKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTZWxlY3RlZENvbXBsZXRpb25JbmZvO1xuKGZ1bmN0aW9uIChTZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIFNlbGVjdGVkQ29tcGxldGlvbkluZm8uY3JlYXRlID0gY3JlYXRlO1xufSkoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB8fCAoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyA9IHt9KSk7XG52YXIgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25Db250ZXh0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiB7IHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25Db250ZXh0IHx8IChJbmxpbmVDb21wbGV0aW9uQ29udGV4dCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBVUkkuaXMoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRm9sZGVyLmlzID0gaXM7XG59KShXb3Jrc3BhY2VGb2xkZXIgfHwgKFdvcmtzcGFjZUZvbGRlciA9IHt9KSk7XG5jb25zdCBFT0wgPSBbJ1xcbicsICdcXHJcXG4nLCAnXFxyJ107XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG52YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElUZXh0RG9jdW1lbnQgbGl0ZXJhbCBmcm9tIHRoZSBnaXZlbiB1cmkgYW5kIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJVGV4dERvY3VtZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZUNvdW50KVxuICAgICAgICAgICAgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgbGV0IHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGUubmV3VGV4dCArIHRleHQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAvLyBzb3J0ZWRcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgICAgIG1lcmdlU29ydChsZWZ0LCBjb21wYXJlKTtcbiAgICAgICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgbGV0IGxlZnRJZHggPSAwO1xuICAgICAgICBsZXQgcmlnaHRJZHggPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgdXBkYXRlKGV2ZW50LCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBldmVudC50ZXh0O1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9XG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgbGV0IG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgfVxufVxudmFyIElzO1xuKGZ1bmN0aW9uIChJcykge1xuICAgIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZSk7XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9nbG9iYWwgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0XHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcbi8qKioqKiovIFx0XHRcdHRyeSB7XG4vKioqKioqLyBcdFx0XHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuLyoqKioqKi8gXHRcdFx0fSBjYXRjaCAoZSkge1xuLyoqKioqKi8gXHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fSkoKTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbigoKSA9PiB7XG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBMYW5ndWFnZUNsaWVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTGFuZ3VhZ2VDbGllbnQpXG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9jb21tb24vbWVzc2FnZVJlYWRlci5qc1xudmFyIG1lc3NhZ2VSZWFkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MTMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L3JlYWRlci5qc1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgMjAyNCBUeXBlRm94IGFuZCBvdGhlcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGluIHRoZSBwYWNrYWdlIHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuY2xhc3MgV2ViU29ja2V0TWVzc2FnZVJlYWRlciBleHRlbmRzIG1lc3NhZ2VSZWFkZXIuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBzb2NrZXQ7XG4gICAgc3RhdGUgPSAnaW5pdGlhbCc7XG4gICAgY2FsbGJhY2s7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudHMgPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihzb2NrZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uTWVzc2FnZShtZXNzYWdlID0+IHRoaXMucmVhZE1lc3NhZ2UobWVzc2FnZSkpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbkVycm9yKGVycm9yID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uQ2xvc2UoKGNvZGUsIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IDEwMDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJycgKyBjb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgZHVyaW5nIHNvY2tldCByZWNvbm5lY3Q6IGNvZGUgPSAke2NvZGV9LCByZWFzb24gPSAke3JlYXNvbn1gXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcmVDbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnbGlzdGVuaW5nJztcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmV2ZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZShldmVudC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihldmVudC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ2luaXRpYWwnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ2luaXRpYWwnO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmV2ZW50cy5zcGxpY2UoMCwgdGhpcy5ldmVudHMubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZWFkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZSgwLCAwLCB7IG1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2xpc3RlbmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJycgKyA0MDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFcnJvciBkdXJpbmcgbWVzc2FnZSBwYXJzaW5nLCByZWFzb24gPSAke3R5cGVvZiBlcnIgPT09ICdvYmplY3QnID8gZXJyLm1lc3NhZ2UgOiAndW5rbm93bid9YFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZmlyZUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZSgwLCAwLCB7IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdsaXN0ZW5pbmcnKSB7XG4gICAgICAgICAgICBzdXBlci5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdpbml0aWFsJykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuc3BsaWNlKDAsIDAsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnbGlzdGVuaW5nJykge1xuICAgICAgICAgICAgc3VwZXIuZmlyZUNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdjbG9zZWQnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWRlci5qcy5tYXBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL21lc3NhZ2VXcml0ZXIuanNcbnZhciBtZXNzYWdlV3JpdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NzQ1KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLXdzLWpzb25ycGMvbGliL3NvY2tldC93cml0ZXIuanNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgVHlwZUZveCBhbmQgb3RoZXJzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBpbiB0aGUgcGFja2FnZSByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNsYXNzIFdlYlNvY2tldE1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBtZXNzYWdlV3JpdGVyLkFic3RyYWN0TWVzc2FnZVdyaXRlciB7XG4gICAgZXJyb3JDb3VudCA9IDA7XG4gICAgc29ja2V0O1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgIH1cbiAgICBhc3luYyB3cml0ZShtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShtc2cpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cml0ZXIuanMubWFwXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2Jyb3dzZXIvbWFpbi5qc1xudmFyIG1haW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4NzkpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvc29ja2V0L2Nvbm5lY3Rpb24uanNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgVHlwZUZveCBhbmQgb3RoZXJzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBpbiB0aGUgcGFja2FnZSByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRDb25uZWN0aW9uKHNvY2tldCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgbWVzc2FnZVJlYWRlciA9IG5ldyBXZWJTb2NrZXRNZXNzYWdlUmVhZGVyKHNvY2tldCk7XG4gICAgY29uc3QgbWVzc2FnZVdyaXRlciA9IG5ldyBXZWJTb2NrZXRNZXNzYWdlV3JpdGVyKHNvY2tldCk7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9ICgwLG1haW4uY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKG1lc3NhZ2VSZWFkZXIsIG1lc3NhZ2VXcml0ZXIsIGxvZ2dlcik7XG4gICAgY29ubmVjdGlvbi5vbkNsb3NlKCgpID0+IGNvbm5lY3Rpb24uZGlzcG9zZSgpKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24uanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL2xpYi9zb2NrZXQvaW5kZXguanNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgVHlwZUZveCBhbmQgb3RoZXJzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBpbiB0aGUgcGFja2FnZSByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvbG9nZ2VyLmpzXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcbmNsYXNzIENvbnNvbGVMb2dnZXIge1xuICAgIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgd2FybihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgaW5mbyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcbiAgICB9XG4gICAgbG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgfVxuICAgIGRlYnVnKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS13cy1qc29ucnBjL2xpYi9jb25uZWN0aW9uLmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSAyMDI0IFR5cGVGb3ggYW5kIG90aGVycy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgaW4gdGhlIHBhY2thZ2Ugcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbmZ1bmN0aW9uIGxpc3RlbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3ZWJTb2NrZXQsIG9uQ29ubmVjdGlvbiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBsb2dnZXIgPSBvcHRpb25zLmxvZ2dlciB8fCBuZXcgQ29uc29sZUxvZ2dlcigpO1xuICAgIHdlYlNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRvU29ja2V0KHdlYlNvY2tldCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBjcmVhdGVXZWJTb2NrZXRDb25uZWN0aW9uKHNvY2tldCwgbG9nZ2VyKTtcbiAgICAgICAgb25Db25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b1NvY2tldCh3ZWJTb2NrZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZW5kOiBjb250ZW50ID0+IHdlYlNvY2tldC5zZW5kKGNvbnRlbnQpLFxuICAgICAgICBvbk1lc3NhZ2U6IGNiID0+IHtcbiAgICAgICAgICAgIHdlYlNvY2tldC5vbm1lc3NhZ2UgPSBldmVudCA9PiBjYihldmVudC5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogY2IgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHdlYlNvY2tldC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZXZlbnQsICdtZXNzYWdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXZlbnQubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9zZTogY2IgPT4ge1xuICAgICAgICAgICAgd2ViU29ja2V0Lm9uY2xvc2UgPSBldmVudCA9PiBjYihldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlOiAoKSA9PiB3ZWJTb2NrZXQuY2xvc2UoKVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLmpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtd3MtanNvbnJwYy9saWIvaW5kZXguanNcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgVHlwZUZveCBhbmQgb3RoZXJzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBpbiB0aGUgcGFja2FnZSByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2xpYi9icm93c2VyL21haW4uanNcbnZhciBicm93c2VyX21haW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sL2Jyb3dzZXIuanNcbnZhciBicm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzEzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc2VydmljZXMvYmFzZS1zZXJ2aWNlLnRzXG52YXIgYmFzZV9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTI1KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tZXNzYWdlLXR5cGVzLnRzXG5mdW5jdGlvbiBfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5jbGFzcyBCYXNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlc3Npb25JZFwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiZG9jdW1lbnRVcmlcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrSWRcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uSWQgPSBkb2N1bWVudElkZW50aWZpZXIuc2Vzc2lvbklkO1xuICAgICAgICB0aGlzLmRvY3VtZW50VXJpID0gZG9jdW1lbnRJZGVudGlmaWVyLmRvY3VtZW50VXJpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrSWQgPSBjYWxsYmFja0lkO1xuICAgIH1cbn1cbmNsYXNzIEluaXRNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUsIHZlcnNpb24sIG1vZGUsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5pbml0KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5jbGFzcyBGb3JtYXRNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUsIGZvcm1hdCl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmZvcm1hdCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgfVxufVxuY2xhc3MgQ29tcGxldGVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jb21wbGV0ZSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lQ29tcGxldGVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5pbmxpbmVDb21wbGV0ZSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgUmVzb2x2ZUNvbXBsZXRpb25NZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5yZXNvbHZlQ29tcGxldGlvbik7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgSG92ZXJNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5ob3Zlcik7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgVmFsaWRhdGVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLnZhbGlkYXRlKTtcbiAgICB9XG59XG5jbGFzcyBDaGFuZ2VNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUsIHZlcnNpb24pe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jaGFuZ2UpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbn1cbmNsYXNzIERlbHRhc01lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkLCB2YWx1ZSwgdmVyc2lvbil7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmFwcGx5RGVsdGEpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbn1cbmNsYXNzIENoYW5nZU1vZGVNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUsIHZlcnNpb24sIG1vZGUpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jaGFuZ2VNb2RlKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG59XG5jbGFzcyBDaGFuZ2VPcHRpb25zTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIG9wdGlvbnMsIG1lcmdlID0gZmFsc2Upe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jaGFuZ2VPcHRpb25zKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIm1lcmdlXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubWVyZ2UgPSBtZXJnZTtcbiAgICB9XG59XG5jbGFzcyBDbG9zZURvY3VtZW50TWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5jbG9zZURvY3VtZW50KTtcbiAgICB9XG59XG5jbGFzcyBDbG9zZUNvbm5lY3Rpb25NZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFja0lkKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuY2xvc2VDb25uZWN0aW9uKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrSWRcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja0lkID0gY2FsbGJhY2tJZDtcbiAgICB9XG59XG5jbGFzcyBHbG9iYWxPcHRpb25zTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZU5hbWUsIG9wdGlvbnMsIG1lcmdlKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuZ2xvYmFsT3B0aW9ucyk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlTmFtZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwibWVyZ2VcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLm1lcmdlID0gbWVyZ2U7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJlRmVhdHVyZXNNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlTmFtZSwgb3B0aW9ucyl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLmNvbmZpZ3VyZUZlYXR1cmVzKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VOYW1lXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG59XG5jbGFzcyBTaWduYXR1cmVIZWxwTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQsIHZhbHVlKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuc2lnbmF0dXJlSGVscCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgRG9jdW1lbnRIaWdobGlnaHRNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5kb2N1bWVudEhpZ2hsaWdodCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgR2V0U2VtYW50aWNUb2tlbnNNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5nZXRTZW1hbnRpY1Rva2Vucyk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgR2V0Q29kZUFjdGlvbnNNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCwgdmFsdWUsIGNvbnRleHQpe1xuICAgICAgICBzdXBlcihkb2N1bWVudElkZW50aWZpZXIsIGNhbGxiYWNrSWQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5nZXRDb2RlQWN0aW9ucyk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxufVxuY2xhc3MgU2V0V29ya3NwYWNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpe1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5zZXRXb3Jrc3BhY2UpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIEV4ZWN1dGVDb21tYW5kTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZU5hbWUsIGNhbGxiYWNrSWQsIGNvbW1hbmQsIGFyZ3Mpe1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY2FsbGJhY2tJZFwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmljZU5hbWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgTWVzc2FnZVR5cGUuZXhlY3V0ZUNvbW1hbmQpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImFyZ3NcIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgICB0aGlzLmNhbGxiYWNrSWQgPSBjYWxsYmFja0lkO1xuICAgICAgICB0aGlzLnZhbHVlID0gY29tbWFuZDtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG59XG5jbGFzcyBBcHBsaWVkRWRpdE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXJ2aWNlTmFtZSwgY2FsbGJhY2tJZCl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjYWxsYmFja0lkXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlTmFtZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5hcHBsaWVkRWRpdCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tJZCA9IGNhbGxiYWNrSWQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5jbGFzcyBSZW5hbWVEb2N1bWVudE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRJZGVudGlmaWVyLCBjYWxsYmFja0lkLCB2YWx1ZSwgdmVyc2lvbil7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50SWRlbnRpZmllciwgY2FsbGJhY2tJZCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIE1lc3NhZ2VUeXBlLnJlbmFtZURvY3VtZW50KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG59XG5jbGFzcyBTZW5kUmVxdWVzdE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VOYW1lLCBjYWxsYmFja0lkLCByZXF1ZXN0TmFtZSwgYXJncyl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjYWxsYmFja0lkXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlTmFtZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5zZW5kUmVxdWVzdCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiYXJnc1wiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tJZCA9IGNhbGxiYWNrSWQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSByZXF1ZXN0TmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG59XG5jbGFzcyBTZW5kUmVzcG9uc2VNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlTmFtZSwgY2FsbGJhY2tJZCwgYXJncyl7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjYWxsYmFja0lkXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlTmFtZVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwidHlwZVwiLCBNZXNzYWdlVHlwZS5zZW5kUmVzcG9uc2UpO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiYXJnc1wiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tJZCA9IGNhbGxiYWNrSWQ7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxufVxudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uKE1lc3NhZ2VUeXBlKSB7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJpbml0XCJdID0gMF0gPSBcImluaXRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImZvcm1hdFwiXSA9IDFdID0gXCJmb3JtYXRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNvbXBsZXRlXCJdID0gMl0gPSBcImNvbXBsZXRlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJyZXNvbHZlQ29tcGxldGlvblwiXSA9IDNdID0gXCJyZXNvbHZlQ29tcGxldGlvblwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2hhbmdlXCJdID0gNF0gPSBcImNoYW5nZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiaG92ZXJcIl0gPSA1XSA9IFwiaG92ZXJcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcInZhbGlkYXRlXCJdID0gNl0gPSBcInZhbGlkYXRlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJhcHBseURlbHRhXCJdID0gN10gPSBcImFwcGx5RGVsdGFcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNoYW5nZU1vZGVcIl0gPSA4XSA9IFwiY2hhbmdlTW9kZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2hhbmdlT3B0aW9uc1wiXSA9IDldID0gXCJjaGFuZ2VPcHRpb25zXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJjbG9zZURvY3VtZW50XCJdID0gMTBdID0gXCJjbG9zZURvY3VtZW50XCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJnbG9iYWxPcHRpb25zXCJdID0gMTFdID0gXCJnbG9iYWxPcHRpb25zXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJjb25maWd1cmVGZWF0dXJlc1wiXSA9IDEyXSA9IFwiY29uZmlndXJlRmVhdHVyZXNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcInNpZ25hdHVyZUhlbHBcIl0gPSAxM10gPSBcInNpZ25hdHVyZUhlbHBcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImRvY3VtZW50SGlnaGxpZ2h0XCJdID0gMTRdID0gXCJkb2N1bWVudEhpZ2hsaWdodFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiY2xvc2VDb25uZWN0aW9uXCJdID0gMTVdID0gXCJjbG9zZUNvbm5lY3Rpb25cIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImNhcGFiaWxpdGllc0NoYW5nZVwiXSA9IDE2XSA9IFwiY2FwYWJpbGl0aWVzQ2hhbmdlXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJnZXRTZW1hbnRpY1Rva2Vuc1wiXSA9IDE3XSA9IFwiZ2V0U2VtYW50aWNUb2tlbnNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcImdldENvZGVBY3Rpb25zXCJdID0gMThdID0gXCJnZXRDb2RlQWN0aW9uc1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiZXhlY3V0ZUNvbW1hbmRcIl0gPSAxOV0gPSBcImV4ZWN1dGVDb21tYW5kXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJhcHBseUVkaXRcIl0gPSAyMF0gPSBcImFwcGx5RWRpdFwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiYXBwbGllZEVkaXRcIl0gPSAyMV0gPSBcImFwcGxpZWRFZGl0XCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJzZXRXb3Jrc3BhY2VcIl0gPSAyMl0gPSBcInNldFdvcmtzcGFjZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wicmVuYW1lRG9jdW1lbnRcIl0gPSAyM10gPSBcInJlbmFtZURvY3VtZW50XCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJzZW5kUmVxdWVzdFwiXSA9IDI0XSA9IFwic2VuZFJlcXVlc3RcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcInNob3dEb2N1bWVudFwiXSA9IDI1XSA9IFwic2hvd0RvY3VtZW50XCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJzZW5kUmVzcG9uc2VcIl0gPSAyNl0gPSBcInNlbmRSZXNwb25zZVwiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiaW5saW5lQ29tcGxldGVcIl0gPSAyN10gPSBcImlubGluZUNvbXBsZXRlXCI7XG59KShNZXNzYWdlVHlwZSB8fCAoTWVzc2FnZVR5cGUgPSB7fSkpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS11cmkvbGliL2VzbS9pbmRleC5tanNcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIHByb2Nlc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MDcpO1xudmFyIExJQjsoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17OTc1OnQ9PntmdW5jdGlvbiBlKHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KHQpKX1mdW5jdGlvbiByKHQsZSl7Zm9yKHZhciByLG49XCJcIixpPTAsbz0tMSxzPTAsaD0wO2g8PXQubGVuZ3RoOysraCl7aWYoaDx0Lmxlbmd0aClyPXQuY2hhckNvZGVBdChoKTtlbHNle2lmKDQ3PT09cilicmVhaztyPTQ3fWlmKDQ3PT09cil7aWYobz09PWgtMXx8MT09PXMpO2Vsc2UgaWYobyE9PWgtMSYmMj09PXMpe2lmKG4ubGVuZ3RoPDJ8fDIhPT1pfHw0NiE9PW4uY2hhckNvZGVBdChuLmxlbmd0aC0xKXx8NDYhPT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMikpaWYobi5sZW5ndGg+Mil7dmFyIGE9bi5sYXN0SW5kZXhPZihcIi9cIik7aWYoYSE9PW4ubGVuZ3RoLTEpey0xPT09YT8obj1cIlwiLGk9MCk6aT0obj1uLnNsaWNlKDAsYSkpLmxlbmd0aC0xLW4ubGFzdEluZGV4T2YoXCIvXCIpLG89aCxzPTA7Y29udGludWV9fWVsc2UgaWYoMj09PW4ubGVuZ3RofHwxPT09bi5sZW5ndGgpe249XCJcIixpPTAsbz1oLHM9MDtjb250aW51ZX1lJiYobi5sZW5ndGg+MD9uKz1cIi8uLlwiOm49XCIuLlwiLGk9Mil9ZWxzZSBuLmxlbmd0aD4wP24rPVwiL1wiK3Quc2xpY2UobysxLGgpOm49dC5zbGljZShvKzEsaCksaT1oLW8tMTtvPWgscz0wfWVsc2UgNDY9PT1yJiYtMSE9PXM/KytzOnM9LTF9cmV0dXJuIG59dmFyIG49e3Jlc29sdmU6ZnVuY3Rpb24oKXtmb3IodmFyIHQsbj1cIlwiLGk9ITEsbz1hcmd1bWVudHMubGVuZ3RoLTE7bz49LTEmJiFpO28tLSl7dmFyIHM7bz49MD9zPWFyZ3VtZW50c1tvXToodm9pZCAwPT09dCYmKHQ9cHJvY2Vzcy5jd2QoKSkscz10KSxlKHMpLDAhPT1zLmxlbmd0aCYmKG49cytcIi9cIituLGk9NDc9PT1zLmNoYXJDb2RlQXQoMCkpfXJldHVybiBuPXIobiwhaSksaT9uLmxlbmd0aD4wP1wiL1wiK246XCIvXCI6bi5sZW5ndGg+MD9uOlwiLlwifSxub3JtYWxpemU6ZnVuY3Rpb24odCl7aWYoZSh0KSwwPT09dC5sZW5ndGgpcmV0dXJuXCIuXCI7dmFyIG49NDc9PT10LmNoYXJDb2RlQXQoMCksaT00Nz09PXQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKTtyZXR1cm4gMCE9PSh0PXIodCwhbikpLmxlbmd0aHx8bnx8KHQ9XCIuXCIpLHQubGVuZ3RoPjAmJmkmJih0Kz1cIi9cIiksbj9cIi9cIit0OnR9LGlzQWJzb2x1dGU6ZnVuY3Rpb24odCl7cmV0dXJuIGUodCksdC5sZW5ndGg+MCYmNDc9PT10LmNoYXJDb2RlQXQoMCl9LGpvaW46ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm5cIi5cIjtmb3IodmFyIHQscj0wO3I8YXJndW1lbnRzLmxlbmd0aDsrK3Ipe3ZhciBpPWFyZ3VtZW50c1tyXTtlKGkpLGkubGVuZ3RoPjAmJih2b2lkIDA9PT10P3Q9aTp0Kz1cIi9cIitpKX1yZXR1cm4gdm9pZCAwPT09dD9cIi5cIjpuLm5vcm1hbGl6ZSh0KX0scmVsYXRpdmU6ZnVuY3Rpb24odCxyKXtpZihlKHQpLGUociksdD09PXIpcmV0dXJuXCJcIjtpZigodD1uLnJlc29sdmUodCkpPT09KHI9bi5yZXNvbHZlKHIpKSlyZXR1cm5cIlwiO2Zvcih2YXIgaT0xO2k8dC5sZW5ndGgmJjQ3PT09dC5jaGFyQ29kZUF0KGkpOysraSk7Zm9yKHZhciBvPXQubGVuZ3RoLHM9by1pLGg9MTtoPHIubGVuZ3RoJiY0Nz09PXIuY2hhckNvZGVBdChoKTsrK2gpO2Zvcih2YXIgYT1yLmxlbmd0aC1oLGM9czxhP3M6YSxmPS0xLHU9MDt1PD1jOysrdSl7aWYodT09PWMpe2lmKGE+Yyl7aWYoNDc9PT1yLmNoYXJDb2RlQXQoaCt1KSlyZXR1cm4gci5zbGljZShoK3UrMSk7aWYoMD09PXUpcmV0dXJuIHIuc2xpY2UoaCt1KX1lbHNlIHM+YyYmKDQ3PT09dC5jaGFyQ29kZUF0KGkrdSk/Zj11OjA9PT11JiYoZj0wKSk7YnJlYWt9dmFyIGw9dC5jaGFyQ29kZUF0KGkrdSk7aWYobCE9PXIuY2hhckNvZGVBdChoK3UpKWJyZWFrOzQ3PT09bCYmKGY9dSl9dmFyIGc9XCJcIjtmb3IodT1pK2YrMTt1PD1vOysrdSl1IT09byYmNDchPT10LmNoYXJDb2RlQXQodSl8fCgwPT09Zy5sZW5ndGg/Zys9XCIuLlwiOmcrPVwiLy4uXCIpO3JldHVybiBnLmxlbmd0aD4wP2crci5zbGljZShoK2YpOihoKz1mLDQ3PT09ci5jaGFyQ29kZUF0KGgpJiYrK2gsci5zbGljZShoKSl9LF9tYWtlTG9uZzpmdW5jdGlvbih0KXtyZXR1cm4gdH0sZGlybmFtZTpmdW5jdGlvbih0KXtpZihlKHQpLDA9PT10Lmxlbmd0aClyZXR1cm5cIi5cIjtmb3IodmFyIHI9dC5jaGFyQ29kZUF0KDApLG49NDc9PT1yLGk9LTEsbz0hMCxzPXQubGVuZ3RoLTE7cz49MTstLXMpaWYoNDc9PT0ocj10LmNoYXJDb2RlQXQocykpKXtpZighbyl7aT1zO2JyZWFrfX1lbHNlIG89ITE7cmV0dXJuLTE9PT1pP24/XCIvXCI6XCIuXCI6biYmMT09PWk/XCIvL1wiOnQuc2xpY2UoMCxpKX0sYmFzZW5hbWU6ZnVuY3Rpb24odCxyKXtpZih2b2lkIDAhPT1yJiZcInN0cmluZ1wiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtlKHQpO3ZhciBuLGk9MCxvPS0xLHM9ITA7aWYodm9pZCAwIT09ciYmci5sZW5ndGg+MCYmci5sZW5ndGg8PXQubGVuZ3RoKXtpZihyLmxlbmd0aD09PXQubGVuZ3RoJiZyPT09dClyZXR1cm5cIlwiO3ZhciBoPXIubGVuZ3RoLTEsYT0tMTtmb3Iobj10Lmxlbmd0aC0xO24+PTA7LS1uKXt2YXIgYz10LmNoYXJDb2RlQXQobik7aWYoNDc9PT1jKXtpZighcyl7aT1uKzE7YnJlYWt9fWVsc2UtMT09PWEmJihzPSExLGE9bisxKSxoPj0wJiYoYz09PXIuY2hhckNvZGVBdChoKT8tMT09LS1oJiYobz1uKTooaD0tMSxvPWEpKX1yZXR1cm4gaT09PW8/bz1hOi0xPT09byYmKG89dC5sZW5ndGgpLHQuc2xpY2UoaSxvKX1mb3Iobj10Lmxlbmd0aC0xO24+PTA7LS1uKWlmKDQ3PT09dC5jaGFyQ29kZUF0KG4pKXtpZighcyl7aT1uKzE7YnJlYWt9fWVsc2UtMT09PW8mJihzPSExLG89bisxKTtyZXR1cm4tMT09PW8/XCJcIjp0LnNsaWNlKGksbyl9LGV4dG5hbWU6ZnVuY3Rpb24odCl7ZSh0KTtmb3IodmFyIHI9LTEsbj0wLGk9LTEsbz0hMCxzPTAsaD10Lmxlbmd0aC0xO2g+PTA7LS1oKXt2YXIgYT10LmNoYXJDb2RlQXQoaCk7aWYoNDchPT1hKS0xPT09aSYmKG89ITEsaT1oKzEpLDQ2PT09YT8tMT09PXI/cj1oOjEhPT1zJiYocz0xKTotMSE9PXImJihzPS0xKTtlbHNlIGlmKCFvKXtuPWgrMTticmVha319cmV0dXJuLTE9PT1yfHwtMT09PWl8fDA9PT1zfHwxPT09cyYmcj09PWktMSYmcj09PW4rMT9cIlwiOnQuc2xpY2UocixpKX0sZm9ybWF0OmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10fHxcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiB0KTtyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgcj1lLmRpcnx8ZS5yb290LG49ZS5iYXNlfHwoZS5uYW1lfHxcIlwiKSsoZS5leHR8fFwiXCIpO3JldHVybiByP3I9PT1lLnJvb3Q/cituOnIrXCIvXCIrbjpufSgwLHQpfSxwYXJzZTpmdW5jdGlvbih0KXtlKHQpO3ZhciByPXtyb290OlwiXCIsZGlyOlwiXCIsYmFzZTpcIlwiLGV4dDpcIlwiLG5hbWU6XCJcIn07aWYoMD09PXQubGVuZ3RoKXJldHVybiByO3ZhciBuLGk9dC5jaGFyQ29kZUF0KDApLG89NDc9PT1pO28/KHIucm9vdD1cIi9cIixuPTEpOm49MDtmb3IodmFyIHM9LTEsaD0wLGE9LTEsYz0hMCxmPXQubGVuZ3RoLTEsdT0wO2Y+PW47LS1mKWlmKDQ3IT09KGk9dC5jaGFyQ29kZUF0KGYpKSktMT09PWEmJihjPSExLGE9ZisxKSw0Nj09PWk/LTE9PT1zP3M9ZjoxIT09dSYmKHU9MSk6LTEhPT1zJiYodT0tMSk7ZWxzZSBpZighYyl7aD1mKzE7YnJlYWt9cmV0dXJuLTE9PT1zfHwtMT09PWF8fDA9PT11fHwxPT09dSYmcz09PWEtMSYmcz09PWgrMT8tMSE9PWEmJihyLmJhc2U9ci5uYW1lPTA9PT1oJiZvP3Quc2xpY2UoMSxhKTp0LnNsaWNlKGgsYSkpOigwPT09aCYmbz8oci5uYW1lPXQuc2xpY2UoMSxzKSxyLmJhc2U9dC5zbGljZSgxLGEpKTooci5uYW1lPXQuc2xpY2UoaCxzKSxyLmJhc2U9dC5zbGljZShoLGEpKSxyLmV4dD10LnNsaWNlKHMsYSkpLGg+MD9yLmRpcj10LnNsaWNlKDAsaC0xKTpvJiYoci5kaXI9XCIvXCIpLHJ9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtuLnBvc2l4PW4sdC5leHBvcnRzPW59fSxlPXt9O2Z1bmN0aW9uIHIobil7dmFyIGk9ZVtuXTtpZih2b2lkIDAhPT1pKXJldHVybiBpLmV4cG9ydHM7dmFyIG89ZVtuXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbbl0obyxvLmV4cG9ydHMsciksby5leHBvcnRzfXIuZD0odCxlKT0+e2Zvcih2YXIgbiBpbiBlKXIubyhlLG4pJiYhci5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmVbbl19KX0sci5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxyLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciBuPXt9O2xldCBpO2lmKHIucihuKSxyLmQobix7VVJJOigpPT5sLFV0aWxzOigpPT5JfSksXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MpaT1cIndpbjMyXCI9PT1wcm9jZXNzLnBsYXRmb3JtO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvcil7bGV0IHQ9bmF2aWdhdG9yLnVzZXJBZ2VudDtpPXQuaW5kZXhPZihcIldpbmRvd3NcIik+PTB9Y29uc3Qgbz0vXlxcd1tcXHdcXGQrLi1dKiQvLHM9L15cXC8vLGg9L15cXC9cXC8vO2Z1bmN0aW9uIGEodCxlKXtpZighdC5zY2hlbWUmJmUpdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBTY2hlbWUgaXMgbWlzc2luZzoge3NjaGVtZTogXCJcIiwgYXV0aG9yaXR5OiBcIiR7dC5hdXRob3JpdHl9XCIsIHBhdGg6IFwiJHt0LnBhdGh9XCIsIHF1ZXJ5OiBcIiR7dC5xdWVyeX1cIiwgZnJhZ21lbnQ6IFwiJHt0LmZyYWdtZW50fVwifWApO2lmKHQuc2NoZW1lJiYhby50ZXN0KHQuc2NoZW1lKSl0aHJvdyBuZXcgRXJyb3IoXCJbVXJpRXJyb3JdOiBTY2hlbWUgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLlwiKTtpZih0LnBhdGgpaWYodC5hdXRob3JpdHkpe2lmKCFzLnRlc3QodC5wYXRoKSl0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGNvbnRhaW5zIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY29tcG9uZW50IG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSBzbGFzaCAoXCIvXCIpIGNoYXJhY3RlcicpfWVsc2UgaWYoaC50ZXN0KHQucGF0aCkpdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBkb2VzIG5vdCBjb250YWluIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY2Fubm90IGJlZ2luIHdpdGggdHdvIHNsYXNoIGNoYXJhY3RlcnMgKFwiLy9cIiknKX1jb25zdCBjPVwiXCIsZj1cIi9cIix1PS9eKChbXjovPyNdKz8pOik/KFxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8vO2NsYXNzIGx7c3RhdGljIGlzVXJpKHQpe3JldHVybiB0IGluc3RhbmNlb2YgbHx8ISF0JiZcInN0cmluZ1wiPT10eXBlb2YgdC5hdXRob3JpdHkmJlwic3RyaW5nXCI9PXR5cGVvZiB0LmZyYWdtZW50JiZcInN0cmluZ1wiPT10eXBlb2YgdC5wYXRoJiZcInN0cmluZ1wiPT10eXBlb2YgdC5xdWVyeSYmXCJzdHJpbmdcIj09dHlwZW9mIHQuc2NoZW1lJiZcInN0cmluZ1wiPT10eXBlb2YgdC5mc1BhdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQud2l0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC50b1N0cmluZ31zY2hlbWU7YXV0aG9yaXR5O3BhdGg7cXVlcnk7ZnJhZ21lbnQ7Y29uc3RydWN0b3IodCxlLHIsbixpLG89ITEpe1wib2JqZWN0XCI9PXR5cGVvZiB0Pyh0aGlzLnNjaGVtZT10LnNjaGVtZXx8Yyx0aGlzLmF1dGhvcml0eT10LmF1dGhvcml0eXx8Yyx0aGlzLnBhdGg9dC5wYXRofHxjLHRoaXMucXVlcnk9dC5xdWVyeXx8Yyx0aGlzLmZyYWdtZW50PXQuZnJhZ21lbnR8fGMpOih0aGlzLnNjaGVtZT1mdW5jdGlvbih0LGUpe3JldHVybiB0fHxlP3Q6XCJmaWxlXCJ9KHQsbyksdGhpcy5hdXRob3JpdHk9ZXx8Yyx0aGlzLnBhdGg9ZnVuY3Rpb24odCxlKXtzd2l0Y2godCl7Y2FzZVwiaHR0cHNcIjpjYXNlXCJodHRwXCI6Y2FzZVwiZmlsZVwiOmU/ZVswXSE9PWYmJihlPWYrZSk6ZT1mfXJldHVybiBlfSh0aGlzLnNjaGVtZSxyfHxjKSx0aGlzLnF1ZXJ5PW58fGMsdGhpcy5mcmFnbWVudD1pfHxjLGEodGhpcyxvKSl9Z2V0IGZzUGF0aCgpe3JldHVybiB2KHRoaXMsITEpfXdpdGgodCl7aWYoIXQpcmV0dXJuIHRoaXM7bGV0e3NjaGVtZTplLGF1dGhvcml0eTpyLHBhdGg6bixxdWVyeTppLGZyYWdtZW50Om99PXQ7cmV0dXJuIHZvaWQgMD09PWU/ZT10aGlzLnNjaGVtZTpudWxsPT09ZSYmKGU9Yyksdm9pZCAwPT09cj9yPXRoaXMuYXV0aG9yaXR5Om51bGw9PT1yJiYocj1jKSx2b2lkIDA9PT1uP249dGhpcy5wYXRoOm51bGw9PT1uJiYobj1jKSx2b2lkIDA9PT1pP2k9dGhpcy5xdWVyeTpudWxsPT09aSYmKGk9Yyksdm9pZCAwPT09bz9vPXRoaXMuZnJhZ21lbnQ6bnVsbD09PW8mJihvPWMpLGU9PT10aGlzLnNjaGVtZSYmcj09PXRoaXMuYXV0aG9yaXR5JiZuPT09dGhpcy5wYXRoJiZpPT09dGhpcy5xdWVyeSYmbz09PXRoaXMuZnJhZ21lbnQ/dGhpczpuZXcgZChlLHIsbixpLG8pfXN0YXRpYyBwYXJzZSh0LGU9ITEpe2NvbnN0IHI9dS5leGVjKHQpO3JldHVybiByP25ldyBkKHJbMl18fGMsdyhyWzRdfHxjKSx3KHJbNV18fGMpLHcocls3XXx8YyksdyhyWzldfHxjKSxlKTpuZXcgZChjLGMsYyxjLGMpfXN0YXRpYyBmaWxlKHQpe2xldCBlPWM7aWYoaSYmKHQ9dC5yZXBsYWNlKC9cXFxcL2csZikpLHRbMF09PT1mJiZ0WzFdPT09Zil7Y29uc3Qgcj10LmluZGV4T2YoZiwyKTstMT09PXI/KGU9dC5zdWJzdHJpbmcoMiksdD1mKTooZT10LnN1YnN0cmluZygyLHIpLHQ9dC5zdWJzdHJpbmcocil8fGYpfXJldHVybiBuZXcgZChcImZpbGVcIixlLHQsYyxjKX1zdGF0aWMgZnJvbSh0KXtjb25zdCBlPW5ldyBkKHQuc2NoZW1lLHQuYXV0aG9yaXR5LHQucGF0aCx0LnF1ZXJ5LHQuZnJhZ21lbnQpO3JldHVybiBhKGUsITApLGV9dG9TdHJpbmcodD0hMSl7cmV0dXJuIGIodGhpcyx0KX10b0pTT04oKXtyZXR1cm4gdGhpc31zdGF0aWMgcmV2aXZlKHQpe2lmKHQpe2lmKHQgaW5zdGFuY2VvZiBsKXJldHVybiB0O3tjb25zdCBlPW5ldyBkKHQpO3JldHVybiBlLl9mb3JtYXR0ZWQ9dC5leHRlcm5hbCxlLl9mc1BhdGg9dC5fc2VwPT09Zz90LmZzUGF0aDpudWxsLGV9fXJldHVybiB0fX1jb25zdCBnPWk/MTp2b2lkIDA7Y2xhc3MgZCBleHRlbmRzIGx7X2Zvcm1hdHRlZD1udWxsO19mc1BhdGg9bnVsbDtnZXQgZnNQYXRoKCl7cmV0dXJuIHRoaXMuX2ZzUGF0aHx8KHRoaXMuX2ZzUGF0aD12KHRoaXMsITEpKSx0aGlzLl9mc1BhdGh9dG9TdHJpbmcodD0hMSl7cmV0dXJuIHQ/Yih0aGlzLCEwKToodGhpcy5fZm9ybWF0dGVkfHwodGhpcy5fZm9ybWF0dGVkPWIodGhpcywhMSkpLHRoaXMuX2Zvcm1hdHRlZCl9dG9KU09OKCl7Y29uc3QgdD17JG1pZDoxfTtyZXR1cm4gdGhpcy5fZnNQYXRoJiYodC5mc1BhdGg9dGhpcy5fZnNQYXRoLHQuX3NlcD1nKSx0aGlzLl9mb3JtYXR0ZWQmJih0LmV4dGVybmFsPXRoaXMuX2Zvcm1hdHRlZCksdGhpcy5wYXRoJiYodC5wYXRoPXRoaXMucGF0aCksdGhpcy5zY2hlbWUmJih0LnNjaGVtZT10aGlzLnNjaGVtZSksdGhpcy5hdXRob3JpdHkmJih0LmF1dGhvcml0eT10aGlzLmF1dGhvcml0eSksdGhpcy5xdWVyeSYmKHQucXVlcnk9dGhpcy5xdWVyeSksdGhpcy5mcmFnbWVudCYmKHQuZnJhZ21lbnQ9dGhpcy5mcmFnbWVudCksdH19Y29uc3QgcD17NTg6XCIlM0FcIiw0NzpcIiUyRlwiLDYzOlwiJTNGXCIsMzU6XCIlMjNcIiw5MTpcIiU1QlwiLDkzOlwiJTVEXCIsNjQ6XCIlNDBcIiwzMzpcIiUyMVwiLDM2OlwiJTI0XCIsMzg6XCIlMjZcIiwzOTpcIiUyN1wiLDQwOlwiJTI4XCIsNDE6XCIlMjlcIiw0MjpcIiUyQVwiLDQzOlwiJTJCXCIsNDQ6XCIlMkNcIiw1OTpcIiUzQlwiLDYxOlwiJTNEXCIsMzI6XCIlMjBcIn07ZnVuY3Rpb24gbSh0LGUscil7bGV0IG4saT0tMTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7Y29uc3Qgcz10LmNoYXJDb2RlQXQobyk7aWYocz49OTcmJnM8PTEyMnx8cz49NjUmJnM8PTkwfHxzPj00OCYmczw9NTd8fDQ1PT09c3x8NDY9PT1zfHw5NT09PXN8fDEyNj09PXN8fGUmJjQ3PT09c3x8ciYmOTE9PT1zfHxyJiY5Mz09PXN8fHImJjU4PT09cyktMSE9PWkmJihuKz1lbmNvZGVVUklDb21wb25lbnQodC5zdWJzdHJpbmcoaSxvKSksaT0tMSksdm9pZCAwIT09biYmKG4rPXQuY2hhckF0KG8pKTtlbHNle3ZvaWQgMD09PW4mJihuPXQuc3Vic3RyKDAsbykpO2NvbnN0IGU9cFtzXTt2b2lkIDAhPT1lPygtMSE9PWkmJihuKz1lbmNvZGVVUklDb21wb25lbnQodC5zdWJzdHJpbmcoaSxvKSksaT0tMSksbis9ZSk6LTE9PT1pJiYoaT1vKX19cmV0dXJuLTEhPT1pJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKGkpKSksdm9pZCAwIT09bj9uOnR9ZnVuY3Rpb24geSh0KXtsZXQgZTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3Qgbj10LmNoYXJDb2RlQXQocik7MzU9PT1ufHw2Mz09PW4/KHZvaWQgMD09PWUmJihlPXQuc3Vic3RyKDAscikpLGUrPXBbbl0pOnZvaWQgMCE9PWUmJihlKz10W3JdKX1yZXR1cm4gdm9pZCAwIT09ZT9lOnR9ZnVuY3Rpb24gdih0LGUpe2xldCByO3JldHVybiByPXQuYXV0aG9yaXR5JiZ0LnBhdGgubGVuZ3RoPjEmJlwiZmlsZVwiPT09dC5zY2hlbWU/YC8vJHt0LmF1dGhvcml0eX0ke3QucGF0aH1gOjQ3PT09dC5wYXRoLmNoYXJDb2RlQXQoMCkmJih0LnBhdGguY2hhckNvZGVBdCgxKT49NjUmJnQucGF0aC5jaGFyQ29kZUF0KDEpPD05MHx8dC5wYXRoLmNoYXJDb2RlQXQoMSk+PTk3JiZ0LnBhdGguY2hhckNvZGVBdCgxKTw9MTIyKSYmNTg9PT10LnBhdGguY2hhckNvZGVBdCgyKT9lP3QucGF0aC5zdWJzdHIoMSk6dC5wYXRoWzFdLnRvTG93ZXJDYXNlKCkrdC5wYXRoLnN1YnN0cigyKTp0LnBhdGgsaSYmKHI9ci5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcIikpLHJ9ZnVuY3Rpb24gYih0LGUpe2NvbnN0IHI9ZT95Om07bGV0IG49XCJcIix7c2NoZW1lOmksYXV0aG9yaXR5Om8scGF0aDpzLHF1ZXJ5OmgsZnJhZ21lbnQ6YX09dDtpZihpJiYobis9aSxuKz1cIjpcIiksKG98fFwiZmlsZVwiPT09aSkmJihuKz1mLG4rPWYpLG8pe2xldCB0PW8uaW5kZXhPZihcIkBcIik7aWYoLTEhPT10KXtjb25zdCBlPW8uc3Vic3RyKDAsdCk7bz1vLnN1YnN0cih0KzEpLHQ9ZS5sYXN0SW5kZXhPZihcIjpcIiksLTE9PT10P24rPXIoZSwhMSwhMSk6KG4rPXIoZS5zdWJzdHIoMCx0KSwhMSwhMSksbis9XCI6XCIsbis9cihlLnN1YnN0cih0KzEpLCExLCEwKSksbis9XCJAXCJ9bz1vLnRvTG93ZXJDYXNlKCksdD1vLmxhc3RJbmRleE9mKFwiOlwiKSwtMT09PXQ/bis9cihvLCExLCEwKToobis9cihvLnN1YnN0cigwLHQpLCExLCEwKSxuKz1vLnN1YnN0cih0KSl9aWYocyl7aWYocy5sZW5ndGg+PTMmJjQ3PT09cy5jaGFyQ29kZUF0KDApJiY1OD09PXMuY2hhckNvZGVBdCgyKSl7Y29uc3QgdD1zLmNoYXJDb2RlQXQoMSk7dD49NjUmJnQ8PTkwJiYocz1gLyR7U3RyaW5nLmZyb21DaGFyQ29kZSh0KzMyKX06JHtzLnN1YnN0cigzKX1gKX1lbHNlIGlmKHMubGVuZ3RoPj0yJiY1OD09PXMuY2hhckNvZGVBdCgxKSl7Y29uc3QgdD1zLmNoYXJDb2RlQXQoMCk7dD49NjUmJnQ8PTkwJiYocz1gJHtTdHJpbmcuZnJvbUNoYXJDb2RlKHQrMzIpfToke3Muc3Vic3RyKDIpfWApfW4rPXIocywhMCwhMSl9cmV0dXJuIGgmJihuKz1cIj9cIixuKz1yKGgsITEsITEpKSxhJiYobis9XCIjXCIsbis9ZT9hOm0oYSwhMSwhMSkpLG59ZnVuY3Rpb24gQyh0KXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0KX1jYXRjaHtyZXR1cm4gdC5sZW5ndGg+Mz90LnN1YnN0cigwLDMpK0ModC5zdWJzdHIoMykpOnR9fWNvbnN0IEE9LyglWzAtOUEtWmEtel1bMC05QS1aYS16XSkrL2c7ZnVuY3Rpb24gdyh0KXtyZXR1cm4gdC5tYXRjaChBKT90LnJlcGxhY2UoQSwodD0+Qyh0KSkpOnR9dmFyIHg9cig5NzUpO2NvbnN0IFA9eC5wb3NpeHx8eCxfPVwiL1wiO3ZhciBJOyFmdW5jdGlvbih0KXt0LmpvaW5QYXRoPWZ1bmN0aW9uKHQsLi4uZSl7cmV0dXJuIHQud2l0aCh7cGF0aDpQLmpvaW4odC5wYXRoLC4uLmUpfSl9LHQucmVzb2x2ZVBhdGg9ZnVuY3Rpb24odCwuLi5lKXtsZXQgcj10LnBhdGgsbj0hMTtyWzBdIT09XyYmKHI9XytyLG49ITApO2xldCBpPVAucmVzb2x2ZShyLC4uLmUpO3JldHVybiBuJiZpWzBdPT09XyYmIXQuYXV0aG9yaXR5JiYoaT1pLnN1YnN0cmluZygxKSksdC53aXRoKHtwYXRoOml9KX0sdC5kaXJuYW1lPWZ1bmN0aW9uKHQpe2lmKDA9PT10LnBhdGgubGVuZ3RofHx0LnBhdGg9PT1fKXJldHVybiB0O2xldCBlPVAuZGlybmFtZSh0LnBhdGgpO3JldHVybiAxPT09ZS5sZW5ndGgmJjQ2PT09ZS5jaGFyQ29kZUF0KDApJiYoZT1cIlwiKSx0LndpdGgoe3BhdGg6ZX0pfSx0LmJhc2VuYW1lPWZ1bmN0aW9uKHQpe3JldHVybiBQLmJhc2VuYW1lKHQucGF0aCl9LHQuZXh0bmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gUC5leHRuYW1lKHQucGF0aCl9fShJfHwoST17fSkpLExJQj1ufSkoKTtjb25zdHtVUkk6IGxhbmd1YWdlX2NsaWVudF9VUkksVXRpbHN9PUxJQjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZXJ2aWNlcy9sYW5ndWFnZS1jbGllbnQudHNcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcbmZ1bmN0aW9uIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5cblxuXG5cbmNsYXNzIExhbmd1YWdlQ2xpZW50IGV4dGVuZHMgYmFzZV9zZXJ2aWNlLkJhc2VTZXJ2aWNlIHtcbiAgICAkY29ubmVjdCgpIHtcbiAgICAgICAgc3dpdGNoKHRoaXMuc2VydmVyRGF0YS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWJ3b3JrZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAoJ3dvcmtlcicgaW4gdGhpcy5zZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNvbm5lY3RXb3JrZXIodGhpcy5zZXJ2ZXJEYXRhLndvcmtlciwgdGhpcy5zZXJ2ZXJEYXRhLmluaXRpYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gd29ya2VyIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzb2NrZXRcIjpcbiAgICAgICAgICAgICAgICBpZiAoJ3NvY2tldCcgaW4gdGhpcy5zZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gdGhpcy5zZXJ2ZXJEYXRhLnNvY2tldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY29ubmVjdFNvY2tldCh0aGlzLnNlcnZlckRhdGEuaW5pdGlhbGl6YXRpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzb2NrZXRVcmwgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNlcnZlciB0eXBlOiBcIiArIHRoaXMuc2VydmVyRGF0YS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAkY29ubmVjdFNvY2tldChpbml0aWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgbGlzdGVuKHtcbiAgICAgICAgICAgIHdlYlNvY2tldDogdGhpcy5zb2NrZXQsXG4gICAgICAgICAgICBvbkNvbm5lY3Rpb246IChjb25uZWN0aW9uKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuJGluaXRDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGluaXRpYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHRoaXMuc29ja2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIH1cbiAgICAkY29ubmVjdFdvcmtlcih3b3JrZXIsIGluaXRpYWxpemF0aW9uT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gKDAsYnJvd3Nlci5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24pKG5ldyBicm93c2VyLkJyb3dzZXJNZXNzYWdlUmVhZGVyKHdvcmtlciksIG5ldyBicm93c2VyLkJyb3dzZXJNZXNzYWdlV3JpdGVyKHdvcmtlcikpO1xuICAgICAgICB0aGlzLiRpbml0Q29ubmVjdGlvbihjb25uZWN0aW9uLCBpbml0aWFsaXphdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICAkaW5pdENvbm5lY3Rpb24oY29ubmVjdGlvbiwgaW5pdGlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIGNvbm5lY3Rpb24ubGlzdGVuKCk7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLnNlbmRJbml0aWFsaXplKGluaXRpYWxpemF0aW9uT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L3B1Ymxpc2hEaWFnbm9zdGljcycsIChyZXN1bHQpPT57XG4gICAgICAgICAgICBsZXQgcG9zdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IE1lc3NhZ2VUeXBlLnZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIFwiZG9jdW1lbnRVcmlcIjogcmVzdWx0LnVyaSxcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHJlc3VsdC5kaWFnbm9zdGljc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnBvc3RNZXNzYWdlKHBvc3RNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbignd2luZG93L3Nob3dNZXNzYWdlJywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIHRoaXMuc2hvd0xvZyhwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uTm90aWZpY2F0aW9uKCd3aW5kb3cvbG9nTWVzc2FnZScsIChwYXJhbXMpPT57XG4gICAgICAgICAgICB0aGlzLnNob3dMb2cocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbk5vdGlmaWNhdGlvbignJC9sb2dUcmFjZScsIChwYXJhbXMpPT57XG4gICAgICAgICAgICB0aGlzLnNob3dUcmFjZShwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uUmVxdWVzdCgnd2luZG93L3Nob3dNZXNzYWdlUmVxdWVzdCcsIChwYXJhbXMpPT57XG4gICAgICAgICAgICB0aGlzLnNob3dMb2cocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vblJlcXVlc3QoJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmxvZyhwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uUmVxdWVzdCgnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eScsIChwYXJhbXMpPT57XG4gICAgICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS5sb2cocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vblJlcXVlc3QoJ3dvcmtzcGFjZS9hcHBseUVkaXQnLCBhc3luYyAocGFyYW1zKT0+e1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2NhbGxiYWNrSWRdID0gKHJlc3VsdCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hcHBsaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHJlc3VsdC5mYWlsdXJlUmVhc29uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBwb3N0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IE1lc3NhZ2VUeXBlLmFwcGx5RWRpdCxcbiAgICAgICAgICAgICAgICAgICAgXCJzZXJ2aWNlTmFtZVwiOiB0aGlzLnNlcnZpY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHBhcmFtcy5lZGl0LFxuICAgICAgICAgICAgICAgICAgICBcImNhbGxiYWNrSWRcIjogY2FsbGJhY2tJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jdHgucG9zdE1lc3NhZ2UocG9zdE1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25SZXF1ZXN0KCd3aW5kb3cvc2hvd0RvY3VtZW50JywgKHBhcmFtcyk9PntcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tjYWxsYmFja0lkXSA9IChyZXN1bHQpPT57XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBwb3N0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IE1lc3NhZ2VUeXBlLnNob3dEb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgXCJzZXJ2aWNlTmFtZVwiOiB0aGlzLnNlcnZpY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnBvc3RNZXNzYWdlKHBvc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uRXJyb3IoKGUpPT57XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uQ2xvc2UoKCk9PntcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jICRyZWNvbm5lY3QoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5kb2N1bWVudHMpLmZvckVhY2goKGRvY3VtZW50KT0+dGhpcy5yZW1vdmVEb2N1bWVudChkb2N1bWVudCkpO1xuICAgICAgICBhd2FpdCB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy4kY29ubmVjdCgpO1xuICAgIH1cbiAgICBzZW5kQXBwbGllZFJlc3VsdChyZXN1bHQsIGNhbGxiYWNrSWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkIHx8ICF0aGlzLmNhbGxiYWNrc1tjYWxsYmFja0lkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2NhbGxiYWNrSWRdKHJlc3VsdCk7XG4gICAgfVxuICAgIHNlbmRSZXNwb25zZShjYWxsYmFja0lkLCBhcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCB8fCAhdGhpcy5jYWxsYmFja3NbY2FsbGJhY2tJZF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrc1tjYWxsYmFja0lkXShhcmdzKTtcbiAgICB9XG4gICAgc2hvd0xvZyhwYXJhbXMpIHtcbiAgICAgICAgc3dpdGNoKHBhcmFtcy50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS5lcnJvcihwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUud2FybihwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUuaW5mbyhwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmxvZyhwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvd1RyYWNlKHBhcmFtcykge1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfY29uc29sZS5sb2cocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBpZiAocGFyYW1zLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGxhbmd1YWdlX2NsaWVudF9jb25zb2xlLmxvZyhwYXJhbXMudmVyYm9zZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIuYWRkRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiBkb2N1bWVudFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVucXVldWVJZk5vdENvbm5lY3RlZCgoKT0+dGhpcy5jb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oJ3RleHREb2N1bWVudC9kaWRPcGVuJywgdGV4dERvY3VtZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICBlbnF1ZXVlSWZOb3RDb25uZWN0ZWQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkIHx8ICF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLmVucXVldWVJZk5vdENvbm5lY3RlZCgoKT0+dGhpcy5jb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oJ3RleHREb2N1bWVudC9kaWRDbG9zZScsIHtcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgIHZhciBfdGhpc19jb25uZWN0aW9uO1xuICAgICAgICAoX3RoaXNfY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbikgPT09IG51bGwgfHwgX3RoaXNfY29ubmVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfY29ubmVjdGlvbi5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24pIHJldHVybjtcbiAgICAgICAgYXdhaXQgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdChcInNodXRkb3duXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbignZXhpdCcpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgc2VuZEluaXRpYWxpemUoaW5pdGlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiB0aGlzLmNsaWVudENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uT3B0aW9uczogaW5pdGlhbGl6YXRpb25PcHRpb25zLFxuICAgICAgICAgICAgcHJvY2Vzc0lkOiBudWxsLFxuICAgICAgICAgICAgcm9vdFVyaTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy53b3Jrc3BhY2VVcmkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uud29ya3NwYWNlRm9sZGVycyA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtzcGFjZUZvbGRlclxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoXCJpbml0aWFsaXplXCIsIG1lc3NhZ2UpLnRoZW4oKHBhcmFtcyk9PntcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMgPSBwYXJhbXMuY2FwYWJpbGl0aWVzO1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZU5hbWUgPSB0aGlzLnNlcnZpY2VOYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5kb2N1bWVudHMpLmZvckVhY2goKGRvY3VtZW50VXJpKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogTWVzc2FnZVR5cGUuY2FwYWJpbGl0aWVzQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZXJ2aWNlTmFtZV06IHRoaXMuc2VydmljZUNhcGFiaWxpdGllc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFVyaTogZG9jdW1lbnRVcmlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnBvc3RNZXNzYWdlKHBvc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oJ2luaXRpYWxpemVkJykudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKCd3b3Jrc3BhY2UvZGlkQ2hhbmdlQ29uZmlndXJhdGlvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1F1ZXVlLmZvckVhY2goKHJlcXVlc3RDYWxsYmFjayk9PnJlcXVlc3RDYWxsYmFjaygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzUXVldWUgPSBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzMTtcbiAgICAgICAgc3VwZXIuYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkIHx8ICF0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMpID09PSBicm93c2VyX21haW4uVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMxID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllczEudGV4dERvY3VtZW50U3luYykgIT09IGJyb3dzZXJfbWFpbi5UZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0VmFsdWUoaWRlbnRpZmllciwgdGhpcy5nZXREb2N1bWVudChpZGVudGlmaWVyLnVyaSkuZ2V0VGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnRDaGFuZ2UgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGlkZW50aWZpZXIudXJpLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGlkZW50aWZpZXIudmVyc2lvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnRDaGFuZ2VzOiBkZWx0YXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnLCB0ZXh0RG9jdW1lbnRDaGFuZ2UpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcztcbiAgICAgICAgc3VwZXIuc2V0VmFsdWUoaWRlbnRpZmllciwgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMpID09PSBicm93c2VyX21haW4uVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudENoYW5nZSA9IHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIHVyaTogaWRlbnRpZmllci51cmksXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogaWRlbnRpZmllci52ZXJzaW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudENoYW5nZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbigndGV4dERvY3VtZW50L2RpZENoYW5nZScsIHRleHREb2N1bWVudENoYW5nZSk7XG4gICAgfVxuICAgIGFzeW5jIGRvSG92ZXIoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuaG92ZXJQcm92aWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L2hvdmVyJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd0ZXh0RG9jdW1lbnQvY29tcGxldGlvbicsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkb0lubGluZUNvbXBsZXRlKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLmlubGluZUNvbXBsZXRpb25Qcm92aWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmksXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZlcnNpb246IGRvY3VtZW50LnZlcnNpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcktpbmQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L2lubGluZUNvbXBsZXRpb24nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgdmFyIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfY29tcGxldGlvblByb3ZpZGVyLCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc19jb21wbGV0aW9uUHJvdmlkZXIgPSBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlcikgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllc19jb21wbGV0aW9uUHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfY29tcGxldGlvblByb3ZpZGVyLnJlc29sdmVQcm92aWRlcikpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCdjb21wbGV0aW9uSXRlbS9yZXNvbHZlJywgaXRlbVtcIml0ZW1cIl0pO1xuICAgIH1cbiAgICBhc3luYyBkb1ZhbGlkYXRpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgLy9UT0RPOiB0ZXh0RG9jdW1lbnQvZGlhZ25vc3RpYyBjYXBhYmlsaXR5XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgYXN5bmMgZm9ybWF0KGRvY3VtZW50LCByYW5nZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzICYmICh0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMuZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQcm92aWRlciB8fCB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMuZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZm9ybWF0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L2Zvcm1hdHRpbmcnLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZm9ybWF0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3RleHREb2N1bWVudC9yYW5nZUZvcm1hdHRpbmcnLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIuc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY29uZmlnQ2hhbmdlcyA9IHtcbiAgICAgICAgICAgIHNldHRpbmdzOiBvcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5xdWV1ZUlmTm90Q29ubmVjdGVkKCgpPT50aGlzLmNvbm5lY3Rpb24uc2VuZE5vdGlmaWNhdGlvbignd29ya3NwYWNlL2RpZENoYW5nZUNvbmZpZ3VyYXRpb24nLCBjb25maWdDaGFuZ2VzKSk7XG4gICAgfVxuICAgIHNldFdvcmtzcGFjZSh3b3Jrc3BhY2VVcmkpIHtcbiAgICAgICAgdmFyIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlX3dvcmtzcGFjZUZvbGRlcnMsIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlLCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBzdXBlci5zZXRXb3Jrc3BhY2Uod29ya3NwYWNlVXJpKTtcbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX3dvcmtzcGFjZSA9IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMud29ya3NwYWNlKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX3dvcmtzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlX3dvcmtzcGFjZUZvbGRlcnMgPSBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX3dvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX3dvcmtzcGFjZV93b3Jrc3BhY2VGb2xkZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX3dvcmtzcGFjZV93b3Jrc3BhY2VGb2xkZXJzLmNoYW5nZU5vdGlmaWNhdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGFkZGVkOiBbXG4gICAgICAgICAgICAgICAgdGhpcy53b3Jrc3BhY2VGb2xkZXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZW1vdmVkOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRSZXF1ZXN0KCd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycycsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBnZXQgd29ya3NwYWNlRm9sZGVyKCkge1xuICAgICAgICBsZXQgd29ya3NwYWNlVXJpID0gdGhpcy53b3Jrc3BhY2VVcmk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmk6IGxhbmd1YWdlX2NsaWVudF9VUkkuZmlsZSh3b3Jrc3BhY2VVcmkpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBuYW1lOiB3b3Jrc3BhY2VVcmkuc3BsaXQoXCIvXCIpLnBvcCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGZpbmREb2N1bWVudEhpZ2hsaWdodHMoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy5kb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyKSkgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3RleHREb2N1bWVudC9kb2N1bWVudEhpZ2hsaWdodCcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwcm92aWRlU2lnbmF0dXJlSGVscChkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoKF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPSB0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMuc2lnbmF0dXJlSGVscFByb3ZpZGVyKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L3NpZ25hdHVyZUhlbHAnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VtYW50aWNUb2tlbnMoZG9jdW1lbnQsIHJhbmdlKSB7XG4gICAgICAgIHZhciBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID0gdGhpcy5zZXJ2aWNlQ2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzLnNlbWFudGljVG9rZW5zUHJvdmlkZXIpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2VDYXBhYmlsaXRpZXMuc2VtYW50aWNUb2tlbnNQcm92aWRlci5yYW5nZSkge1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHVyaTogZG9jdW1lbnQudXJpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3RleHREb2N1bWVudC9zZW1hbnRpY1Rva2Vucy9mdWxsJywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBkb2N1bWVudC51cmlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QoJ3RleHREb2N1bWVudC9zZW1hbnRpY1Rva2Vucy9yYW5nZScsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldENvZGVBY3Rpb25zKGRvY3VtZW50LCByYW5nZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy5jb2RlQWN0aW9uUHJvdmlkZXIpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGRvY3VtZW50LnVyaVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgndGV4dERvY3VtZW50L2NvZGVBY3Rpb24nLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZXhlY3V0ZUNvbW1hbmQoY29tbWFuZCwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcywgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllczE7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICBpZiAoISgoX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcy5leGVjdXRlQ29tbWFuZFByb3ZpZGVyKSB8fCAhKChfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzMSA9IHRoaXMuc2VydmljZUNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX3RoaXNfc2VydmljZUNhcGFiaWxpdGllczEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMxLmV4ZWN1dGVDb21tYW5kUHJvdmlkZXIuY29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdCgnd29ya3NwYWNlL2V4ZWN1dGVDb21tYW5kJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBjdXN0b20gcmVxdWVzdCB0byB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi8gc2VuZFJlcXVlc3QobmFtZSwgYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZFJlcXVlc3QobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kUmVxdWVzdChuYW1lLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VydmVyRGF0YSwgY3R4LCB3b3Jrc3BhY2VVcmkpe1xuICAgICAgICBzdXBlcihzZXJ2ZXJEYXRhLm1vZGVzLCB3b3Jrc3BhY2VVcmkpO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiJHNlcnZpY2VcIiwgdm9pZCAwKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImlzQ29ubmVjdGVkXCIsIGZhbHNlKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImlzSW5pdGlhbGl6ZWRcIiwgZmFsc2UpO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic29ja2V0XCIsIHZvaWQgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjb25uZWN0aW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJyZXF1ZXN0c1F1ZXVlXCIsIFtdKTtcbiAgICAgICAgbGFuZ3VhZ2VfY2xpZW50X2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrSWRcIiwgMCk7XG4gICAgICAgIGxhbmd1YWdlX2NsaWVudF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJjYWxsYmFja3NcIiwge30pO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwic2VydmVyRGF0YVwiLCB2b2lkIDApO1xuICAgICAgICBsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY3R4XCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLnNlcnZlckRhdGEgPSBzZXJ2ZXJEYXRhO1xuICAgICAgICB0aGlzLiRjb25uZWN0KCk7XG4gICAgfVxufVxuXG59KSgpO1xuXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiYSIsImkiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsInByb2Nlc3MiLCJjb25zb2xlIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX3JlcXVpcmUiLCJfcmVxdWlyZSRjb2RlcyIsImNvZGVzIiwiRVJSX0FNQklHVU9VU19BUkdVTUVOVCIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiRVJSX0lOVkFMSURfQVJHX1ZBTFVFIiwiRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFIiwiRVJSX01JU1NJTkdfQVJHUyIsIkFzc2VydGlvbkVycm9yIiwiX3JlcXVpcmUyIiwiaW5zcGVjdCIsIl9yZXF1aXJlJHR5cGVzIiwidHlwZXMiLCJpc1Byb21pc2UiLCJpc1JlZ0V4cCIsIm9iamVjdEFzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsIm9iamVjdElzIiwiaXMiLCJlcnJvckNhY2hlIiwiTWFwIiwiaXNEZWVwRXF1YWwiLCJpc0RlZXBTdHJpY3RFcXVhbCIsInBhcnNlRXhwcmVzc2lvbkF0IiwiZmluZE5vZGVBcm91bmQiLCJkZWNvZGVyIiwibGF6eUxvYWRDb21wYXJpc29uIiwiY29tcGFyaXNvbiIsImVzY2FwZVNlcXVlbmNlc1JlZ0V4cCIsIm1ldGEiLCJlc2NhcGVGbiIsInN0ciIsImNoYXJDb2RlQXQiLCJ3YXJuZWQiLCJhc3NlcnQiLCJvayIsIk5PX0VYQ0VQVElPTl9TRU5USU5FTCIsImlubmVyRmFpbCIsIm1lc3NhZ2UiLCJFcnJvciIsImZhaWwiLCJhY3R1YWwiLCJleHBlY3RlZCIsIm9wZXJhdG9yIiwic3RhY2tTdGFydEZuIiwiYXJnc0xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImludGVybmFsTWVzc2FnZSIsInVuZGVmaW5lZCIsIndhcm4iLCJlbWl0V2FybmluZyIsImJpbmQiLCJlcnJBcmdzIiwiZXJyIiwiZ2VuZXJhdGVkTWVzc2FnZSIsImlubmVyT2siLCJmbiIsImFyZ0xlbiIsInZhbHVlIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsImNvbmNhdCIsImVxdWFsIiwibm90RXF1YWwiLCJkZWVwRXF1YWwiLCJub3REZWVwRXF1YWwiLCJkZWVwU3RyaWN0RXF1YWwiLCJub3REZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3RFcXVhbCIsIm5vdFN0cmljdEVxdWFsIiwiQ29tcGFyaXNvbiIsImtleXMiLCJfdGhpcyIsImZvckVhY2giLCJrZXkiLCJ0ZXN0IiwiY29tcGFyZUV4Y2VwdGlvbktleSIsImIiLCJuYW1lIiwiZXhwZWN0ZWRFeGNlcHRpb24iLCJtc2ciLCJwdXNoIiwiaXNQcm90b3R5cGVPZiIsImNhbGwiLCJnZXRBY3R1YWwiLCJlIiwiY2hlY2tJc1Byb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJ3YWl0Rm9yQWN0dWFsIiwicHJvbWlzZUZuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXN1bHRQcm9taXNlIiwiZXhwZWN0c0Vycm9yIiwiZXJyb3IiLCJkZXRhaWxzIiwiZm5UeXBlIiwiZXhwZWN0c05vRXJyb3IiLCJ0aHJvd3MiLCJfbGVuMiIsIl9rZXkyIiwicmVqZWN0cyIsIl9sZW4zIiwiX2tleTMiLCJyZXN1bHQiLCJkb2VzTm90VGhyb3ciLCJfbGVuNCIsIl9rZXk0IiwiZG9lc05vdFJlamVjdCIsIl9sZW41IiwiX2tleTUiLCJpZkVycm9yIiwibmV3RXJyIiwib3JpZ1N0YWNrIiwic3RhY2siLCJ0bXAyIiwic3BsaXQiLCJzaGlmdCIsInRtcDEiLCJwb3MiLCJpbmRleE9mIiwic2xpY2UiLCJqb2luIiwic3RyaWN0IiwiX2xlbjYiLCJfa2V5NiIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl93cmFwTmF0aXZlU3VwZXIiLCJDbGFzcyIsIl9jYWNoZSIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiaGFzIiwiZ2V0Iiwic2V0IiwiV3JhcHBlciIsIl9jb25zdHJ1Y3QiLCJfZ2V0UHJvdG90eXBlT2YiLCJpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiRGF0ZSIsInRvU3RyaW5nIiwiUGFyZW50IiwiRnVuY3Rpb24iLCJvIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiZ2V0UHJvdG90eXBlT2YiLCJlbmRzV2l0aCIsInNlYXJjaCIsInRoaXNfbGVuIiwic3Vic3RyaW5nIiwicmVwZWF0IiwiY291bnQiLCJNYXRoIiwiZmxvb3IiLCJtYXhDb3VudCIsImxvZyIsImJsdWUiLCJncmVlbiIsInJlZCIsIndoaXRlIiwia1JlYWRhYmxlT3BlcmF0b3IiLCJzdHJpY3RFcXVhbE9iamVjdCIsIm5vdFN0cmljdEVxdWFsT2JqZWN0Iiwibm90SWRlbnRpY2FsIiwia01heFNob3J0TGVuZ3RoIiwiY29weUVycm9yIiwiaW5zcGVjdFZhbHVlIiwidmFsIiwiY29tcGFjdCIsImN1c3RvbUluc3BlY3QiLCJkZXB0aCIsIm1heEFycmF5TGVuZ3RoIiwiSW5maW5pdHkiLCJzaG93SGlkZGVuIiwiYnJlYWtMZW5ndGgiLCJzaG93UHJveHkiLCJzb3J0ZWQiLCJnZXR0ZXJzIiwiY3JlYXRlRXJyRGlmZiIsIm90aGVyIiwicmVzIiwibGFzdFBvcyIsImVuZCIsInNraXBwZWQiLCJhY3R1YWxJbnNwZWN0ZWQiLCJhY3R1YWxMaW5lcyIsImV4cGVjdGVkTGluZXMiLCJpbmRpY2F0b3IiLCJpbnB1dExlbmd0aCIsIm1heExlbmd0aCIsInN0ZGVyciIsImlzVFRZIiwiY29sdW1ucyIsInBvcCIsIm1heExpbmVzIiwibWF4IiwiX2FjdHVhbExpbmVzIiwicHJpbnRlZExpbmVzIiwic2tpcHBlZE1zZyIsImN1ciIsImV4cGVjdGVkTGluZSIsImFjdHVhbExpbmUiLCJkaXZlcmdpbmdMaW5lcyIsIl9FcnJvciIsIm9wdGlvbnMiLCJsaW1pdCIsInN0YWNrVHJhY2VMaW1pdCIsIlN0cmluZyIsImdldENvbG9yRGVwdGgiLCJiYXNlIiwiX3JlcyIsImtub3duT3BlcmF0b3JzIiwiY29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiY3VzdG9tIiwicmVjdXJzZVRpbWVzIiwiY3R4IiwidXRpbCIsImNyZWF0ZUVycm9yVHlwZSIsIkJhc2UiLCJnZXRNZXNzYWdlIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiTm9kZUVycm9yIiwiX0Jhc2UiLCJvbmVPZiIsInRoaW5nIiwiaXNBcnJheSIsImxlbiIsIm1hcCIsInN0YXJ0c1dpdGgiLCJzdWJzdHIiLCJpbmNsdWRlcyIsInN0YXJ0IiwiZGV0ZXJtaW5lciIsInJlcGxhY2UiLCJ0eXBlIiwicmVhc29uIiwiaW5zcGVjdGVkIiwiUmFuZ2VFcnJvciIsImlucHV0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiX3MiLCJuZXh0IiwiZG9uZSIsInJlZ2V4RmxhZ3NTdXBwb3J0ZWQiLCJmbGFncyIsImFycmF5RnJvbVNldCIsImFycmF5IiwiYXJyYXlGcm9tTWFwIiwib2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzIiwibnVtYmVySXNOYU4iLCJOdW1iZXIiLCJpc05hTiIsInVuY3VycnlUaGlzIiwiZiIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJvYmplY3RUb1N0cmluZyIsImlzQW55QXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyVmlldyIsImlzRGF0ZSIsImlzTWFwIiwiaXNTZXQiLCJpc05hdGl2ZUVycm9yIiwiaXNCb3hlZFByaW1pdGl2ZSIsImlzTnVtYmVyT2JqZWN0IiwiaXNTdHJpbmdPYmplY3QiLCJpc0Jvb2xlYW5PYmplY3QiLCJpc0JpZ0ludE9iamVjdCIsImlzU3ltYm9sT2JqZWN0IiwiaXNGbG9hdDMyQXJyYXkiLCJpc0Zsb2F0NjRBcnJheSIsImlzTm9uSW5kZXgiLCJwb3ciLCJnZXRPd25Ob25JbmRleFByb3BlcnRpZXMiLCJjb21wYXJlIiwieCIsInkiLCJtaW4iLCJPTkxZX0VOVU1FUkFCTEUiLCJrU3RyaWN0Iiwia0xvb3NlIiwia05vSXRlcmF0b3IiLCJrSXNBcnJheSIsImtJc1NldCIsImtJc01hcCIsImFyZVNpbWlsYXJSZWdFeHBzIiwiUmVnRXhwIiwiYXJlU2ltaWxhckZsb2F0QXJyYXlzIiwiYnl0ZUxlbmd0aCIsIm9mZnNldCIsImFyZVNpbWlsYXJUeXBlZEFycmF5cyIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYXJlRXF1YWxBcnJheUJ1ZmZlcnMiLCJidWYxIiwiYnVmMiIsImlzRXF1YWxCb3hlZFByaW1pdGl2ZSIsInZhbDEiLCJ2YWwyIiwidmFsdWVPZiIsIkJvb2xlYW4iLCJCaWdJbnQiLCJpbm5lckRlZXBFcXVhbCIsIm1lbW9zIiwidmFsMVRhZyIsInZhbDJUYWciLCJrZXlzMSIsImtleXMyIiwia2V5Q2hlY2siLCJnZXRUaW1lIiwiX2tleXMiLCJfa2V5czIiLCJzaXplIiwiZ2V0RW51bWVyYWJsZXMiLCJrIiwiaXRlcmF0aW9uVHlwZSIsImFLZXlzIiwiYktleXMiLCJzeW1ib2xLZXlzQSIsInN5bWJvbEtleXNCIiwiX3N5bWJvbEtleXNCIiwicG9zaXRpb24iLCJ2YWwyTWVtb0EiLCJ2YWwyTWVtb0IiLCJhcmVFcSIsIm9iakVxdWl2IiwiZGVsZXRlIiwic2V0SGFzRXF1YWxFbGVtZW50IiwibWVtbyIsInNldFZhbHVlcyIsImZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyIsInByaW0iLCJzZXRNaWdodEhhdmVMb29zZVByaW0iLCJhbHRWYWx1ZSIsIm1hcE1pZ2h0SGF2ZUxvb3NlUHJpbSIsIml0ZW0iLCJjdXJCIiwic2V0RXF1aXYiLCJhVmFsdWVzIiwiU2V0IiwiYWRkIiwiYlZhbHVlcyIsIl92YWwiLCJtYXBIYXNFcXVhbEVudHJ5Iiwia2V5MSIsIml0ZW0xIiwia2V5MiIsIm1hcEVxdWl2IiwiYUVudHJpZXMiLCJfYUVudHJpZXMkaSIsIml0ZW0yIiwiYkVudHJpZXMiLCJfaTIiLCJfYkVudHJpZXMkX2kiLCJrZXlzQSIsIkdldEludHJpbnNpYyIsImNhbGxCaW5kIiwiJGluZGV4T2YiLCJjYWxsQm91bmRJbnRyaW5zaWMiLCJhbGxvd01pc3NpbmciLCJpbnRyaW5zaWMiLCJzZXRGdW5jdGlvbkxlbmd0aCIsIiRUeXBlRXJyb3IiLCIkYXBwbHkiLCIkY2FsbCIsIiRyZWZsZWN0QXBwbHkiLCIkZGVmaW5lUHJvcGVydHkiLCIkbWF4Iiwib3JpZ2luYWxGdW5jdGlvbiIsImZ1bmMiLCJhcHBseUJpbmQiLCJub3ciLCJ0aW1lcyIsImciLCJ3aW5kb3ciLCJmdW5jdGlvbnMiLCJpbmZvIiwidGltZSIsInRpbWVFbmQiLCJ0cmFjZSIsImRpciIsImNvbnNvbGVBc3NlcnQiLCJ0dXBsZSIsImxhYmVsIiwiZHVyYXRpb24iLCJmb3JtYXQiLCJvYmplY3QiLCJleHByZXNzaW9uIiwiJFN5bnRheEVycm9yIiwiZ29wZCIsImRlZmluZURhdGFQcm9wZXJ0eSIsInByb3BlcnR5Iiwibm9uRW51bWVyYWJsZSIsIm5vbldyaXRhYmxlIiwibm9uQ29uZmlndXJhYmxlIiwibG9vc2UiLCJkZXNjIiwiaGFzU3ltYm9scyIsInRvU3RyIiwiaXNGdW5jdGlvbiIsInN1cHBvcnRzRGVzY3JpcHRvcnMiLCJwcmVkaWNhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJlZGljYXRlcyIsIkV2YWxFcnJvciIsIlN5bnRheEVycm9yIiwiVVJJRXJyb3IiLCJmaXJzdFNvdXJjZSIsInRvIiwibmV4dFNvdXJjZSIsImtleXNBcnJheSIsIm5leHRJbmRleCIsIm5leHRLZXkiLCJwb2x5ZmlsbCIsImlzQ2FsbGFibGUiLCJmb3JFYWNoQXJyYXkiLCJyZWNlaXZlciIsImZvckVhY2hTdHJpbmciLCJzdHJpbmciLCJjaGFyQXQiLCJmb3JFYWNoT2JqZWN0IiwibGlzdCIsInRoaXNBcmciLCJFUlJPUl9NRVNTQUdFIiwiZnVuY1R5cGUiLCJjb25jYXR0eSIsImoiLCJzbGljeSIsImFyckxpa2UiLCJqb2lueSIsImpvaW5lciIsInRoYXQiLCJib3VuZCIsImJpbmRlciIsImJvdW5kTGVuZ3RoIiwiYm91bmRBcmdzIiwiRW1wdHkiLCJpbXBsZW1lbnRhdGlvbiIsIiRFcnJvciIsIiRFdmFsRXJyb3IiLCIkUmFuZ2VFcnJvciIsIiRSZWZlcmVuY2VFcnJvciIsIiRVUklFcnJvciIsIiRGdW5jdGlvbiIsImdldEV2YWxsZWRDb25zdHJ1Y3RvciIsImV4cHJlc3Npb25TeW50YXgiLCIkZ09QRCIsInRocm93VHlwZUVycm9yIiwiVGhyb3dUeXBlRXJyb3IiLCJjYWxsZWUiLCJjYWxsZWVUaHJvd3MiLCJnT1BEdGhyb3dzIiwiaGFzUHJvdG8iLCJnZXRQcm90byIsIm5lZWRzRXZhbCIsIlR5cGVkQXJyYXkiLCJJTlRSSU5TSUNTIiwiQWdncmVnYXRlRXJyb3IiLCJBcnJheUJ1ZmZlciIsIkF0b21pY3MiLCJCaWdJbnQ2NEFycmF5IiwiQmlnVWludDY0QXJyYXkiLCJEYXRhVmlldyIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsImV2YWwiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiaXNGaW5pdGUiLCJKU09OIiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJXZWFrTWFwIiwiV2Vha1JlZiIsIldlYWtTZXQiLCJlcnJvclByb3RvIiwiZG9FdmFsIiwiZ2VuIiwiTEVHQUNZX0FMSUFTRVMiLCJoYXNPd24iLCIkY29uY2F0IiwiJHNwbGljZUFwcGx5Iiwic3BsaWNlIiwiJHJlcGxhY2UiLCIkc3RyU2xpY2UiLCIkZXhlYyIsImV4ZWMiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwic3RyaW5nVG9QYXRoIiwiZmlyc3QiLCJsYXN0IiwibWF0Y2giLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImdldEJhc2VJbnRyaW5zaWMiLCJpbnRyaW5zaWNOYW1lIiwiYWxpYXMiLCJwYXJ0cyIsImludHJpbnNpY0Jhc2VOYW1lIiwiaW50cmluc2ljUmVhbE5hbWUiLCJza2lwRnVydGhlckNhY2hpbmciLCJpc093biIsInBhcnQiLCJoYXNQcm9wZXJ0eURlc2NyaXB0b3JzIiwiaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWciLCJmb28iLCIkT2JqZWN0Iiwib3JpZ1N5bWJvbCIsImhhc1N5bWJvbFNoYW0iLCJoYXNOYXRpdmVTeW1ib2xzIiwic3ltT2JqIiwic3ltVmFsIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInN5bXMiLCJoYXNUb1N0cmluZ1RhZ1NoYW1zIiwidG9TdHJpbmdUYWciLCIkaGFzT3duIiwiaW5oZXJpdHMiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJoYXNUb1N0cmluZ1RhZyIsImNhbGxCb3VuZCIsIiR0b1N0cmluZyIsImlzU3RhbmRhcmRBcmd1bWVudHMiLCJpc0FyZ3VtZW50cyIsImlzTGVnYWN5QXJndW1lbnRzIiwic3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyIsImZuVG9TdHIiLCJyZWZsZWN0QXBwbHkiLCJiYWRBcnJheUxpa2UiLCJpc0NhbGxhYmxlTWFya2VyIiwiXyIsImNvbnN0cnVjdG9yUmVnZXgiLCJpc0VTNkNsYXNzRm4iLCJpc0VTNkNsYXNzRnVuY3Rpb24iLCJmblN0ciIsInRyeUZ1bmN0aW9uT2JqZWN0IiwidHJ5RnVuY3Rpb25Ub1N0ciIsIm9iamVjdENsYXNzIiwiZm5DbGFzcyIsImdlbkNsYXNzIiwiZGRhQ2xhc3MiLCJkZGFDbGFzczIiLCJkZGFDbGFzczMiLCJpc0lFNjgiLCJpc0REQSIsImlzRG9jdW1lbnREb3RBbGwiLCJkb2N1bWVudCIsImFsbCIsInN0ckNsYXNzIiwiaXNGblJlZ2V4IiwiZ2V0R2VuZXJhdG9yRnVuYyIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbmVyYXRvckZ1bmMiLCJnZXRQb2x5ZmlsbCIsInNoaW0iLCJOYU4iLCJzaGltTnVtYmVySXNOYU4iLCJ0ZXN0SXNOYU4iLCJ3aGljaFR5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJzaGltT2JqZWN0SXMiLCJ0ZXN0T2JqZWN0SXMiLCJrZXlzU2hpbSIsImlzQXJncyIsImlzRW51bWVyYWJsZSIsImhhc0RvbnRFbnVtQnVnIiwiaGFzUHJvdG9FbnVtQnVnIiwiZG9udEVudW1zIiwiZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUiLCJleGNsdWRlZEtleXMiLCIkYXBwbGljYXRpb25DYWNoZSIsIiRjb25zb2xlIiwiJGV4dGVybmFsIiwiJGZyYW1lIiwiJGZyYW1lRWxlbWVudCIsIiRmcmFtZXMiLCIkaW5uZXJIZWlnaHQiLCIkaW5uZXJXaWR0aCIsIiRvbm1vemZ1bGxzY3JlZW5jaGFuZ2UiLCIkb25tb3pmdWxsc2NyZWVuZXJyb3IiLCIkb3V0ZXJIZWlnaHQiLCIkb3V0ZXJXaWR0aCIsIiRwYWdlWE9mZnNldCIsIiRwYWdlWU9mZnNldCIsIiRwYXJlbnQiLCIkc2Nyb2xsTGVmdCIsIiRzY3JvbGxUb3AiLCIkc2Nyb2xsWCIsIiRzY3JvbGxZIiwiJHNlbGYiLCIkd2Via2l0SW5kZXhlZERCIiwiJHdlYmtpdFN0b3JhZ2VJbmZvIiwiJHdpbmRvdyIsImhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSIsImlzT2JqZWN0IiwiaXNTdHJpbmciLCJ0aGVLZXlzIiwic2tpcFByb3RvIiwic2tpcENvbnN0cnVjdG9yIiwib3JpZ0tleXMiLCJvcmlnaW5hbEtleXMiLCJzaGltT2JqZWN0S2V5cyIsImtleXNXb3Jrc1dpdGhBcmd1bWVudHMiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJuZXh0VGljayIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiaGFzRGVzY3JpcHRvcnMiLCJnT1BEIiwiJGZsb29yIiwiZnVuY3Rpb25MZW5ndGhJc0NvbmZpZ3VyYWJsZSIsImZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImQiLCJCYXNlU2VydmljZSIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIm4iLCJfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9kZWZpbmVfcHJvcGVydHkiLCJhZGREb2N1bWVudCIsImRvY3VtZW50cyIsInVyaSIsIlYiLCJsYW5ndWFnZUlkIiwidGV4dCIsImdldERvY3VtZW50IiwicmVtb3ZlRG9jdW1lbnQiLCJyZW5hbWVEb2N1bWVudCIsIm5ld0RvY3VtZW50VXJpIiwicHJldmlvdXNEb2N1bWVudCIsImdldFRleHQiLCJnZXREb2N1bWVudFZhbHVlIiwiX3RoaXNfZ2V0RG9jdW1lbnQiLCJzZXRWYWx1ZSIsImlkZW50aWZpZXIiLCJzZXRHbG9iYWxPcHRpb25zIiwiZ2xvYmFsT3B0aW9ucyIsInNldFdvcmtzcGFjZSIsIndvcmtzcGFjZVVyaSIsInNldE9wdGlvbnMiLCJkb2N1bWVudFVyaSIsIm1lcmdlIiwickwiLCJnZXRPcHRpb24iLCJvcHRpb25OYW1lIiwiYXBwbHlEZWx0YXMiLCJkZWx0YXMiLCJ1cGRhdGUiLCJkb0NvbXBsZXRlIiwiZG9JbmxpbmVDb21wbGV0ZSIsImRvSG92ZXIiLCJkb1Jlc29sdmUiLCJkb1ZhbGlkYXRpb24iLCJyYW5nZSIsInByb3ZpZGVTaWduYXR1cmVIZWxwIiwiZmluZERvY3VtZW50SGlnaGxpZ2h0cyIsIm9wdGlvbnNUb0ZpbHRlckRpYWdub3N0aWNzIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9JZ25vcmUiLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJlcnJvckNvZGVzVG9JZ25vcmUiLCJlcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsImVycm9yQ29kZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JNZXNzYWdlc1RvSWdub3JlIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyIsImdldFNlbWFudGljVG9rZW5zIiwiZGlzcG9zZSIsImNsb3NlQ29ubmVjdGlvbiIsImdldENvZGVBY3Rpb25zIiwiY29udGV4dCIsImV4ZWN1dGVDb21tYW5kIiwiY29tbWFuZCIsInNlbmRBcHBsaWVkUmVzdWx0IiwiY2FsbGJhY2tJZCIsInNlbmRSZXF1ZXN0Iiwic2VuZFJlc3BvbnNlIiwibW9kZSIsInRleHREb2N1bWVudCIsImRpYWdub3N0aWMiLCJkeW5hbWljUmVnaXN0cmF0aW9uIiwicmVsYXRlZERvY3VtZW50U3VwcG9ydCIsInB1Ymxpc2hEaWFnbm9zdGljcyIsInJlbGF0ZWRJbmZvcm1hdGlvbiIsInZlcnNpb25TdXBwb3J0IiwidGFnU3VwcG9ydCIsInZhbHVlU2V0IiwiRGlhZ25vc3RpY1RhZyIsIlVubmVjZXNzYXJ5IiwiRGVwcmVjYXRlZCIsImhvdmVyIiwiY29udGVudEZvcm1hdCIsInN5bmNocm9uaXphdGlvbiIsIndpbGxTYXZlIiwiZGlkU2F2ZSIsIndpbGxTYXZlV2FpdFVudGlsIiwiZm9ybWF0dGluZyIsImNvbXBsZXRpb24iLCJjb21wbGV0aW9uSXRlbSIsInNuaXBwZXRTdXBwb3J0IiwiY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQiLCJkb2N1bWVudGF0aW9uRm9ybWF0IiwiZGVwcmVjYXRlZFN1cHBvcnQiLCJwcmVzZWxlY3RTdXBwb3J0IiwiY29udGV4dFN1cHBvcnQiLCJzaWduYXR1cmVIZWxwIiwic2lnbmF0dXJlSW5mb3JtYXRpb24iLCJhY3RpdmVQYXJhbWV0ZXJTdXBwb3J0IiwiZG9jdW1lbnRIaWdobGlnaHQiLCJzZW1hbnRpY1Rva2VucyIsIm11bHRpbGluZVRva2VuU3VwcG9ydCIsIm92ZXJsYXBwaW5nVG9rZW5TdXBwb3J0IiwidG9rZW5UeXBlcyIsInRva2VuTW9kaWZpZXJzIiwiZm9ybWF0cyIsInJlcXVlc3RzIiwiZnVsbCIsImRlbHRhIiwiYXVnbWVudHNTeW50YXhUb2tlbnMiLCJjb2RlQWN0aW9uIiwiaW5saW5lQ29tcGxldGlvbiIsInNob3dEb2N1bWVudCIsInN1cHBvcnQiLCJ3b3Jrc3BhY2UiLCJkaWRDaGFuZ2VDb25maWd1cmF0aW9uIiwiYXBwbHlFZGl0Iiwid29ya3NwYWNlRWRpdCIsImZhaWx1cmVIYW5kbGluZyIsIm5vcm1hbGl6ZXNMaW5lRW5kaW5ncyIsImRvY3VtZW50Q2hhbmdlcyIsInNlcnZpY2VOYW1lIiwic2VydmljZURhdGEiLCJjbGFzc05hbWUiLCJtb2RlcyIsIm1lcmdlT2JqZWN0cyIsIm9iajEiLCJvYmoyIiwiZXhjbHVkZVVuZGVmaW5lZCIsImV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMiLCJtZXJnZWRPYmplY3RzIiwiZmlsdGVyZWRFbnRyaWVzIiwiZW50cmllcyIsImZyb21FbnRyaWVzIiwibm90RW1wdHkiLCJpc0VtcHR5UmFuZ2UiLCJyb3ciLCJjb2x1bW4iLCJtZXJnZVJhbmdlcyIsInJhbmdlcyIsInNvcnQiLCJjb21wYXJlUG9pbnRzIiwiY21wIiwicDEiLCJwMiIsImNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkiLCJyZWdleHBBcnJheSIsImNvbnZlcnRUb1VyaSIsImZpbGVQYXRoIiwiVVJJIiwiZmlsZSIsImlzQnVmZmVyIiwiYXJnIiwiY29weSIsImZpbGwiLCJyZWFkVUludDgiLCJpc0FyZ3VtZW50c09iamVjdCIsIkJpZ0ludFN1cHBvcnRlZCIsIlN5bWJvbFN1cHBvcnRlZCIsIk9iamVjdFRvU3RyaW5nIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xlYW5WYWx1ZSIsImJpZ0ludFZhbHVlIiwic3ltYm9sVmFsdWUiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwicHJvdG90eXBlVmFsdWVPZiIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc01hcFRvU3RyaW5nIiwid29ya2luZyIsImlzU2V0VG9TdHJpbmciLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsIlNoYXJlZEFycmF5QnVmZmVyQ29weSIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwibWV0aG9kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZm9ybWF0UmVnRXhwIiwib2JqZWN0cyIsInN0cmluZ2lmeSIsImlzTnVsbCIsImRlcHJlY2F0ZSIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0VudlJlZ2V4IiwiTk9ERV9ERUJVRyIsImRlYnVnRW52IiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsIm9wdHMiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiY29sb3JzIiwiaXNCb29sZWFuIiwiX2V4dGVuZCIsImlzVW5kZWZpbmVkIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwic3R5bGVzIiwic3R5bGVUeXBlIiwic3R5bGUiLCJhcnJheVRvSGFzaCIsImhhc2giLCJpZHgiLCJyZXQiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwib3V0cHV0IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiaXNOdW1iZXIiLCJsIiwibGluZSIsIm51bUxpbmVzRXN0IiwicmVkdWNlIiwicHJldiIsImFyIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwicHJvcCIsImtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCIsInByb21pc2lmeSIsIm9yaWdpbmFsIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlUmVqZWN0IiwicHJvbWlzZSIsInJlamVjdCIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsImNiIiwibmV3UmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwibWF5YmVDYiIsInJlaiIsIl9fY3JlYXRlQmluZGluZyIsIm0iLCJrMiIsIl9fZXNNb2R1bGUiLCJfX2V4cG9ydFN0YXIiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIkJyb3dzZXJNZXNzYWdlV3JpdGVyIiwiQnJvd3Nlck1lc3NhZ2VSZWFkZXIiLCJyaWxfMSIsImRlZmF1bHQiLCJpbnN0YWxsIiwiYXBpXzEiLCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXIiLCJsaXN0ZW4iLCJjYWxsYmFjayIsIl9vbkRhdGEiLCJldmVudCIsInBvcnQiLCJFbWl0dGVyIiwiX21lc3NhZ2VMaXN0ZW5lciIsImZpcmUiLCJkYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVFcnJvciIsIm9ubWVzc2FnZSIsIkFic3RyYWN0TWVzc2FnZVdyaXRlciIsIndyaXRlIiwicG9zdE1lc3NhZ2UiLCJoYW5kbGVFcnJvciIsImVycm9yQ291bnQiLCJyZWFkZXIiLCJ3cml0ZXIiLCJsb2dnZXIiLCJOdWxsTG9nZ2VyIiwiQ29ubmVjdGlvblN0cmF0ZWd5IiwiY29ubmVjdGlvblN0cmF0ZWd5IiwiTWVzc2FnZUJ1ZmZlciIsIkFic3RyYWN0TWVzc2FnZUJ1ZmZlciIsImVtcHR5QnVmZmVyIiwiZnJvbVN0cmluZyIsIl9lbmNvZGluZyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZW5jb2RpbmciLCJhc2NpaURlY29kZXIiLCJkZWNvZGUiLCJUZXh0RGVjb2RlciIsImFzTmF0aXZlIiwiYWxsb2NOYXRpdmUiLCJSZWFkYWJsZVN0cmVhbVdyYXBwZXIiLCJvbkNsb3NlIiwibGlzdGVuZXIiLCJzb2NrZXQiLCJEaXNwb3NhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uRXJyb3IiLCJvbkVuZCIsIm9uRGF0YSIsImJsb2IiLCJhcnJheUJ1ZmZlciIsIlJBTCIsIldyaXRhYmxlU3RyZWFtV3JhcHBlciIsInNlbmQiLCJjbG9zZSIsIl90ZXh0RW5jb2RlciIsIl9yaWwiLCJmcmVlemUiLCJtZXNzYWdlQnVmZmVyIiwiYXBwbGljYXRpb25Kc29uIiwiZW5jb2RlciIsImNoYXJzZXQiLCJwYXJzZSIsInN0cmVhbSIsImFzUmVhZGFibGVTdHJlYW0iLCJhc1dyaXRhYmxlU3RyZWFtIiwidGltZXIiLCJtcyIsImhhbmRsZSIsInNldEltbWVkaWF0ZSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlJJTCIsIlByb2dyZXNzVHlwZSIsIlByb2dyZXNzVG9rZW4iLCJDb25uZWN0aW9uT3B0aW9ucyIsIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIiLCJNZXNzYWdlV3JpdGVyIiwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIiwiTWVzc2FnZVJlYWRlciIsIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSIsIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuU291cmNlIiwiRXZlbnQiLCJMUlVDYWNoZSIsIlRvdWNoIiwiTGlua2VkTWFwIiwiUGFyYW1ldGVyU3RydWN0dXJlcyIsIk5vdGlmaWNhdGlvblR5cGU5IiwiTm90aWZpY2F0aW9uVHlwZTgiLCJOb3RpZmljYXRpb25UeXBlNyIsIk5vdGlmaWNhdGlvblR5cGU2IiwiTm90aWZpY2F0aW9uVHlwZTUiLCJOb3RpZmljYXRpb25UeXBlNCIsIk5vdGlmaWNhdGlvblR5cGUzIiwiTm90aWZpY2F0aW9uVHlwZTIiLCJOb3RpZmljYXRpb25UeXBlMSIsIk5vdGlmaWNhdGlvblR5cGUwIiwiTm90aWZpY2F0aW9uVHlwZSIsIkVycm9yQ29kZXMiLCJSZXNwb25zZUVycm9yIiwiUmVxdWVzdFR5cGU5IiwiUmVxdWVzdFR5cGU4IiwiUmVxdWVzdFR5cGU3IiwiUmVxdWVzdFR5cGU2IiwiUmVxdWVzdFR5cGU1IiwiUmVxdWVzdFR5cGU0IiwiUmVxdWVzdFR5cGUzIiwiUmVxdWVzdFR5cGUyIiwiUmVxdWVzdFR5cGUxIiwiUmVxdWVzdFR5cGUwIiwiUmVxdWVzdFR5cGUiLCJNZXNzYWdlIiwiTWVzc2FnZVN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDb25uZWN0aW9uRXJyb3IiLCJDb25uZWN0aW9uRXJyb3JzIiwiTG9nVHJhY2VOb3RpZmljYXRpb24iLCJTZXRUcmFjZU5vdGlmaWNhdGlvbiIsIlRyYWNlRm9ybWF0IiwiVHJhY2VWYWx1ZXMiLCJUcmFjZSIsIm1lc3NhZ2VzXzEiLCJsaW5rZWRNYXBfMSIsImRpc3Bvc2FibGVfMSIsImV2ZW50c18xIiwiY2FuY2VsbGF0aW9uXzEiLCJzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xIiwibWVzc2FnZVJlYWRlcl8xIiwibWVzc2FnZVdyaXRlcl8xIiwibWVzc2FnZUJ1ZmZlcl8xIiwiY29ubmVjdGlvbl8xIiwicmFsXzEiLCJJcyIsIk5vbmUiLCJpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCIsIm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiQ2FuY2VsbGVkIiwiY2FuZGlkYXRlIiwiYm9vbGVhbiIsInNob3J0Y3V0RXZlbnQiLCJNdXRhYmxlVG9rZW4iLCJjYW5jZWwiLCJfaXNDYW5jZWxsZWQiLCJfZW1pdHRlciIsInRva2VuIiwiX3Rva2VuIiwiUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDYW5jZWxOb3RpZmljYXRpb24iLCJQcm9ncmVzc05vdGlmaWNhdGlvbiIsIlN0YXJSZXF1ZXN0SGFuZGxlciIsIk9mZiIsIk1lc3NhZ2VzIiwiQ29tcGFjdCIsIlZlcmJvc2UiLCJ0b0xvd2VyQ2FzZSIsIlRleHQiLCJjYW5jZWxVbmRpc3BhdGNoZWQiLCJraW5kIiwiY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJzZW5kQ2FuY2VsbGF0aW9uIiwiY29ubiIsImlkIiwic2VuZE5vdGlmaWNhdGlvbiIsImNsZWFudXAiLCJzZW5kZXIiLCJoYW5kbGVNZXNzYWdlIiwiY2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJtZXNzYWdlU3RyYXRlZ3kiLCJDb25uZWN0aW9uU3RhdGUiLCJtZXNzYWdlUmVhZGVyIiwibWVzc2FnZVdyaXRlciIsIl9sb2dnZXIiLCJzZXF1ZW5jZU51bWJlciIsIm5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyIiwidW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIiLCJzdGFyUmVxdWVzdEhhbmRsZXIiLCJyZXF1ZXN0SGFuZGxlcnMiLCJzdGFyTm90aWZpY2F0aW9uSGFuZGxlciIsIm5vdGlmaWNhdGlvbkhhbmRsZXJzIiwicHJvZ3Jlc3NIYW5kbGVycyIsIm1lc3NhZ2VRdWV1ZSIsInJlc3BvbnNlUHJvbWlzZXMiLCJrbm93bkNhbmNlbGVkUmVxdWVzdHMiLCJyZXF1ZXN0VG9rZW5zIiwidHJhY2VGb3JtYXQiLCJ0cmFjZXIiLCJzdGF0ZSIsIk5ldyIsImVycm9yRW1pdHRlciIsImNsb3NlRW1pdHRlciIsInVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIiLCJ1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIiLCJkaXNwb3NlRW1pdHRlciIsImNyZWF0ZVJlcXVlc3RRdWV1ZUtleSIsImNyZWF0ZVJlc3BvbnNlUXVldWVLZXkiLCJjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSIsImFkZE1lc3NhZ2VUb1F1ZXVlIiwiaXNSZXF1ZXN0IiwiaXNSZXNwb25zZSIsIl9tZXNzYWdlIiwiaXNMaXN0ZW5pbmciLCJMaXN0ZW5pbmciLCJpc0Nsb3NlZCIsIkNsb3NlZCIsImlzRGlzcG9zZWQiLCJEaXNwb3NlZCIsImNsb3NlSGFuZGxlciIsInJlYWRFcnJvckhhbmRsZXIiLCJ3cml0ZUVycm9ySGFuZGxlciIsInRyaWdnZXJNZXNzYWdlUXVldWUiLCJwcm9jZXNzTWVzc2FnZVF1ZXVlIiwiaGFuZGxlUmVxdWVzdCIsImlzTm90aWZpY2F0aW9uIiwiaGFuZGxlTm90aWZpY2F0aW9uIiwiaGFuZGxlUmVzcG9uc2UiLCJoYW5kbGVJbnZhbGlkTWVzc2FnZSIsImNhbmNlbElkIiwicGFyYW1zIiwidG9DYW5jZWwiLCJzdHJhdGVneSIsInJlc3BvbnNlIiwidHJhY2VTZW5kaW5nUmVzcG9uc2UiLCJjYW5jZWxsYXRpb25Ub2tlbiIsInRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24iLCJyZXF1ZXN0TWVzc2FnZSIsInJlcGx5IiwicmVzdWx0T3JFcnJvciIsInN0YXJ0VGltZSIsImpzb25ycGMiLCJ0b0pzb24iLCJyZXBseUVycm9yIiwicmVwbHlTdWNjZXNzIiwidHJhY2VSZWNlaXZlZFJlcXVlc3QiLCJlbGVtZW50IiwicmVxdWVzdEhhbmRsZXIiLCJoYW5kbGVyIiwidG9rZW5LZXkiLCJjYW5jZWxsYXRpb25Tb3VyY2UiLCJoYW5kbGVyUmVzdWx0IiwibnVtYmVyT2ZQYXJhbXMiLCJJbnZhbGlkUGFyYW1zIiwicGFyYW1ldGVyU3RydWN0dXJlcyIsImJ5TmFtZSIsImJ5UG9zaXRpb24iLCJJbnRlcm5hbEVycm9yIiwiTWV0aG9kTm90Rm91bmQiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZXNwb25zZVByb21pc2UiLCJ0cmFjZVJlY2VpdmVkUmVzcG9uc2UiLCJub3RpZmljYXRpb25IYW5kbGVyIiwicmVzcG9uc2VIYW5kbGVyIiwic3RyaW5naWZ5VHJhY2UiLCJ0cmFjZVNlbmRpbmdSZXF1ZXN0IiwibG9nTFNQTWVzc2FnZSIsInRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbiIsInRpbWVyU3RhcnQiLCJsc3BNZXNzYWdlIiwiaXNMU1BNZXNzYWdlIiwidGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQiLCJ0aHJvd0lmTGlzdGVuaW5nIiwiQWxyZWFkeUxpc3RlbmluZyIsInRocm93SWZOb3RMaXN0ZW5pbmciLCJ1bmRlZmluZWRUb051bGwiLCJwYXJhbSIsIm51bGxUb1VuZGVmaW5lZCIsImlzTmFtZWRQYXJhbSIsImNvbXB1dGVTaW5nbGVQYXJhbSIsImF1dG8iLCJjb21wdXRlTWVzc2FnZVBhcmFtcyIsImNvbm5lY3Rpb24iLCJtZXNzYWdlUGFyYW1zIiwicGFyYW1TdGFydCIsInBhcmFtRW5kIiwibm90aWZpY2F0aW9uTWVzc2FnZSIsIm9uTm90aWZpY2F0aW9uIiwib25Qcm9ncmVzcyIsIl90eXBlIiwic2VuZFByb2dyZXNzIiwib25VbmhhbmRsZWRQcm9ncmVzcyIsImRpc3Bvc2FibGUiLCJlbmFibGVDYW5jZWxsYXRpb24iLCJyZXNvbHZlV2l0aENsZWFudXAiLCJyIiwicmVqZWN0V2l0aENsZWFudXAiLCJNZXNzYWdlV3JpdGVFcnJvciIsIm9uUmVxdWVzdCIsImhhc1BlbmRpbmdSZXNwb25zZSIsIl92YWx1ZSIsIl90cmFjZXIiLCJzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMiLCJfc2VuZE5vdGlmaWNhdGlvbiIsIl90cmFjZUZvcm1hdCIsIm9uVW5oYW5kbGVkTm90aWZpY2F0aW9uIiwib25EaXNwb3NlIiwiUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQiLCJ2YWx1ZXMiLCJ2ZXJib3NlIiwiX2Rpc3Bvc2FibGUiLCJDYWxsYmFja0xpc3QiLCJidWNrZXQiLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwicmVtb3ZlIiwiZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0IiwiaW52b2tlIiwiY2FsbGJhY2tzIiwiY29udGV4dHMiLCJpc0VtcHR5IiwiX2V2ZW50IiwidGhpc0FyZ3MiLCJkaXNwb3NhYmxlcyIsIl9vcHRpb25zIiwib25GaXJzdExpc3RlbmVyQWRkIiwiX25vb3AiLCJvbkxhc3RMaXN0ZW5lclJlbW92ZSIsInN0cmluZ0FycmF5IiwiZXZlcnkiLCJlbGVtIiwiX2EiLCJGaXJzdCIsIkFzT2xkIiwiTGFzdCIsIkFzTmV3IiwiY2xlYXIiLCJfbWFwIiwiX2hlYWQiLCJfdGFpbCIsIl9zaXplIiwiX3N0YXRlIiwidG91Y2giLCJwcmV2aW91cyIsImFkZEl0ZW1MYXN0IiwiYWRkSXRlbUZpcnN0IiwicmVtb3ZlSXRlbSIsImNhbGxiYWNrZm4iLCJjdXJyZW50IiwidHJpbU9sZCIsIm5ld1NpemUiLCJjdXJyZW50U2l6ZSIsInRvSlNPTiIsImZyb21KU09OIiwiX2xpbWl0IiwiY2hlY2tUcmltIiwicmF0aW8iLCJfcmF0aW8iLCJwZWVrIiwicm91bmQiLCJDUiIsIkxGIiwiQ1JMRiIsImFwcGVuZCIsImNodW5rIiwidG9BcHBlbmQiLCJfY2h1bmtzIiwiX3RvdGFsTGVuZ3RoIiwidHJ5UmVhZEhlYWRlcnMiLCJsb3dlckNhc2VLZXlzIiwiY2h1bmtJbmRleCIsImNodW5rQnl0ZXNSZWFkIiwiX3JlYWQiLCJoZWFkZXJzIiwiaGVhZGVyIiwiaW5kZXgiLCJ0cmltIiwidHJ5UmVhZEJvZHkiLCJudW1iZXJPZkJ5dGVzIiwiYnl0ZUNvdW50IiwicmVzdWx0T2Zmc2V0IiwiY2h1bmtQYXJ0Iiwic2VtYXBob3JlXzEiLCJvblBhcnRpYWxNZXNzYWdlIiwiYXNFcnJvciIsImZpcmVDbG9zZSIsInBhcnRpYWxNZXNzYWdlRW1pdHRlciIsImZpcmVQYXJ0aWFsTWVzc2FnZSIsIlJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMiLCJmcm9tT3B0aW9ucyIsImNvbnRlbnREZWNvZGVyIiwiY29udGVudERlY29kZXJzIiwiY29udGVudFR5cGVEZWNvZGVyIiwiY29udGVudFR5cGVEZWNvZGVycyIsInBhcnRpYWxNZXNzYWdlVGltZW91dCIsIl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQiLCJuZXh0TWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VUb2tlbiIsInBhcnRpYWxNZXNzYWdlVGltZXIiLCJyZWFkYWJsZSIsImNvbnRlbnRMZW5ndGgiLCJib2R5Iiwic2V0UGFydGlhbE1lc3NhZ2VUaW1lciIsImNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lciIsInJlYWRTZW1hcGhvcmUiLCJsb2NrIiwiYnl0ZXMiLCJ3YWl0aW5nVGltZSIsIlNlbWFwaG9yZSIsIkNvbnRlbnRMZW5ndGgiLCJSZXNvbHZlZE1lc3NhZ2VXcml0ZXJPcHRpb25zIiwiY29udGVudFR5cGVFbmNvZGVyIiwiY29udGVudEVuY29kZXIiLCJ3cml0ZVNlbWFwaG9yZSIsInBheWxvYWQiLCJkb1dyaXRlIiwiQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIiwiUGFyc2VFcnJvciIsIkludmFsaWRSZXF1ZXN0IiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZVN0YXJ0Iiwic2VydmVyRXJyb3JTdGFydCIsIk1lc3NhZ2VSZWFkRXJyb3IiLCJDb25uZWN0aW9uSW5hY3RpdmUiLCJTZXJ2ZXJOb3RJbml0aWFsaXplZCIsIlVua25vd25FcnJvckNvZGUiLCJqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlRW5kIiwic2VydmVyRXJyb3JFbmQiLCJfcGFyYW1ldGVyU3RydWN0dXJlcyIsIl9yYWwiLCJyYWwiLCJ0aHVuayIsIl93YWl0aW5nIiwicnVuTmV4dCIsImFjdGl2ZSIsIl9hY3RpdmUiLCJfY2FwYWNpdHkiLCJkb1J1bk5leHQiLCJjYXBhY2l0eSIsIkNhbmNlbGxhdGlvblN0YXRlIiwiQ29udGludWUiLCJyZXF1ZXN0IiwiYnVmZmVycyIsIiRjYW5jZWxsYXRpb25EYXRhIiwiX2Nvbm4iLCJzdG9yZSIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW4iLCJsb2FkIiwiU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSIsImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiIsImJyb3dzZXJfMSIsIkxTUEVycm9yQ29kZXMiLCJsc3BSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsIlJlcXVlc3RGYWlsZWQiLCJTZXJ2ZXJDYW5jZWxsZWQiLCJDb250ZW50TW9kaWZpZWQiLCJSZXF1ZXN0Q2FuY2VsbGVkIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlRW5kIiwidnNjb2RlX2pzb25ycGNfMSIsIlByb3RvY29sTm90aWZpY2F0aW9uVHlwZSIsIlByb3RvY29sTm90aWZpY2F0aW9uVHlwZTAiLCJQcm90b2NvbFJlcXVlc3RUeXBlIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZTAiLCJSZWdpc3RyYXRpb25UeXBlIiwiTWVzc2FnZURpcmVjdGlvbiIsIkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCIsIkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCIsIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCIsIm1lc3NhZ2VEaXJlY3Rpb24iLCJjbGllbnRUb1NlcnZlciIsIkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdCIsIkRvY3VtZW50Q29sb3JSZXF1ZXN0IiwiQ29uZmlndXJhdGlvblJlcXVlc3QiLCJzZXJ2ZXJUb0NsaWVudCIsIkRlY2xhcmF0aW9uUmVxdWVzdCIsIl9fbm9EeW5hbWljSW1wb3J0IiwiRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0IiwiV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QiLCJEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCIsIkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhIiwicmV0cmlnZ2VyUmVxdWVzdCIsIkZ1bGwiLCJVbmNoYW5nZWQiLCJwYXJ0aWFsUmVzdWx0IiwiV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCIsIkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uIiwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24iLCJXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0IiwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24iLCJXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0IiwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kIiwiZm9sZGVyIiwiRm9sZGluZ1JhbmdlUmVmcmVzaFJlcXVlc3QiLCJGb2xkaW5nUmFuZ2VSZXF1ZXN0IiwiSW1wbGVtZW50YXRpb25SZXF1ZXN0IiwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QiLCJJbmxheUhpbnRSZXNvbHZlUmVxdWVzdCIsIklubGF5SGludFJlcXVlc3QiLCJJbmxpbmVDb21wbGV0aW9uUmVxdWVzdCIsIklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0IiwiQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IiwiQ29kZUFjdGlvblJlcXVlc3QiLCJEb2N1bWVudFN5bWJvbFJlcXVlc3QiLCJEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QiLCJSZWZlcmVuY2VzUmVxdWVzdCIsIkRlZmluaXRpb25SZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFJlcXVlc3QiLCJTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQiLCJIb3ZlclJlcXVlc3QiLCJDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QiLCJDb21wbGV0aW9uUmVxdWVzdCIsIkNvbXBsZXRpb25UcmlnZ2VyS2luZCIsIlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiIsIldhdGNoS2luZCIsIlJlbGF0aXZlUGF0dGVybiIsIkZpbGVDaGFuZ2VUeXBlIiwiRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IiwiV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTYXZlUmVhc29uIiwiRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IiwiRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudFN5bmNLaW5kIiwiVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24iLCJMb2dNZXNzYWdlTm90aWZpY2F0aW9uIiwiU2hvd01lc3NhZ2VSZXF1ZXN0IiwiU2hvd01lc3NhZ2VOb3RpZmljYXRpb24iLCJNZXNzYWdlVHlwZSIsIkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24iLCJFeGl0Tm90aWZpY2F0aW9uIiwiU2h1dGRvd25SZXF1ZXN0IiwiSW5pdGlhbGl6ZWROb3RpZmljYXRpb24iLCJJbml0aWFsaXplRXJyb3JDb2RlcyIsIkluaXRpYWxpemVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzc09wdGlvbnMiLCJUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIiwiU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyIsIlBvc2l0aW9uRW5jb2RpbmdLaW5kIiwiRmFpbHVyZUhhbmRsaW5nS2luZCIsIlJlc291cmNlT3BlcmF0aW9uS2luZCIsIlVucmVnaXN0cmF0aW9uUmVxdWVzdCIsIlJlZ2lzdHJhdGlvblJlcXVlc3QiLCJEb2N1bWVudFNlbGVjdG9yIiwiTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyIiwiTm90ZWJvb2tEb2N1bWVudEZpbHRlciIsIlRleHREb2N1bWVudEZpbHRlciIsIk1vbmlrZXJSZXF1ZXN0IiwiTW9uaWtlcktpbmQiLCJVbmlxdWVuZXNzTGV2ZWwiLCJMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0IiwiU2hvd0RvY3VtZW50UmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSIsIlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0IiwiVG9rZW5Gb3JtYXQiLCJXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uIiwiV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QiLCJXb3JrRG9uZVByb2dyZXNzIiwiU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0IiwiRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiIsIldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0IiwiVHlwZURlZmluaXRpb25SZXF1ZXN0IiwiQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCIsIkV4ZWN1dGVDb21tYW5kUmVxdWVzdCIsIlByZXBhcmVSZW5hbWVSZXF1ZXN0IiwiUmVuYW1lUmVxdWVzdCIsIlByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yIiwiRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCIsIkRvY3VtZW50UmFuZ2VzRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QiLCJEb2N1bWVudExpbmtSZXF1ZXN0IiwiQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCIsIkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QiLCJDb2RlTGVuc1JlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCIsIkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIiwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUiLCJOb3RlYm9va0RvY3VtZW50IiwiTm90ZWJvb2tDZWxsIiwiRXhlY3V0aW9uU3VtbWFyeSIsIk5vdGVib29rQ2VsbEtpbmQiLCJUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QiLCJUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0IiwiVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IiwidnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEiLCJwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xIiwicHJvdG9jb2xfdHlwZURlZmluaXRpb25fMSIsInByb3RvY29sX3dvcmtzcGFjZUZvbGRlcl8xIiwicHJvdG9jb2xfY29uZmlndXJhdGlvbl8xIiwicHJvdG9jb2xfY29sb3JQcm92aWRlcl8xIiwicHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEiLCJwcm90b2NvbF9kZWNsYXJhdGlvbl8xIiwicHJvdG9jb2xfc2VsZWN0aW9uUmFuZ2VfMSIsInByb3RvY29sX3Byb2dyZXNzXzEiLCJwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEiLCJwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xIiwicHJvdG9jb2xfc2hvd0RvY3VtZW50XzEiLCJwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMSIsInByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEiLCJwcm90b2NvbF9tb25pa2VyXzEiLCJwcm90b2NvbF90eXBlSGllcmFyY2h5XzEiLCJwcm90b2NvbF9pbmxpbmVWYWx1ZV8xIiwicHJvdG9jb2xfaW5sYXlIaW50XzEiLCJwcm90b2NvbF9kaWFnbm9zdGljXzEiLCJwcm90b2NvbF9ub3RlYm9va18xIiwicHJvdG9jb2xfaW5saW5lQ29tcGxldGlvbl8xIiwibGFuZ3VhZ2UiLCJzY2hlbWUiLCJwYXR0ZXJuIiwib2JqZWN0TGl0ZXJhbCIsIm5vdGVib29rVHlwZSIsIm5vdGVib29rIiwiQ3JlYXRlIiwiUmVuYW1lIiwiRGVsZXRlIiwiQWJvcnQiLCJUcmFuc2FjdGlvbmFsIiwiVGV4dE9ubHlUcmFuc2FjdGlvbmFsIiwiVW5kbyIsIlVURjgiLCJVVEYxNiIsIlVURjMyIiwiaGFzSWQiLCJkb2N1bWVudFNlbGVjdG9yIiwid29ya0RvbmVQcm9ncmVzcyIsImhhc1dvcmtEb25lUHJvZ3Jlc3MiLCJ1bmtub3duUHJvdG9jb2xWZXJzaW9uIiwiV2FybmluZyIsIkluZm8iLCJMb2ciLCJEZWJ1ZyIsIkluY3JlbWVudGFsIiwiaXNJbmNyZW1lbnRhbCIsInJhbmdlTGVuZ3RoIiwiaXNGdWxsIiwiTWFudWFsIiwiQWZ0ZXJEZWxheSIsIkZvY3VzT3V0IiwiQ3JlYXRlZCIsIkNoYW5nZWQiLCJEZWxldGVkIiwiYmFzZVVyaSIsIldvcmtzcGFjZUZvbGRlciIsIkNoYW5nZSIsIkludm9rZWQiLCJUcmlnZ2VyQ2hhcmFjdGVyIiwiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyIsIkNvbnRlbnRDaGFuZ2UiLCJJZGVudGlmaWVyIiwicHJvamVjdCIsImdyb3VwIiwiZ2xvYmFsIiwiJGltcG9ydCIsIiRleHBvcnQiLCJsb2NhbCIsIk1hcmt1cCIsIkNvZGUiLCJleGVjdXRpb25PcmRlciIsInN1Y2Nlc3MiLCJ1aW50ZWdlciIsImVxdWFscyIsIm9uZSIsIkRvY3VtZW50VXJpIiwibWV0YWRhdGEiLCJkaWZmIiwidHdvIiwiZXhlY3V0aW9uU3VtbWFyeSIsImVxdWFsc01ldGFkYXRhIiwib25lQXJyYXkiLCJvdGhlckFycmF5Iiwib25lS2V5cyIsIm90aGVyS2V5cyIsImNlbGxzIiwiaW50ZWdlciIsInR5cGVkQXJyYXkiLCJyZWdpc3RyYXRpb25NZXRob2QiLCJkZWxldGVDb3VudCIsIlJlbGF0aXZlIiwiY2hlY2siLCJhdmFpbGFibGVUeXBlZEFycmF5cyIsImdsb2JhbFRoaXMiLCJ0eXBlZEFycmF5cyIsIiRzbGljZSIsImNhY2hlIiwicHJvdG8iLCJzdXBlclByb3RvIiwidHJ5VHlwZWRBcnJheXMiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImZvdW5kIiwiZ2V0dGVyIiwidHJ5U2xpY2VzIiwidHJ5QWxsU2xpY2VzIiwidGFnIiwicG9zc2libGVOYW1lcyIsIm91dCIsIl9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fIiwiVGV4dERvY3VtZW50IiwiRnVsbFRleHREb2N1bWVudCIsIl91cmkiLCJfbGFuZ3VhZ2VJZCIsIl92ZXJzaW9uIiwib2Zmc2V0QXQiLCJfY29udGVudCIsImNoYW5nZXMiLCJjaGFuZ2UiLCJnZXRXZWxsZm9ybWVkUmFuZ2UiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJsaW5lT2Zmc2V0cyIsIl9saW5lT2Zmc2V0cyIsImFkZGVkTGluZU9mZnNldHMiLCJjb21wdXRlTGluZU9mZnNldHMiLCJnZXRMaW5lT2Zmc2V0cyIsInBvc2l0aW9uQXQiLCJsb3ciLCJoaWdoIiwiY2hhcmFjdGVyIiwibWlkIiwiZW5zdXJlQmVmb3JlRU9MIiwibGluZU9mZnNldCIsIm5leHRMaW5lT2Zmc2V0IiwiaXNFT0wiLCJsaW5lQ291bnQiLCJjb250ZW50IiwiYXBwbHlFZGl0cyIsImVkaXRzIiwic29ydGVkRWRpdHMiLCJtZXJnZVNvcnQiLCJnZXRXZWxsZm9ybWVkRWRpdCIsImxhc3RNb2RpZmllZE9mZnNldCIsInNwYW5zIiwibmV3VGV4dCIsImxlZnQiLCJyaWdodCIsImxlZnRJZHgiLCJyaWdodElkeCIsImlzQXRMaW5lU3RhcnQiLCJ0ZXh0T2Zmc2V0IiwiY2giLCJjaGFyIiwidGV4dEVkaXQiLCJBbm5vdGF0ZWRUZXh0RWRpdCIsIkNoYW5nZUFubm90YXRpb24iLCJDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciIsIkNvZGVBY3Rpb24iLCJDb2RlQWN0aW9uQ29udGV4dCIsIkNvZGVBY3Rpb25LaW5kIiwiQ29kZUFjdGlvblRyaWdnZXJLaW5kIiwiQ29kZURlc2NyaXB0aW9uIiwiQ29kZUxlbnMiLCJDb2xvciIsIkNvbG9ySW5mb3JtYXRpb24iLCJDb2xvclByZXNlbnRhdGlvbiIsIkNvbW1hbmQiLCJDb21wbGV0aW9uSXRlbSIsIkNvbXBsZXRpb25JdGVtS2luZCIsIkNvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIiwiQ29tcGxldGlvbkl0ZW1UYWciLCJDb21wbGV0aW9uTGlzdCIsIkNyZWF0ZUZpbGUiLCJEZWxldGVGaWxlIiwiRGlhZ25vc3RpYyIsIkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24iLCJEaWFnbm9zdGljU2V2ZXJpdHkiLCJEb2N1bWVudEhpZ2hsaWdodCIsIkRvY3VtZW50SGlnaGxpZ2h0S2luZCIsIkRvY3VtZW50TGluayIsIkRvY3VtZW50U3ltYm9sIiwiRU9MIiwiRm9sZGluZ1JhbmdlIiwiRm9sZGluZ1JhbmdlS2luZCIsIkZvcm1hdHRpbmdPcHRpb25zIiwiSG92ZXIiLCJJbmxheUhpbnQiLCJJbmxheUhpbnRLaW5kIiwiSW5sYXlIaW50TGFiZWxQYXJ0IiwiSW5saW5lQ29tcGxldGlvbkNvbnRleHQiLCJJbmxpbmVDb21wbGV0aW9uSXRlbSIsIklubGluZUNvbXBsZXRpb25MaXN0IiwiSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kIiwiSW5saW5lVmFsdWVDb250ZXh0IiwiSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24iLCJJbmxpbmVWYWx1ZVRleHQiLCJJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIiwiSW5zZXJ0UmVwbGFjZUVkaXQiLCJJbnNlcnRUZXh0Rm9ybWF0IiwiSW5zZXJ0VGV4dE1vZGUiLCJMb2NhdGlvbiIsIkxvY2F0aW9uTGluayIsIk1hcmtlZFN0cmluZyIsIk1hcmt1cENvbnRlbnQiLCJNYXJrdXBLaW5kIiwiT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiUGFyYW1ldGVySW5mb3JtYXRpb24iLCJQb3NpdGlvbiIsIlJhbmdlIiwiUmVuYW1lRmlsZSIsIlNlbGVjdGVkQ29tcGxldGlvbkluZm8iLCJTZWxlY3Rpb25SYW5nZSIsIlNlbWFudGljVG9rZW5Nb2RpZmllcnMiLCJTZW1hbnRpY1Rva2VuVHlwZXMiLCJTZW1hbnRpY1Rva2VucyIsIlNpZ25hdHVyZUluZm9ybWF0aW9uIiwiU3RyaW5nVmFsdWUiLCJTeW1ib2xJbmZvcm1hdGlvbiIsIlN5bWJvbEtpbmQiLCJTeW1ib2xUYWciLCJUZXh0RG9jdW1lbnRFZGl0IiwiVGV4dERvY3VtZW50SWRlbnRpZmllciIsIlRleHREb2N1bWVudEl0ZW0iLCJUZXh0RWRpdCIsIlZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJXb3Jrc3BhY2VDaGFuZ2UiLCJXb3Jrc3BhY2VFZGl0IiwiV29ya3NwYWNlU3ltYm9sIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwidGhyZWUiLCJmb3VyIiwidGFyZ2V0VXJpIiwidGFyZ2V0UmFuZ2UiLCJ0YXJnZXRTZWxlY3Rpb25SYW5nZSIsIm9yaWdpblNlbGVjdGlvblJhbmdlIiwiYWxwaGEiLCJudW1iZXJSYW5nZSIsImNvbG9yIiwiYWRkaXRpb25hbFRleHRFZGl0cyIsIkNvbW1lbnQiLCJJbXBvcnRzIiwiUmVnaW9uIiwic3RhcnRDaGFyYWN0ZXIiLCJlbmRDaGFyYWN0ZXIiLCJjb2xsYXBzZWRUZXh0IiwiZGVmaW5lZCIsImxvY2F0aW9uIiwiSW5mb3JtYXRpb24iLCJIaW50IiwiaHJlZiIsInNldmVyaXR5IiwiY29kZURlc2NyaXB0aW9uIiwiaW5zZXJ0IiwiZGVsIiwibmVlZHNDb25maXJtYXRpb24iLCJkZXNjcmlwdGlvbiIsImFubm90YXRpb24iLCJhbm5vdGF0aW9uSWQiLCJvdmVyd3JpdGUiLCJpZ25vcmVJZkV4aXN0cyIsIm9sZFVyaSIsIm5ld1VyaSIsInJlY3Vyc2l2ZSIsImlnbm9yZUlmTm90RXhpc3RzIiwiVGV4dEVkaXRDaGFuZ2VJbXBsIiwiZWRpdCIsImFzc2VydENoYW5nZUFubm90YXRpb25zIiwiY2hhbmdlQW5ub3RhdGlvbnMiLCJtYW5hZ2UiLCJDaGFuZ2VBbm5vdGF0aW9ucyIsIl9hbm5vdGF0aW9ucyIsImlkT3JBbm5vdGF0aW9uIiwibmV4dElkIiwiX2NvdW50ZXIiLCJhbm5vdGF0aW9ucyIsImluaXREb2N1bWVudENoYW5nZXMiLCJfY2hhbmdlQW5ub3RhdGlvbnMiLCJfd29ya3NwYWNlRWRpdCIsImdldFRleHRFZGl0Q2hhbmdlIiwiX3RleHRFZGl0Q2hhbmdlcyIsInRleHREb2N1bWVudEVkaXQiLCJpbml0Q2hhbmdlcyIsImNyZWF0ZUZpbGUiLCJvcHRpb25zT3JBbm5vdGF0aW9uIiwib3BlcmF0aW9uIiwicmVuYW1lRmlsZSIsImRlbGV0ZUZpbGUiLCJ0ZXh0RWRpdENoYW5nZSIsIlBsYWluVGV4dCIsIk1hcmtkb3duIiwiTWV0aG9kIiwiRmllbGQiLCJWYXJpYWJsZSIsIkludGVyZmFjZSIsIk1vZHVsZSIsIlByb3BlcnR5IiwiVW5pdCIsIlZhbHVlIiwiRW51bSIsIktleXdvcmQiLCJTbmlwcGV0IiwiRmlsZSIsIlJlZmVyZW5jZSIsIkZvbGRlciIsIkVudW1NZW1iZXIiLCJDb25zdGFudCIsIlN0cnVjdCIsIk9wZXJhdG9yIiwiVHlwZVBhcmFtZXRlciIsImFzSXMiLCJhZGp1c3RJbmRlbnRhdGlvbiIsImRldGFpbCIsIml0ZW1zIiwiaXNJbmNvbXBsZXRlIiwiZnJvbVBsYWluVGV4dCIsInBsYWluVGV4dCIsImNvbnRlbnRzIiwiZG9jdW1lbnRhdGlvbiIsInBhcmFtZXRlcnMiLCJSZWFkIiwiV3JpdGUiLCJOYW1lc3BhY2UiLCJQYWNrYWdlIiwiS2V5IiwiTnVsbCIsImNvbnRhaW5lck5hbWUiLCJzZWxlY3Rpb25SYW5nZSIsImNoaWxkcmVuIiwidGFncyIsIlF1aWNrRml4IiwiUmVmYWN0b3IiLCJSZWZhY3RvckV4dHJhY3QiLCJSZWZhY3RvcklubGluZSIsIlJlZmFjdG9yUmV3cml0ZSIsIlNvdXJjZSIsIlNvdXJjZU9yZ2FuaXplSW1wb3J0cyIsIlNvdXJjZUZpeEFsbCIsIkF1dG9tYXRpYyIsImRpYWdub3N0aWNzIiwib25seSIsInRyaWdnZXJLaW5kIiwia2luZE9yQ29tbWFuZE9yRWRpdCIsImNoZWNrS2luZCIsImlzUHJlZmVycmVkIiwidGFiU2l6ZSIsImluc2VydFNwYWNlcyIsInBhcmVudCIsInJlc3VsdElkIiwidmFyaWFibGVOYW1lIiwiY2FzZVNlbnNpdGl2ZUxvb2t1cCIsImZyYW1lSWQiLCJzdG9wcGVkTG9jYXRpb24iLCJUeXBlIiwiUGFyYW1ldGVyIiwidG9vbHRpcCIsInRleHRFZGl0cyIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiY3JlYXRlU25pcHBldCIsImluc2VydFRleHQiLCJmaWx0ZXJUZXh0Iiwic2VsZWN0ZWRDb21wbGV0aW9uSW5mbyIsImlzTGluZVN0YXJ0IiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJkZWZpbml0aW9uIiwiTGFuZ3VhZ2VDbGllbnQiLCJXZWJTb2NrZXRNZXNzYWdlUmVhZGVyIiwiZXZlbnRzIiwicmVhZE1lc3NhZ2UiLCJvbk1lc3NhZ2UiLCJXZWJTb2NrZXRNZXNzYWdlV3JpdGVyIiwibWFpbiIsImNyZWF0ZVdlYlNvY2tldENvbm5lY3Rpb24iLCJDb25zb2xlTG9nZ2VyIiwiZGVidWciLCJ3ZWJTb2NrZXQiLCJvbkNvbm5lY3Rpb24iLCJvbm9wZW4iLCJ0b1NvY2tldCIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiYnJvd3Nlcl9tYWluIiwiYmFzZV9zZXJ2aWNlIiwiQmFzZU1lc3NhZ2UiLCJkb2N1bWVudElkZW50aWZpZXIiLCJzZXNzaW9uSWQiLCJJbml0TWVzc2FnZSIsImluaXQiLCJGb3JtYXRNZXNzYWdlIiwiQ29tcGxldGVNZXNzYWdlIiwiY29tcGxldGUiLCJJbmxpbmVDb21wbGV0ZU1lc3NhZ2UiLCJpbmxpbmVDb21wbGV0ZSIsIlJlc29sdmVDb21wbGV0aW9uTWVzc2FnZSIsInJlc29sdmVDb21wbGV0aW9uIiwiSG92ZXJNZXNzYWdlIiwiVmFsaWRhdGVNZXNzYWdlIiwidmFsaWRhdGUiLCJDaGFuZ2VNZXNzYWdlIiwiRGVsdGFzTWVzc2FnZSIsImFwcGx5RGVsdGEiLCJDaGFuZ2VNb2RlTWVzc2FnZSIsImNoYW5nZU1vZGUiLCJDaGFuZ2VPcHRpb25zTWVzc2FnZSIsImNoYW5nZU9wdGlvbnMiLCJDbG9zZURvY3VtZW50TWVzc2FnZSIsImNsb3NlRG9jdW1lbnQiLCJDbG9zZUNvbm5lY3Rpb25NZXNzYWdlIiwiR2xvYmFsT3B0aW9uc01lc3NhZ2UiLCJDb25maWd1cmVGZWF0dXJlc01lc3NhZ2UiLCJjb25maWd1cmVGZWF0dXJlcyIsIlNpZ25hdHVyZUhlbHBNZXNzYWdlIiwiRG9jdW1lbnRIaWdobGlnaHRNZXNzYWdlIiwiR2V0U2VtYW50aWNUb2tlbnNNZXNzYWdlIiwiR2V0Q29kZUFjdGlvbnNNZXNzYWdlIiwiU2V0V29ya3NwYWNlTWVzc2FnZSIsIkV4ZWN1dGVDb21tYW5kTWVzc2FnZSIsIkFwcGxpZWRFZGl0TWVzc2FnZSIsImFwcGxpZWRFZGl0IiwiUmVuYW1lRG9jdW1lbnRNZXNzYWdlIiwiU2VuZFJlcXVlc3RNZXNzYWdlIiwicmVxdWVzdE5hbWUiLCJTZW5kUmVzcG9uc2VNZXNzYWdlIiwiTElCIiwidCIsInMiLCJoIiwibGFzdEluZGV4T2YiLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwicmVsYXRpdmUiLCJjIiwidSIsIl9tYWtlTG9uZyIsImRpcm5hbWUiLCJiYXNlbmFtZSIsImV4dG5hbWUiLCJleHQiLCJzZXAiLCJkZWxpbWl0ZXIiLCJ3aW4zMiIsInBvc2l4IiwiVXRpbHMiLCJJIiwicGxhdGZvcm0iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJhdXRob3JpdHkiLCJwYXRoIiwicXVlcnkiLCJmcmFnbWVudCIsImlzVXJpIiwiZnNQYXRoIiwid2l0aCIsInYiLCJ3IiwiZnJvbSIsInJldml2ZSIsIl9mb3JtYXR0ZWQiLCJleHRlcm5hbCIsIl9mc1BhdGgiLCJfc2VwIiwiJG1pZCIsImZyb21DaGFyQ29kZSIsIkMiLCJBIiwiUCIsImpvaW5QYXRoIiwicmVzb2x2ZVBhdGgiLCJsYW5ndWFnZV9jbGllbnRfVVJJIiwibGFuZ3VhZ2VfY2xpZW50X2NvbnNvbGUiLCJsYW5ndWFnZV9jbGllbnRfZGVmaW5lX3Byb3BlcnR5IiwiJGNvbm5lY3QiLCJzZXJ2ZXJEYXRhIiwiJGNvbm5lY3RXb3JrZXIiLCJ3b3JrZXIiLCJpbml0aWFsaXphdGlvbk9wdGlvbnMiLCIkY29ubmVjdFNvY2tldCIsIiRpbml0Q29ubmVjdGlvbiIsInJlYWR5U3RhdGUiLCJXZWJTb2NrZXQiLCJPUEVOIiwiZGlzcGF0Y2hFdmVudCIsImlzQ29ubmVjdGVkIiwic2VuZEluaXRpYWxpemUiLCJzaG93TG9nIiwic2hvd1RyYWNlIiwiYXBwbGllZCIsImZhaWx1cmVSZWFzb24iLCIkcmVjb25uZWN0IiwidGV4dERvY3VtZW50TWVzc2FnZSIsImVucXVldWVJZk5vdENvbm5lY3RlZCIsImlzSW5pdGlhbGl6ZWQiLCJyZXF1ZXN0c1F1ZXVlIiwiX3RoaXNfY29ubmVjdGlvbiIsImNhcGFiaWxpdGllcyIsImNsaWVudENhcGFiaWxpdGllcyIsInByb2Nlc3NJZCIsInJvb3RVcmkiLCJ3b3Jrc3BhY2VGb2xkZXJzIiwid29ya3NwYWNlRm9sZGVyIiwic2VydmljZUNhcGFiaWxpdGllcyIsImNhcGFiaWxpdGllc0NoYW5nZSIsInNldHRpbmdzIiwicmVxdWVzdENhbGxiYWNrIiwiX3RoaXNfc2VydmljZUNhcGFiaWxpdGllcyIsIl90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXMxIiwidGV4dERvY3VtZW50U3luYyIsInRleHREb2N1bWVudENoYW5nZSIsImNvbnRlbnRDaGFuZ2VzIiwiaG92ZXJQcm92aWRlciIsImNvbXBsZXRpb25Qcm92aWRlciIsImlubGluZUNvbXBsZXRpb25Qcm92aWRlciIsIl90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfY29tcGxldGlvblByb3ZpZGVyIiwicmVzb2x2ZVByb3ZpZGVyIiwiZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQcm92aWRlciIsImRvY3VtZW50Rm9ybWF0dGluZ1Byb3ZpZGVyIiwiY29uZmlnQ2hhbmdlcyIsIl90aGlzX3NlcnZpY2VDYXBhYmlsaXRpZXNfd29ya3NwYWNlX3dvcmtzcGFjZUZvbGRlcnMiLCJfdGhpc19zZXJ2aWNlQ2FwYWJpbGl0aWVzX3dvcmtzcGFjZSIsImNoYW5nZU5vdGlmaWNhdGlvbnMiLCJhZGRlZCIsInJlbW92ZWQiLCJkb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyIiwic2lnbmF0dXJlSGVscFByb3ZpZGVyIiwic2VtYW50aWNUb2tlbnNQcm92aWRlciIsImNvZGVBY3Rpb25Qcm92aWRlciIsImV4ZWN1dGVDb21tYW5kUHJvdmlkZXIiLCJjb21tYW5kcyJdLCJzb3VyY2VSb290IjoiIn0=